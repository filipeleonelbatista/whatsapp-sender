;(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory()
  else if (typeof define === 'function' && define.amd) define([], factory)
  else {
    var a = factory()
    for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i]
  }
})(global, () => {
  return /******/ (() => {
    // webpackBootstrap
    /******/ var __webpack_modules__ = {
      /***/ './node_modules/balanced-match/index.js':
        /*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
        /***/ (module) => {
          'use strict'

          module.exports = balanced
          function balanced(a, b, str) {
            if (a instanceof RegExp) a = maybeMatch(a, str)
            if (b instanceof RegExp) b = maybeMatch(b, str)

            var r = range(a, b, str)

            return (
              r && {
                start: r[0],
                end: r[1],
                pre: str.slice(0, r[0]),
                body: str.slice(r[0] + a.length, r[1]),
                post: str.slice(r[1] + b.length)
              }
            )
          }

          function maybeMatch(reg, str) {
            var m = str.match(reg)
            return m ? m[0] : null
          }

          balanced.range = range
          function range(a, b, str) {
            var begs, beg, left, right, result
            var ai = str.indexOf(a)
            var bi = str.indexOf(b, ai + 1)
            var i = ai

            if (ai >= 0 && bi > 0) {
              if (a === b) {
                return [ai, bi]
              }
              begs = []
              left = str.length

              while (i >= 0 && !result) {
                if (i == ai) {
                  begs.push(i)
                  ai = str.indexOf(a, i + 1)
                } else if (begs.length == 1) {
                  result = [begs.pop(), bi]
                } else {
                  beg = begs.pop()
                  if (beg < left) {
                    left = beg
                    right = bi
                  }

                  bi = str.indexOf(b, i + 1)
                }

                i = ai < bi && ai >= 0 ? ai : bi
              }

              if (begs.length) {
                result = [left, right]
              }
            }

            return result
          }

          /***/
        },

      /***/ './node_modules/brace-expansion/index.js':
        /*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          var concatMap = __webpack_require__(
            /*! concat-map */ './node_modules/concat-map/index.js'
          )
          var balanced = __webpack_require__(
            /*! balanced-match */ './node_modules/balanced-match/index.js'
          )

          module.exports = expandTop

          var escSlash = '\0SLASH' + Math.random() + '\0'
          var escOpen = '\0OPEN' + Math.random() + '\0'
          var escClose = '\0CLOSE' + Math.random() + '\0'
          var escComma = '\0COMMA' + Math.random() + '\0'
          var escPeriod = '\0PERIOD' + Math.random() + '\0'

          function numeric(str) {
            return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0)
          }

          function escapeBraces(str) {
            return str
              .split('\\\\')
              .join(escSlash)
              .split('\\{')
              .join(escOpen)
              .split('\\}')
              .join(escClose)
              .split('\\,')
              .join(escComma)
              .split('\\.')
              .join(escPeriod)
          }

          function unescapeBraces(str) {
            return str
              .split(escSlash)
              .join('\\')
              .split(escOpen)
              .join('{')
              .split(escClose)
              .join('}')
              .split(escComma)
              .join(',')
              .split(escPeriod)
              .join('.')
          }

          // Basically just str.split(","), but handling cases
          // where we have nested braced sections, which should be
          // treated as individual members, like {a,{b,c},d}
          function parseCommaParts(str) {
            if (!str) return ['']

            var parts = []
            var m = balanced('{', '}', str)

            if (!m) return str.split(',')

            var pre = m.pre
            var body = m.body
            var post = m.post
            var p = pre.split(',')

            p[p.length - 1] += '{' + body + '}'
            var postParts = parseCommaParts(post)
            if (post.length) {
              p[p.length - 1] += postParts.shift()
              p.push.apply(p, postParts)
            }

            parts.push.apply(parts, p)

            return parts
          }

          function expandTop(str) {
            if (!str) return []

            // I don't know why Bash 4.3 does this, but it does.
            // Anything starting with {} will have the first two bytes preserved
            // but *only* at the top level, so {},a}b will not expand to anything,
            // but a{},b}c will be expanded to [a}c,abc].
            // One could argue that this is a bug in Bash, but since the goal of
            // this module is to match Bash's rules, we escape a leading {}
            if (str.substr(0, 2) === '{}') {
              str = '\\{\\}' + str.substr(2)
            }

            return expand(escapeBraces(str), true).map(unescapeBraces)
          }

          function identity(e) {
            return e
          }

          function embrace(str) {
            return '{' + str + '}'
          }
          function isPadded(el) {
            return /^-?0\d/.test(el)
          }

          function lte(i, y) {
            return i <= y
          }
          function gte(i, y) {
            return i >= y
          }

          function expand(str, isTop) {
            var expansions = []

            var m = balanced('{', '}', str)
            if (!m || /\$$/.test(m.pre)) return [str]

            var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body)
            var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body)
            var isSequence = isNumericSequence || isAlphaSequence
            var isOptions = m.body.indexOf(',') >= 0
            if (!isSequence && !isOptions) {
              // {a},b}
              if (m.post.match(/,.*\}/)) {
                str = m.pre + '{' + m.body + escClose + m.post
                return expand(str)
              }
              return [str]
            }

            var n
            if (isSequence) {
              n = m.body.split(/\.\./)
            } else {
              n = parseCommaParts(m.body)
              if (n.length === 1) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand(n[0], false).map(embrace)
                if (n.length === 1) {
                  var post = m.post.length ? expand(m.post, false) : ['']
                  return post.map(function (p) {
                    return m.pre + n[0] + p
                  })
                }
              }
            }

            // at this point, n is the parts, and we know it's not a comma set
            // with a single entry.

            // no need to expand pre, since it is guaranteed to be free of brace-sets
            var pre = m.pre
            var post = m.post.length ? expand(m.post, false) : ['']

            var N

            if (isSequence) {
              var x = numeric(n[0])
              var y = numeric(n[1])
              var width = Math.max(n[0].length, n[1].length)
              var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1
              var test = lte
              var reverse = y < x
              if (reverse) {
                incr *= -1
                test = gte
              }
              var pad = n.some(isPadded)

              N = []

              for (var i = x; test(i, y); i += incr) {
                var c
                if (isAlphaSequence) {
                  c = String.fromCharCode(i)
                  if (c === '\\') c = ''
                } else {
                  c = String(i)
                  if (pad) {
                    var need = width - c.length
                    if (need > 0) {
                      var z = new Array(need + 1).join('0')
                      if (i < 0) c = '-' + z + c.slice(1)
                      else c = z + c
                    }
                  }
                }
                N.push(c)
              }
            } else {
              N = concatMap(n, function (el) {
                return expand(el, false)
              })
            }

            for (var j = 0; j < N.length; j++) {
              for (var k = 0; k < post.length; k++) {
                var expansion = pre + N[j] + post[k]
                if (!isTop || isSequence || expansion) expansions.push(expansion)
              }
            }

            return expansions
          }

          /***/
        },

      /***/ './node_modules/concat-map/index.js':
        /*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
        /***/ (module) => {
          module.exports = function (xs, fn) {
            var res = []
            for (var i = 0; i < xs.length; i++) {
              var x = fn(xs[i], i)
              if (isArray(x)) res.push.apply(res, x)
              else res.push(x)
            }
            return res
          }

          var isArray =
            Array.isArray ||
            function (xs) {
              return Object.prototype.toString.call(xs) === '[object Array]'
            }

          /***/
        },

      /***/ './node_modules/core-util-is/lib/util.js':
        /*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
        /***/ (__unused_webpack_module, exports) => {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.

          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg)
            }
            return objectToString(arg) === '[object Array]'
          }
          exports.isArray = isArray

          function isBoolean(arg) {
            return typeof arg === 'boolean'
          }
          exports.isBoolean = isBoolean

          function isNull(arg) {
            return arg === null
          }
          exports.isNull = isNull

          function isNullOrUndefined(arg) {
            return arg == null
          }
          exports.isNullOrUndefined = isNullOrUndefined

          function isNumber(arg) {
            return typeof arg === 'number'
          }
          exports.isNumber = isNumber

          function isString(arg) {
            return typeof arg === 'string'
          }
          exports.isString = isString

          function isSymbol(arg) {
            return typeof arg === 'symbol'
          }
          exports.isSymbol = isSymbol

          function isUndefined(arg) {
            return arg === void 0
          }
          exports.isUndefined = isUndefined

          function isRegExp(re) {
            return objectToString(re) === '[object RegExp]'
          }
          exports.isRegExp = isRegExp

          function isObject(arg) {
            return typeof arg === 'object' && arg !== null
          }
          exports.isObject = isObject

          function isDate(d) {
            return objectToString(d) === '[object Date]'
          }
          exports.isDate = isDate

          function isError(e) {
            return objectToString(e) === '[object Error]' || e instanceof Error
          }
          exports.isError = isError

          function isFunction(arg) {
            return typeof arg === 'function'
          }
          exports.isFunction = isFunction

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === 'boolean' ||
              typeof arg === 'number' ||
              typeof arg === 'string' ||
              typeof arg === 'symbol' || // ES6 symbol
              typeof arg === 'undefined'
            )
          }
          exports.isPrimitive = isPrimitive

          exports.isBuffer = Buffer.isBuffer

          function objectToString(o) {
            return Object.prototype.toString.call(o)
          }

          /***/
        },

      /***/ './node_modules/fs.realpath/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/fs.realpath/index.js ***!
  \*******************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          module.exports = realpath
          realpath.realpath = realpath
          realpath.sync = realpathSync
          realpath.realpathSync = realpathSync
          realpath.monkeypatch = monkeypatch
          realpath.unmonkeypatch = unmonkeypatch

          var fs = __webpack_require__(/*! fs */ 'fs')
          var origRealpath = fs.realpath
          var origRealpathSync = fs.realpathSync

          var version = process.version
          var ok = /^v[0-5]\./.test(version)
          var old = __webpack_require__(/*! ./old.js */ './node_modules/fs.realpath/old.js')

          function newError(er) {
            return (
              er &&
              er.syscall === 'realpath' &&
              (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG')
            )
          }

          function realpath(p, cache, cb) {
            if (ok) {
              return origRealpath(p, cache, cb)
            }

            if (typeof cache === 'function') {
              cb = cache
              cache = null
            }
            origRealpath(p, cache, function (er, result) {
              if (newError(er)) {
                old.realpath(p, cache, cb)
              } else {
                cb(er, result)
              }
            })
          }

          function realpathSync(p, cache) {
            if (ok) {
              return origRealpathSync(p, cache)
            }

            try {
              return origRealpathSync(p, cache)
            } catch (er) {
              if (newError(er)) {
                return old.realpathSync(p, cache)
              } else {
                throw er
              }
            }
          }

          function monkeypatch() {
            fs.realpath = realpath
            fs.realpathSync = realpathSync
          }

          function unmonkeypatch() {
            fs.realpath = origRealpath
            fs.realpathSync = origRealpathSync
          }

          /***/
        },

      /***/ './node_modules/fs.realpath/old.js':
        /*!*****************************************!*\
  !*** ./node_modules/fs.realpath/old.js ***!
  \*****************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var pathModule = __webpack_require__(/*! path */ 'path')
          var isWindows = process.platform === 'win32'
          var fs = __webpack_require__(/*! fs */ 'fs')

          // JavaScript implementation of realpath, ported from node pre-v6

          var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG)

          function rethrow() {
            // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
            // is fairly slow to generate.
            var callback
            if (DEBUG) {
              var backtrace = new Error()
              callback = debugCallback
            } else callback = missingCallback

            return callback

            function debugCallback(err) {
              if (err) {
                backtrace.message = err.message
                err = backtrace
                missingCallback(err)
              }
            }

            function missingCallback(err) {
              if (err) {
                if (process.throwDeprecation)
                  throw err // Forgot a callback but don't know where? Use NODE_DEBUG=fs
                else if (!process.noDeprecation) {
                  var msg = 'fs: missing callback ' + (err.stack || err.message)
                  if (process.traceDeprecation) console.trace(msg)
                  else console.error(msg)
                }
              }
            }
          }

          function maybeCallback(cb) {
            return typeof cb === 'function' ? cb : rethrow()
          }

          var normalize = pathModule.normalize

          // Regexp that finds the next partion of a (partial) path
          // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
          if (isWindows) {
            var nextPartRe = /(.*?)(?:[\/\\]+|$)/g
          } else {
            var nextPartRe = /(.*?)(?:[\/]+|$)/g
          }

          // Regex to find the device root, including trailing slash. E.g. 'c:\\'.
          if (isWindows) {
            var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/
          } else {
            var splitRootRe = /^[\/]*/
          }

          exports.realpathSync = function realpathSync(p, cache) {
            // make p is absolute
            p = pathModule.resolve(p)

            if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
              return cache[p]
            }

            var original = p,
              seenLinks = {},
              knownHard = {}

            // current character position in p
            var pos
            // the partial path so far, including a trailing slash if any
            var current
            // the partial path without a trailing slash (except when pointing at a root)
            var base
            // the partial path scanned in the previous round, with slash
            var previous

            start()

            function start() {
              // Skip over roots
              var m = splitRootRe.exec(p)
              pos = m[0].length
              current = m[0]
              base = m[0]
              previous = ''

              // On windows, check that the root exists. On unix there is no need.
              if (isWindows && !knownHard[base]) {
                fs.lstatSync(base)
                knownHard[base] = true
              }
            }

            // walk down the path, swapping out linked pathparts for their real
            // values
            // NB: p.length changes.
            while (pos < p.length) {
              // find the next part
              nextPartRe.lastIndex = pos
              var result = nextPartRe.exec(p)
              previous = current
              current += result[0]
              base = previous + result[1]
              pos = nextPartRe.lastIndex

              // continue if not a symlink
              if (knownHard[base] || (cache && cache[base] === base)) {
                continue
              }

              var resolvedLink
              if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
                // some known symbolic link.  no need to stat again.
                resolvedLink = cache[base]
              } else {
                var stat = fs.lstatSync(base)
                if (!stat.isSymbolicLink()) {
                  knownHard[base] = true
                  if (cache) cache[base] = base
                  continue
                }

                // read the link if it wasn't read before
                // dev/ino always return 0 on windows, so skip the check.
                var linkTarget = null
                if (!isWindows) {
                  var id = stat.dev.toString(32) + ':' + stat.ino.toString(32)
                  if (seenLinks.hasOwnProperty(id)) {
                    linkTarget = seenLinks[id]
                  }
                }
                if (linkTarget === null) {
                  fs.statSync(base)
                  linkTarget = fs.readlinkSync(base)
                }
                resolvedLink = pathModule.resolve(previous, linkTarget)
                // track this, if given a cache.
                if (cache) cache[base] = resolvedLink
                if (!isWindows) seenLinks[id] = linkTarget
              }

              // resolve the link, then start over
              p = pathModule.resolve(resolvedLink, p.slice(pos))
              start()
            }

            if (cache) cache[original] = p

            return p
          }

          exports.realpath = function realpath(p, cache, cb) {
            if (typeof cb !== 'function') {
              cb = maybeCallback(cache)
              cache = null
            }

            // make p is absolute
            p = pathModule.resolve(p)

            if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
              return process.nextTick(cb.bind(null, null, cache[p]))
            }

            var original = p,
              seenLinks = {},
              knownHard = {}

            // current character position in p
            var pos
            // the partial path so far, including a trailing slash if any
            var current
            // the partial path without a trailing slash (except when pointing at a root)
            var base
            // the partial path scanned in the previous round, with slash
            var previous

            start()

            function start() {
              // Skip over roots
              var m = splitRootRe.exec(p)
              pos = m[0].length
              current = m[0]
              base = m[0]
              previous = ''

              // On windows, check that the root exists. On unix there is no need.
              if (isWindows && !knownHard[base]) {
                fs.lstat(base, function (err) {
                  if (err) return cb(err)
                  knownHard[base] = true
                  LOOP()
                })
              } else {
                process.nextTick(LOOP)
              }
            }

            // walk down the path, swapping out linked pathparts for their real
            // values
            function LOOP() {
              // stop if scanned past end of path
              if (pos >= p.length) {
                if (cache) cache[original] = p
                return cb(null, p)
              }

              // find the next part
              nextPartRe.lastIndex = pos
              var result = nextPartRe.exec(p)
              previous = current
              current += result[0]
              base = previous + result[1]
              pos = nextPartRe.lastIndex

              // continue if not a symlink
              if (knownHard[base] || (cache && cache[base] === base)) {
                return process.nextTick(LOOP)
              }

              if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
                // known symbolic link.  no need to stat again.
                return gotResolvedLink(cache[base])
              }

              return fs.lstat(base, gotStat)
            }

            function gotStat(err, stat) {
              if (err) return cb(err)

              // if not a symlink, skip to the next path part
              if (!stat.isSymbolicLink()) {
                knownHard[base] = true
                if (cache) cache[base] = base
                return process.nextTick(LOOP)
              }

              // stat & read the link if not read before
              // call gotTarget as soon as the link target is known
              // dev/ino always return 0 on windows, so skip the check.
              if (!isWindows) {
                var id = stat.dev.toString(32) + ':' + stat.ino.toString(32)
                if (seenLinks.hasOwnProperty(id)) {
                  return gotTarget(null, seenLinks[id], base)
                }
              }
              fs.stat(base, function (err) {
                if (err) return cb(err)

                fs.readlink(base, function (err, target) {
                  if (!isWindows) seenLinks[id] = target
                  gotTarget(err, target)
                })
              })
            }

            function gotTarget(err, target, base) {
              if (err) return cb(err)

              var resolvedLink = pathModule.resolve(previous, target)
              if (cache) cache[base] = resolvedLink
              gotResolvedLink(resolvedLink)
            }

            function gotResolvedLink(resolvedLink) {
              // resolve the link, then start over
              p = pathModule.resolve(resolvedLink, p.slice(pos))
              start()
            }
          }

          /***/
        },

      /***/ './node_modules/glob/common.js':
        /*!*************************************!*\
  !*** ./node_modules/glob/common.js ***!
  \*************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          exports.setopts = setopts
          exports.ownProp = ownProp
          exports.makeAbs = makeAbs
          exports.finish = finish
          exports.mark = mark
          exports.isIgnored = isIgnored
          exports.childrenIgnored = childrenIgnored

          function ownProp(obj, field) {
            return Object.prototype.hasOwnProperty.call(obj, field)
          }

          var fs = __webpack_require__(/*! fs */ 'fs')
          var path = __webpack_require__(/*! path */ 'path')
          var minimatch = __webpack_require__(
            /*! minimatch */ './node_modules/minimatch/minimatch.js'
          )
          var isAbsolute = __webpack_require__(
            /*! path-is-absolute */ './node_modules/path-is-absolute/index.js'
          )
          var Minimatch = minimatch.Minimatch

          function alphasort(a, b) {
            return a.localeCompare(b, 'en')
          }

          function setupIgnores(self, options) {
            self.ignore = options.ignore || []

            if (!Array.isArray(self.ignore)) self.ignore = [self.ignore]

            if (self.ignore.length) {
              self.ignore = self.ignore.map(ignoreMap)
            }
          }

          // ignore patterns are always in dot:true mode.
          function ignoreMap(pattern) {
            var gmatcher = null
            if (pattern.slice(-3) === '/**') {
              var gpattern = pattern.replace(/(\/\*\*)+$/, '')
              gmatcher = new Minimatch(gpattern, { dot: true })
            }

            return {
              matcher: new Minimatch(pattern, { dot: true }),
              gmatcher: gmatcher
            }
          }

          function setopts(self, pattern, options) {
            if (!options) options = {}

            // base-matching: just use globstar for that.
            if (options.matchBase && -1 === pattern.indexOf('/')) {
              if (options.noglobstar) {
                throw new Error('base matching requires globstar')
              }
              pattern = '**/' + pattern
            }

            self.silent = !!options.silent
            self.pattern = pattern
            self.strict = options.strict !== false
            self.realpath = !!options.realpath
            self.realpathCache = options.realpathCache || Object.create(null)
            self.follow = !!options.follow
            self.dot = !!options.dot
            self.mark = !!options.mark
            self.nodir = !!options.nodir
            if (self.nodir) self.mark = true
            self.sync = !!options.sync
            self.nounique = !!options.nounique
            self.nonull = !!options.nonull
            self.nosort = !!options.nosort
            self.nocase = !!options.nocase
            self.stat = !!options.stat
            self.noprocess = !!options.noprocess
            self.absolute = !!options.absolute
            self.fs = options.fs || fs

            self.maxLength = options.maxLength || Infinity
            self.cache = options.cache || Object.create(null)
            self.statCache = options.statCache || Object.create(null)
            self.symlinks = options.symlinks || Object.create(null)

            setupIgnores(self, options)

            self.changedCwd = false
            var cwd = process.cwd()
            if (!ownProp(options, 'cwd')) self.cwd = cwd
            else {
              self.cwd = path.resolve(options.cwd)
              self.changedCwd = self.cwd !== cwd
            }

            self.root = options.root || path.resolve(self.cwd, '/')
            self.root = path.resolve(self.root)
            if (process.platform === 'win32') self.root = self.root.replace(/\\/g, '/')

            // TODO: is an absolute `cwd` supposed to be resolved against `root`?
            // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
            self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
            if (process.platform === 'win32') self.cwdAbs = self.cwdAbs.replace(/\\/g, '/')
            self.nomount = !!options.nomount

            // disable comments and negation in Minimatch.
            // Note that they are not supported in Glob itself anyway.
            options.nonegate = true
            options.nocomment = true
            // always treat \ in patterns as escapes, not path separators
            options.allowWindowsEscape = false

            self.minimatch = new Minimatch(pattern, options)
            self.options = self.minimatch.options
          }

          function finish(self) {
            var nou = self.nounique
            var all = nou ? [] : Object.create(null)

            for (var i = 0, l = self.matches.length; i < l; i++) {
              var matches = self.matches[i]
              if (!matches || Object.keys(matches).length === 0) {
                if (self.nonull) {
                  // do like the shell, and spit out the literal glob
                  var literal = self.minimatch.globSet[i]
                  if (nou) all.push(literal)
                  else all[literal] = true
                }
              } else {
                // had matches
                var m = Object.keys(matches)
                if (nou) all.push.apply(all, m)
                else
                  m.forEach(function (m) {
                    all[m] = true
                  })
              }
            }

            if (!nou) all = Object.keys(all)

            if (!self.nosort) all = all.sort(alphasort)

            // at *some* point we statted all of these
            if (self.mark) {
              for (var i = 0; i < all.length; i++) {
                all[i] = self._mark(all[i])
              }
              if (self.nodir) {
                all = all.filter(function (e) {
                  var notDir = !/\/$/.test(e)
                  var c = self.cache[e] || self.cache[makeAbs(self, e)]
                  if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c)
                  return notDir
                })
              }
            }

            if (self.ignore.length)
              all = all.filter(function (m) {
                return !isIgnored(self, m)
              })

            self.found = all
          }

          function mark(self, p) {
            var abs = makeAbs(self, p)
            var c = self.cache[abs]
            var m = p
            if (c) {
              var isDir = c === 'DIR' || Array.isArray(c)
              var slash = p.slice(-1) === '/'

              if (isDir && !slash) m += '/'
              else if (!isDir && slash) m = m.slice(0, -1)

              if (m !== p) {
                var mabs = makeAbs(self, m)
                self.statCache[mabs] = self.statCache[abs]
                self.cache[mabs] = self.cache[abs]
              }
            }

            return m
          }

          // lotta situps...
          function makeAbs(self, f) {
            var abs = f
            if (f.charAt(0) === '/') {
              abs = path.join(self.root, f)
            } else if (isAbsolute(f) || f === '') {
              abs = f
            } else if (self.changedCwd) {
              abs = path.resolve(self.cwd, f)
            } else {
              abs = path.resolve(f)
            }

            if (process.platform === 'win32') abs = abs.replace(/\\/g, '/')

            return abs
          }

          // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
          // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
          function isIgnored(self, path) {
            if (!self.ignore.length) return false

            return self.ignore.some(function (item) {
              return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
            })
          }

          function childrenIgnored(self, path) {
            if (!self.ignore.length) return false

            return self.ignore.some(function (item) {
              return !!(item.gmatcher && item.gmatcher.match(path))
            })
          }

          /***/
        },

      /***/ './node_modules/glob/glob.js':
        /*!***********************************!*\
  !*** ./node_modules/glob/glob.js ***!
  \***********************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Approach:
          //
          // 1. Get the minimatch set
          // 2. For each pattern in the set, PROCESS(pattern, false)
          // 3. Store matches per-set, then uniq them
          //
          // PROCESS(pattern, inGlobStar)
          // Get the first [n] items from pattern that are all strings
          // Join these together.  This is PREFIX.
          //   If there is no more remaining, then stat(PREFIX) and
          //   add to matches if it succeeds.  END.
          //
          // If inGlobStar and PREFIX is symlink and points to dir
          //   set ENTRIES = []
          // else readdir(PREFIX) as ENTRIES
          //   If fail, END
          //
          // with ENTRIES
          //   If pattern[n] is GLOBSTAR
          //     // handle the case where the globstar match is empty
          //     // by pruning it out, and testing the resulting pattern
          //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
          //     // handle other cases.
          //     for ENTRY in ENTRIES (not dotfiles)
          //       // attach globstar + tail onto the entry
          //       // Mark that this entry is a globstar match
          //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
          //
          //   else // not globstar
          //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
          //       Test ENTRY against pattern[n]
          //       If fails, continue
          //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
          //
          // Caveat:
          //   Cache all stats and readdirs results to minimize syscall.  Since all
          //   we ever care about is existence and directory-ness, we can just keep
          //   `true` for files, and [children,...] for directories, or `false` for
          //   things that don't exist.

          module.exports = glob

          var rp = __webpack_require__(/*! fs.realpath */ './node_modules/fs.realpath/index.js')
          var minimatch = __webpack_require__(
            /*! minimatch */ './node_modules/minimatch/minimatch.js'
          )
          var Minimatch = minimatch.Minimatch
          var inherits = __webpack_require__(/*! inherits */ './node_modules/inherits/inherits.js')
          var EE = __webpack_require__(/*! events */ 'events').EventEmitter
          var path = __webpack_require__(/*! path */ 'path')
          var assert = __webpack_require__(/*! assert */ 'assert')
          var isAbsolute = __webpack_require__(
            /*! path-is-absolute */ './node_modules/path-is-absolute/index.js'
          )
          var globSync = __webpack_require__(/*! ./sync.js */ './node_modules/glob/sync.js')
          var common = __webpack_require__(/*! ./common.js */ './node_modules/glob/common.js')
          var setopts = common.setopts
          var ownProp = common.ownProp
          var inflight = __webpack_require__(/*! inflight */ './node_modules/inflight/inflight.js')
          var util = __webpack_require__(/*! util */ 'util')
          var childrenIgnored = common.childrenIgnored
          var isIgnored = common.isIgnored

          var once = __webpack_require__(/*! once */ './node_modules/once/once.js')

          function glob(pattern, options, cb) {
            if (typeof options === 'function') (cb = options), (options = {})
            if (!options) options = {}

            if (options.sync) {
              if (cb) throw new TypeError('callback provided to sync glob')
              return globSync(pattern, options)
            }

            return new Glob(pattern, options, cb)
          }

          glob.sync = globSync
          var GlobSync = (glob.GlobSync = globSync.GlobSync)

          // old api surface
          glob.glob = glob

          function extend(origin, add) {
            if (add === null || typeof add !== 'object') {
              return origin
            }

            var keys = Object.keys(add)
            var i = keys.length
            while (i--) {
              origin[keys[i]] = add[keys[i]]
            }
            return origin
          }

          glob.hasMagic = function (pattern, options_) {
            var options = extend({}, options_)
            options.noprocess = true

            var g = new Glob(pattern, options)
            var set = g.minimatch.set

            if (!pattern) return false

            if (set.length > 1) return true

            for (var j = 0; j < set[0].length; j++) {
              if (typeof set[0][j] !== 'string') return true
            }

            return false
          }

          glob.Glob = Glob
          inherits(Glob, EE)
          function Glob(pattern, options, cb) {
            if (typeof options === 'function') {
              cb = options
              options = null
            }

            if (options && options.sync) {
              if (cb) throw new TypeError('callback provided to sync glob')
              return new GlobSync(pattern, options)
            }

            if (!(this instanceof Glob)) return new Glob(pattern, options, cb)

            setopts(this, pattern, options)
            this._didRealPath = false

            // process each pattern in the minimatch set
            var n = this.minimatch.set.length

            // The matches are stored as {<filename>: true,...} so that
            // duplicates are automagically pruned.
            // Later, we do an Object.keys() on these.
            // Keep them as a list so we can fill in when nonull is set.
            this.matches = new Array(n)

            if (typeof cb === 'function') {
              cb = once(cb)
              this.on('error', cb)
              this.on('end', function (matches) {
                cb(null, matches)
              })
            }

            var self = this
            this._processing = 0

            this._emitQueue = []
            this._processQueue = []
            this.paused = false

            if (this.noprocess) return this

            if (n === 0) return done()

            var sync = true
            for (var i = 0; i < n; i++) {
              this._process(this.minimatch.set[i], i, false, done)
            }
            sync = false

            function done() {
              --self._processing
              if (self._processing <= 0) {
                if (sync) {
                  process.nextTick(function () {
                    self._finish()
                  })
                } else {
                  self._finish()
                }
              }
            }
          }

          Glob.prototype._finish = function () {
            assert(this instanceof Glob)
            if (this.aborted) return

            if (this.realpath && !this._didRealpath) return this._realpath()

            common.finish(this)
            this.emit('end', this.found)
          }

          Glob.prototype._realpath = function () {
            if (this._didRealpath) return

            this._didRealpath = true

            var n = this.matches.length
            if (n === 0) return this._finish()

            var self = this
            for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next)

            function next() {
              if (--n === 0) self._finish()
            }
          }

          Glob.prototype._realpathSet = function (index, cb) {
            var matchset = this.matches[index]
            if (!matchset) return cb()

            var found = Object.keys(matchset)
            var self = this
            var n = found.length

            if (n === 0) return cb()

            var set = (this.matches[index] = Object.create(null))
            found.forEach(function (p, i) {
              // If there's a problem with the stat, then it means that
              // one or more of the links in the realpath couldn't be
              // resolved.  just return the abs value in that case.
              p = self._makeAbs(p)
              rp.realpath(p, self.realpathCache, function (er, real) {
                if (!er) set[real] = true
                else if (er.syscall === 'stat') set[p] = true
                else self.emit('error', er) // srsly wtf right here

                if (--n === 0) {
                  self.matches[index] = set
                  cb()
                }
              })
            })
          }

          Glob.prototype._mark = function (p) {
            return common.mark(this, p)
          }

          Glob.prototype._makeAbs = function (f) {
            return common.makeAbs(this, f)
          }

          Glob.prototype.abort = function () {
            this.aborted = true
            this.emit('abort')
          }

          Glob.prototype.pause = function () {
            if (!this.paused) {
              this.paused = true
              this.emit('pause')
            }
          }

          Glob.prototype.resume = function () {
            if (this.paused) {
              this.emit('resume')
              this.paused = false
              if (this._emitQueue.length) {
                var eq = this._emitQueue.slice(0)
                this._emitQueue.length = 0
                for (var i = 0; i < eq.length; i++) {
                  var e = eq[i]
                  this._emitMatch(e[0], e[1])
                }
              }
              if (this._processQueue.length) {
                var pq = this._processQueue.slice(0)
                this._processQueue.length = 0
                for (var i = 0; i < pq.length; i++) {
                  var p = pq[i]
                  this._processing--
                  this._process(p[0], p[1], p[2], p[3])
                }
              }
            }
          }

          Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
            assert(this instanceof Glob)
            assert(typeof cb === 'function')

            if (this.aborted) return

            this._processing++
            if (this.paused) {
              this._processQueue.push([pattern, index, inGlobStar, cb])
              return
            }

            //console.error('PROCESS %d', this._processing, pattern)

            // Get the first [n] parts of pattern that are all strings.
            var n = 0
            while (typeof pattern[n] === 'string') {
              n++
            }
            // now n is the index of the first one that is *not* a string.

            // see if there's anything else
            var prefix
            switch (n) {
              // if not, then this is rather simple
              case pattern.length:
                this._processSimple(pattern.join('/'), index, cb)
                return

              case 0:
                // pattern *starts* with some non-trivial item.
                // going to readdir(cwd), but not include the prefix in matches.
                prefix = null
                break

              default:
                // pattern has some string bits in the front.
                // whatever it starts with, whether that's 'absolute' like /foo/bar,
                // or 'relative' like '../baz'
                prefix = pattern.slice(0, n).join('/')
                break
            }

            var remain = pattern.slice(n)

            // get the list of entries.
            var read
            if (prefix === null) read = '.'
            else if (
              isAbsolute(prefix) ||
              isAbsolute(
                pattern
                  .map(function (p) {
                    return typeof p === 'string' ? p : '[*]'
                  })
                  .join('/')
              )
            ) {
              if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix
              read = prefix
            } else read = prefix

            var abs = this._makeAbs(read)

            //if ignored, skip _processing
            if (childrenIgnored(this, read)) return cb()

            var isGlobStar = remain[0] === minimatch.GLOBSTAR
            if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
            else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
          }

          Glob.prototype._processReaddir = function (
            prefix,
            read,
            abs,
            remain,
            index,
            inGlobStar,
            cb
          ) {
            var self = this
            this._readdir(abs, inGlobStar, function (er, entries) {
              return self._processReaddir2(
                prefix,
                read,
                abs,
                remain,
                index,
                inGlobStar,
                entries,
                cb
              )
            })
          }

          Glob.prototype._processReaddir2 = function (
            prefix,
            read,
            abs,
            remain,
            index,
            inGlobStar,
            entries,
            cb
          ) {
            // if the abs isn't a dir, then nothing can match!
            if (!entries) return cb()

            // It will only match dot entries if it starts with a dot, or if
            // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
            var pn = remain[0]
            var negate = !!this.minimatch.negate
            var rawGlob = pn._glob
            var dotOk = this.dot || rawGlob.charAt(0) === '.'

            var matchedEntries = []
            for (var i = 0; i < entries.length; i++) {
              var e = entries[i]
              if (e.charAt(0) !== '.' || dotOk) {
                var m
                if (negate && !prefix) {
                  m = !e.match(pn)
                } else {
                  m = e.match(pn)
                }
                if (m) matchedEntries.push(e)
              }
            }

            //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

            var len = matchedEntries.length
            // If there are no matched entries, then nothing matches.
            if (len === 0) return cb()

            // if this is the last remaining pattern bit, then no need for
            // an additional stat *unless* the user has specified mark or
            // stat explicitly.  We know they exist, since readdir returned
            // them.

            if (remain.length === 1 && !this.mark && !this.stat) {
              if (!this.matches[index]) this.matches[index] = Object.create(null)

              for (var i = 0; i < len; i++) {
                var e = matchedEntries[i]
                if (prefix) {
                  if (prefix !== '/') e = prefix + '/' + e
                  else e = prefix + e
                }

                if (e.charAt(0) === '/' && !this.nomount) {
                  e = path.join(this.root, e)
                }
                this._emitMatch(index, e)
              }
              // This was the last one, and no stats were needed
              return cb()
            }

            // now test all matched entries as stand-ins for that part
            // of the pattern.
            remain.shift()
            for (var i = 0; i < len; i++) {
              var e = matchedEntries[i]
              var newPattern
              if (prefix) {
                if (prefix !== '/') e = prefix + '/' + e
                else e = prefix + e
              }
              this._process([e].concat(remain), index, inGlobStar, cb)
            }
            cb()
          }

          Glob.prototype._emitMatch = function (index, e) {
            if (this.aborted) return

            if (isIgnored(this, e)) return

            if (this.paused) {
              this._emitQueue.push([index, e])
              return
            }

            var abs = isAbsolute(e) ? e : this._makeAbs(e)

            if (this.mark) e = this._mark(e)

            if (this.absolute) e = abs

            if (this.matches[index][e]) return

            if (this.nodir) {
              var c = this.cache[abs]
              if (c === 'DIR' || Array.isArray(c)) return
            }

            this.matches[index][e] = true

            var st = this.statCache[abs]
            if (st) this.emit('stat', e, st)

            this.emit('match', e)
          }

          Glob.prototype._readdirInGlobStar = function (abs, cb) {
            if (this.aborted) return

            // follow all symlinked directories forever
            // just proceed as if this is a non-globstar situation
            if (this.follow) return this._readdir(abs, false, cb)

            var lstatkey = 'lstat\0' + abs
            var self = this
            var lstatcb = inflight(lstatkey, lstatcb_)

            if (lstatcb) self.fs.lstat(abs, lstatcb)

            function lstatcb_(er, lstat) {
              if (er && er.code === 'ENOENT') return cb()

              var isSym = lstat && lstat.isSymbolicLink()
              self.symlinks[abs] = isSym

              // If it's not a symlink or a dir, then it's definitely a regular file.
              // don't bother doing a readdir in that case.
              if (!isSym && lstat && !lstat.isDirectory()) {
                self.cache[abs] = 'FILE'
                cb()
              } else self._readdir(abs, false, cb)
            }
          }

          Glob.prototype._readdir = function (abs, inGlobStar, cb) {
            if (this.aborted) return

            cb = inflight('readdir\0' + abs + '\0' + inGlobStar, cb)
            if (!cb) return

            //console.error('RD %j %j', +inGlobStar, abs)
            if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb)

            if (ownProp(this.cache, abs)) {
              var c = this.cache[abs]
              if (!c || c === 'FILE') return cb()

              if (Array.isArray(c)) return cb(null, c)
            }

            var self = this
            self.fs.readdir(abs, readdirCb(this, abs, cb))
          }

          function readdirCb(self, abs, cb) {
            return function (er, entries) {
              if (er) self._readdirError(abs, er, cb)
              else self._readdirEntries(abs, entries, cb)
            }
          }

          Glob.prototype._readdirEntries = function (abs, entries, cb) {
            if (this.aborted) return

            // if we haven't asked to stat everything, then just
            // assume that everything in there exists, so we can avoid
            // having to stat it a second time.
            if (!this.mark && !this.stat) {
              for (var i = 0; i < entries.length; i++) {
                var e = entries[i]
                if (abs === '/') e = abs + e
                else e = abs + '/' + e
                this.cache[e] = true
              }
            }

            this.cache[abs] = entries
            return cb(null, entries)
          }

          Glob.prototype._readdirError = function (f, er, cb) {
            if (this.aborted) return

            // handle errors, and cache the information
            switch (er.code) {
              case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
              case 'ENOTDIR': // totally normal. means it *does* exist.
                var abs = this._makeAbs(f)
                this.cache[abs] = 'FILE'
                if (abs === this.cwdAbs) {
                  var error = new Error(er.code + ' invalid cwd ' + this.cwd)
                  error.path = this.cwd
                  error.code = er.code
                  this.emit('error', error)
                  this.abort()
                }
                break

              case 'ENOENT': // not terribly unusual
              case 'ELOOP':
              case 'ENAMETOOLONG':
              case 'UNKNOWN':
                this.cache[this._makeAbs(f)] = false
                break

              default: // some unusual error.  Treat as failure.
                this.cache[this._makeAbs(f)] = false
                if (this.strict) {
                  this.emit('error', er)
                  // If the error is handled, then we abort
                  // if not, we threw out of here
                  this.abort()
                }
                if (!this.silent) console.error('glob error', er)
                break
            }

            return cb()
          }

          Glob.prototype._processGlobStar = function (
            prefix,
            read,
            abs,
            remain,
            index,
            inGlobStar,
            cb
          ) {
            var self = this
            this._readdir(abs, inGlobStar, function (er, entries) {
              self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
            })
          }

          Glob.prototype._processGlobStar2 = function (
            prefix,
            read,
            abs,
            remain,
            index,
            inGlobStar,
            entries,
            cb
          ) {
            //console.error('pgs2', prefix, remain[0], entries)

            // no entries means not a dir, so it can never have matches
            // foo.txt/** doesn't match foo.txt
            if (!entries) return cb()

            // test without the globstar, and with every child both below
            // and replacing the globstar.
            var remainWithoutGlobStar = remain.slice(1)
            var gspref = prefix ? [prefix] : []
            var noGlobStar = gspref.concat(remainWithoutGlobStar)

            // the noGlobStar pattern exits the inGlobStar state
            this._process(noGlobStar, index, false, cb)

            var isSym = this.symlinks[abs]
            var len = entries.length

            // If it's a symlink, and we're in a globstar, then stop
            if (isSym && inGlobStar) return cb()

            for (var i = 0; i < len; i++) {
              var e = entries[i]
              if (e.charAt(0) === '.' && !this.dot) continue

              // these two cases enter the inGlobStar state
              var instead = gspref.concat(entries[i], remainWithoutGlobStar)
              this._process(instead, index, true, cb)

              var below = gspref.concat(entries[i], remain)
              this._process(below, index, true, cb)
            }

            cb()
          }

          Glob.prototype._processSimple = function (prefix, index, cb) {
            // XXX review this.  Shouldn't it be doing the mounting etc
            // before doing stat?  kinda weird?
            var self = this
            this._stat(prefix, function (er, exists) {
              self._processSimple2(prefix, index, er, exists, cb)
            })
          }
          Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
            //console.error('ps2', prefix, exists)

            if (!this.matches[index]) this.matches[index] = Object.create(null)

            // If it doesn't exist, then just mark the lack of results
            if (!exists) return cb()

            if (prefix && isAbsolute(prefix) && !this.nomount) {
              var trail = /[\/\\]$/.test(prefix)
              if (prefix.charAt(0) === '/') {
                prefix = path.join(this.root, prefix)
              } else {
                prefix = path.resolve(this.root, prefix)
                if (trail) prefix += '/'
              }
            }

            if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/')

            // Mark this as a match
            this._emitMatch(index, prefix)
            cb()
          }

          // Returns either 'DIR', 'FILE', or false
          Glob.prototype._stat = function (f, cb) {
            var abs = this._makeAbs(f)
            var needDir = f.slice(-1) === '/'

            if (f.length > this.maxLength) return cb()

            if (!this.stat && ownProp(this.cache, abs)) {
              var c = this.cache[abs]

              if (Array.isArray(c)) c = 'DIR'

              // It exists, but maybe not how we need it
              if (!needDir || c === 'DIR') return cb(null, c)

              if (needDir && c === 'FILE') return cb()

              // otherwise we have to stat, because maybe c=true
              // if we know it exists, but not what it is.
            }

            var exists
            var stat = this.statCache[abs]
            if (stat !== undefined) {
              if (stat === false) return cb(null, stat)
              else {
                var type = stat.isDirectory() ? 'DIR' : 'FILE'
                if (needDir && type === 'FILE') return cb()
                else return cb(null, type, stat)
              }
            }

            var self = this
            var statcb = inflight('stat\0' + abs, lstatcb_)
            if (statcb) self.fs.lstat(abs, statcb)

            function lstatcb_(er, lstat) {
              if (lstat && lstat.isSymbolicLink()) {
                // If it's a symlink, then treat it as the target, unless
                // the target does not exist, then treat it as a file.
                return self.fs.stat(abs, function (er, stat) {
                  if (er) self._stat2(f, abs, null, lstat, cb)
                  else self._stat2(f, abs, er, stat, cb)
                })
              } else {
                self._stat2(f, abs, er, lstat, cb)
              }
            }
          }

          Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
            if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
              this.statCache[abs] = false
              return cb()
            }

            var needDir = f.slice(-1) === '/'
            this.statCache[abs] = stat

            if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat)

            var c = true
            if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE'
            this.cache[abs] = this.cache[abs] || c

            if (needDir && c === 'FILE') return cb()

            return cb(null, c, stat)
          }

          /***/
        },

      /***/ './node_modules/glob/sync.js':
        /*!***********************************!*\
  !*** ./node_modules/glob/sync.js ***!
  \***********************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          module.exports = globSync
          globSync.GlobSync = GlobSync

          var rp = __webpack_require__(/*! fs.realpath */ './node_modules/fs.realpath/index.js')
          var minimatch = __webpack_require__(
            /*! minimatch */ './node_modules/minimatch/minimatch.js'
          )
          var Minimatch = minimatch.Minimatch
          var Glob = __webpack_require__(/*! ./glob.js */ './node_modules/glob/glob.js').Glob
          var util = __webpack_require__(/*! util */ 'util')
          var path = __webpack_require__(/*! path */ 'path')
          var assert = __webpack_require__(/*! assert */ 'assert')
          var isAbsolute = __webpack_require__(
            /*! path-is-absolute */ './node_modules/path-is-absolute/index.js'
          )
          var common = __webpack_require__(/*! ./common.js */ './node_modules/glob/common.js')
          var setopts = common.setopts
          var ownProp = common.ownProp
          var childrenIgnored = common.childrenIgnored
          var isIgnored = common.isIgnored

          function globSync(pattern, options) {
            if (typeof options === 'function' || arguments.length === 3)
              throw new TypeError(
                'callback provided to sync glob\n' +
                  'See: https://github.com/isaacs/node-glob/issues/167'
              )

            return new GlobSync(pattern, options).found
          }

          function GlobSync(pattern, options) {
            if (!pattern) throw new Error('must provide pattern')

            if (typeof options === 'function' || arguments.length === 3)
              throw new TypeError(
                'callback provided to sync glob\n' +
                  'See: https://github.com/isaacs/node-glob/issues/167'
              )

            if (!(this instanceof GlobSync)) return new GlobSync(pattern, options)

            setopts(this, pattern, options)

            if (this.noprocess) return this

            var n = this.minimatch.set.length
            this.matches = new Array(n)
            for (var i = 0; i < n; i++) {
              this._process(this.minimatch.set[i], i, false)
            }
            this._finish()
          }

          GlobSync.prototype._finish = function () {
            assert.ok(this instanceof GlobSync)
            if (this.realpath) {
              var self = this
              this.matches.forEach(function (matchset, index) {
                var set = (self.matches[index] = Object.create(null))
                for (var p in matchset) {
                  try {
                    p = self._makeAbs(p)
                    var real = rp.realpathSync(p, self.realpathCache)
                    set[real] = true
                  } catch (er) {
                    if (er.syscall === 'stat') set[self._makeAbs(p)] = true
                    else throw er
                  }
                }
              })
            }
            common.finish(this)
          }

          GlobSync.prototype._process = function (pattern, index, inGlobStar) {
            assert.ok(this instanceof GlobSync)

            // Get the first [n] parts of pattern that are all strings.
            var n = 0
            while (typeof pattern[n] === 'string') {
              n++
            }
            // now n is the index of the first one that is *not* a string.

            // See if there's anything else
            var prefix
            switch (n) {
              // if not, then this is rather simple
              case pattern.length:
                this._processSimple(pattern.join('/'), index)
                return

              case 0:
                // pattern *starts* with some non-trivial item.
                // going to readdir(cwd), but not include the prefix in matches.
                prefix = null
                break

              default:
                // pattern has some string bits in the front.
                // whatever it starts with, whether that's 'absolute' like /foo/bar,
                // or 'relative' like '../baz'
                prefix = pattern.slice(0, n).join('/')
                break
            }

            var remain = pattern.slice(n)

            // get the list of entries.
            var read
            if (prefix === null) read = '.'
            else if (
              isAbsolute(prefix) ||
              isAbsolute(
                pattern
                  .map(function (p) {
                    return typeof p === 'string' ? p : '[*]'
                  })
                  .join('/')
              )
            ) {
              if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix
              read = prefix
            } else read = prefix

            var abs = this._makeAbs(read)

            //if ignored, skip processing
            if (childrenIgnored(this, read)) return

            var isGlobStar = remain[0] === minimatch.GLOBSTAR
            if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
            else this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
          }

          GlobSync.prototype._processReaddir = function (
            prefix,
            read,
            abs,
            remain,
            index,
            inGlobStar
          ) {
            var entries = this._readdir(abs, inGlobStar)

            // if the abs isn't a dir, then nothing can match!
            if (!entries) return

            // It will only match dot entries if it starts with a dot, or if
            // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
            var pn = remain[0]
            var negate = !!this.minimatch.negate
            var rawGlob = pn._glob
            var dotOk = this.dot || rawGlob.charAt(0) === '.'

            var matchedEntries = []
            for (var i = 0; i < entries.length; i++) {
              var e = entries[i]
              if (e.charAt(0) !== '.' || dotOk) {
                var m
                if (negate && !prefix) {
                  m = !e.match(pn)
                } else {
                  m = e.match(pn)
                }
                if (m) matchedEntries.push(e)
              }
            }

            var len = matchedEntries.length
            // If there are no matched entries, then nothing matches.
            if (len === 0) return

            // if this is the last remaining pattern bit, then no need for
            // an additional stat *unless* the user has specified mark or
            // stat explicitly.  We know they exist, since readdir returned
            // them.

            if (remain.length === 1 && !this.mark && !this.stat) {
              if (!this.matches[index]) this.matches[index] = Object.create(null)

              for (var i = 0; i < len; i++) {
                var e = matchedEntries[i]
                if (prefix) {
                  if (prefix.slice(-1) !== '/') e = prefix + '/' + e
                  else e = prefix + e
                }

                if (e.charAt(0) === '/' && !this.nomount) {
                  e = path.join(this.root, e)
                }
                this._emitMatch(index, e)
              }
              // This was the last one, and no stats were needed
              return
            }

            // now test all matched entries as stand-ins for that part
            // of the pattern.
            remain.shift()
            for (var i = 0; i < len; i++) {
              var e = matchedEntries[i]
              var newPattern
              if (prefix) newPattern = [prefix, e]
              else newPattern = [e]
              this._process(newPattern.concat(remain), index, inGlobStar)
            }
          }

          GlobSync.prototype._emitMatch = function (index, e) {
            if (isIgnored(this, e)) return

            var abs = this._makeAbs(e)

            if (this.mark) e = this._mark(e)

            if (this.absolute) {
              e = abs
            }

            if (this.matches[index][e]) return

            if (this.nodir) {
              var c = this.cache[abs]
              if (c === 'DIR' || Array.isArray(c)) return
            }

            this.matches[index][e] = true

            if (this.stat) this._stat(e)
          }

          GlobSync.prototype._readdirInGlobStar = function (abs) {
            // follow all symlinked directories forever
            // just proceed as if this is a non-globstar situation
            if (this.follow) return this._readdir(abs, false)

            var entries
            var lstat
            var stat
            try {
              lstat = this.fs.lstatSync(abs)
            } catch (er) {
              if (er.code === 'ENOENT') {
                // lstat failed, doesn't exist
                return null
              }
            }

            var isSym = lstat && lstat.isSymbolicLink()
            this.symlinks[abs] = isSym

            // If it's not a symlink or a dir, then it's definitely a regular file.
            // don't bother doing a readdir in that case.
            if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE'
            else entries = this._readdir(abs, false)

            return entries
          }

          GlobSync.prototype._readdir = function (abs, inGlobStar) {
            var entries

            if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs)

            if (ownProp(this.cache, abs)) {
              var c = this.cache[abs]
              if (!c || c === 'FILE') return null

              if (Array.isArray(c)) return c
            }

            try {
              return this._readdirEntries(abs, this.fs.readdirSync(abs))
            } catch (er) {
              this._readdirError(abs, er)
              return null
            }
          }

          GlobSync.prototype._readdirEntries = function (abs, entries) {
            // if we haven't asked to stat everything, then just
            // assume that everything in there exists, so we can avoid
            // having to stat it a second time.
            if (!this.mark && !this.stat) {
              for (var i = 0; i < entries.length; i++) {
                var e = entries[i]
                if (abs === '/') e = abs + e
                else e = abs + '/' + e
                this.cache[e] = true
              }
            }

            this.cache[abs] = entries

            // mark and cache dir-ness
            return entries
          }

          GlobSync.prototype._readdirError = function (f, er) {
            // handle errors, and cache the information
            switch (er.code) {
              case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
              case 'ENOTDIR': // totally normal. means it *does* exist.
                var abs = this._makeAbs(f)
                this.cache[abs] = 'FILE'
                if (abs === this.cwdAbs) {
                  var error = new Error(er.code + ' invalid cwd ' + this.cwd)
                  error.path = this.cwd
                  error.code = er.code
                  throw error
                }
                break

              case 'ENOENT': // not terribly unusual
              case 'ELOOP':
              case 'ENAMETOOLONG':
              case 'UNKNOWN':
                this.cache[this._makeAbs(f)] = false
                break

              default: // some unusual error.  Treat as failure.
                this.cache[this._makeAbs(f)] = false
                if (this.strict) throw er
                if (!this.silent) console.error('glob error', er)
                break
            }
          }

          GlobSync.prototype._processGlobStar = function (
            prefix,
            read,
            abs,
            remain,
            index,
            inGlobStar
          ) {
            var entries = this._readdir(abs, inGlobStar)

            // no entries means not a dir, so it can never have matches
            // foo.txt/** doesn't match foo.txt
            if (!entries) return

            // test without the globstar, and with every child both below
            // and replacing the globstar.
            var remainWithoutGlobStar = remain.slice(1)
            var gspref = prefix ? [prefix] : []
            var noGlobStar = gspref.concat(remainWithoutGlobStar)

            // the noGlobStar pattern exits the inGlobStar state
            this._process(noGlobStar, index, false)

            var len = entries.length
            var isSym = this.symlinks[abs]

            // If it's a symlink, and we're in a globstar, then stop
            if (isSym && inGlobStar) return

            for (var i = 0; i < len; i++) {
              var e = entries[i]
              if (e.charAt(0) === '.' && !this.dot) continue

              // these two cases enter the inGlobStar state
              var instead = gspref.concat(entries[i], remainWithoutGlobStar)
              this._process(instead, index, true)

              var below = gspref.concat(entries[i], remain)
              this._process(below, index, true)
            }
          }

          GlobSync.prototype._processSimple = function (prefix, index) {
            // XXX review this.  Shouldn't it be doing the mounting etc
            // before doing stat?  kinda weird?
            var exists = this._stat(prefix)

            if (!this.matches[index]) this.matches[index] = Object.create(null)

            // If it doesn't exist, then just mark the lack of results
            if (!exists) return

            if (prefix && isAbsolute(prefix) && !this.nomount) {
              var trail = /[\/\\]$/.test(prefix)
              if (prefix.charAt(0) === '/') {
                prefix = path.join(this.root, prefix)
              } else {
                prefix = path.resolve(this.root, prefix)
                if (trail) prefix += '/'
              }
            }

            if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/')

            // Mark this as a match
            this._emitMatch(index, prefix)
          }

          // Returns either 'DIR', 'FILE', or false
          GlobSync.prototype._stat = function (f) {
            var abs = this._makeAbs(f)
            var needDir = f.slice(-1) === '/'

            if (f.length > this.maxLength) return false

            if (!this.stat && ownProp(this.cache, abs)) {
              var c = this.cache[abs]

              if (Array.isArray(c)) c = 'DIR'

              // It exists, but maybe not how we need it
              if (!needDir || c === 'DIR') return c

              if (needDir && c === 'FILE') return false

              // otherwise we have to stat, because maybe c=true
              // if we know it exists, but not what it is.
            }

            var exists
            var stat = this.statCache[abs]
            if (!stat) {
              var lstat
              try {
                lstat = this.fs.lstatSync(abs)
              } catch (er) {
                if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
                  this.statCache[abs] = false
                  return false
                }
              }

              if (lstat && lstat.isSymbolicLink()) {
                try {
                  stat = this.fs.statSync(abs)
                } catch (er) {
                  stat = lstat
                }
              } else {
                stat = lstat
              }
            }

            this.statCache[abs] = stat

            var c = true
            if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE'

            this.cache[abs] = this.cache[abs] || c

            if (needDir && c === 'FILE') return false

            return c
          }

          GlobSync.prototype._mark = function (p) {
            return common.mark(this, p)
          }

          GlobSync.prototype._makeAbs = function (f) {
            return common.makeAbs(this, f)
          }

          /***/
        },

      /***/ './node_modules/immediate/lib/index.js':
        /*!*********************************************!*\
  !*** ./node_modules/immediate/lib/index.js ***!
  \*********************************************/
        /***/ (module) => {
          'use strict'

          var Mutation = global.MutationObserver || global.WebKitMutationObserver

          var scheduleDrain

          if (process.browser) {
            if (Mutation) {
              var called = 0
              var observer = new Mutation(nextTick)
              var element = global.document.createTextNode('')
              observer.observe(element, {
                characterData: true
              })
              scheduleDrain = function () {
                element.data = called = ++called % 2
              }
            } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
              var channel = new global.MessageChannel()
              channel.port1.onmessage = nextTick
              scheduleDrain = function () {
                channel.port2.postMessage(0)
              }
            } else if (
              'document' in global &&
              'onreadystatechange' in global.document.createElement('script')
            ) {
              scheduleDrain = function () {
                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                var scriptEl = global.document.createElement('script')
                scriptEl.onreadystatechange = function () {
                  nextTick()

                  scriptEl.onreadystatechange = null
                  scriptEl.parentNode.removeChild(scriptEl)
                  scriptEl = null
                }
                global.document.documentElement.appendChild(scriptEl)
              }
            } else {
              scheduleDrain = function () {
                setTimeout(nextTick, 0)
              }
            }
          } else {
            scheduleDrain = function () {
              process.nextTick(nextTick)
            }
          }

          var draining
          var queue = []
          //named nextTick for less confusing stack traces
          function nextTick() {
            draining = true
            var i, oldQueue
            var len = queue.length
            while (len) {
              oldQueue = queue
              queue = []
              i = -1
              while (++i < len) {
                oldQueue[i]()
              }
              len = queue.length
            }
            draining = false
          }

          module.exports = immediate
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain()
            }
          }

          /***/
        },

      /***/ './node_modules/inflight/inflight.js':
        /*!*******************************************!*\
  !*** ./node_modules/inflight/inflight.js ***!
  \*******************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          var wrappy = __webpack_require__(/*! wrappy */ './node_modules/wrappy/wrappy.js')
          var reqs = Object.create(null)
          var once = __webpack_require__(/*! once */ './node_modules/once/once.js')

          module.exports = wrappy(inflight)

          function inflight(key, cb) {
            if (reqs[key]) {
              reqs[key].push(cb)
              return null
            } else {
              reqs[key] = [cb]
              return makeres(key)
            }
          }

          function makeres(key) {
            return once(function RES() {
              var cbs = reqs[key]
              var len = cbs.length
              var args = slice(arguments)

              // XXX It's somewhat ambiguous whether a new callback added in this
              // pass should be queued for later execution if something in the
              // list of callbacks throws, or if it should just be discarded.
              // However, it's such an edge case that it hardly matters, and either
              // choice is likely as surprising as the other.
              // As it happens, we do go ahead and schedule it for later execution.
              try {
                for (var i = 0; i < len; i++) {
                  cbs[i].apply(null, args)
                }
              } finally {
                if (cbs.length > len) {
                  // added more in the interim.
                  // de-zalgo, just in case, but don't call again.
                  cbs.splice(0, len)
                  process.nextTick(function () {
                    RES.apply(null, args)
                  })
                } else {
                  delete reqs[key]
                }
              }
            })
          }

          function slice(args) {
            var length = args.length
            var array = []

            for (var i = 0; i < length; i++) array[i] = args[i]
            return array
          }

          /***/
        },

      /***/ './node_modules/inherits/inherits.js':
        /*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          try {
            var util = __webpack_require__(/*! util */ 'util')
            /* istanbul ignore next */
            if (typeof util.inherits !== 'function') throw ''
            module.exports = util.inherits
          } catch (e) {
            /* istanbul ignore next */
            module.exports = __webpack_require__(
              /*! ./inherits_browser.js */ './node_modules/inherits/inherits_browser.js'
            )
          }

          /***/
        },

      /***/ './node_modules/inherits/inherits_browser.js':
        /*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
        /***/ (module) => {
          if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                })
              }
            }
          } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () {}
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
              }
            }
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/base64.js':
        /*!******************************************!*\
  !*** ./node_modules/jszip/lib/base64.js ***!
  \******************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')
          var support = __webpack_require__(/*! ./support */ './node_modules/jszip/lib/support.js')
          // private property
          var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='

          // public method for encoding
          exports.encode = function (input) {
            var output = []
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4
            var i = 0,
              len = input.length,
              remainingBytes = len

            var isArray = utils.getTypeOf(input) !== 'string'
            while (i < input.length) {
              remainingBytes = len - i

              if (!isArray) {
                chr1 = input.charCodeAt(i++)
                chr2 = i < len ? input.charCodeAt(i++) : 0
                chr3 = i < len ? input.charCodeAt(i++) : 0
              } else {
                chr1 = input[i++]
                chr2 = i < len ? input[i++] : 0
                chr3 = i < len ? input[i++] : 0
              }

              enc1 = chr1 >> 2
              enc2 = ((chr1 & 3) << 4) | (chr2 >> 4)
              enc3 = remainingBytes > 1 ? ((chr2 & 15) << 2) | (chr3 >> 6) : 64
              enc4 = remainingBytes > 2 ? chr3 & 63 : 64

              output.push(
                _keyStr.charAt(enc1) +
                  _keyStr.charAt(enc2) +
                  _keyStr.charAt(enc3) +
                  _keyStr.charAt(enc4)
              )
            }

            return output.join('')
          }

          // public method for decoding
          exports.decode = function (input) {
            var chr1, chr2, chr3
            var enc1, enc2, enc3, enc4
            var i = 0,
              resultIndex = 0

            var dataUrlPrefix = 'data:'

            if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
              // This is a common error: people give a data url
              // (data:image/png;base64,iVBOR...) with a {base64: true} and
              // wonders why things don't work.
              // We can detect that the string input looks like a data url but we
              // *can't* be sure it is one: removing everything up to the comma would
              // be too dangerous.
              throw new Error('Invalid base64 input, it looks like a data url.')
            }

            input = input.replace(/[^A-Za-z0-9+/=]/g, '')

            var totalLength = (input.length * 3) / 4
            if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
              totalLength--
            }
            if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
              totalLength--
            }
            if (totalLength % 1 !== 0) {
              // totalLength is not an integer, the length does not match a valid
              // base64 content. That can happen if:
              // - the input is not a base64 content
              // - the input is *almost* a base64 content, with a extra chars at the
              //   beginning or at the end
              // - the input uses a base64 variant (base64url for example)
              throw new Error('Invalid base64 input, bad content length.')
            }
            var output
            if (support.uint8array) {
              output = new Uint8Array(totalLength | 0)
            } else {
              output = new Array(totalLength | 0)
            }

            while (i < input.length) {
              enc1 = _keyStr.indexOf(input.charAt(i++))
              enc2 = _keyStr.indexOf(input.charAt(i++))
              enc3 = _keyStr.indexOf(input.charAt(i++))
              enc4 = _keyStr.indexOf(input.charAt(i++))

              chr1 = (enc1 << 2) | (enc2 >> 4)
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)
              chr3 = ((enc3 & 3) << 6) | enc4

              output[resultIndex++] = chr1

              if (enc3 !== 64) {
                output[resultIndex++] = chr2
              }
              if (enc4 !== 64) {
                output[resultIndex++] = chr3
              }
            }

            return output
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/compressedObject.js':
        /*!****************************************************!*\
  !*** ./node_modules/jszip/lib/compressedObject.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var external = __webpack_require__(
            /*! ./external */ './node_modules/jszip/lib/external.js'
          )
          var DataWorker = __webpack_require__(
            /*! ./stream/DataWorker */ './node_modules/jszip/lib/stream/DataWorker.js'
          )
          var Crc32Probe = __webpack_require__(
            /*! ./stream/Crc32Probe */ './node_modules/jszip/lib/stream/Crc32Probe.js'
          )
          var DataLengthProbe = __webpack_require__(
            /*! ./stream/DataLengthProbe */ './node_modules/jszip/lib/stream/DataLengthProbe.js'
          )

          /**
           * Represent a compressed object, with everything needed to decompress it.
           * @constructor
           * @param {number} compressedSize the size of the data compressed.
           * @param {number} uncompressedSize the size of the data after decompression.
           * @param {number} crc32 the crc32 of the decompressed file.
           * @param {object} compression the type of compression, see lib/compressions.js.
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
           */
          function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
            this.compressedSize = compressedSize
            this.uncompressedSize = uncompressedSize
            this.crc32 = crc32
            this.compression = compression
            this.compressedContent = data
          }

          CompressedObject.prototype = {
            /**
             * Create a worker to get the uncompressed content.
             * @return {GenericWorker} the worker.
             */
            getContentWorker: function () {
              var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
                .pipe(this.compression.uncompressWorker())
                .pipe(new DataLengthProbe('data_length'))

              var that = this
              worker.on('end', function () {
                if (this.streamInfo['data_length'] !== that.uncompressedSize) {
                  throw new Error('Bug : uncompressed data size mismatch')
                }
              })
              return worker
            },
            /**
             * Create a worker to get the compressed content.
             * @return {GenericWorker} the worker.
             */
            getCompressedWorker: function () {
              return new DataWorker(external.Promise.resolve(this.compressedContent))
                .withStreamInfo('compressedSize', this.compressedSize)
                .withStreamInfo('uncompressedSize', this.uncompressedSize)
                .withStreamInfo('crc32', this.crc32)
                .withStreamInfo('compression', this.compression)
            }
          }

          /**
           * Chain the given worker with other workers to compress the content with the
           * given compression.
           * @param {GenericWorker} uncompressedWorker the worker to pipe.
           * @param {Object} compression the compression object.
           * @param {Object} compressionOptions the options to use when compressing.
           * @return {GenericWorker} the new worker compressing the content.
           */
          CompressedObject.createWorkerFrom = function (
            uncompressedWorker,
            compression,
            compressionOptions
          ) {
            return uncompressedWorker
              .pipe(new Crc32Probe())
              .pipe(new DataLengthProbe('uncompressedSize'))
              .pipe(compression.compressWorker(compressionOptions))
              .pipe(new DataLengthProbe('compressedSize'))
              .withStreamInfo('compression', compression)
          }

          module.exports = CompressedObject

          /***/
        },

      /***/ './node_modules/jszip/lib/compressions.js':
        /*!************************************************!*\
  !*** ./node_modules/jszip/lib/compressions.js ***!
  \************************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var GenericWorker = __webpack_require__(
            /*! ./stream/GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )

          exports.STORE = {
            magic: '\x00\x00',
            compressWorker: function () {
              return new GenericWorker('STORE compression')
            },
            uncompressWorker: function () {
              return new GenericWorker('STORE decompression')
            }
          }
          exports.DEFLATE = __webpack_require__(/*! ./flate */ './node_modules/jszip/lib/flate.js')

          /***/
        },

      /***/ './node_modules/jszip/lib/crc32.js':
        /*!*****************************************!*\
  !*** ./node_modules/jszip/lib/crc32.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')

          /**
           * The following functions come from pako, from pako/lib/zlib/crc32.js
           * released under the MIT license, see pako https://github.com/nodeca/pako/
           */

          // Use ordinary array, since untyped makes no boost here
          function makeTable() {
            var c,
              table = []

            for (var n = 0; n < 256; n++) {
              c = n
              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1
              }
              table[n] = c
            }

            return table
          }

          // Create table on load. Just 255 signed longs. Not a problem.
          var crcTable = makeTable()

          function crc32(crc, buf, len, pos) {
            var t = crcTable,
              end = pos + len

            crc = crc ^ -1

            for (var i = pos; i < end; i++) {
              crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff]
            }

            return crc ^ -1 // >>> 0;
          }

          // That's all for the pako functions.

          /**
           * Compute the crc32 of a string.
           * This is almost the same as the function crc32, but for strings. Using the
           * same function for the two use cases leads to horrible performances.
           * @param {Number} crc the starting value of the crc.
           * @param {String} str the string to use.
           * @param {Number} len the length of the string.
           * @param {Number} pos the starting position for the crc32 computation.
           * @return {Number} the computed crc32.
           */
          function crc32str(crc, str, len, pos) {
            var t = crcTable,
              end = pos + len

            crc = crc ^ -1

            for (var i = pos; i < end; i++) {
              crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xff]
            }

            return crc ^ -1 // >>> 0;
          }

          module.exports = function crc32wrapper(input, crc) {
            if (typeof input === 'undefined' || !input.length) {
              return 0
            }

            var isArray = utils.getTypeOf(input) !== 'string'

            if (isArray) {
              return crc32(crc | 0, input, input.length, 0)
            } else {
              return crc32str(crc | 0, input, input.length, 0)
            }
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/defaults.js':
        /*!********************************************!*\
  !*** ./node_modules/jszip/lib/defaults.js ***!
  \********************************************/
        /***/ (__unused_webpack_module, exports) => {
          'use strict'

          exports.base64 = false
          exports.binary = false
          exports.dir = false
          exports.createFolders = true
          exports.date = null
          exports.compression = null
          exports.compressionOptions = null
          exports.comment = null
          exports.unixPermissions = null
          exports.dosPermissions = null

          /***/
        },

      /***/ './node_modules/jszip/lib/external.js':
        /*!********************************************!*\
  !*** ./node_modules/jszip/lib/external.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          // load the global object first:
          // - it should be better integrated in the system (unhandledRejection in node)
          // - the environment may have a custom Promise implementation (see zone.js)
          var ES6Promise = null
          if (typeof Promise !== 'undefined') {
            ES6Promise = Promise
          } else {
            ES6Promise = __webpack_require__(/*! lie */ './node_modules/lie/lib/index.js')
          }

          /**
           * Let the user use/change some implementations.
           */
          module.exports = {
            Promise: ES6Promise
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/flate.js':
        /*!*****************************************!*\
  !*** ./node_modules/jszip/lib/flate.js ***!
  \*****************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var USE_TYPEDARRAY =
            typeof Uint8Array !== 'undefined' &&
            typeof Uint16Array !== 'undefined' &&
            typeof Uint32Array !== 'undefined'

          var pako = __webpack_require__(/*! pako */ './node_modules/pako/index.js')
          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')
          var GenericWorker = __webpack_require__(
            /*! ./stream/GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )

          var ARRAY_TYPE = USE_TYPEDARRAY ? 'uint8array' : 'array'

          exports.magic = '\x08\x00'

          /**
           * Create a worker that uses pako to inflate/deflate.
           * @constructor
           * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
           * @param {Object} options the options to use when (de)compressing.
           */
          function FlateWorker(action, options) {
            GenericWorker.call(this, 'FlateWorker/' + action)

            this._pako = null
            this._pakoAction = action
            this._pakoOptions = options
            // the `meta` object from the last chunk received
            // this allow this worker to pass around metadata
            this.meta = {}
          }

          utils.inherits(FlateWorker, GenericWorker)

          /**
           * @see GenericWorker.processChunk
           */
          FlateWorker.prototype.processChunk = function (chunk) {
            this.meta = chunk.meta
            if (this._pako === null) {
              this._createPako()
            }
            this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false)
          }

          /**
           * @see GenericWorker.flush
           */
          FlateWorker.prototype.flush = function () {
            GenericWorker.prototype.flush.call(this)
            if (this._pako === null) {
              this._createPako()
            }
            this._pako.push([], true)
          }
          /**
           * @see GenericWorker.cleanUp
           */
          FlateWorker.prototype.cleanUp = function () {
            GenericWorker.prototype.cleanUp.call(this)
            this._pako = null
          }

          /**
           * Create the _pako object.
           * TODO: lazy-loading this object isn't the best solution but it's the
           * quickest. The best solution is to lazy-load the worker list. See also the
           * issue #446.
           */
          FlateWorker.prototype._createPako = function () {
            this._pako = new pako[this._pakoAction]({
              raw: true,
              level: this._pakoOptions.level || -1 // default compression
            })
            var self = this
            this._pako.onData = function (data) {
              self.push({
                data: data,
                meta: self.meta
              })
            }
          }

          exports.compressWorker = function (compressionOptions) {
            return new FlateWorker('Deflate', compressionOptions)
          }
          exports.uncompressWorker = function () {
            return new FlateWorker('Inflate', {})
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/generate/ZipFileWorker.js':
        /*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/generate/ZipFileWorker.js ***!
  \**********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')
          var GenericWorker = __webpack_require__(
            /*! ../stream/GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )
          var utf8 = __webpack_require__(/*! ../utf8 */ './node_modules/jszip/lib/utf8.js')
          var crc32 = __webpack_require__(/*! ../crc32 */ './node_modules/jszip/lib/crc32.js')
          var signature = __webpack_require__(
            /*! ../signature */ './node_modules/jszip/lib/signature.js'
          )

          /**
           * Transform an integer into a string in hexadecimal.
           * @private
           * @param {number} dec the number to convert.
           * @param {number} bytes the number of bytes to generate.
           * @returns {string} the result.
           */
          var decToHex = function (dec, bytes) {
            var hex = '',
              i
            for (i = 0; i < bytes; i++) {
              hex += String.fromCharCode(dec & 0xff)
              dec = dec >>> 8
            }
            return hex
          }

          /**
           * Generate the UNIX part of the external file attributes.
           * @param {Object} unixPermissions the unix permissions or null.
           * @param {Boolean} isDir true if the entry is a directory, false otherwise.
           * @return {Number} a 32 bit integer.
           *
           * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
           *
           * TTTTsstrwxrwxrwx0000000000ADVSHR
           * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
           *     ^^^_________________________ setuid, setgid, sticky
           *        ^^^^^^^^^________________ permissions
           *                 ^^^^^^^^^^______ not used ?
           *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
           */
          var generateUnixExternalFileAttr = function (unixPermissions, isDir) {
            var result = unixPermissions
            if (!unixPermissions) {
              // I can't use octal values in strict mode, hence the hexa.
              //  040775 => 0x41fd
              // 0100664 => 0x81b4
              result = isDir ? 0x41fd : 0x81b4
            }
            return (result & 0xffff) << 16
          }

          /**
           * Generate the DOS part of the external file attributes.
           * @param {Object} dosPermissions the dos permissions or null.
           * @param {Boolean} isDir true if the entry is a directory, false otherwise.
           * @return {Number} a 32 bit integer.
           *
           * Bit 0     Read-Only
           * Bit 1     Hidden
           * Bit 2     System
           * Bit 3     Volume Label
           * Bit 4     Directory
           * Bit 5     Archive
           */
          var generateDosExternalFileAttr = function (dosPermissions) {
            // the dir flag is already set for compatibility
            return (dosPermissions || 0) & 0x3f
          }

          /**
           * Generate the various parts used in the construction of the final zip file.
           * @param {Object} streamInfo the hash with information about the compressed file.
           * @param {Boolean} streamedContent is the content streamed ?
           * @param {Boolean} streamingEnded is the stream finished ?
           * @param {number} offset the current offset from the start of the zip file.
           * @param {String} platform let's pretend we are this platform (change platform dependents fields)
           * @param {Function} encodeFileName the function to encode the file name / comment.
           * @return {Object} the zip parts.
           */
          var generateZipParts = function (
            streamInfo,
            streamedContent,
            streamingEnded,
            offset,
            platform,
            encodeFileName
          ) {
            var file = streamInfo['file'],
              compression = streamInfo['compression'],
              useCustomEncoding = encodeFileName !== utf8.utf8encode,
              encodedFileName = utils.transformTo('string', encodeFileName(file.name)),
              utfEncodedFileName = utils.transformTo('string', utf8.utf8encode(file.name)),
              comment = file.comment,
              encodedComment = utils.transformTo('string', encodeFileName(comment)),
              utfEncodedComment = utils.transformTo('string', utf8.utf8encode(comment)),
              useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
              useUTF8ForComment = utfEncodedComment.length !== comment.length,
              dosTime,
              dosDate,
              extraFields = '',
              unicodePathExtraField = '',
              unicodeCommentExtraField = '',
              dir = file.dir,
              date = file.date

            var dataInfo = {
              crc32: 0,
              compressedSize: 0,
              uncompressedSize: 0
            }

            // if the content is streamed, the sizes/crc32 are only available AFTER
            // the end of the stream.
            if (!streamedContent || streamingEnded) {
              dataInfo.crc32 = streamInfo['crc32']
              dataInfo.compressedSize = streamInfo['compressedSize']
              dataInfo.uncompressedSize = streamInfo['uncompressedSize']
            }

            var bitflag = 0
            if (streamedContent) {
              // Bit 3: the sizes/crc32 are set to zero in the local header.
              // The correct values are put in the data descriptor immediately
              // following the compressed data.
              bitflag |= 0x0008
            }
            if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
              // Bit 11: Language encoding flag (EFS).
              bitflag |= 0x0800
            }

            var extFileAttr = 0
            var versionMadeBy = 0
            if (dir) {
              // dos or unix, we set the dos dir flag
              extFileAttr |= 0x00010
            }
            if (platform === 'UNIX') {
              versionMadeBy = 0x031e // UNIX, version 3.0
              extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir)
            } else {
              // DOS or other, fallback to DOS
              versionMadeBy = 0x0014 // DOS, version 2.0
              extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir)
            }

            // date
            // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
            // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
            // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

            dosTime = date.getUTCHours()
            dosTime = dosTime << 6
            dosTime = dosTime | date.getUTCMinutes()
            dosTime = dosTime << 5
            dosTime = dosTime | (date.getUTCSeconds() / 2)

            dosDate = date.getUTCFullYear() - 1980
            dosDate = dosDate << 4
            dosDate = dosDate | (date.getUTCMonth() + 1)
            dosDate = dosDate << 5
            dosDate = dosDate | date.getUTCDate()

            if (useUTF8ForFileName) {
              // set the unicode path extra field. unzip needs at least one extra
              // field to correctly handle unicode path, so using the path is as good
              // as any other information. This could improve the situation with
              // other archive managers too.
              // This field is usually used without the utf8 flag, with a non
              // unicode path in the header (winrar, winzip). This helps (a bit)
              // with the messy Windows' default compressed folders feature but
              // breaks on p7zip which doesn't seek the unicode path extra field.
              // So for now, UTF-8 everywhere !
              unicodePathExtraField =
                // Version
                decToHex(1, 1) +
                // NameCRC32
                decToHex(crc32(encodedFileName), 4) +
                // UnicodeName
                utfEncodedFileName

              extraFields +=
                // Info-ZIP Unicode Path Extra Field
                '\x75\x70' +
                // size
                decToHex(unicodePathExtraField.length, 2) +
                // content
                unicodePathExtraField
            }

            if (useUTF8ForComment) {
              unicodeCommentExtraField =
                // Version
                decToHex(1, 1) +
                // CommentCRC32
                decToHex(crc32(encodedComment), 4) +
                // UnicodeName
                utfEncodedComment

              extraFields +=
                // Info-ZIP Unicode Path Extra Field
                '\x75\x63' +
                // size
                decToHex(unicodeCommentExtraField.length, 2) +
                // content
                unicodeCommentExtraField
            }

            var header = ''

            // version needed to extract
            header += '\x0A\x00'
            // general purpose bit flag
            header += decToHex(bitflag, 2)
            // compression method
            header += compression.magic
            // last mod file time
            header += decToHex(dosTime, 2)
            // last mod file date
            header += decToHex(dosDate, 2)
            // crc-32
            header += decToHex(dataInfo.crc32, 4)
            // compressed size
            header += decToHex(dataInfo.compressedSize, 4)
            // uncompressed size
            header += decToHex(dataInfo.uncompressedSize, 4)
            // file name length
            header += decToHex(encodedFileName.length, 2)
            // extra field length
            header += decToHex(extraFields.length, 2)

            var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields

            var dirRecord =
              signature.CENTRAL_FILE_HEADER +
              // version made by (00: DOS)
              decToHex(versionMadeBy, 2) +
              // file header (common to file and central directory)
              header +
              // file comment length
              decToHex(encodedComment.length, 2) +
              // disk number start
              '\x00\x00' +
              // internal file attributes TODO
              '\x00\x00' +
              // external file attributes
              decToHex(extFileAttr, 4) +
              // relative offset of local header
              decToHex(offset, 4) +
              // file name
              encodedFileName +
              // extra field
              extraFields +
              // file comment
              encodedComment

            return {
              fileRecord: fileRecord,
              dirRecord: dirRecord
            }
          }

          /**
           * Generate the EOCD record.
           * @param {Number} entriesCount the number of entries in the zip file.
           * @param {Number} centralDirLength the length (in bytes) of the central dir.
           * @param {Number} localDirLength the length (in bytes) of the local dir.
           * @param {String} comment the zip file comment as a binary string.
           * @param {Function} encodeFileName the function to encode the comment.
           * @return {String} the EOCD record.
           */
          var generateCentralDirectoryEnd = function (
            entriesCount,
            centralDirLength,
            localDirLength,
            comment,
            encodeFileName
          ) {
            var dirEnd = ''
            var encodedComment = utils.transformTo('string', encodeFileName(comment))

            // end of central dir signature
            dirEnd =
              signature.CENTRAL_DIRECTORY_END +
              // number of this disk
              '\x00\x00' +
              // number of the disk with the start of the central directory
              '\x00\x00' +
              // total number of entries in the central directory on this disk
              decToHex(entriesCount, 2) +
              // total number of entries in the central directory
              decToHex(entriesCount, 2) +
              // size of the central directory   4 bytes
              decToHex(centralDirLength, 4) +
              // offset of start of central directory with respect to the starting disk number
              decToHex(localDirLength, 4) +
              // .ZIP file comment length
              decToHex(encodedComment.length, 2) +
              // .ZIP file comment
              encodedComment

            return dirEnd
          }

          /**
           * Generate data descriptors for a file entry.
           * @param {Object} streamInfo the hash generated by a worker, containing information
           * on the file entry.
           * @return {String} the data descriptors.
           */
          var generateDataDescriptors = function (streamInfo) {
            var descriptor = ''
            descriptor =
              signature.DATA_DESCRIPTOR +
              // crc-32                          4 bytes
              decToHex(streamInfo['crc32'], 4) +
              // compressed size                 4 bytes
              decToHex(streamInfo['compressedSize'], 4) +
              // uncompressed size               4 bytes
              decToHex(streamInfo['uncompressedSize'], 4)

            return descriptor
          }

          /**
           * A worker to concatenate other workers to create a zip file.
           * @param {Boolean} streamFiles `true` to stream the content of the files,
           * `false` to accumulate it.
           * @param {String} comment the comment to use.
           * @param {String} platform the platform to use, "UNIX" or "DOS".
           * @param {Function} encodeFileName the function to encode file names and comments.
           */
          function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
            GenericWorker.call(this, 'ZipFileWorker')
            // The number of bytes written so far. This doesn't count accumulated chunks.
            this.bytesWritten = 0
            // The comment of the zip file
            this.zipComment = comment
            // The platform "generating" the zip file.
            this.zipPlatform = platform
            // the function to encode file names and comments.
            this.encodeFileName = encodeFileName
            // Should we stream the content of the files ?
            this.streamFiles = streamFiles
            // If `streamFiles` is false, we will need to accumulate the content of the
            // files to calculate sizes / crc32 (and write them *before* the content).
            // This boolean indicates if we are accumulating chunks (it will change a lot
            // during the lifetime of this worker).
            this.accumulate = false
            // The buffer receiving chunks when accumulating content.
            this.contentBuffer = []
            // The list of generated directory records.
            this.dirRecords = []
            // The offset (in bytes) from the beginning of the zip file for the current source.
            this.currentSourceOffset = 0
            // The total number of entries in this zip file.
            this.entriesCount = 0
            // the name of the file currently being added, null when handling the end of the zip file.
            // Used for the emitted metadata.
            this.currentFile = null

            this._sources = []
          }
          utils.inherits(ZipFileWorker, GenericWorker)

          /**
           * @see GenericWorker.push
           */
          ZipFileWorker.prototype.push = function (chunk) {
            var currentFilePercent = chunk.meta.percent || 0
            var entriesCount = this.entriesCount
            var remainingFiles = this._sources.length

            if (this.accumulate) {
              this.contentBuffer.push(chunk)
            } else {
              this.bytesWritten += chunk.data.length

              GenericWorker.prototype.push.call(this, {
                data: chunk.data,
                meta: {
                  currentFile: this.currentFile,
                  percent: entriesCount
                    ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) /
                      entriesCount
                    : 100
                }
              })
            }
          }

          /**
           * The worker started a new source (an other worker).
           * @param {Object} streamInfo the streamInfo object from the new source.
           */
          ZipFileWorker.prototype.openedSource = function (streamInfo) {
            this.currentSourceOffset = this.bytesWritten
            this.currentFile = streamInfo['file'].name

            var streamedContent = this.streamFiles && !streamInfo['file'].dir

            // don't stream folders (because they don't have any content)
            if (streamedContent) {
              var record = generateZipParts(
                streamInfo,
                streamedContent,
                false,
                this.currentSourceOffset,
                this.zipPlatform,
                this.encodeFileName
              )
              this.push({
                data: record.fileRecord,
                meta: { percent: 0 }
              })
            } else {
              // we need to wait for the whole file before pushing anything
              this.accumulate = true
            }
          }

          /**
           * The worker finished a source (an other worker).
           * @param {Object} streamInfo the streamInfo object from the finished source.
           */
          ZipFileWorker.prototype.closedSource = function (streamInfo) {
            this.accumulate = false
            var streamedContent = this.streamFiles && !streamInfo['file'].dir
            var record = generateZipParts(
              streamInfo,
              streamedContent,
              true,
              this.currentSourceOffset,
              this.zipPlatform,
              this.encodeFileName
            )

            this.dirRecords.push(record.dirRecord)
            if (streamedContent) {
              // after the streamed file, we put data descriptors
              this.push({
                data: generateDataDescriptors(streamInfo),
                meta: { percent: 100 }
              })
            } else {
              // the content wasn't streamed, we need to push everything now
              // first the file record, then the content
              this.push({
                data: record.fileRecord,
                meta: { percent: 0 }
              })
              while (this.contentBuffer.length) {
                this.push(this.contentBuffer.shift())
              }
            }
            this.currentFile = null
          }

          /**
           * @see GenericWorker.flush
           */
          ZipFileWorker.prototype.flush = function () {
            var localDirLength = this.bytesWritten
            for (var i = 0; i < this.dirRecords.length; i++) {
              this.push({
                data: this.dirRecords[i],
                meta: { percent: 100 }
              })
            }
            var centralDirLength = this.bytesWritten - localDirLength

            var dirEnd = generateCentralDirectoryEnd(
              this.dirRecords.length,
              centralDirLength,
              localDirLength,
              this.zipComment,
              this.encodeFileName
            )

            this.push({
              data: dirEnd,
              meta: { percent: 100 }
            })
          }

          /**
           * Prepare the next source to be read.
           */
          ZipFileWorker.prototype.prepareNextSource = function () {
            this.previous = this._sources.shift()
            this.openedSource(this.previous.streamInfo)
            if (this.isPaused) {
              this.previous.pause()
            } else {
              this.previous.resume()
            }
          }

          /**
           * @see GenericWorker.registerPrevious
           */
          ZipFileWorker.prototype.registerPrevious = function (previous) {
            this._sources.push(previous)
            var self = this

            previous.on('data', function (chunk) {
              self.processChunk(chunk)
            })
            previous.on('end', function () {
              self.closedSource(self.previous.streamInfo)
              if (self._sources.length) {
                self.prepareNextSource()
              } else {
                self.end()
              }
            })
            previous.on('error', function (e) {
              self.error(e)
            })
            return this
          }

          /**
           * @see GenericWorker.resume
           */
          ZipFileWorker.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false
            }

            if (!this.previous && this._sources.length) {
              this.prepareNextSource()
              return true
            }
            if (!this.previous && !this._sources.length && !this.generatedError) {
              this.end()
              return true
            }
          }

          /**
           * @see GenericWorker.error
           */
          ZipFileWorker.prototype.error = function (e) {
            var sources = this._sources
            if (!GenericWorker.prototype.error.call(this, e)) {
              return false
            }
            for (var i = 0; i < sources.length; i++) {
              try {
                sources[i].error(e)
              } catch (e) {
                // the `error` exploded, nothing to do
              }
            }
            return true
          }

          /**
           * @see GenericWorker.lock
           */
          ZipFileWorker.prototype.lock = function () {
            GenericWorker.prototype.lock.call(this)
            var sources = this._sources
            for (var i = 0; i < sources.length; i++) {
              sources[i].lock()
            }
          }

          module.exports = ZipFileWorker

          /***/
        },

      /***/ './node_modules/jszip/lib/generate/index.js':
        /*!**************************************************!*\
  !*** ./node_modules/jszip/lib/generate/index.js ***!
  \**************************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var compressions = __webpack_require__(
            /*! ../compressions */ './node_modules/jszip/lib/compressions.js'
          )
          var ZipFileWorker = __webpack_require__(
            /*! ./ZipFileWorker */ './node_modules/jszip/lib/generate/ZipFileWorker.js'
          )

          /**
           * Find the compression to use.
           * @param {String} fileCompression the compression defined at the file level, if any.
           * @param {String} zipCompression the compression defined at the load() level.
           * @return {Object} the compression object to use.
           */
          var getCompression = function (fileCompression, zipCompression) {
            var compressionName = fileCompression || zipCompression
            var compression = compressions[compressionName]
            if (!compression) {
              throw new Error(compressionName + ' is not a valid compression method !')
            }
            return compression
          }

          /**
           * Create a worker to generate a zip file.
           * @param {JSZip} zip the JSZip instance at the right root level.
           * @param {Object} options to generate the zip file.
           * @param {String} comment the comment to use.
           */
          exports.generateWorker = function (zip, options, comment) {
            var zipFileWorker = new ZipFileWorker(
              options.streamFiles,
              comment,
              options.platform,
              options.encodeFileName
            )
            var entriesCount = 0
            try {
              zip.forEach(function (relativePath, file) {
                entriesCount++
                var compression = getCompression(file.options.compression, options.compression)
                var compressionOptions =
                  file.options.compressionOptions || options.compressionOptions || {}
                var dir = file.dir,
                  date = file.date

                file
                  ._compressWorker(compression, compressionOptions)
                  .withStreamInfo('file', {
                    name: relativePath,
                    dir: dir,
                    date: date,
                    comment: file.comment || '',
                    unixPermissions: file.unixPermissions,
                    dosPermissions: file.dosPermissions
                  })
                  .pipe(zipFileWorker)
              })
              zipFileWorker.entriesCount = entriesCount
            } catch (e) {
              zipFileWorker.error(e)
            }

            return zipFileWorker
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/index.js':
        /*!*****************************************!*\
  !*** ./node_modules/jszip/lib/index.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          /**
           * Representation a of zip file in js
           * @constructor
           */
          function JSZip() {
            // if this constructor is used without `new`, it adds `new` before itself:
            if (!(this instanceof JSZip)) {
              return new JSZip()
            }

            if (arguments.length) {
              throw new Error(
                'The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.'
              )
            }

            // object containing the files :
            // {
            //   "folder/" : {...},
            //   "folder/data.txt" : {...}
            // }
            // NOTE: we use a null prototype because we do not
            // want filenames like "toString" coming from a zip file
            // to overwrite methods and attributes in a normal Object.
            this.files = Object.create(null)

            this.comment = null

            // Where we are in the hierarchy
            this.root = ''
            this.clone = function () {
              var newObj = new JSZip()
              for (var i in this) {
                if (typeof this[i] !== 'function') {
                  newObj[i] = this[i]
                }
              }
              return newObj
            }
          }
          JSZip.prototype = __webpack_require__(
            /*! ./object */ './node_modules/jszip/lib/object.js'
          )
          JSZip.prototype.loadAsync = __webpack_require__(
            /*! ./load */ './node_modules/jszip/lib/load.js'
          )
          JSZip.support = __webpack_require__(
            /*! ./support */ './node_modules/jszip/lib/support.js'
          )
          JSZip.defaults = __webpack_require__(
            /*! ./defaults */ './node_modules/jszip/lib/defaults.js'
          )

          // TODO find a better way to handle this version,
          // a require('package.json').version doesn't work with webpack, see #327
          JSZip.version = '3.10.1'

          JSZip.loadAsync = function (content, options) {
            return new JSZip().loadAsync(content, options)
          }

          JSZip.external = __webpack_require__(
            /*! ./external */ './node_modules/jszip/lib/external.js'
          )
          module.exports = JSZip

          /***/
        },

      /***/ './node_modules/jszip/lib/load.js':
        /*!****************************************!*\
  !*** ./node_modules/jszip/lib/load.js ***!
  \****************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')
          var external = __webpack_require__(
            /*! ./external */ './node_modules/jszip/lib/external.js'
          )
          var utf8 = __webpack_require__(/*! ./utf8 */ './node_modules/jszip/lib/utf8.js')
          var ZipEntries = __webpack_require__(
            /*! ./zipEntries */ './node_modules/jszip/lib/zipEntries.js'
          )
          var Crc32Probe = __webpack_require__(
            /*! ./stream/Crc32Probe */ './node_modules/jszip/lib/stream/Crc32Probe.js'
          )
          var nodejsUtils = __webpack_require__(
            /*! ./nodejsUtils */ './node_modules/jszip/lib/nodejsUtils.js'
          )

          /**
           * Check the CRC32 of an entry.
           * @param {ZipEntry} zipEntry the zip entry to check.
           * @return {Promise} the result.
           */
          function checkEntryCRC32(zipEntry) {
            return new external.Promise(function (resolve, reject) {
              var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe())
              worker
                .on('error', function (e) {
                  reject(e)
                })
                .on('end', function () {
                  if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                    reject(new Error('Corrupted zip : CRC32 mismatch'))
                  } else {
                    resolve()
                  }
                })
                .resume()
            })
          }

          module.exports = function (data, options) {
            var zip = this
            options = utils.extend(options || {}, {
              base64: false,
              checkCRC32: false,
              optimizedBinaryString: false,
              createFolders: false,
              decodeFileName: utf8.utf8decode
            })

            if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              return external.Promise.reject(
                new Error("JSZip can't accept a stream when loading a zip file.")
              )
            }

            return utils
              .prepareContent(
                'the loaded zip file',
                data,
                true,
                options.optimizedBinaryString,
                options.base64
              )
              .then(function (data) {
                var zipEntries = new ZipEntries(options)
                zipEntries.load(data)
                return zipEntries
              })
              .then(function checkCRC32(zipEntries) {
                var promises = [external.Promise.resolve(zipEntries)]
                var files = zipEntries.files
                if (options.checkCRC32) {
                  for (var i = 0; i < files.length; i++) {
                    promises.push(checkEntryCRC32(files[i]))
                  }
                }
                return external.Promise.all(promises)
              })
              .then(function addFiles(results) {
                var zipEntries = results.shift()
                var files = zipEntries.files
                for (var i = 0; i < files.length; i++) {
                  var input = files[i]

                  var unsafeName = input.fileNameStr
                  var safeName = utils.resolve(input.fileNameStr)

                  zip.file(safeName, input.decompressed, {
                    binary: true,
                    optimizedBinaryString: true,
                    date: input.date,
                    dir: input.dir,
                    comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                    unixPermissions: input.unixPermissions,
                    dosPermissions: input.dosPermissions,
                    createFolders: options.createFolders
                  })
                  if (!input.dir) {
                    zip.file(safeName).unsafeOriginalName = unsafeName
                  }
                }
                if (zipEntries.zipComment.length) {
                  zip.comment = zipEntries.zipComment
                }

                return zip
              })
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/nodejsUtils.js':
        /*!***********************************************!*\
  !*** ./node_modules/jszip/lib/nodejsUtils.js ***!
  \***********************************************/
        /***/ (module) => {
          'use strict'

          module.exports = {
            /**
             * True if this is running in Nodejs, will be undefined in a browser.
             * In a browser, browserify won't include this file and the whole module
             * will be resolved an empty object.
             */
            isNode: typeof Buffer !== 'undefined',
            /**
             * Create a new nodejs Buffer from an existing content.
             * @param {Object} data the data to pass to the constructor.
             * @param {String} encoding the encoding to use.
             * @return {Buffer} a new Buffer.
             */
            newBufferFrom: function (data, encoding) {
              if (Buffer.from && Buffer.from !== Uint8Array.from) {
                return Buffer.from(data, encoding)
              } else {
                if (typeof data === 'number') {
                  // Safeguard for old Node.js versions. On newer versions,
                  // Buffer.from(number) / Buffer(number, encoding) already throw.
                  throw new Error('The "data" argument must not be a number')
                }
                return new Buffer(data, encoding)
              }
            },
            /**
             * Create a new nodejs Buffer with the specified size.
             * @param {Integer} size the size of the buffer.
             * @return {Buffer} a new Buffer.
             */
            allocBuffer: function (size) {
              if (Buffer.alloc) {
                return Buffer.alloc(size)
              } else {
                var buf = new Buffer(size)
                buf.fill(0)
                return buf
              }
            },
            /**
             * Find out if an object is a Buffer.
             * @param {Object} b the object to test.
             * @return {Boolean} true if the object is a Buffer, false otherwise.
             */
            isBuffer: function (b) {
              return Buffer.isBuffer(b)
            },

            isStream: function (obj) {
              return (
                obj &&
                typeof obj.on === 'function' &&
                typeof obj.pause === 'function' &&
                typeof obj.resume === 'function'
              )
            }
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js ***!
  \*******************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')
          var GenericWorker = __webpack_require__(
            /*! ../stream/GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )

          /**
           * A worker that use a nodejs stream as source.
           * @constructor
           * @param {String} filename the name of the file entry for this stream.
           * @param {Readable} stream the nodejs stream.
           */
          function NodejsStreamInputAdapter(filename, stream) {
            GenericWorker.call(this, 'Nodejs stream input adapter for ' + filename)
            this._upstreamEnded = false
            this._bindStream(stream)
          }

          utils.inherits(NodejsStreamInputAdapter, GenericWorker)

          /**
           * Prepare the stream and bind the callbacks on it.
           * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
           * @param {Stream} stream the nodejs stream to use.
           */
          NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
            var self = this
            this._stream = stream
            stream.pause()
            stream
              .on('data', function (chunk) {
                self.push({
                  data: chunk,
                  meta: {
                    percent: 0
                  }
                })
              })
              .on('error', function (e) {
                if (self.isPaused) {
                  this.generatedError = e
                } else {
                  self.error(e)
                }
              })
              .on('end', function () {
                if (self.isPaused) {
                  self._upstreamEnded = true
                } else {
                  self.end()
                }
              })
          }
          NodejsStreamInputAdapter.prototype.pause = function () {
            if (!GenericWorker.prototype.pause.call(this)) {
              return false
            }
            this._stream.pause()
            return true
          }
          NodejsStreamInputAdapter.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false
            }

            if (this._upstreamEnded) {
              this.end()
            } else {
              this._stream.resume()
            }

            return true
          }

          module.exports = NodejsStreamInputAdapter

          /***/
        },

      /***/ './node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js':
        /*!********************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js ***!
  \********************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var Readable = __webpack_require__(
            /*! readable-stream */ './node_modules/jszip/node_modules/readable-stream/readable.js'
          ).Readable

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')
          utils.inherits(NodejsStreamOutputAdapter, Readable)

          /**
           * A nodejs stream using a worker as source.
           * @see the SourceWrapper in http://nodejs.org/api/stream.html
           * @constructor
           * @param {StreamHelper} helper the helper wrapping the worker
           * @param {Object} options the nodejs stream options
           * @param {Function} updateCb the update callback.
           */
          function NodejsStreamOutputAdapter(helper, options, updateCb) {
            Readable.call(this, options)
            this._helper = helper

            var self = this
            helper
              .on('data', function (data, meta) {
                if (!self.push(data)) {
                  self._helper.pause()
                }
                if (updateCb) {
                  updateCb(meta)
                }
              })
              .on('error', function (e) {
                self.emit('error', e)
              })
              .on('end', function () {
                self.push(null)
              })
          }

          NodejsStreamOutputAdapter.prototype._read = function () {
            this._helper.resume()
          }

          module.exports = NodejsStreamOutputAdapter

          /***/
        },

      /***/ './node_modules/jszip/lib/object.js':
        /*!******************************************!*\
  !*** ./node_modules/jszip/lib/object.js ***!
  \******************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utf8 = __webpack_require__(/*! ./utf8 */ './node_modules/jszip/lib/utf8.js')
          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')
          var GenericWorker = __webpack_require__(
            /*! ./stream/GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )
          var StreamHelper = __webpack_require__(
            /*! ./stream/StreamHelper */ './node_modules/jszip/lib/stream/StreamHelper.js'
          )
          var defaults = __webpack_require__(
            /*! ./defaults */ './node_modules/jszip/lib/defaults.js'
          )
          var CompressedObject = __webpack_require__(
            /*! ./compressedObject */ './node_modules/jszip/lib/compressedObject.js'
          )
          var ZipObject = __webpack_require__(
            /*! ./zipObject */ './node_modules/jszip/lib/zipObject.js'
          )
          var generate = __webpack_require__(
            /*! ./generate */ './node_modules/jszip/lib/generate/index.js'
          )
          var nodejsUtils = __webpack_require__(
            /*! ./nodejsUtils */ './node_modules/jszip/lib/nodejsUtils.js'
          )
          var NodejsStreamInputAdapter = __webpack_require__(
            /*! ./nodejs/NodejsStreamInputAdapter */ './node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js'
          )

          /**
           * Add a file in the current folder.
           * @private
           * @param {string} name the name of the file
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
           * @param {Object} originalOptions the options of the file
           * @return {Object} the new file.
           */
          var fileAdd = function (name, data, originalOptions) {
            // be sure sub folders exist
            var dataType = utils.getTypeOf(data),
              parent

            /*
             * Correct options.
             */

            var o = utils.extend(originalOptions || {}, defaults)
            o.date = o.date || new Date()
            if (o.compression !== null) {
              o.compression = o.compression.toUpperCase()
            }

            if (typeof o.unixPermissions === 'string') {
              o.unixPermissions = parseInt(o.unixPermissions, 8)
            }

            // UNX_IFDIR  0040000 see zipinfo.c
            if (o.unixPermissions && o.unixPermissions & 0x4000) {
              o.dir = true
            }
            // Bit 4    Directory
            if (o.dosPermissions && o.dosPermissions & 0x0010) {
              o.dir = true
            }

            if (o.dir) {
              name = forceTrailingSlash(name)
            }
            if (o.createFolders && (parent = parentFolder(name))) {
              folderAdd.call(this, parent, true)
            }

            var isUnicodeString = dataType === 'string' && o.binary === false && o.base64 === false
            if (!originalOptions || typeof originalOptions.binary === 'undefined') {
              o.binary = !isUnicodeString
            }

            var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0

            if (isCompressedEmpty || o.dir || !data || data.length === 0) {
              o.base64 = false
              o.binary = true
              data = ''
              o.compression = 'STORE'
              dataType = 'string'
            }

            /*
             * Convert content to fit.
             */

            var zipObjectContent = null
            if (data instanceof CompressedObject || data instanceof GenericWorker) {
              zipObjectContent = data
            } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              zipObjectContent = new NodejsStreamInputAdapter(name, data)
            } else {
              zipObjectContent = utils.prepareContent(
                name,
                data,
                o.binary,
                o.optimizedBinaryString,
                o.base64
              )
            }

            var object = new ZipObject(name, zipObjectContent, o)
            this.files[name] = object
            /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
          }

          /**
           * Find the parent folder of the path.
           * @private
           * @param {string} path the path to use
           * @return {string} the parent folder, or ""
           */
          var parentFolder = function (path) {
            if (path.slice(-1) === '/') {
              path = path.substring(0, path.length - 1)
            }
            var lastSlash = path.lastIndexOf('/')
            return lastSlash > 0 ? path.substring(0, lastSlash) : ''
          }

          /**
           * Returns the path with a slash at the end.
           * @private
           * @param {String} path the path to check.
           * @return {String} the path with a trailing slash.
           */
          var forceTrailingSlash = function (path) {
            // Check the name ends with a /
            if (path.slice(-1) !== '/') {
              path += '/' // IE doesn't like substr(-1)
            }
            return path
          }

          /**
           * Add a (sub) folder in the current folder.
           * @private
           * @param {string} name the folder's name
           * @param {boolean=} [createFolders] If true, automatically create sub
           *  folders. Defaults to false.
           * @return {Object} the new folder.
           */
          var folderAdd = function (name, createFolders) {
            createFolders =
              typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders

            name = forceTrailingSlash(name)

            // Does this folder already exist?
            if (!this.files[name]) {
              fileAdd.call(this, name, null, {
                dir: true,
                createFolders: createFolders
              })
            }
            return this.files[name]
          }

          /**
           * Cross-window, cross-Node-context regular expression detection
           * @param  {Object}  object Anything
           * @return {Boolean}        true if the object is a regular expression,
           * false otherwise
           */
          function isRegExp(object) {
            return Object.prototype.toString.call(object) === '[object RegExp]'
          }

          // return the actual prototype of JSZip
          var out = {
            /**
             * @see loadAsync
             */
            load: function () {
              throw new Error(
                'This method has been removed in JSZip 3.0, please check the upgrade guide.'
              )
            },

            /**
             * Call a callback function for each entry at this folder level.
             * @param {Function} cb the callback function:
             * function (relativePath, file) {...}
             * It takes 2 arguments : the relative path and the file.
             */
            forEach: function (cb) {
              var filename, relativePath, file
              // ignore warning about unwanted properties because this.files is a null prototype object
              /* eslint-disable-next-line guard-for-in */
              for (filename in this.files) {
                file = this.files[filename]
                relativePath = filename.slice(this.root.length, filename.length)
                if (relativePath && filename.slice(0, this.root.length) === this.root) {
                  // the file is in the current root
                  cb(relativePath, file) // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
                }
              }
            },

            /**
             * Filter nested files/folders with the specified function.
             * @param {Function} search the predicate to use :
             * function (relativePath, file) {...}
             * It takes 2 arguments : the relative path and the file.
             * @return {Array} An array of matching elements.
             */
            filter: function (search) {
              var result = []
              this.forEach(function (relativePath, entry) {
                if (search(relativePath, entry)) {
                  // the file matches the function
                  result.push(entry)
                }
              })
              return result
            },

            /**
             * Add a file to the zip file, or search a file.
             * @param   {string|RegExp} name The name of the file to add (if data is defined),
             * the name of the file to find (if no data) or a regex to match files.
             * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
             * @param   {Object} o     File options
             * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
             * a file (when searching by string) or an array of files (when searching by regex).
             */
            file: function (name, data, o) {
              if (arguments.length === 1) {
                if (isRegExp(name)) {
                  var regexp = name
                  return this.filter(function (relativePath, file) {
                    return !file.dir && regexp.test(relativePath)
                  })
                } else {
                  // text
                  var obj = this.files[this.root + name]
                  if (obj && !obj.dir) {
                    return obj
                  } else {
                    return null
                  }
                }
              } else {
                // more than one argument : we have data !
                name = this.root + name
                fileAdd.call(this, name, data, o)
              }
              return this
            },

            /**
             * Add a directory to the zip file, or search.
             * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
             * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
             */
            folder: function (arg) {
              if (!arg) {
                return this
              }

              if (isRegExp(arg)) {
                return this.filter(function (relativePath, file) {
                  return file.dir && arg.test(relativePath)
                })
              }

              // else, name is a new folder
              var name = this.root + arg
              var newFolder = folderAdd.call(this, name)

              // Allow chaining by returning a new object with this folder as the root
              var ret = this.clone()
              ret.root = newFolder.name
              return ret
            },

            /**
             * Delete a file, or a directory and all sub-files, from the zip
             * @param {string} name the name of the file to delete
             * @return {JSZip} this JSZip object
             */
            remove: function (name) {
              name = this.root + name
              var file = this.files[name]
              if (!file) {
                // Look for any folders
                if (name.slice(-1) !== '/') {
                  name += '/'
                }
                file = this.files[name]
              }

              if (file && !file.dir) {
                // file
                delete this.files[name]
              } else {
                // maybe a folder, delete recursively
                var kids = this.filter(function (relativePath, file) {
                  return file.name.slice(0, name.length) === name
                })
                for (var i = 0; i < kids.length; i++) {
                  delete this.files[kids[i].name]
                }
              }

              return this
            },

            /**
             * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
             */
            generate: function () {
              throw new Error(
                'This method has been removed in JSZip 3.0, please check the upgrade guide.'
              )
            },

            /**
             * Generate the complete zip file as an internal stream.
             * @param {Object} options the options to generate the zip file :
             * - compression, "STORE" by default.
             * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
             * @return {StreamHelper} the streamed zip file.
             */
            generateInternalStream: function (options) {
              var worker,
                opts = {}
              try {
                opts = utils.extend(options || {}, {
                  streamFiles: false,
                  compression: 'STORE',
                  compressionOptions: null,
                  type: '',
                  platform: 'DOS',
                  comment: null,
                  mimeType: 'application/zip',
                  encodeFileName: utf8.utf8encode
                })

                opts.type = opts.type.toLowerCase()
                opts.compression = opts.compression.toUpperCase()

                // "binarystring" is preferred but the internals use "string".
                if (opts.type === 'binarystring') {
                  opts.type = 'string'
                }

                if (!opts.type) {
                  throw new Error('No output type specified.')
                }

                utils.checkSupport(opts.type)

                // accept nodejs `process.platform`
                if (
                  opts.platform === 'darwin' ||
                  opts.platform === 'freebsd' ||
                  opts.platform === 'linux' ||
                  opts.platform === 'sunos'
                ) {
                  opts.platform = 'UNIX'
                }
                if (opts.platform === 'win32') {
                  opts.platform = 'DOS'
                }

                var comment = opts.comment || this.comment || ''
                worker = generate.generateWorker(this, opts, comment)
              } catch (e) {
                worker = new GenericWorker('error')
                worker.error(e)
              }
              return new StreamHelper(worker, opts.type || 'string', opts.mimeType)
            },
            /**
             * Generate the complete zip file asynchronously.
             * @see generateInternalStream
             */
            generateAsync: function (options, onUpdate) {
              return this.generateInternalStream(options).accumulate(onUpdate)
            },
            /**
             * Generate the complete zip file asynchronously.
             * @see generateInternalStream
             */
            generateNodeStream: function (options, onUpdate) {
              options = options || {}
              if (!options.type) {
                options.type = 'nodebuffer'
              }
              return this.generateInternalStream(options).toNodejsStream(onUpdate)
            }
          }
          module.exports = out

          /***/
        },

      /***/ './node_modules/jszip/lib/reader/ArrayReader.js':
        /*!******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/ArrayReader.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var DataReader = __webpack_require__(
            /*! ./DataReader */ './node_modules/jszip/lib/reader/DataReader.js'
          )
          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')

          function ArrayReader(data) {
            DataReader.call(this, data)
            for (var i = 0; i < this.data.length; i++) {
              data[i] = data[i] & 0xff
            }
          }
          utils.inherits(ArrayReader, DataReader)
          /**
           * @see DataReader.byteAt
           */
          ArrayReader.prototype.byteAt = function (i) {
            return this.data[this.zero + i]
          }
          /**
           * @see DataReader.lastIndexOfSignature
           */
          ArrayReader.prototype.lastIndexOfSignature = function (sig) {
            var sig0 = sig.charCodeAt(0),
              sig1 = sig.charCodeAt(1),
              sig2 = sig.charCodeAt(2),
              sig3 = sig.charCodeAt(3)
            for (var i = this.length - 4; i >= 0; --i) {
              if (
                this.data[i] === sig0 &&
                this.data[i + 1] === sig1 &&
                this.data[i + 2] === sig2 &&
                this.data[i + 3] === sig3
              ) {
                return i - this.zero
              }
            }

            return -1
          }
          /**
           * @see DataReader.readAndCheckSignature
           */
          ArrayReader.prototype.readAndCheckSignature = function (sig) {
            var sig0 = sig.charCodeAt(0),
              sig1 = sig.charCodeAt(1),
              sig2 = sig.charCodeAt(2),
              sig3 = sig.charCodeAt(3),
              data = this.readData(4)
            return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3]
          }
          /**
           * @see DataReader.readData
           */
          ArrayReader.prototype.readData = function (size) {
            this.checkOffset(size)
            if (size === 0) {
              return []
            }
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size)
            this.index += size
            return result
          }
          module.exports = ArrayReader

          /***/
        },

      /***/ './node_modules/jszip/lib/reader/DataReader.js':
        /*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/DataReader.js ***!
  \*****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')

          function DataReader(data) {
            this.data = data // type : see implementation
            this.length = data.length
            this.index = 0
            this.zero = 0
          }
          DataReader.prototype = {
            /**
             * Check that the offset will not go too far.
             * @param {string} offset the additional offset to check.
             * @throws {Error} an Error if the offset is out of bounds.
             */
            checkOffset: function (offset) {
              this.checkIndex(this.index + offset)
            },
            /**
             * Check that the specified index will not be too far.
             * @param {string} newIndex the index to check.
             * @throws {Error} an Error if the index is out of bounds.
             */
            checkIndex: function (newIndex) {
              if (this.length < this.zero + newIndex || newIndex < 0) {
                throw new Error(
                  'End of data reached (data length = ' +
                    this.length +
                    ', asked index = ' +
                    newIndex +
                    '). Corrupted zip ?'
                )
              }
            },
            /**
             * Change the index.
             * @param {number} newIndex The new index.
             * @throws {Error} if the new index is out of the data.
             */
            setIndex: function (newIndex) {
              this.checkIndex(newIndex)
              this.index = newIndex
            },
            /**
             * Skip the next n bytes.
             * @param {number} n the number of bytes to skip.
             * @throws {Error} if the new index is out of the data.
             */
            skip: function (n) {
              this.setIndex(this.index + n)
            },
            /**
             * Get the byte at the specified index.
             * @param {number} i the index to use.
             * @return {number} a byte.
             */
            byteAt: function () {
              // see implementations
            },
            /**
             * Get the next number with a given byte size.
             * @param {number} size the number of bytes to read.
             * @return {number} the corresponding number.
             */
            readInt: function (size) {
              var result = 0,
                i
              this.checkOffset(size)
              for (i = this.index + size - 1; i >= this.index; i--) {
                result = (result << 8) + this.byteAt(i)
              }
              this.index += size
              return result
            },
            /**
             * Get the next string with a given byte size.
             * @param {number} size the number of bytes to read.
             * @return {string} the corresponding string.
             */
            readString: function (size) {
              return utils.transformTo('string', this.readData(size))
            },
            /**
             * Get raw data without conversion, <size> bytes.
             * @param {number} size the number of bytes to read.
             * @return {Object} the raw data, implementation specific.
             */
            readData: function () {
              // see implementations
            },
            /**
             * Find the last occurrence of a zip signature (4 bytes).
             * @param {string} sig the signature to find.
             * @return {number} the index of the last occurrence, -1 if not found.
             */
            lastIndexOfSignature: function () {
              // see implementations
            },
            /**
             * Read the signature (4 bytes) at the current position and compare it with sig.
             * @param {string} sig the expected signature
             * @return {boolean} true if the signature matches, false otherwise.
             */
            readAndCheckSignature: function () {
              // see implementations
            },
            /**
             * Get the next date.
             * @return {Date} the date.
             */
            readDate: function () {
              var dostime = this.readInt(4)
              return new Date(
                Date.UTC(
                  ((dostime >> 25) & 0x7f) + 1980, // year
                  ((dostime >> 21) & 0x0f) - 1, // month
                  (dostime >> 16) & 0x1f, // day
                  (dostime >> 11) & 0x1f, // hour
                  (dostime >> 5) & 0x3f, // minute
                  (dostime & 0x1f) << 1
                )
              ) // second
            }
          }
          module.exports = DataReader

          /***/
        },

      /***/ './node_modules/jszip/lib/reader/NodeBufferReader.js':
        /*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/NodeBufferReader.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var Uint8ArrayReader = __webpack_require__(
            /*! ./Uint8ArrayReader */ './node_modules/jszip/lib/reader/Uint8ArrayReader.js'
          )
          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')

          function NodeBufferReader(data) {
            Uint8ArrayReader.call(this, data)
          }
          utils.inherits(NodeBufferReader, Uint8ArrayReader)

          /**
           * @see DataReader.readData
           */
          NodeBufferReader.prototype.readData = function (size) {
            this.checkOffset(size)
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size)
            this.index += size
            return result
          }
          module.exports = NodeBufferReader

          /***/
        },

      /***/ './node_modules/jszip/lib/reader/StringReader.js':
        /*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/StringReader.js ***!
  \*******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var DataReader = __webpack_require__(
            /*! ./DataReader */ './node_modules/jszip/lib/reader/DataReader.js'
          )
          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')

          function StringReader(data) {
            DataReader.call(this, data)
          }
          utils.inherits(StringReader, DataReader)
          /**
           * @see DataReader.byteAt
           */
          StringReader.prototype.byteAt = function (i) {
            return this.data.charCodeAt(this.zero + i)
          }
          /**
           * @see DataReader.lastIndexOfSignature
           */
          StringReader.prototype.lastIndexOfSignature = function (sig) {
            return this.data.lastIndexOf(sig) - this.zero
          }
          /**
           * @see DataReader.readAndCheckSignature
           */
          StringReader.prototype.readAndCheckSignature = function (sig) {
            var data = this.readData(4)
            return sig === data
          }
          /**
           * @see DataReader.readData
           */
          StringReader.prototype.readData = function (size) {
            this.checkOffset(size)
            // this will work because the constructor applied the "& 0xff" mask.
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size)
            this.index += size
            return result
          }
          module.exports = StringReader

          /***/
        },

      /***/ './node_modules/jszip/lib/reader/Uint8ArrayReader.js':
        /*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/Uint8ArrayReader.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var ArrayReader = __webpack_require__(
            /*! ./ArrayReader */ './node_modules/jszip/lib/reader/ArrayReader.js'
          )
          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')

          function Uint8ArrayReader(data) {
            ArrayReader.call(this, data)
          }
          utils.inherits(Uint8ArrayReader, ArrayReader)
          /**
           * @see DataReader.readData
           */
          Uint8ArrayReader.prototype.readData = function (size) {
            this.checkOffset(size)
            if (size === 0) {
              // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
              return new Uint8Array(0)
            }
            var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size)
            this.index += size
            return result
          }
          module.exports = Uint8ArrayReader

          /***/
        },

      /***/ './node_modules/jszip/lib/reader/readerFor.js':
        /*!****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/readerFor.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')
          var support = __webpack_require__(/*! ../support */ './node_modules/jszip/lib/support.js')
          var ArrayReader = __webpack_require__(
            /*! ./ArrayReader */ './node_modules/jszip/lib/reader/ArrayReader.js'
          )
          var StringReader = __webpack_require__(
            /*! ./StringReader */ './node_modules/jszip/lib/reader/StringReader.js'
          )
          var NodeBufferReader = __webpack_require__(
            /*! ./NodeBufferReader */ './node_modules/jszip/lib/reader/NodeBufferReader.js'
          )
          var Uint8ArrayReader = __webpack_require__(
            /*! ./Uint8ArrayReader */ './node_modules/jszip/lib/reader/Uint8ArrayReader.js'
          )

          /**
           * Create a reader adapted to the data.
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
           * @return {DataReader} the data reader.
           */
          module.exports = function (data) {
            var type = utils.getTypeOf(data)
            utils.checkSupport(type)
            if (type === 'string' && !support.uint8array) {
              return new StringReader(data)
            }
            if (type === 'nodebuffer') {
              return new NodeBufferReader(data)
            }
            if (support.uint8array) {
              return new Uint8ArrayReader(utils.transformTo('uint8array', data))
            }
            return new ArrayReader(utils.transformTo('array', data))
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/signature.js':
        /*!*********************************************!*\
  !*** ./node_modules/jszip/lib/signature.js ***!
  \*********************************************/
        /***/ (__unused_webpack_module, exports) => {
          'use strict'

          exports.LOCAL_FILE_HEADER = 'PK\x03\x04'
          exports.CENTRAL_FILE_HEADER = 'PK\x01\x02'
          exports.CENTRAL_DIRECTORY_END = 'PK\x05\x06'
          exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = 'PK\x06\x07'
          exports.ZIP64_CENTRAL_DIRECTORY_END = 'PK\x06\x06'
          exports.DATA_DESCRIPTOR = 'PK\x07\x08'

          /***/
        },

      /***/ './node_modules/jszip/lib/stream/ConvertWorker.js':
        /*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/ConvertWorker.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var GenericWorker = __webpack_require__(
            /*! ./GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )
          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')

          /**
           * A worker which convert chunks to a specified type.
           * @constructor
           * @param {String} destType the destination type.
           */
          function ConvertWorker(destType) {
            GenericWorker.call(this, 'ConvertWorker to ' + destType)
            this.destType = destType
          }
          utils.inherits(ConvertWorker, GenericWorker)

          /**
           * @see GenericWorker.processChunk
           */
          ConvertWorker.prototype.processChunk = function (chunk) {
            this.push({
              data: utils.transformTo(this.destType, chunk.data),
              meta: chunk.meta
            })
          }
          module.exports = ConvertWorker

          /***/
        },

      /***/ './node_modules/jszip/lib/stream/Crc32Probe.js':
        /*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/Crc32Probe.js ***!
  \*****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var GenericWorker = __webpack_require__(
            /*! ./GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )
          var crc32 = __webpack_require__(/*! ../crc32 */ './node_modules/jszip/lib/crc32.js')
          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')

          /**
           * A worker which calculate the crc32 of the data flowing through.
           * @constructor
           */
          function Crc32Probe() {
            GenericWorker.call(this, 'Crc32Probe')
            this.withStreamInfo('crc32', 0)
          }
          utils.inherits(Crc32Probe, GenericWorker)

          /**
           * @see GenericWorker.processChunk
           */
          Crc32Probe.prototype.processChunk = function (chunk) {
            this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0)
            this.push(chunk)
          }
          module.exports = Crc32Probe

          /***/
        },

      /***/ './node_modules/jszip/lib/stream/DataLengthProbe.js':
        /*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataLengthProbe.js ***!
  \**********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')
          var GenericWorker = __webpack_require__(
            /*! ./GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )

          /**
           * A worker which calculate the total length of the data flowing through.
           * @constructor
           * @param {String} propName the name used to expose the length
           */
          function DataLengthProbe(propName) {
            GenericWorker.call(this, 'DataLengthProbe for ' + propName)
            this.propName = propName
            this.withStreamInfo(propName, 0)
          }
          utils.inherits(DataLengthProbe, GenericWorker)

          /**
           * @see GenericWorker.processChunk
           */
          DataLengthProbe.prototype.processChunk = function (chunk) {
            if (chunk) {
              var length = this.streamInfo[this.propName] || 0
              this.streamInfo[this.propName] = length + chunk.data.length
            }
            GenericWorker.prototype.processChunk.call(this, chunk)
          }
          module.exports = DataLengthProbe

          /***/
        },

      /***/ './node_modules/jszip/lib/stream/DataWorker.js':
        /*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataWorker.js ***!
  \*****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')
          var GenericWorker = __webpack_require__(
            /*! ./GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )

          // the size of the generated chunks
          // TODO expose this as a public variable
          var DEFAULT_BLOCK_SIZE = 16 * 1024

          /**
           * A worker that reads a content and emits chunks.
           * @constructor
           * @param {Promise} dataP the promise of the data to split
           */
          function DataWorker(dataP) {
            GenericWorker.call(this, 'DataWorker')
            var self = this
            this.dataIsReady = false
            this.index = 0
            this.max = 0
            this.data = null
            this.type = ''

            this._tickScheduled = false

            dataP.then(
              function (data) {
                self.dataIsReady = true
                self.data = data
                self.max = (data && data.length) || 0
                self.type = utils.getTypeOf(data)
                if (!self.isPaused) {
                  self._tickAndRepeat()
                }
              },
              function (e) {
                self.error(e)
              }
            )
          }

          utils.inherits(DataWorker, GenericWorker)

          /**
           * @see GenericWorker.cleanUp
           */
          DataWorker.prototype.cleanUp = function () {
            GenericWorker.prototype.cleanUp.call(this)
            this.data = null
          }

          /**
           * @see GenericWorker.resume
           */
          DataWorker.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false
            }

            if (!this._tickScheduled && this.dataIsReady) {
              this._tickScheduled = true
              utils.delay(this._tickAndRepeat, [], this)
            }
            return true
          }

          /**
           * Trigger a tick a schedule an other call to this function.
           */
          DataWorker.prototype._tickAndRepeat = function () {
            this._tickScheduled = false
            if (this.isPaused || this.isFinished) {
              return
            }
            this._tick()
            if (!this.isFinished) {
              utils.delay(this._tickAndRepeat, [], this)
              this._tickScheduled = true
            }
          }

          /**
           * Read and push a chunk.
           */
          DataWorker.prototype._tick = function () {
            if (this.isPaused || this.isFinished) {
              return false
            }

            var size = DEFAULT_BLOCK_SIZE
            var data = null,
              nextIndex = Math.min(this.max, this.index + size)
            if (this.index >= this.max) {
              // EOF
              return this.end()
            } else {
              switch (this.type) {
                case 'string':
                  data = this.data.substring(this.index, nextIndex)
                  break
                case 'uint8array':
                  data = this.data.subarray(this.index, nextIndex)
                  break
                case 'array':
                case 'nodebuffer':
                  data = this.data.slice(this.index, nextIndex)
                  break
              }
              this.index = nextIndex
              return this.push({
                data: data,
                meta: {
                  percent: this.max ? (this.index / this.max) * 100 : 0
                }
              })
            }
          }

          module.exports = DataWorker

          /***/
        },

      /***/ './node_modules/jszip/lib/stream/GenericWorker.js':
        /*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/GenericWorker.js ***!
  \********************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * A worker that does nothing but passing chunks to the next one. This is like
           * a nodejs stream but with some differences. On the good side :
           * - it works on IE 6-9 without any issue / polyfill
           * - it weights less than the full dependencies bundled with browserify
           * - it forwards errors (no need to declare an error handler EVERYWHERE)
           *
           * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
           * object containing anything (`percent` for example), see each worker for more
           * details. The latter is the real data (String, Uint8Array, etc).
           *
           * @constructor
           * @param {String} name the name of the stream (mainly used for debugging purposes)
           */
          function GenericWorker(name) {
            // the name of the worker
            this.name = name || 'default'
            // an object containing metadata about the workers chain
            this.streamInfo = {}
            // an error which happened when the worker was paused
            this.generatedError = null
            // an object containing metadata to be merged by this worker into the general metadata
            this.extraStreamInfo = {}
            // true if the stream is paused (and should not do anything), false otherwise
            this.isPaused = true
            // true if the stream is finished (and should not do anything), false otherwise
            this.isFinished = false
            // true if the stream is locked to prevent further structure updates (pipe), false otherwise
            this.isLocked = false
            // the event listeners
            this._listeners = {
              data: [],
              end: [],
              error: []
            }
            // the previous worker, if any
            this.previous = null
          }

          GenericWorker.prototype = {
            /**
             * Push a chunk to the next workers.
             * @param {Object} chunk the chunk to push
             */
            push: function (chunk) {
              this.emit('data', chunk)
            },
            /**
             * End the stream.
             * @return {Boolean} true if this call ended the worker, false otherwise.
             */
            end: function () {
              if (this.isFinished) {
                return false
              }

              this.flush()
              try {
                this.emit('end')
                this.cleanUp()
                this.isFinished = true
              } catch (e) {
                this.emit('error', e)
              }
              return true
            },
            /**
             * End the stream with an error.
             * @param {Error} e the error which caused the premature end.
             * @return {Boolean} true if this call ended the worker with an error, false otherwise.
             */
            error: function (e) {
              if (this.isFinished) {
                return false
              }

              if (this.isPaused) {
                this.generatedError = e
              } else {
                this.isFinished = true

                this.emit('error', e)

                // in the workers chain exploded in the middle of the chain,
                // the error event will go downward but we also need to notify
                // workers upward that there has been an error.
                if (this.previous) {
                  this.previous.error(e)
                }

                this.cleanUp()
              }
              return true
            },
            /**
             * Add a callback on an event.
             * @param {String} name the name of the event (data, end, error)
             * @param {Function} listener the function to call when the event is triggered
             * @return {GenericWorker} the current object for chainability
             */
            on: function (name, listener) {
              this._listeners[name].push(listener)
              return this
            },
            /**
             * Clean any references when a worker is ending.
             */
            cleanUp: function () {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null
              this._listeners = []
            },
            /**
             * Trigger an event. This will call registered callback with the provided arg.
             * @param {String} name the name of the event (data, end, error)
             * @param {Object} arg the argument to call the callback with.
             */
            emit: function (name, arg) {
              if (this._listeners[name]) {
                for (var i = 0; i < this._listeners[name].length; i++) {
                  this._listeners[name][i].call(this, arg)
                }
              }
            },
            /**
             * Chain a worker with an other.
             * @param {Worker} next the worker receiving events from the current one.
             * @return {worker} the next worker for chainability
             */
            pipe: function (next) {
              return next.registerPrevious(this)
            },
            /**
             * Same as `pipe` in the other direction.
             * Using an API with `pipe(next)` is very easy.
             * Implementing the API with the point of view of the next one registering
             * a source is easier, see the ZipFileWorker.
             * @param {Worker} previous the previous worker, sending events to this one
             * @return {Worker} the current worker for chainability
             */
            registerPrevious: function (previous) {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.")
              }

              // sharing the streamInfo...
              this.streamInfo = previous.streamInfo
              // ... and adding our own bits
              this.mergeStreamInfo()
              this.previous = previous
              var self = this
              previous.on('data', function (chunk) {
                self.processChunk(chunk)
              })
              previous.on('end', function () {
                self.end()
              })
              previous.on('error', function (e) {
                self.error(e)
              })
              return this
            },
            /**
             * Pause the stream so it doesn't send events anymore.
             * @return {Boolean} true if this call paused the worker, false otherwise.
             */
            pause: function () {
              if (this.isPaused || this.isFinished) {
                return false
              }
              this.isPaused = true

              if (this.previous) {
                this.previous.pause()
              }
              return true
            },
            /**
             * Resume a paused stream.
             * @return {Boolean} true if this call resumed the worker, false otherwise.
             */
            resume: function () {
              if (!this.isPaused || this.isFinished) {
                return false
              }
              this.isPaused = false

              // if true, the worker tried to resume but failed
              var withError = false
              if (this.generatedError) {
                this.error(this.generatedError)
                withError = true
              }
              if (this.previous) {
                this.previous.resume()
              }

              return !withError
            },
            /**
             * Flush any remaining bytes as the stream is ending.
             */
            flush: function () {},
            /**
             * Process a chunk. This is usually the method overridden.
             * @param {Object} chunk the chunk to process.
             */
            processChunk: function (chunk) {
              this.push(chunk)
            },
            /**
             * Add a key/value to be added in the workers chain streamInfo once activated.
             * @param {String} key the key to use
             * @param {Object} value the associated value
             * @return {Worker} the current worker for chainability
             */
            withStreamInfo: function (key, value) {
              this.extraStreamInfo[key] = value
              this.mergeStreamInfo()
              return this
            },
            /**
             * Merge this worker's streamInfo into the chain's streamInfo.
             */
            mergeStreamInfo: function () {
              for (var key in this.extraStreamInfo) {
                if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
                  continue
                }
                this.streamInfo[key] = this.extraStreamInfo[key]
              }
            },

            /**
             * Lock the stream to prevent further updates on the workers chain.
             * After calling this method, all calls to pipe will fail.
             */
            lock: function () {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.")
              }
              this.isLocked = true
              if (this.previous) {
                this.previous.lock()
              }
            },

            /**
             *
             * Pretty print the workers chain.
             */
            toString: function () {
              var me = 'Worker ' + this.name
              if (this.previous) {
                return this.previous + ' -> ' + me
              } else {
                return me
              }
            }
          }

          module.exports = GenericWorker

          /***/
        },

      /***/ './node_modules/jszip/lib/stream/StreamHelper.js':
        /*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/stream/StreamHelper.js ***!
  \*******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ../utils */ './node_modules/jszip/lib/utils.js')
          var ConvertWorker = __webpack_require__(
            /*! ./ConvertWorker */ './node_modules/jszip/lib/stream/ConvertWorker.js'
          )
          var GenericWorker = __webpack_require__(
            /*! ./GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )
          var base64 = __webpack_require__(/*! ../base64 */ './node_modules/jszip/lib/base64.js')
          var support = __webpack_require__(/*! ../support */ './node_modules/jszip/lib/support.js')
          var external = __webpack_require__(
            /*! ../external */ './node_modules/jszip/lib/external.js'
          )

          var NodejsStreamOutputAdapter = null
          if (support.nodestream) {
            try {
              NodejsStreamOutputAdapter = __webpack_require__(
                /*! ../nodejs/NodejsStreamOutputAdapter */ './node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js'
              )
            } catch (e) {
              // ignore
            }
          }

          /**
           * Apply the final transformation of the data. If the user wants a Blob for
           * example, it's easier to work with an U8intArray and finally do the
           * ArrayBuffer/Blob conversion.
           * @param {String} type the name of the final type
           * @param {String|Uint8Array|Buffer} content the content to transform
           * @param {String} mimeType the mime type of the content, if applicable.
           * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
           */
          function transformZipOutput(type, content, mimeType) {
            switch (type) {
              case 'blob':
                return utils.newBlob(utils.transformTo('arraybuffer', content), mimeType)
              case 'base64':
                return base64.encode(content)
              default:
                return utils.transformTo(type, content)
            }
          }

          /**
           * Concatenate an array of data of the given type.
           * @param {String} type the type of the data in the given array.
           * @param {Array} dataArray the array containing the data chunks to concatenate
           * @return {String|Uint8Array|Buffer} the concatenated data
           * @throws Error if the asked type is unsupported
           */
          function concat(type, dataArray) {
            var i,
              index = 0,
              res = null,
              totalLength = 0
            for (i = 0; i < dataArray.length; i++) {
              totalLength += dataArray[i].length
            }
            switch (type) {
              case 'string':
                return dataArray.join('')
              case 'array':
                return Array.prototype.concat.apply([], dataArray)
              case 'uint8array':
                res = new Uint8Array(totalLength)
                for (i = 0; i < dataArray.length; i++) {
                  res.set(dataArray[i], index)
                  index += dataArray[i].length
                }
                return res
              case 'nodebuffer':
                return Buffer.concat(dataArray)
              default:
                throw new Error("concat : unsupported type '" + type + "'")
            }
          }

          /**
           * Listen a StreamHelper, accumulate its content and concatenate it into a
           * complete block.
           * @param {StreamHelper} helper the helper to use.
           * @param {Function} updateCallback a callback called on each update. Called
           * with one arg :
           * - the metadata linked to the update received.
           * @return Promise the promise for the accumulation.
           */
          function accumulate(helper, updateCallback) {
            return new external.Promise(function (resolve, reject) {
              var dataArray = []
              var chunkType = helper._internalType,
                resultType = helper._outputType,
                mimeType = helper._mimeType
              helper
                .on('data', function (data, meta) {
                  dataArray.push(data)
                  if (updateCallback) {
                    updateCallback(meta)
                  }
                })
                .on('error', function (err) {
                  dataArray = []
                  reject(err)
                })
                .on('end', function () {
                  try {
                    var result = transformZipOutput(
                      resultType,
                      concat(chunkType, dataArray),
                      mimeType
                    )
                    resolve(result)
                  } catch (e) {
                    reject(e)
                  }
                  dataArray = []
                })
                .resume()
            })
          }

          /**
           * An helper to easily use workers outside of JSZip.
           * @constructor
           * @param {Worker} worker the worker to wrap
           * @param {String} outputType the type of data expected by the use
           * @param {String} mimeType the mime type of the content, if applicable.
           */
          function StreamHelper(worker, outputType, mimeType) {
            var internalType = outputType
            switch (outputType) {
              case 'blob':
              case 'arraybuffer':
                internalType = 'uint8array'
                break
              case 'base64':
                internalType = 'string'
                break
            }

            try {
              // the type used internally
              this._internalType = internalType
              // the type used to output results
              this._outputType = outputType
              // the mime type
              this._mimeType = mimeType
              utils.checkSupport(internalType)
              this._worker = worker.pipe(new ConvertWorker(internalType))
              // the last workers can be rewired without issues but we need to
              // prevent any updates on previous workers.
              worker.lock()
            } catch (e) {
              this._worker = new GenericWorker('error')
              this._worker.error(e)
            }
          }

          StreamHelper.prototype = {
            /**
             * Listen a StreamHelper, accumulate its content and concatenate it into a
             * complete block.
             * @param {Function} updateCb the update callback.
             * @return Promise the promise for the accumulation.
             */
            accumulate: function (updateCb) {
              return accumulate(this, updateCb)
            },
            /**
             * Add a listener on an event triggered on a stream.
             * @param {String} evt the name of the event
             * @param {Function} fn the listener
             * @return {StreamHelper} the current helper.
             */
            on: function (evt, fn) {
              var self = this

              if (evt === 'data') {
                this._worker.on(evt, function (chunk) {
                  fn.call(self, chunk.data, chunk.meta)
                })
              } else {
                this._worker.on(evt, function () {
                  utils.delay(fn, arguments, self)
                })
              }
              return this
            },
            /**
             * Resume the flow of chunks.
             * @return {StreamHelper} the current helper.
             */
            resume: function () {
              utils.delay(this._worker.resume, [], this._worker)
              return this
            },
            /**
             * Pause the flow of chunks.
             * @return {StreamHelper} the current helper.
             */
            pause: function () {
              this._worker.pause()
              return this
            },
            /**
             * Return a nodejs stream for this helper.
             * @param {Function} updateCb the update callback.
             * @return {NodejsStreamOutputAdapter} the nodejs stream.
             */
            toNodejsStream: function (updateCb) {
              utils.checkSupport('nodestream')
              if (this._outputType !== 'nodebuffer') {
                // an object stream containing blob/arraybuffer/uint8array/string
                // is strange and I don't know if it would be useful.
                // I you find this comment and have a good usecase, please open a
                // bug report !
                throw new Error(this._outputType + ' is not supported by this method')
              }

              return new NodejsStreamOutputAdapter(
                this,
                {
                  objectMode: this._outputType !== 'nodebuffer'
                },
                updateCb
              )
            }
          }

          module.exports = StreamHelper

          /***/
        },

      /***/ './node_modules/jszip/lib/support.js':
        /*!*******************************************!*\
  !*** ./node_modules/jszip/lib/support.js ***!
  \*******************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          exports.base64 = true
          exports.array = true
          exports.string = true
          exports.arraybuffer =
            typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined'
          exports.nodebuffer = typeof Buffer !== 'undefined'
          // contains true if JSZip can read/generate Uint8Array, false otherwise.
          exports.uint8array = typeof Uint8Array !== 'undefined'

          if (typeof ArrayBuffer === 'undefined') {
            exports.blob = false
          } else {
            var buffer = new ArrayBuffer(0)
            try {
              exports.blob =
                new Blob([buffer], {
                  type: 'application/zip'
                }).size === 0
            } catch (e) {
              try {
                var Builder =
                  self.BlobBuilder ||
                  self.WebKitBlobBuilder ||
                  self.MozBlobBuilder ||
                  self.MSBlobBuilder
                var builder = new Builder()
                builder.append(buffer)
                exports.blob = builder.getBlob('application/zip').size === 0
              } catch (e) {
                exports.blob = false
              }
            }
          }

          try {
            exports.nodestream = !!__webpack_require__(
              /*! readable-stream */ './node_modules/jszip/node_modules/readable-stream/readable.js'
            ).Readable
          } catch (e) {
            exports.nodestream = false
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/utf8.js':
        /*!****************************************!*\
  !*** ./node_modules/jszip/lib/utf8.js ***!
  \****************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')
          var support = __webpack_require__(/*! ./support */ './node_modules/jszip/lib/support.js')
          var nodejsUtils = __webpack_require__(
            /*! ./nodejsUtils */ './node_modules/jszip/lib/nodejsUtils.js'
          )
          var GenericWorker = __webpack_require__(
            /*! ./stream/GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )

          /**
           * The following functions come from pako, from pako/lib/utils/strings
           * released under the MIT license, see pako https://github.com/nodeca/pako/
           */

          // Table with utf8 lengths (calculated by first byte of sequence)
          // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
          // because max possible codepoint is 0x10ffff
          var _utf8len = new Array(256)
          for (var i = 0; i < 256; i++) {
            _utf8len[i] =
              i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1
          }
          _utf8len[254] = _utf8len[254] = 1 // Invalid sequence start

          // convert string to array (typed, when possible)
          var string2buf = function (str) {
            var buf,
              c,
              c2,
              m_pos,
              i,
              str_len = str.length,
              buf_len = 0

            // count binary size
            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos)
              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1)
                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)
                  m_pos++
                }
              }
              buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4
            }

            // allocate buffer
            if (support.uint8array) {
              buf = new Uint8Array(buf_len)
            } else {
              buf = new Array(buf_len)
            }

            // convert
            for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos)
              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1)
                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)
                  m_pos++
                }
              }
              if (c < 0x80) {
                /* one byte */
                buf[i++] = c
              } else if (c < 0x800) {
                /* two bytes */
                buf[i++] = 0xc0 | (c >>> 6)
                buf[i++] = 0x80 | (c & 0x3f)
              } else if (c < 0x10000) {
                /* three bytes */
                buf[i++] = 0xe0 | (c >>> 12)
                buf[i++] = 0x80 | ((c >>> 6) & 0x3f)
                buf[i++] = 0x80 | (c & 0x3f)
              } else {
                /* four bytes */
                buf[i++] = 0xf0 | (c >>> 18)
                buf[i++] = 0x80 | ((c >>> 12) & 0x3f)
                buf[i++] = 0x80 | ((c >>> 6) & 0x3f)
                buf[i++] = 0x80 | (c & 0x3f)
              }
            }

            return buf
          }

          // Calculate max possible position in utf8 buffer,
          // that will not break sequence. If that's not possible
          // - (very small limits) return max size as is.
          //
          // buf[] - utf8 bytes array
          // max   - length limit (mandatory);
          var utf8border = function (buf, max) {
            var pos

            max = max || buf.length
            if (max > buf.length) {
              max = buf.length
            }

            // go back from last position, until start of sequence found
            pos = max - 1
            while (pos >= 0 && (buf[pos] & 0xc0) === 0x80) {
              pos--
            }

            // Fuckup - very small and broken sequence,
            // return max, because we should return something anyway.
            if (pos < 0) {
              return max
            }

            // If we came to start of buffer - that means vuffer is too small,
            // return max too.
            if (pos === 0) {
              return max
            }

            return pos + _utf8len[buf[pos]] > max ? pos : max
          }

          // convert array to string
          var buf2string = function (buf) {
            var i, out, c, c_len
            var len = buf.length

            // Reserve max possible length (2 words per char)
            // NB: by unknown reasons, Array is significantly faster for
            //     String.fromCharCode.apply than Uint16Array.
            var utf16buf = new Array(len * 2)

            for (out = 0, i = 0; i < len; ) {
              c = buf[i++]
              // quick process ascii
              if (c < 0x80) {
                utf16buf[out++] = c
                continue
              }

              c_len = _utf8len[c]
              // skip 5 & 6 byte codes
              if (c_len > 4) {
                utf16buf[out++] = 0xfffd
                i += c_len - 1
                continue
              }

              // apply mask on first byte
              c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07
              // join the rest
              while (c_len > 1 && i < len) {
                c = (c << 6) | (buf[i++] & 0x3f)
                c_len--
              }

              // terminated by end of string?
              if (c_len > 1) {
                utf16buf[out++] = 0xfffd
                continue
              }

              if (c < 0x10000) {
                utf16buf[out++] = c
              } else {
                c -= 0x10000
                utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff)
                utf16buf[out++] = 0xdc00 | (c & 0x3ff)
              }
            }

            // shrinkBuf(utf16buf, out)
            if (utf16buf.length !== out) {
              if (utf16buf.subarray) {
                utf16buf = utf16buf.subarray(0, out)
              } else {
                utf16buf.length = out
              }
            }

            // return String.fromCharCode.apply(null, utf16buf);
            return utils.applyFromCharCode(utf16buf)
          }

          // That's all for the pako functions.

          /**
           * Transform a javascript string into an array (typed if possible) of bytes,
           * UTF-8 encoded.
           * @param {String} str the string to encode
           * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
           */
          exports.utf8encode = function utf8encode(str) {
            if (support.nodebuffer) {
              return nodejsUtils.newBufferFrom(str, 'utf-8')
            }

            return string2buf(str)
          }

          /**
           * Transform a bytes array (or a representation) representing an UTF-8 encoded
           * string into a javascript string.
           * @param {Array|Uint8Array|Buffer} buf the data de decode
           * @return {String} the decoded string.
           */
          exports.utf8decode = function utf8decode(buf) {
            if (support.nodebuffer) {
              return utils.transformTo('nodebuffer', buf).toString('utf-8')
            }

            buf = utils.transformTo(support.uint8array ? 'uint8array' : 'array', buf)

            return buf2string(buf)
          }

          /**
           * A worker to decode utf8 encoded binary chunks into string chunks.
           * @constructor
           */
          function Utf8DecodeWorker() {
            GenericWorker.call(this, 'utf-8 decode')
            // the last bytes if a chunk didn't end with a complete codepoint.
            this.leftOver = null
          }
          utils.inherits(Utf8DecodeWorker, GenericWorker)

          /**
           * @see GenericWorker.processChunk
           */
          Utf8DecodeWorker.prototype.processChunk = function (chunk) {
            var data = utils.transformTo(support.uint8array ? 'uint8array' : 'array', chunk.data)

            // 1st step, re-use what's left of the previous chunk
            if (this.leftOver && this.leftOver.length) {
              if (support.uint8array) {
                var previousData = data
                data = new Uint8Array(previousData.length + this.leftOver.length)
                data.set(this.leftOver, 0)
                data.set(previousData, this.leftOver.length)
              } else {
                data = this.leftOver.concat(data)
              }
              this.leftOver = null
            }

            var nextBoundary = utf8border(data)
            var usableData = data
            if (nextBoundary !== data.length) {
              if (support.uint8array) {
                usableData = data.subarray(0, nextBoundary)
                this.leftOver = data.subarray(nextBoundary, data.length)
              } else {
                usableData = data.slice(0, nextBoundary)
                this.leftOver = data.slice(nextBoundary, data.length)
              }
            }

            this.push({
              data: exports.utf8decode(usableData),
              meta: chunk.meta
            })
          }

          /**
           * @see GenericWorker.flush
           */
          Utf8DecodeWorker.prototype.flush = function () {
            if (this.leftOver && this.leftOver.length) {
              this.push({
                data: exports.utf8decode(this.leftOver),
                meta: {}
              })
              this.leftOver = null
            }
          }
          exports.Utf8DecodeWorker = Utf8DecodeWorker

          /**
           * A worker to endcode string chunks into utf8 encoded binary chunks.
           * @constructor
           */
          function Utf8EncodeWorker() {
            GenericWorker.call(this, 'utf-8 encode')
          }
          utils.inherits(Utf8EncodeWorker, GenericWorker)

          /**
           * @see GenericWorker.processChunk
           */
          Utf8EncodeWorker.prototype.processChunk = function (chunk) {
            this.push({
              data: exports.utf8encode(chunk.data),
              meta: chunk.meta
            })
          }
          exports.Utf8EncodeWorker = Utf8EncodeWorker

          /***/
        },

      /***/ './node_modules/jszip/lib/utils.js':
        /*!*****************************************!*\
  !*** ./node_modules/jszip/lib/utils.js ***!
  \*****************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var support = __webpack_require__(/*! ./support */ './node_modules/jszip/lib/support.js')
          var base64 = __webpack_require__(/*! ./base64 */ './node_modules/jszip/lib/base64.js')
          var nodejsUtils = __webpack_require__(
            /*! ./nodejsUtils */ './node_modules/jszip/lib/nodejsUtils.js'
          )
          var external = __webpack_require__(
            /*! ./external */ './node_modules/jszip/lib/external.js'
          )
          __webpack_require__(/*! setimmediate */ './node_modules/setimmediate/setImmediate.js')

          /**
           * Convert a string that pass as a "binary string": it should represent a byte
           * array but may have > 255 char codes. Be sure to take only the first byte
           * and returns the byte array.
           * @param {String} str the string to transform.
           * @return {Array|Uint8Array} the string in a binary format.
           */
          function string2binary(str) {
            var result = null
            if (support.uint8array) {
              result = new Uint8Array(str.length)
            } else {
              result = new Array(str.length)
            }
            return stringToArrayLike(str, result)
          }

          /**
           * Create a new blob with the given content and the given type.
           * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
           * an Uint8Array because the stock browser of android 4 won't accept it (it
           * will be silently converted to a string, "[object Uint8Array]").
           *
           * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
           * when a large amount of Array is used to create the Blob, the amount of
           * memory consumed is nearly 100 times the original data amount.
           *
           * @param {String} type the mime type of the blob.
           * @return {Blob} the created blob.
           */
          exports.newBlob = function (part, type) {
            exports.checkSupport('blob')

            try {
              // Blob constructor
              return new Blob([part], {
                type: type
              })
            } catch (e) {
              try {
                // deprecated, browser only, old way
                var Builder =
                  self.BlobBuilder ||
                  self.WebKitBlobBuilder ||
                  self.MozBlobBuilder ||
                  self.MSBlobBuilder
                var builder = new Builder()
                builder.append(part)
                return builder.getBlob(type)
              } catch (e) {
                // well, fuck ?!
                throw new Error("Bug : can't construct the Blob.")
              }
            }
          }
          /**
           * The identity function.
           * @param {Object} input the input.
           * @return {Object} the same input.
           */
          function identity(input) {
            return input
          }

          /**
           * Fill in an array with a string.
           * @param {String} str the string to use.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
           * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
           */
          function stringToArrayLike(str, array) {
            for (var i = 0; i < str.length; ++i) {
              array[i] = str.charCodeAt(i) & 0xff
            }
            return array
          }

          /**
           * An helper for the function arrayLikeToString.
           * This contains static information and functions that
           * can be optimized by the browser JIT compiler.
           */
          var arrayToStringHelper = {
            /**
             * Transform an array of int into a string, chunk by chunk.
             * See the performances notes on arrayLikeToString.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
             * @param {String} type the type of the array.
             * @param {Integer} chunk the chunk size.
             * @return {String} the resulting string.
             * @throws Error if the chunk is too big for the stack.
             */
            stringifyByChunk: function (array, type, chunk) {
              var result = [],
                k = 0,
                len = array.length
              // shortcut
              if (len <= chunk) {
                return String.fromCharCode.apply(null, array)
              }
              while (k < len) {
                if (type === 'array' || type === 'nodebuffer') {
                  result.push(
                    String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len)))
                  )
                } else {
                  result.push(
                    String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len)))
                  )
                }
                k += chunk
              }
              return result.join('')
            },
            /**
             * Call String.fromCharCode on every item in the array.
             * This is the naive implementation, which generate A LOT of intermediate string.
             * This should be used when everything else fail.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
             * @return {String} the result.
             */
            stringifyByChar: function (array) {
              var resultStr = ''
              for (var i = 0; i < array.length; i++) {
                resultStr += String.fromCharCode(array[i])
              }
              return resultStr
            },
            applyCanBeUsed: {
              /**
               * true if the browser accepts to use String.fromCharCode on Uint8Array
               */
              uint8array: (function () {
                try {
                  return (
                    support.uint8array &&
                    String.fromCharCode.apply(null, new Uint8Array(1)).length === 1
                  )
                } catch (e) {
                  return false
                }
              })(),
              /**
               * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
               */
              nodebuffer: (function () {
                try {
                  return (
                    support.nodebuffer &&
                    String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1
                  )
                } catch (e) {
                  return false
                }
              })()
            }
          }

          /**
           * Transform an array-like object to a string.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
           * @return {String} the result.
           */
          function arrayLikeToString(array) {
            // Performances notes :
            // --------------------
            // String.fromCharCode.apply(null, array) is the fastest, see
            // see http://jsperf.com/converting-a-uint8array-to-a-string/2
            // but the stack is limited (and we can get huge arrays !).
            //
            // result += String.fromCharCode(array[i]); generate too many strings !
            //
            // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
            // TODO : we now have workers that split the work. Do we still need that ?
            var chunk = 65536,
              type = exports.getTypeOf(array),
              canUseApply = true
            if (type === 'uint8array') {
              canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array
            } else if (type === 'nodebuffer') {
              canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer
            }

            if (canUseApply) {
              while (chunk > 1) {
                try {
                  return arrayToStringHelper.stringifyByChunk(array, type, chunk)
                } catch (e) {
                  chunk = Math.floor(chunk / 2)
                }
              }
            }

            // no apply or chunk error : slow and painful algorithm
            // default browser on android 4.*
            return arrayToStringHelper.stringifyByChar(array)
          }

          exports.applyFromCharCode = arrayLikeToString

          /**
           * Copy the data from an array-like to an other array-like.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
           * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
           */
          function arrayLikeToArrayLike(arrayFrom, arrayTo) {
            for (var i = 0; i < arrayFrom.length; i++) {
              arrayTo[i] = arrayFrom[i]
            }
            return arrayTo
          }

          // a matrix containing functions to transform everything into everything.
          var transform = {}

          // string to ?
          transform['string'] = {
            string: identity,
            array: function (input) {
              return stringToArrayLike(input, new Array(input.length))
            },
            arraybuffer: function (input) {
              return transform['string']['uint8array'](input).buffer
            },
            uint8array: function (input) {
              return stringToArrayLike(input, new Uint8Array(input.length))
            },
            nodebuffer: function (input) {
              return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length))
            }
          }

          // array to ?
          transform['array'] = {
            string: arrayLikeToString,
            array: identity,
            arraybuffer: function (input) {
              return new Uint8Array(input).buffer
            },
            uint8array: function (input) {
              return new Uint8Array(input)
            },
            nodebuffer: function (input) {
              return nodejsUtils.newBufferFrom(input)
            }
          }

          // arraybuffer to ?
          transform['arraybuffer'] = {
            string: function (input) {
              return arrayLikeToString(new Uint8Array(input))
            },
            array: function (input) {
              return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))
            },
            arraybuffer: identity,
            uint8array: function (input) {
              return new Uint8Array(input)
            },
            nodebuffer: function (input) {
              return nodejsUtils.newBufferFrom(new Uint8Array(input))
            }
          }

          // uint8array to ?
          transform['uint8array'] = {
            string: arrayLikeToString,
            array: function (input) {
              return arrayLikeToArrayLike(input, new Array(input.length))
            },
            arraybuffer: function (input) {
              return input.buffer
            },
            uint8array: identity,
            nodebuffer: function (input) {
              return nodejsUtils.newBufferFrom(input)
            }
          }

          // nodebuffer to ?
          transform['nodebuffer'] = {
            string: arrayLikeToString,
            array: function (input) {
              return arrayLikeToArrayLike(input, new Array(input.length))
            },
            arraybuffer: function (input) {
              return transform['nodebuffer']['uint8array'](input).buffer
            },
            uint8array: function (input) {
              return arrayLikeToArrayLike(input, new Uint8Array(input.length))
            },
            nodebuffer: identity
          }

          /**
           * Transform an input into any type.
           * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
           * If no output type is specified, the unmodified input will be returned.
           * @param {String} outputType the output type.
           * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
           * @throws {Error} an Error if the browser doesn't support the requested output type.
           */
          exports.transformTo = function (outputType, input) {
            if (!input) {
              // undefined, null, etc
              // an empty string won't harm.
              input = ''
            }
            if (!outputType) {
              return input
            }
            exports.checkSupport(outputType)
            var inputType = exports.getTypeOf(input)
            var result = transform[inputType][outputType](input)
            return result
          }

          /**
           * Resolve all relative path components, "." and "..", in a path. If these relative components
           * traverse above the root then the resulting path will only contain the final path component.
           *
           * All empty components, e.g. "//", are removed.
           * @param {string} path A path with / or \ separators
           * @returns {string} The path with all relative path components resolved.
           */
          exports.resolve = function (path) {
            var parts = path.split('/')
            var result = []
            for (var index = 0; index < parts.length; index++) {
              var part = parts[index]
              // Allow the first and last component to be empty for trailing slashes.
              if (part === '.' || (part === '' && index !== 0 && index !== parts.length - 1)) {
                continue
              } else if (part === '..') {
                result.pop()
              } else {
                result.push(part)
              }
            }
            return result.join('/')
          }

          /**
           * Return the type of the input.
           * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
           * @param {Object} input the input to identify.
           * @return {String} the (lowercase) type of the input.
           */
          exports.getTypeOf = function (input) {
            if (typeof input === 'string') {
              return 'string'
            }
            if (Object.prototype.toString.call(input) === '[object Array]') {
              return 'array'
            }
            if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
              return 'nodebuffer'
            }
            if (support.uint8array && input instanceof Uint8Array) {
              return 'uint8array'
            }
            if (support.arraybuffer && input instanceof ArrayBuffer) {
              return 'arraybuffer'
            }
          }

          /**
           * Throw an exception if the type is not supported.
           * @param {String} type the type to check.
           * @throws {Error} an Error if the browser doesn't support the requested type.
           */
          exports.checkSupport = function (type) {
            var supported = support[type.toLowerCase()]
            if (!supported) {
              throw new Error(type + ' is not supported by this platform')
            }
          }

          exports.MAX_VALUE_16BITS = 65535
          exports.MAX_VALUE_32BITS = -1 // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

          /**
           * Prettify a string read as binary.
           * @param {string} str the string to prettify.
           * @return {string} a pretty string.
           */
          exports.pretty = function (str) {
            var res = '',
              code,
              i
            for (i = 0; i < (str || '').length; i++) {
              code = str.charCodeAt(i)
              res += '\\x' + (code < 16 ? '0' : '') + code.toString(16).toUpperCase()
            }
            return res
          }

          /**
           * Defer the call of a function.
           * @param {Function} callback the function to call asynchronously.
           * @param {Array} args the arguments to give to the callback.
           */
          exports.delay = function (callback, args, self) {
            setImmediate(function () {
              callback.apply(self || null, args || [])
            })
          }

          /**
           * Extends a prototype with an other, without calling a constructor with
           * side effects. Inspired by nodejs' `utils.inherits`
           * @param {Function} ctor the constructor to augment
           * @param {Function} superCtor the parent constructor to use
           */
          exports.inherits = function (ctor, superCtor) {
            var Obj = function () {}
            Obj.prototype = superCtor.prototype
            ctor.prototype = new Obj()
          }

          /**
           * Merge the objects passed as parameters into a new one.
           * @private
           * @param {...Object} var_args All objects to merge.
           * @return {Object} a new object with the data of the others.
           */
          exports.extend = function () {
            var result = {},
              i,
              attr
            for (i = 0; i < arguments.length; i++) {
              // arguments is not enumerable in some browsers
              for (attr in arguments[i]) {
                if (
                  Object.prototype.hasOwnProperty.call(arguments[i], attr) &&
                  typeof result[attr] === 'undefined'
                ) {
                  result[attr] = arguments[i][attr]
                }
              }
            }
            return result
          }

          /**
           * Transform arbitrary content into a Promise.
           * @param {String} name a name for the content being processed.
           * @param {Object} inputData the content to process.
           * @param {Boolean} isBinary true if the content is not an unicode string
           * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
           * @param {Boolean} isBase64 true if the string content is encoded with base64.
           * @return {Promise} a promise in a format usable by JSZip.
           */
          exports.prepareContent = function (
            name,
            inputData,
            isBinary,
            isOptimizedBinaryString,
            isBase64
          ) {
            // if inputData is already a promise, this flatten it.
            var promise = external.Promise.resolve(inputData).then(function (data) {
              var isBlob =
                support.blob &&
                (data instanceof Blob ||
                  ['[object File]', '[object Blob]'].indexOf(
                    Object.prototype.toString.call(data)
                  ) !== -1)

              if (isBlob && typeof FileReader !== 'undefined') {
                return new external.Promise(function (resolve, reject) {
                  var reader = new FileReader()

                  reader.onload = function (e) {
                    resolve(e.target.result)
                  }
                  reader.onerror = function (e) {
                    reject(e.target.error)
                  }
                  reader.readAsArrayBuffer(data)
                })
              } else {
                return data
              }
            })

            return promise.then(function (data) {
              var dataType = exports.getTypeOf(data)

              if (!dataType) {
                return external.Promise.reject(
                  new Error(
                    "Can't read the data of '" +
                      name +
                      "'. Is it " +
                      'in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?'
                  )
                )
              }
              // special case : it's way easier to work with Uint8Array than with ArrayBuffer
              if (dataType === 'arraybuffer') {
                data = exports.transformTo('uint8array', data)
              } else if (dataType === 'string') {
                if (isBase64) {
                  data = base64.decode(data)
                } else if (isBinary) {
                  // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                  if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data)
                  }
                }
              }
              return data
            })
          }

          /***/
        },

      /***/ './node_modules/jszip/lib/zipEntries.js':
        /*!**********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntries.js ***!
  \**********************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var readerFor = __webpack_require__(
            /*! ./reader/readerFor */ './node_modules/jszip/lib/reader/readerFor.js'
          )
          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')
          var sig = __webpack_require__(/*! ./signature */ './node_modules/jszip/lib/signature.js')
          var ZipEntry = __webpack_require__(
            /*! ./zipEntry */ './node_modules/jszip/lib/zipEntry.js'
          )
          var support = __webpack_require__(/*! ./support */ './node_modules/jszip/lib/support.js')
          //  class ZipEntries {{{
          /**
           * All the entries in the zip file.
           * @constructor
           * @param {Object} loadOptions Options for loading the stream.
           */
          function ZipEntries(loadOptions) {
            this.files = []
            this.loadOptions = loadOptions
          }
          ZipEntries.prototype = {
            /**
             * Check that the reader is on the specified signature.
             * @param {string} expectedSignature the expected signature.
             * @throws {Error} if it is an other signature.
             */
            checkSignature: function (expectedSignature) {
              if (!this.reader.readAndCheckSignature(expectedSignature)) {
                this.reader.index -= 4
                var signature = this.reader.readString(4)
                throw new Error(
                  'Corrupted zip or bug: unexpected signature ' +
                    '(' +
                    utils.pretty(signature) +
                    ', expected ' +
                    utils.pretty(expectedSignature) +
                    ')'
                )
              }
            },
            /**
             * Check if the given signature is at the given index.
             * @param {number} askedIndex the index to check.
             * @param {string} expectedSignature the signature to expect.
             * @return {boolean} true if the signature is here, false otherwise.
             */
            isSignature: function (askedIndex, expectedSignature) {
              var currentIndex = this.reader.index
              this.reader.setIndex(askedIndex)
              var signature = this.reader.readString(4)
              var result = signature === expectedSignature
              this.reader.setIndex(currentIndex)
              return result
            },
            /**
             * Read the end of the central directory.
             */
            readBlockEndOfCentral: function () {
              this.diskNumber = this.reader.readInt(2)
              this.diskWithCentralDirStart = this.reader.readInt(2)
              this.centralDirRecordsOnThisDisk = this.reader.readInt(2)
              this.centralDirRecords = this.reader.readInt(2)
              this.centralDirSize = this.reader.readInt(4)
              this.centralDirOffset = this.reader.readInt(4)

              this.zipCommentLength = this.reader.readInt(2)
              // warning : the encoding depends of the system locale
              // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
              // On a windows machine, this field is encoded with the localized windows code page.
              var zipComment = this.reader.readData(this.zipCommentLength)
              var decodeParamType = support.uint8array ? 'uint8array' : 'array'
              // To get consistent behavior with the generation part, we will assume that
              // this is utf8 encoded unless specified otherwise.
              var decodeContent = utils.transformTo(decodeParamType, zipComment)
              this.zipComment = this.loadOptions.decodeFileName(decodeContent)
            },
            /**
             * Read the end of the Zip 64 central directory.
             * Not merged with the method readEndOfCentral :
             * The end of central can coexist with its Zip64 brother,
             * I don't want to read the wrong number of bytes !
             */
            readBlockZip64EndOfCentral: function () {
              this.zip64EndOfCentralSize = this.reader.readInt(8)
              this.reader.skip(4)
              // this.versionMadeBy = this.reader.readString(2);
              // this.versionNeeded = this.reader.readInt(2);
              this.diskNumber = this.reader.readInt(4)
              this.diskWithCentralDirStart = this.reader.readInt(4)
              this.centralDirRecordsOnThisDisk = this.reader.readInt(8)
              this.centralDirRecords = this.reader.readInt(8)
              this.centralDirSize = this.reader.readInt(8)
              this.centralDirOffset = this.reader.readInt(8)

              this.zip64ExtensibleData = {}
              var extraDataSize = this.zip64EndOfCentralSize - 44,
                index = 0,
                extraFieldId,
                extraFieldLength,
                extraFieldValue
              while (index < extraDataSize) {
                extraFieldId = this.reader.readInt(2)
                extraFieldLength = this.reader.readInt(4)
                extraFieldValue = this.reader.readData(extraFieldLength)
                this.zip64ExtensibleData[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                }
              }
            },
            /**
             * Read the end of the Zip 64 central directory locator.
             */
            readBlockZip64EndOfCentralLocator: function () {
              this.diskWithZip64CentralDirStart = this.reader.readInt(4)
              this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8)
              this.disksCount = this.reader.readInt(4)
              if (this.disksCount > 1) {
                throw new Error('Multi-volumes zip are not supported')
              }
            },
            /**
             * Read the local files, based on the offset read in the central part.
             */
            readLocalFiles: function () {
              var i, file
              for (i = 0; i < this.files.length; i++) {
                file = this.files[i]
                this.reader.setIndex(file.localHeaderOffset)
                this.checkSignature(sig.LOCAL_FILE_HEADER)
                file.readLocalPart(this.reader)
                file.handleUTF8()
                file.processAttributes()
              }
            },
            /**
             * Read the central directory.
             */
            readCentralDir: function () {
              var file

              this.reader.setIndex(this.centralDirOffset)
              while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
                file = new ZipEntry(
                  {
                    zip64: this.zip64
                  },
                  this.loadOptions
                )
                file.readCentralPart(this.reader)
                this.files.push(file)
              }

              if (this.centralDirRecords !== this.files.length) {
                if (this.centralDirRecords !== 0 && this.files.length === 0) {
                  // We expected some records but couldn't find ANY.
                  // This is really suspicious, as if something went wrong.
                  throw new Error(
                    'Corrupted zip or bug: expected ' +
                      this.centralDirRecords +
                      ' records in central dir, got ' +
                      this.files.length
                  )
                } else {
                  // We found some records but not all.
                  // Something is wrong but we got something for the user: no error here.
                  // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
                }
              }
            },
            /**
             * Read the end of central directory.
             */
            readEndOfCentral: function () {
              var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END)
              if (offset < 0) {
                // Check if the content is a truncated zip or complete garbage.
                // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
                // extractible zip for example) but it can give a good hint.
                // If an ajax request was used without responseType, we will also
                // get unreadable data.
                var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER)

                if (isGarbage) {
                  throw new Error(
                    "Can't find end of central directory : is this a zip file ? " +
                      'If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html'
                  )
                } else {
                  throw new Error("Corrupted zip: can't find end of central directory")
                }
              }
              this.reader.setIndex(offset)
              var endOfCentralDirOffset = offset
              this.checkSignature(sig.CENTRAL_DIRECTORY_END)
              this.readBlockEndOfCentral()

              /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
              if (
                this.diskNumber === utils.MAX_VALUE_16BITS ||
                this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS ||
                this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS ||
                this.centralDirRecords === utils.MAX_VALUE_16BITS ||
                this.centralDirSize === utils.MAX_VALUE_32BITS ||
                this.centralDirOffset === utils.MAX_VALUE_32BITS
              ) {
                this.zip64 = true

                /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

                // should look for a zip64 EOCD locator
                offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR)
                if (offset < 0) {
                  throw new Error(
                    "Corrupted zip: can't find the ZIP64 end of central directory locator"
                  )
                }
                this.reader.setIndex(offset)
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR)
                this.readBlockZip64EndOfCentralLocator()

                // now the zip64 EOCD record
                if (
                  !this.isSignature(
                    this.relativeOffsetEndOfZip64CentralDir,
                    sig.ZIP64_CENTRAL_DIRECTORY_END
                  )
                ) {
                  // console.warn("ZIP64 end of central directory not where expected.");
                  this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(
                    sig.ZIP64_CENTRAL_DIRECTORY_END
                  )
                  if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory")
                  }
                }
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir)
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END)
                this.readBlockZip64EndOfCentral()
              }

              var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize
              if (this.zip64) {
                expectedEndOfCentralDirOffset += 20 // end of central dir 64 locator
                expectedEndOfCentralDirOffset +=
                  12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize
              }

              var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset

              if (extraBytes > 0) {
                // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
                if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                  // The offsets seem wrong, but we have something at the specified offset.
                  // So… we keep it.
                } else {
                  // the offset is wrong, update the "zero" of the reader
                  // this happens if data has been prepended (crx files for example)
                  this.reader.zero = extraBytes
                }
              } else if (extraBytes < 0) {
                throw new Error('Corrupted zip: missing ' + Math.abs(extraBytes) + ' bytes.')
              }
            },
            prepareReader: function (data) {
              this.reader = readerFor(data)
            },
            /**
             * Read a zip file and create ZipEntries.
             * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
             */
            load: function (data) {
              this.prepareReader(data)
              this.readEndOfCentral()
              this.readCentralDir()
              this.readLocalFiles()
            }
          }
          // }}} end of ZipEntries
          module.exports = ZipEntries

          /***/
        },

      /***/ './node_modules/jszip/lib/zipEntry.js':
        /*!********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntry.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var readerFor = __webpack_require__(
            /*! ./reader/readerFor */ './node_modules/jszip/lib/reader/readerFor.js'
          )
          var utils = __webpack_require__(/*! ./utils */ './node_modules/jszip/lib/utils.js')
          var CompressedObject = __webpack_require__(
            /*! ./compressedObject */ './node_modules/jszip/lib/compressedObject.js'
          )
          var crc32fn = __webpack_require__(/*! ./crc32 */ './node_modules/jszip/lib/crc32.js')
          var utf8 = __webpack_require__(/*! ./utf8 */ './node_modules/jszip/lib/utf8.js')
          var compressions = __webpack_require__(
            /*! ./compressions */ './node_modules/jszip/lib/compressions.js'
          )
          var support = __webpack_require__(/*! ./support */ './node_modules/jszip/lib/support.js')

          var MADE_BY_DOS = 0x00
          var MADE_BY_UNIX = 0x03

          /**
           * Find a compression registered in JSZip.
           * @param {string} compressionMethod the method magic to find.
           * @return {Object|null} the JSZip compression object, null if none found.
           */
          var findCompression = function (compressionMethod) {
            for (var method in compressions) {
              if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
                continue
              }
              if (compressions[method].magic === compressionMethod) {
                return compressions[method]
              }
            }
            return null
          }

          // class ZipEntry {{{
          /**
           * An entry in the zip file.
           * @constructor
           * @param {Object} options Options of the current file.
           * @param {Object} loadOptions Options for loading the stream.
           */
          function ZipEntry(options, loadOptions) {
            this.options = options
            this.loadOptions = loadOptions
          }
          ZipEntry.prototype = {
            /**
             * say if the file is encrypted.
             * @return {boolean} true if the file is encrypted, false otherwise.
             */
            isEncrypted: function () {
              // bit 1 is set
              return (this.bitFlag & 0x0001) === 0x0001
            },
            /**
             * say if the file has utf-8 filename/comment.
             * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
             */
            useUTF8: function () {
              // bit 11 is set
              return (this.bitFlag & 0x0800) === 0x0800
            },
            /**
             * Read the local part of a zip file and add the info in this object.
             * @param {DataReader} reader the reader to use.
             */
            readLocalPart: function (reader) {
              var compression, localExtraFieldsLength

              // we already know everything from the central dir !
              // If the central dir data are false, we are doomed.
              // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
              // The less data we get here, the more reliable this should be.
              // Let's skip the whole header and dash to the data !
              reader.skip(22)
              // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
              // Strangely, the filename here is OK.
              // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
              // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
              // Search "unzip mismatching "local" filename continuing with "central" filename version" on
              // the internet.
              //
              // I think I see the logic here : the central directory is used to display
              // content and the local directory is used to extract the files. Mixing / and \
              // may be used to display \ to windows users and use / when extracting the files.
              // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
              this.fileNameLength = reader.readInt(2)
              localExtraFieldsLength = reader.readInt(2) // can't be sure this will be the same as the central dir
              // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
              this.fileName = reader.readData(this.fileNameLength)
              reader.skip(localExtraFieldsLength)

              if (this.compressedSize === -1 || this.uncompressedSize === -1) {
                throw new Error(
                  "Bug or corrupted zip : didn't get enough information from the central directory " +
                    '(compressedSize === -1 || uncompressedSize === -1)'
                )
              }

              compression = findCompression(this.compressionMethod)
              if (compression === null) {
                // no compression found
                throw new Error(
                  'Corrupted zip : compression ' +
                    utils.pretty(this.compressionMethod) +
                    ' unknown (inner file : ' +
                    utils.transformTo('string', this.fileName) +
                    ')'
                )
              }
              this.decompressed = new CompressedObject(
                this.compressedSize,
                this.uncompressedSize,
                this.crc32,
                compression,
                reader.readData(this.compressedSize)
              )
            },

            /**
             * Read the central part of a zip file and add the info in this object.
             * @param {DataReader} reader the reader to use.
             */
            readCentralPart: function (reader) {
              this.versionMadeBy = reader.readInt(2)
              reader.skip(2)
              // this.versionNeeded = reader.readInt(2);
              this.bitFlag = reader.readInt(2)
              this.compressionMethod = reader.readString(2)
              this.date = reader.readDate()
              this.crc32 = reader.readInt(4)
              this.compressedSize = reader.readInt(4)
              this.uncompressedSize = reader.readInt(4)
              var fileNameLength = reader.readInt(2)
              this.extraFieldsLength = reader.readInt(2)
              this.fileCommentLength = reader.readInt(2)
              this.diskNumberStart = reader.readInt(2)
              this.internalFileAttributes = reader.readInt(2)
              this.externalFileAttributes = reader.readInt(4)
              this.localHeaderOffset = reader.readInt(4)

              if (this.isEncrypted()) {
                throw new Error('Encrypted zip are not supported')
              }

              // will be read in the local part, see the comments there
              reader.skip(fileNameLength)
              this.readExtraFields(reader)
              this.parseZIP64ExtraField(reader)
              this.fileComment = reader.readData(this.fileCommentLength)
            },

            /**
             * Parse the external file attributes and get the unix/dos permissions.
             */
            processAttributes: function () {
              this.unixPermissions = null
              this.dosPermissions = null
              var madeBy = this.versionMadeBy >> 8

              // Check if we have the DOS directory flag set.
              // We look for it in the DOS and UNIX permissions
              // but some unknown platform could set it as a compatibility flag.
              this.dir = this.externalFileAttributes & 0x0010 ? true : false

              if (madeBy === MADE_BY_DOS) {
                // first 6 bits (0 to 5)
                this.dosPermissions = this.externalFileAttributes & 0x3f
              }

              if (madeBy === MADE_BY_UNIX) {
                this.unixPermissions = (this.externalFileAttributes >> 16) & 0xffff
                // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
              }

              // fail safe : if the name ends with a / it probably means a folder
              if (!this.dir && this.fileNameStr.slice(-1) === '/') {
                this.dir = true
              }
            },

            /**
             * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
             * @param {DataReader} reader the reader to use.
             */
            parseZIP64ExtraField: function () {
              if (!this.extraFields[0x0001]) {
                return
              }

              // should be something, preparing the extra reader
              var extraReader = readerFor(this.extraFields[0x0001].value)

              // I really hope that these 64bits integer can fit in 32 bits integer, because js
              // won't let us have more.
              if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
                this.uncompressedSize = extraReader.readInt(8)
              }
              if (this.compressedSize === utils.MAX_VALUE_32BITS) {
                this.compressedSize = extraReader.readInt(8)
              }
              if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
                this.localHeaderOffset = extraReader.readInt(8)
              }
              if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
                this.diskNumberStart = extraReader.readInt(4)
              }
            },
            /**
             * Read the central part of a zip file and add the info in this object.
             * @param {DataReader} reader the reader to use.
             */
            readExtraFields: function (reader) {
              var end = reader.index + this.extraFieldsLength,
                extraFieldId,
                extraFieldLength,
                extraFieldValue

              if (!this.extraFields) {
                this.extraFields = {}
              }

              while (reader.index + 4 < end) {
                extraFieldId = reader.readInt(2)
                extraFieldLength = reader.readInt(2)
                extraFieldValue = reader.readData(extraFieldLength)

                this.extraFields[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                }
              }

              reader.setIndex(end)
            },
            /**
             * Apply an UTF8 transformation if needed.
             */
            handleUTF8: function () {
              var decodeParamType = support.uint8array ? 'uint8array' : 'array'
              if (this.useUTF8()) {
                this.fileNameStr = utf8.utf8decode(this.fileName)
                this.fileCommentStr = utf8.utf8decode(this.fileComment)
              } else {
                var upath = this.findExtraFieldUnicodePath()
                if (upath !== null) {
                  this.fileNameStr = upath
                } else {
                  // ASCII text or unsupported code page
                  var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName)
                  this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray)
                }

                var ucomment = this.findExtraFieldUnicodeComment()
                if (ucomment !== null) {
                  this.fileCommentStr = ucomment
                } else {
                  // ASCII text or unsupported code page
                  var commentByteArray = utils.transformTo(decodeParamType, this.fileComment)
                  this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray)
                }
              }
            },

            /**
             * Find the unicode path declared in the extra field, if any.
             * @return {String} the unicode path, null otherwise.
             */
            findExtraFieldUnicodePath: function () {
              var upathField = this.extraFields[0x7075]
              if (upathField) {
                var extraReader = readerFor(upathField.value)

                // wrong version
                if (extraReader.readInt(1) !== 1) {
                  return null
                }

                // the crc of the filename changed, this field is out of date.
                if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                  return null
                }

                return utf8.utf8decode(extraReader.readData(upathField.length - 5))
              }
              return null
            },

            /**
             * Find the unicode comment declared in the extra field, if any.
             * @return {String} the unicode comment, null otherwise.
             */
            findExtraFieldUnicodeComment: function () {
              var ucommentField = this.extraFields[0x6375]
              if (ucommentField) {
                var extraReader = readerFor(ucommentField.value)

                // wrong version
                if (extraReader.readInt(1) !== 1) {
                  return null
                }

                // the crc of the comment changed, this field is out of date.
                if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                  return null
                }

                return utf8.utf8decode(extraReader.readData(ucommentField.length - 5))
              }
              return null
            }
          }
          module.exports = ZipEntry

          /***/
        },

      /***/ './node_modules/jszip/lib/zipObject.js':
        /*!*********************************************!*\
  !*** ./node_modules/jszip/lib/zipObject.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var StreamHelper = __webpack_require__(
            /*! ./stream/StreamHelper */ './node_modules/jszip/lib/stream/StreamHelper.js'
          )
          var DataWorker = __webpack_require__(
            /*! ./stream/DataWorker */ './node_modules/jszip/lib/stream/DataWorker.js'
          )
          var utf8 = __webpack_require__(/*! ./utf8 */ './node_modules/jszip/lib/utf8.js')
          var CompressedObject = __webpack_require__(
            /*! ./compressedObject */ './node_modules/jszip/lib/compressedObject.js'
          )
          var GenericWorker = __webpack_require__(
            /*! ./stream/GenericWorker */ './node_modules/jszip/lib/stream/GenericWorker.js'
          )

          /**
           * A simple object representing a file in the zip file.
           * @constructor
           * @param {string} name the name of the file
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
           * @param {Object} options the options of the file
           */
          var ZipObject = function (name, data, options) {
            this.name = name
            this.dir = options.dir
            this.date = options.date
            this.comment = options.comment
            this.unixPermissions = options.unixPermissions
            this.dosPermissions = options.dosPermissions

            this._data = data
            this._dataBinary = options.binary
            // keep only the compression
            this.options = {
              compression: options.compression,
              compressionOptions: options.compressionOptions
            }
          }

          ZipObject.prototype = {
            /**
             * Create an internal stream for the content of this object.
             * @param {String} type the type of each chunk.
             * @return StreamHelper the stream.
             */
            internalStream: function (type) {
              var result = null,
                outputType = 'string'
              try {
                if (!type) {
                  throw new Error('No output type specified.')
                }
                outputType = type.toLowerCase()
                var askUnicodeString = outputType === 'string' || outputType === 'text'
                if (outputType === 'binarystring' || outputType === 'text') {
                  outputType = 'string'
                }
                result = this._decompressWorker()

                var isUnicodeString = !this._dataBinary

                if (isUnicodeString && !askUnicodeString) {
                  result = result.pipe(new utf8.Utf8EncodeWorker())
                }
                if (!isUnicodeString && askUnicodeString) {
                  result = result.pipe(new utf8.Utf8DecodeWorker())
                }
              } catch (e) {
                result = new GenericWorker('error')
                result.error(e)
              }

              return new StreamHelper(result, outputType, '')
            },

            /**
             * Prepare the content in the asked type.
             * @param {String} type the type of the result.
             * @param {Function} onUpdate a function to call on each internal update.
             * @return Promise the promise of the result.
             */
            async: function (type, onUpdate) {
              return this.internalStream(type).accumulate(onUpdate)
            },

            /**
             * Prepare the content as a nodejs stream.
             * @param {String} type the type of each chunk.
             * @param {Function} onUpdate a function to call on each internal update.
             * @return Stream the stream.
             */
            nodeStream: function (type, onUpdate) {
              return this.internalStream(type || 'nodebuffer').toNodejsStream(onUpdate)
            },

            /**
             * Return a worker for the compressed content.
             * @private
             * @param {Object} compression the compression object to use.
             * @param {Object} compressionOptions the options to use when compressing.
             * @return Worker the worker.
             */
            _compressWorker: function (compression, compressionOptions) {
              if (
                this._data instanceof CompressedObject &&
                this._data.compression.magic === compression.magic
              ) {
                return this._data.getCompressedWorker()
              } else {
                var result = this._decompressWorker()
                if (!this._dataBinary) {
                  result = result.pipe(new utf8.Utf8EncodeWorker())
                }
                return CompressedObject.createWorkerFrom(result, compression, compressionOptions)
              }
            },
            /**
             * Return a worker for the decompressed content.
             * @private
             * @return Worker the worker.
             */
            _decompressWorker: function () {
              if (this._data instanceof CompressedObject) {
                return this._data.getContentWorker()
              } else if (this._data instanceof GenericWorker) {
                return this._data
              } else {
                return new DataWorker(this._data)
              }
            }
          }

          var removedMethods = [
            'asText',
            'asBinary',
            'asNodeBuffer',
            'asUint8Array',
            'asArrayBuffer'
          ]
          var removedFn = function () {
            throw new Error(
              'This method has been removed in JSZip 3.0, please check the upgrade guide.'
            )
          }

          for (var i = 0; i < removedMethods.length; i++) {
            ZipObject.prototype[removedMethods[i]] = removedFn
          }
          module.exports = ZipObject

          /***/
        },

      /***/ './node_modules/jszip/node_modules/isarray/index.js':
        /*!**********************************************************!*\
  !*** ./node_modules/jszip/node_modules/isarray/index.js ***!
  \**********************************************************/
        /***/ (module) => {
          var toString = {}.toString

          module.exports =
            Array.isArray ||
            function (arr) {
              return toString.call(arr) == '[object Array]'
            }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js':
        /*!*******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*******************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // a duplex stream is just a stream that is both readable and writable.
          // Since JS doesn't have multiple prototypal inheritance, this class
          // prototypally inherits from Readable, and then parasitically from
          // Writable.

          /*<replacement>*/

          var pna = __webpack_require__(
            /*! process-nextick-args */ './node_modules/process-nextick-args/index.js'
          )
          /*</replacement>*/

          /*<replacement>*/
          var objectKeys =
            Object.keys ||
            function (obj) {
              var keys = []
              for (var key in obj) {
                keys.push(key)
              }
              return keys
            }
          /*</replacement>*/

          module.exports = Duplex

          /*<replacement>*/
          var util = Object.create(
            __webpack_require__(/*! core-util-is */ './node_modules/core-util-is/lib/util.js')
          )
          util.inherits = __webpack_require__(/*! inherits */ './node_modules/inherits/inherits.js')
          /*</replacement>*/

          var Readable = __webpack_require__(
            /*! ./_stream_readable */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js'
          )
          var Writable = __webpack_require__(
            /*! ./_stream_writable */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js'
          )

          util.inherits(Duplex, Readable)

          {
            // avoid scope creep, the keys array can then be collected
            var keys = objectKeys(Writable.prototype)
            for (var v = 0; v < keys.length; v++) {
              var method = keys[v]
              if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]
            }
          }

          function Duplex(options) {
            if (!(this instanceof Duplex)) return new Duplex(options)

            Readable.call(this, options)
            Writable.call(this, options)

            if (options && options.readable === false) this.readable = false

            if (options && options.writable === false) this.writable = false

            this.allowHalfOpen = true
            if (options && options.allowHalfOpen === false) this.allowHalfOpen = false

            this.once('end', onend)
          }

          Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function () {
              return this._writableState.highWaterMark
            }
          })

          // the no-half-open enforcer
          function onend() {
            // if we allow half-open state, or if the writable side ended,
            // then we're ok.
            if (this.allowHalfOpen || this._writableState.ended) return

            // no more data can be written.
            // But allow more writes to happen in this tick.
            pna.nextTick(onEndNT, this)
          }

          function onEndNT(self) {
            self.end()
          }

          Object.defineProperty(Duplex.prototype, 'destroyed', {
            get: function () {
              if (this._readableState === undefined || this._writableState === undefined) {
                return false
              }
              return this._readableState.destroyed && this._writableState.destroyed
            },
            set: function (value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (this._readableState === undefined || this._writableState === undefined) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._readableState.destroyed = value
              this._writableState.destroyed = value
            }
          })

          Duplex.prototype._destroy = function (err, cb) {
            this.push(null)
            this.end()

            pna.nextTick(cb, err)
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js':
        /*!************************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \************************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // a passthrough stream.
          // basically just the most minimal sort of Transform stream.
          // Every written chunk gets output as-is.

          module.exports = PassThrough

          var Transform = __webpack_require__(
            /*! ./_stream_transform */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js'
          )

          /*<replacement>*/
          var util = Object.create(
            __webpack_require__(/*! core-util-is */ './node_modules/core-util-is/lib/util.js')
          )
          util.inherits = __webpack_require__(/*! inherits */ './node_modules/inherits/inherits.js')
          /*</replacement>*/

          util.inherits(PassThrough, Transform)

          function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options)

            Transform.call(this, options)
          }

          PassThrough.prototype._transform = function (chunk, encoding, cb) {
            cb(null, chunk)
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js':
        /*!*********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js ***!
  \*********************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          /*<replacement>*/

          var pna = __webpack_require__(
            /*! process-nextick-args */ './node_modules/process-nextick-args/index.js'
          )
          /*</replacement>*/

          module.exports = Readable

          /*<replacement>*/
          var isArray = __webpack_require__(
            /*! isarray */ './node_modules/jszip/node_modules/isarray/index.js'
          )
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Readable.ReadableState = ReadableState

          /*<replacement>*/
          var EE = __webpack_require__(/*! events */ 'events').EventEmitter

          var EElistenerCount = function (emitter, type) {
            return emitter.listeners(type).length
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = __webpack_require__(
            /*! ./internal/streams/stream */ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js'
          )
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = __webpack_require__(
            /*! safe-buffer */ './node_modules/jszip/node_modules/safe-buffer/index.js'
          ).Buffer
          var OurUint8Array =
            (typeof global !== 'undefined'
              ? global
              : typeof window !== 'undefined'
              ? window
              : typeof self !== 'undefined'
              ? self
              : {}
            ).Uint8Array || function () {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          /*<replacement>*/
          var util = Object.create(
            __webpack_require__(/*! core-util-is */ './node_modules/core-util-is/lib/util.js')
          )
          util.inherits = __webpack_require__(/*! inherits */ './node_modules/inherits/inherits.js')
          /*</replacement>*/

          /*<replacement>*/
          var debugUtil = __webpack_require__(/*! util */ 'util')
          var debug = void 0
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog('stream')
          } else {
            debug = function () {}
          }
          /*</replacement>*/

          var BufferList = __webpack_require__(
            /*! ./internal/streams/BufferList */ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js'
          )
          var destroyImpl = __webpack_require__(
            /*! ./internal/streams/destroy */ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js'
          )
          var StringDecoder

          util.inherits(Readable, Stream)

          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume']

          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === 'function')
              return emitter.prependListener(event, fn)

            // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.
            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)
            else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn)
            else emitter._events[event] = [fn, emitter._events[event]]
          }

          function ReadableState(options, stream) {
            Duplex =
              Duplex ||
              __webpack_require__(
                /*! ./_stream_duplex */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js'
              )

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode

            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark
            var readableHwm = options.readableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()
            this.buffer = new BufferList()
            this.length = 0
            this.pipes = null
            this.pipesCount = 0
            this.flowing = null
            this.ended = false
            this.endEmitted = false
            this.reading = false

            // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.
            this.sync = true

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false
            this.emittedReadable = false
            this.readableListening = false
            this.resumeScheduled = false

            // has it been destroyed
            this.destroyed = false

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8'

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false

            this.decoder = null
            this.encoding = null
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = __webpack_require__(
                  /*! string_decoder/ */ './node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js'
                ).StringDecoder
              this.decoder = new StringDecoder(options.encoding)
              this.encoding = options.encoding
            }
          }

          function Readable(options) {
            Duplex =
              Duplex ||
              __webpack_require__(
                /*! ./_stream_duplex */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js'
              )

            if (!(this instanceof Readable)) return new Readable(options)

            this._readableState = new ReadableState(options, this)

            // legacy
            this.readable = true

            if (options) {
              if (typeof options.read === 'function') this._read = options.read

              if (typeof options.destroy === 'function') this._destroy = options.destroy
            }

            Stream.call(this)
          }

          Object.defineProperty(Readable.prototype, 'destroyed', {
            get: function () {
              if (this._readableState === undefined) {
                return false
              }
              return this._readableState.destroyed
            },
            set: function (value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._readableState.destroyed = value
            }
          })

          Readable.prototype.destroy = destroyImpl.destroy
          Readable.prototype._undestroy = destroyImpl.undestroy
          Readable.prototype._destroy = function (err, cb) {
            this.push(null)
            cb(err)
          }

          // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.
          Readable.prototype.push = function (chunk, encoding) {
            var state = this._readableState
            var skipChunkCheck

            if (!state.objectMode) {
              if (typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding)
                  encoding = ''
                }
                skipChunkCheck = true
              }
            } else {
              skipChunkCheck = true
            }

            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck)
          }

          // Unshift should *always* be something directly out of read()
          Readable.prototype.unshift = function (chunk) {
            return readableAddChunk(this, chunk, null, true, false)
          }

          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState
            if (chunk === null) {
              state.reading = false
              onEofChunk(stream, state)
            } else {
              var er
              if (!skipChunkCheck) er = chunkInvalid(state, chunk)
              if (er) {
                stream.emit('error', er)
              } else if (state.objectMode || (chunk && chunk.length > 0)) {
                if (
                  typeof chunk !== 'string' &&
                  !state.objectMode &&
                  Object.getPrototypeOf(chunk) !== Buffer.prototype
                ) {
                  chunk = _uint8ArrayToBuffer(chunk)
                }

                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit('error', new Error('stream.unshift() after end event'))
                  else addChunk(stream, state, chunk, true)
                } else if (state.ended) {
                  stream.emit('error', new Error('stream.push() after EOF'))
                } else {
                  state.reading = false
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk)
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false)
                    else maybeReadMore(stream, state)
                  } else {
                    addChunk(stream, state, chunk, false)
                  }
                }
              } else if (!addToFront) {
                state.reading = false
              }
            }

            return needMoreData(state)
          }

          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk)
              stream.read(0)
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length
              if (addToFront) state.buffer.unshift(chunk)
              else state.buffer.push(chunk)

              if (state.needReadable) emitReadable(stream)
            }
            maybeReadMore(stream, state)
          }

          function chunkInvalid(state, chunk) {
            var er
            if (
              !_isUint8Array(chunk) &&
              typeof chunk !== 'string' &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError('Invalid non-string/buffer chunk')
            }
            return er
          }

          // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.
          function needMoreData(state) {
            return (
              !state.ended &&
              (state.needReadable || state.length < state.highWaterMark || state.length === 0)
            )
          }

          Readable.prototype.isPaused = function () {
            return this._readableState.flowing === false
          }

          // backwards compatibility.
          Readable.prototype.setEncoding = function (enc) {
            if (!StringDecoder)
              StringDecoder = __webpack_require__(
                /*! string_decoder/ */ './node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js'
              ).StringDecoder
            this._readableState.decoder = new StringDecoder(enc)
            this._readableState.encoding = enc
            return this
          }

          // Don't raise the hwm > 8MB
          var MAX_HWM = 0x800000
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--
              n |= n >>> 1
              n |= n >>> 2
              n |= n >>> 4
              n |= n >>> 8
              n |= n >>> 16
              n++
            }
            return n
          }

          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function howMuchToRead(n, state) {
            if (n <= 0 || (state.length === 0 && state.ended)) return 0
            if (state.objectMode) return 1
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length) return state.buffer.head.data.length
              else return state.length
            }
            // If we're asking for more than the current hwm, then raise the hwm.
            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)
            if (n <= state.length) return n
            // Don't have enough
            if (!state.ended) {
              state.needReadable = true
              return 0
            }
            return state.length
          }

          // you can override either this method, or the async _read(n) below.
          Readable.prototype.read = function (n) {
            debug('read', n)
            n = parseInt(n, 10)
            var state = this._readableState
            var nOrig = n

            if (n !== 0) state.emittedReadable = false

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (
              n === 0 &&
              state.needReadable &&
              (state.length >= state.highWaterMark || state.ended)
            ) {
              debug('read: emitReadable', state.length, state.ended)
              if (state.length === 0 && state.ended) endReadable(this)
              else emitReadable(this)
              return null
            }

            n = howMuchToRead(n, state)

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this)
              return null
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable
            debug('need readable', doRead)

            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true
              debug('length less than watermark', doRead)
            }

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
              doRead = false
              debug('reading or ended', doRead)
            } else if (doRead) {
              debug('do read')
              state.reading = true
              state.sync = true
              // if the length is currently zero, then we *need* a readable event.
              if (state.length === 0) state.needReadable = true
              // call internal read method
              this._read(state.highWaterMark)
              state.sync = false
              // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.
              if (!state.reading) n = howMuchToRead(nOrig, state)
            }

            var ret
            if (n > 0) ret = fromList(n, state)
            else ret = null

            if (ret === null) {
              state.needReadable = true
              n = 0
            } else {
              state.length -= n
            }

            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true

              // If we tried to read() past the EOF, then emit end on the next tick.
              if (nOrig !== n && state.ended) endReadable(this)
            }

            if (ret !== null) this.emit('data', ret)

            return ret
          }

          function onEofChunk(stream, state) {
            if (state.ended) return
            if (state.decoder) {
              var chunk = state.decoder.end()
              if (chunk && chunk.length) {
                state.buffer.push(chunk)
                state.length += state.objectMode ? 1 : chunk.length
              }
            }
            state.ended = true

            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream)
          }

          // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.
          function emitReadable(stream) {
            var state = stream._readableState
            state.needReadable = false
            if (!state.emittedReadable) {
              debug('emitReadable', state.flowing)
              state.emittedReadable = true
              if (state.sync) pna.nextTick(emitReadable_, stream)
              else emitReadable_(stream)
            }
          }

          function emitReadable_(stream) {
            debug('emit readable')
            stream.emit('readable')
            flow(stream)
          }

          // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true
              pna.nextTick(maybeReadMore_, stream, state)
            }
          }

          function maybeReadMore_(stream, state) {
            var len = state.length
            while (
              !state.reading &&
              !state.flowing &&
              !state.ended &&
              state.length < state.highWaterMark
            ) {
              debug('maybeReadMore read 0')
              stream.read(0)
              if (len === state.length)
                // didn't get any data, stop spinning.
                break
              else len = state.length
            }
            state.readingMore = false
          }

          // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.
          Readable.prototype._read = function (n) {
            this.emit('error', new Error('_read() is not implemented'))
          }

          Readable.prototype.pipe = function (dest, pipeOpts) {
            var src = this
            var state = this._readableState

            switch (state.pipesCount) {
              case 0:
                state.pipes = dest
                break
              case 1:
                state.pipes = [state.pipes, dest]
                break
              default:
                state.pipes.push(dest)
                break
            }
            state.pipesCount += 1
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts)

            var doEnd =
              (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr

            var endFn = doEnd ? onend : unpipe
            if (state.endEmitted) pna.nextTick(endFn)
            else src.once('end', endFn)

            dest.on('unpipe', onunpipe)
            function onunpipe(readable, unpipeInfo) {
              debug('onunpipe')
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true
                  cleanup()
                }
              }
            }

            function onend() {
              debug('onend')
              dest.end()
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src)
            dest.on('drain', ondrain)

            var cleanedUp = false
            function cleanup() {
              debug('cleanup')
              // cleanup event handlers once the pipe is broken
              dest.removeListener('close', onclose)
              dest.removeListener('finish', onfinish)
              dest.removeListener('drain', ondrain)
              dest.removeListener('error', onerror)
              dest.removeListener('unpipe', onunpipe)
              src.removeListener('end', onend)
              src.removeListener('end', unpipe)
              src.removeListener('data', ondata)

              cleanedUp = true

              // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain()
            }

            // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.
            var increasedAwaitDrain = false
            src.on('data', ondata)
            function ondata(chunk) {
              debug('ondata')
              increasedAwaitDrain = false
              var ret = dest.write(chunk)
              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if (
                  ((state.pipesCount === 1 && state.pipes === dest) ||
                    (state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1)) &&
                  !cleanedUp
                ) {
                  debug('false write response, pause', state.awaitDrain)
                  state.awaitDrain++
                  increasedAwaitDrain = true
                }
                src.pause()
              }
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
              debug('onerror', er)
              unpipe()
              dest.removeListener('error', onerror)
              if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er)
            }

            // Make sure our error handler is attached before userland ones.
            prependListener(dest, 'error', onerror)

            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
              dest.removeListener('finish', onfinish)
              unpipe()
            }
            dest.once('close', onclose)
            function onfinish() {
              debug('onfinish')
              dest.removeListener('close', onclose)
              unpipe()
            }
            dest.once('finish', onfinish)

            function unpipe() {
              debug('unpipe')
              src.unpipe(dest)
            }

            // tell the dest that it's being piped to
            dest.emit('pipe', src)

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
              debug('pipe resume')
              src.resume()
            }

            return dest
          }

          function pipeOnDrain(src) {
            return function () {
              var state = src._readableState
              debug('pipeOnDrain', state.awaitDrain)
              if (state.awaitDrain) state.awaitDrain--
              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                state.flowing = true
                flow(src)
              }
            }
          }

          Readable.prototype.unpipe = function (dest) {
            var state = this._readableState
            var unpipeInfo = { hasUnpiped: false }

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0) return this

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this

              if (!dest) dest = state.pipes

              // got a match.
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false
              if (dest) dest.emit('unpipe', this, unpipeInfo)
              return this
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
              // remove all.
              var dests = state.pipes
              var len = state.pipesCount
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false

              for (var i = 0; i < len; i++) {
                dests[i].emit('unpipe', this, { hasUnpiped: false })
              }
              return this
            }

            // try to find the right one.
            var index = indexOf(state.pipes, dest)
            if (index === -1) return this

            state.pipes.splice(index, 1)
            state.pipesCount -= 1
            if (state.pipesCount === 1) state.pipes = state.pipes[0]

            dest.emit('unpipe', this, unpipeInfo)

            return this
          }

          // set up data events if they are asked for
          // Ensure readable listeners eventually get something
          Readable.prototype.on = function (ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn)

            if (ev === 'data') {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false) this.resume()
            } else if (ev === 'readable') {
              var state = this._readableState
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true
                state.emittedReadable = false
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this)
                } else if (state.length) {
                  emitReadable(this)
                }
              }
            }

            return res
          }
          Readable.prototype.addListener = Readable.prototype.on

          function nReadingNextTick(self) {
            debug('readable nexttick read 0')
            self.read(0)
          }

          // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.
          Readable.prototype.resume = function () {
            var state = this._readableState
            if (!state.flowing) {
              debug('resume')
              state.flowing = true
              resume(this, state)
            }
            return this
          }

          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true
              pna.nextTick(resume_, stream, state)
            }
          }

          function resume_(stream, state) {
            if (!state.reading) {
              debug('resume read 0')
              stream.read(0)
            }

            state.resumeScheduled = false
            state.awaitDrain = 0
            stream.emit('resume')
            flow(stream)
            if (state.flowing && !state.reading) stream.read(0)
          }

          Readable.prototype.pause = function () {
            debug('call pause flowing=%j', this._readableState.flowing)
            if (false !== this._readableState.flowing) {
              debug('pause')
              this._readableState.flowing = false
              this.emit('pause')
            }
            return this
          }

          function flow(stream) {
            var state = stream._readableState
            debug('flow', state.flowing)
            while (state.flowing && stream.read() !== null) {}
          }

          // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.
          Readable.prototype.wrap = function (stream) {
            var _this = this

            var state = this._readableState
            var paused = false

            stream.on('end', function () {
              debug('wrapped end')
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end()
                if (chunk && chunk.length) _this.push(chunk)
              }

              _this.push(null)
            })

            stream.on('data', function (chunk) {
              debug('wrapped data')
              if (state.decoder) chunk = state.decoder.write(chunk)

              // don't skip over falsy values in objectMode
              if (state.objectMode && (chunk === null || chunk === undefined)) return
              else if (!state.objectMode && (!chunk || !chunk.length)) return

              var ret = _this.push(chunk)
              if (!ret) {
                paused = true
                stream.pause()
              }
            })

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === 'function') {
                this[i] = (function (method) {
                  return function () {
                    return stream[method].apply(stream, arguments)
                  }
                })(i)
              }
            }

            // proxy certain important events.
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]))
            }

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            this._read = function (n) {
              debug('wrapped _read', n)
              if (paused) {
                paused = false
                stream.resume()
              }
            }

            return this
          }

          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function () {
              return this._readableState.highWaterMark
            }
          })

          // exposed for testing purposes only.
          Readable._fromList = fromList

          // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null

            var ret
            if (state.objectMode) ret = state.buffer.shift()
            else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join('')
              else if (state.buffer.length === 1) ret = state.buffer.head.data
              else ret = state.buffer.concat(state.length)
              state.buffer.clear()
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder)
            }

            return ret
          }

          // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromListPartial(n, list, hasStrings) {
            var ret
            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n)
              list.head.data = list.head.data.slice(n)
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift()
            } else {
              // result spans more than one buffer
              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list)
            }
            return ret
          }

          // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBufferString(n, list) {
            var p = list.head
            var c = 1
            var ret = p.data
            n -= ret.length
            while ((p = p.next)) {
              var str = p.data
              var nb = n > str.length ? str.length : n
              if (nb === str.length) ret += str
              else ret += str.slice(0, n)
              n -= nb
              if (n === 0) {
                if (nb === str.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = str.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n)
            var p = list.head
            var c = 1
            p.data.copy(ret)
            n -= p.data.length
            while ((p = p.next)) {
              var buf = p.data
              var nb = n > buf.length ? buf.length : n
              buf.copy(ret, ret.length - n, 0, nb)
              n -= nb
              if (n === 0) {
                if (nb === buf.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = buf.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          function endReadable(stream) {
            var state = stream._readableState

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream')

            if (!state.endEmitted) {
              state.ended = true
              pna.nextTick(endReadableNT, state, stream)
            }
          }

          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true
              stream.readable = false
              stream.emit('end')
            }
          }

          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i
            }
            return -1
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js':
        /*!**********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js ***!
  \**********************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // a transform stream is a readable/writable stream where you do
          // something with the data.  Sometimes it's called a "filter",
          // but that's not a great name for it, since that implies a thing where
          // some bits pass through, and others are simply ignored.  (That would
          // be a valid example of a transform, of course.)
          //
          // While the output is causally related to the input, it's not a
          // necessarily symmetric or synchronous transformation.  For example,
          // a zlib stream might take multiple plain-text writes(), and then
          // emit a single compressed chunk some time in the future.
          //
          // Here's how this works:
          //
          // The Transform stream has all the aspects of the readable and writable
          // stream classes.  When you write(chunk), that calls _write(chunk,cb)
          // internally, and returns false if there's a lot of pending writes
          // buffered up.  When you call read(), that calls _read(n) until
          // there's enough pending readable data buffered up.
          //
          // In a transform stream, the written data is placed in a buffer.  When
          // _read(n) is called, it transforms the queued up data, calling the
          // buffered _write cb's as it consumes chunks.  If consuming a single
          // written chunk would result in multiple output chunks, then the first
          // outputted bit calls the readcb, and subsequent chunks just go into
          // the read buffer, and will cause it to emit 'readable' if necessary.
          //
          // This way, back-pressure is actually determined by the reading side,
          // since _read has to be called to start processing a new chunk.  However,
          // a pathological inflate type of transform can cause excessive buffering
          // here.  For example, imagine a stream where every byte of input is
          // interpreted as an integer from 0-255, and then results in that many
          // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
          // 1kb of data being output.  In this case, you could write a very small
          // amount of input, and end up with a very large amount of output.  In
          // such a pathological inflating mechanism, there'd be no way to tell
          // the system to stop doing the transform.  A single 4MB write could
          // cause the system to run out of memory.
          //
          // However, even in such a pathological case, only a single written chunk
          // would be consumed, and then the rest would wait (un-transformed) until
          // the results of the previous transformed chunk were consumed.

          module.exports = Transform

          var Duplex = __webpack_require__(
            /*! ./_stream_duplex */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js'
          )

          /*<replacement>*/
          var util = Object.create(
            __webpack_require__(/*! core-util-is */ './node_modules/core-util-is/lib/util.js')
          )
          util.inherits = __webpack_require__(/*! inherits */ './node_modules/inherits/inherits.js')
          /*</replacement>*/

          util.inherits(Transform, Duplex)

          function afterTransform(er, data) {
            var ts = this._transformState
            ts.transforming = false

            var cb = ts.writecb

            if (!cb) {
              return this.emit('error', new Error('write callback called multiple times'))
            }

            ts.writechunk = null
            ts.writecb = null

            if (data != null)
              // single equals check for both `null` and `undefined`
              this.push(data)

            cb(er)

            var rs = this._readableState
            rs.reading = false
            if (rs.needReadable || rs.length < rs.highWaterMark) {
              this._read(rs.highWaterMark)
            }
          }

          function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options)

            Duplex.call(this, options)

            this._transformState = {
              afterTransform: afterTransform.bind(this),
              needTransform: false,
              transforming: false,
              writecb: null,
              writechunk: null,
              writeencoding: null
            }

            // start out asking for a readable event once data is transformed.
            this._readableState.needReadable = true

            // we have implemented the _read method, and done the other things
            // that Readable wants before the first _read call, so unset the
            // sync guard flag.
            this._readableState.sync = false

            if (options) {
              if (typeof options.transform === 'function') this._transform = options.transform

              if (typeof options.flush === 'function') this._flush = options.flush
            }

            // When the writable side finishes, then flush out anything remaining.
            this.on('prefinish', prefinish)
          }

          function prefinish() {
            var _this = this

            if (typeof this._flush === 'function') {
              this._flush(function (er, data) {
                done(_this, er, data)
              })
            } else {
              done(this, null, null)
            }
          }

          Transform.prototype.push = function (chunk, encoding) {
            this._transformState.needTransform = false
            return Duplex.prototype.push.call(this, chunk, encoding)
          }

          // This is the part where you do stuff!
          // override this function in implementation classes.
          // 'chunk' is an input chunk.
          //
          // Call `push(newChunk)` to pass along transformed output
          // to the readable side.  You may call 'push' zero or more times.
          //
          // Call `cb(err)` when you are done with this chunk.  If you pass
          // an error, then that'll put the hurt on the whole operation.  If you
          // never call cb(), then you'll never get another chunk.
          Transform.prototype._transform = function (chunk, encoding, cb) {
            throw new Error('_transform() is not implemented')
          }

          Transform.prototype._write = function (chunk, encoding, cb) {
            var ts = this._transformState
            ts.writecb = cb
            ts.writechunk = chunk
            ts.writeencoding = encoding
            if (!ts.transforming) {
              var rs = this._readableState
              if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                this._read(rs.highWaterMark)
            }
          }

          // Doesn't matter what the args are here.
          // _transform does all the work.
          // That we got here means that the readable side wants more data.
          Transform.prototype._read = function (n) {
            var ts = this._transformState

            if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
              ts.transforming = true
              this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
            } else {
              // mark that we need a transform, so that any data that comes in
              // will get processed, now that we've asked for it.
              ts.needTransform = true
            }
          }

          Transform.prototype._destroy = function (err, cb) {
            var _this2 = this

            Duplex.prototype._destroy.call(this, err, function (err2) {
              cb(err2)
              _this2.emit('close')
            })
          }

          function done(stream, er, data) {
            if (er) return stream.emit('error', er)

            if (data != null)
              // single equals check for both `null` and `undefined`
              stream.push(data)

            // if there's nothing in the write buffer, then that means
            // that nothing more will ever be provided
            if (stream._writableState.length)
              throw new Error('Calling transform done when ws.length != 0')

            if (stream._transformState.transforming)
              throw new Error('Calling transform done when still transforming')

            return stream.push(null)
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js':
        /*!*********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*********************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.

          /*<replacement>*/

          var pna = __webpack_require__(
            /*! process-nextick-args */ './node_modules/process-nextick-args/index.js'
          )
          /*</replacement>*/

          module.exports = Writable

          /* <replacement> */
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk
            this.encoding = encoding
            this.callback = cb
            this.next = null
          }

          // It seems a linked list but it is not
          // there will be only 2 of these for each stream
          function CorkedRequest(state) {
            var _this = this

            this.next = null
            this.entry = null
            this.finish = function () {
              onCorkedFinish(_this, state)
            }
          }
          /* </replacement> */

          /*<replacement>*/
          var asyncWrite =
            !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1
              ? setImmediate
              : pna.nextTick
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Writable.WritableState = WritableState

          /*<replacement>*/
          var util = Object.create(
            __webpack_require__(/*! core-util-is */ './node_modules/core-util-is/lib/util.js')
          )
          util.inherits = __webpack_require__(/*! inherits */ './node_modules/inherits/inherits.js')
          /*</replacement>*/

          /*<replacement>*/
          var internalUtil = {
            deprecate: __webpack_require__(
              /*! util-deprecate */ './node_modules/util-deprecate/node.js'
            )
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = __webpack_require__(
            /*! ./internal/streams/stream */ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js'
          )
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = __webpack_require__(
            /*! safe-buffer */ './node_modules/jszip/node_modules/safe-buffer/index.js'
          ).Buffer
          var OurUint8Array =
            (typeof global !== 'undefined'
              ? global
              : typeof window !== 'undefined'
              ? window
              : typeof self !== 'undefined'
              ? self
              : {}
            ).Uint8Array || function () {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          var destroyImpl = __webpack_require__(
            /*! ./internal/streams/destroy */ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js'
          )

          util.inherits(Writable, Stream)

          function nop() {}

          function WritableState(options, stream) {
            Duplex =
              Duplex ||
              __webpack_require__(
                /*! ./_stream_duplex */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js'
              )

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode

            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode

            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark
            var writableHwm = options.writableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // if _final has been called
            this.finalCalled = false

            // drain event flag.
            this.needDrain = false
            // at the start of calling end()
            this.ending = false
            // when end() has been called, and returned
            this.ended = false
            // when 'finish' is emitted
            this.finished = false

            // has it been destroyed
            this.destroyed = false

            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false
            this.decodeStrings = !noDecode

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8'

            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0

            // a flag to see when we're in the middle of a write.
            this.writing = false

            // when true all writes will be buffered until .uncork() call
            this.corked = 0

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true

            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false

            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function (er) {
              onwrite(stream, er)
            }

            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null

            // the amount that is being written when _write is called.
            this.writelen = 0

            this.bufferedRequest = null
            this.lastBufferedRequest = null

            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0

            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false

            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false

            // count buffered requests
            this.bufferedRequestCount = 0

            // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two
            this.corkedRequestsFree = new CorkedRequest(this)
          }

          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest
            var out = []
            while (current) {
              out.push(current)
              current = current.next
            }
            return out
          }
          ;(function () {
            try {
              Object.defineProperty(WritableState.prototype, 'buffer', {
                get: internalUtil.deprecate(
                  function () {
                    return this.getBuffer()
                  },
                  '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.',
                  'DEP0003'
                )
              })
            } catch (_) {}
          })()

          // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.
          var realHasInstance
          if (
            typeof Symbol === 'function' &&
            Symbol.hasInstance &&
            typeof Function.prototype[Symbol.hasInstance] === 'function'
          ) {
            realHasInstance = Function.prototype[Symbol.hasInstance]
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function (object) {
                if (realHasInstance.call(this, object)) return true
                if (this !== Writable) return false

                return object && object._writableState instanceof WritableState
              }
            })
          } else {
            realHasInstance = function (object) {
              return object instanceof this
            }
          }

          function Writable(options) {
            Duplex =
              Duplex ||
              __webpack_require__(
                /*! ./_stream_duplex */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js'
              )

            // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.

            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
              return new Writable(options)
            }

            this._writableState = new WritableState(options, this)

            // legacy.
            this.writable = true

            if (options) {
              if (typeof options.write === 'function') this._write = options.write

              if (typeof options.writev === 'function') this._writev = options.writev

              if (typeof options.destroy === 'function') this._destroy = options.destroy

              if (typeof options.final === 'function') this._final = options.final
            }

            Stream.call(this)
          }

          // Otherwise people can pipe Writable streams, which is just wrong.
          Writable.prototype.pipe = function () {
            this.emit('error', new Error('Cannot pipe, not readable'))
          }

          function writeAfterEnd(stream, cb) {
            var er = new Error('write after end')
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit('error', er)
            pna.nextTick(cb, er)
          }

          // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.
          function validChunk(stream, state, chunk, cb) {
            var valid = true
            var er = false

            if (chunk === null) {
              er = new TypeError('May not write null values to stream')
            } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new TypeError('Invalid non-string/buffer chunk')
            }
            if (er) {
              stream.emit('error', er)
              pna.nextTick(cb, er)
              valid = false
            }
            return valid
          }

          Writable.prototype.write = function (chunk, encoding, cb) {
            var state = this._writableState
            var ret = false
            var isBuf = !state.objectMode && _isUint8Array(chunk)

            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk)
            }

            if (typeof encoding === 'function') {
              cb = encoding
              encoding = null
            }

            if (isBuf) encoding = 'buffer'
            else if (!encoding) encoding = state.defaultEncoding

            if (typeof cb !== 'function') cb = nop

            if (state.ended) writeAfterEnd(this, cb)
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)
            }

            return ret
          }

          Writable.prototype.cork = function () {
            var state = this._writableState

            state.corked++
          }

          Writable.prototype.uncork = function () {
            var state = this._writableState

            if (state.corked) {
              state.corked--

              if (
                !state.writing &&
                !state.corked &&
                !state.bufferProcessing &&
                state.bufferedRequest
              )
                clearBuffer(this, state)
            }
          }

          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === 'string') encoding = encoding.toLowerCase()
            if (
              !(
                [
                  'hex',
                  'utf8',
                  'utf-8',
                  'ascii',
                  'binary',
                  'base64',
                  'ucs2',
                  'ucs-2',
                  'utf16le',
                  'utf-16le',
                  'raw'
                ].indexOf((encoding + '').toLowerCase()) > -1
              )
            )
              throw new TypeError('Unknown encoding: ' + encoding)
            this._writableState.defaultEncoding = encoding
            return this
          }

          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = Buffer.from(chunk, encoding)
            }
            return chunk
          }

          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function () {
              return this._writableState.highWaterMark
            }
          })

          // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding)
              if (chunk !== newChunk) {
                isBuf = true
                encoding = 'buffer'
                chunk = newChunk
              }
            }
            var len = state.objectMode ? 1 : chunk.length

            state.length += len

            var ret = state.length < state.highWaterMark
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret) state.needDrain = true

            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              }
              if (last) {
                last.next = state.lastBufferedRequest
              } else {
                state.bufferedRequest = state.lastBufferedRequest
              }
              state.bufferedRequestCount += 1
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb)
            }

            return ret
          }

          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len
            state.writecb = cb
            state.writing = true
            state.sync = true
            if (writev) stream._writev(chunk, state.onwrite)
            else stream._write(chunk, encoding, state.onwrite)
            state.sync = false
          }

          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb

            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              pna.nextTick(cb, er)
              // this can emit finish, and it will always happen
              // after error
              pna.nextTick(finishMaybe, stream, state)
              stream._writableState.errorEmitted = true
              stream.emit('error', er)
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er)
              stream._writableState.errorEmitted = true
              stream.emit('error', er)
              // this can emit finish, but finish must
              // always follow error
              finishMaybe(stream, state)
            }
          }

          function onwriteStateUpdate(state) {
            state.writing = false
            state.writecb = null
            state.length -= state.writelen
            state.writelen = 0
          }

          function onwrite(stream, er) {
            var state = stream._writableState
            var sync = state.sync
            var cb = state.writecb

            onwriteStateUpdate(state)

            if (er) onwriteError(stream, state, sync, er, cb)
            else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state)

              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state)
              }

              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb)
                /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb)
              }
            }
          }

          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state)
            state.pendingcb--
            cb()
            finishMaybe(stream, state)
          }

          // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false
              stream.emit('drain')
            }
          }

          // if there's something in the buffer waiting, then process it
          function clearBuffer(stream, state) {
            state.bufferProcessing = true
            var entry = state.bufferedRequest

            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount
              var buffer = new Array(l)
              var holder = state.corkedRequestsFree
              holder.entry = entry

              var count = 0
              var allBuffers = true
              while (entry) {
                buffer[count] = entry
                if (!entry.isBuf) allBuffers = false
                entry = entry.next
                count += 1
              }
              buffer.allBuffers = allBuffers

              doWrite(stream, state, true, state.length, buffer, '', holder.finish)

              // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite
              state.pendingcb++
              state.lastBufferedRequest = null
              if (holder.next) {
                state.corkedRequestsFree = holder.next
                holder.next = null
              } else {
                state.corkedRequestsFree = new CorkedRequest(state)
              }
              state.bufferedRequestCount = 0
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk
                var encoding = entry.encoding
                var cb = entry.callback
                var len = state.objectMode ? 1 : chunk.length

                doWrite(stream, state, false, len, chunk, encoding, cb)
                entry = entry.next
                state.bufferedRequestCount--
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                  break
                }
              }

              if (entry === null) state.lastBufferedRequest = null
            }

            state.bufferedRequest = entry
            state.bufferProcessing = false
          }

          Writable.prototype._write = function (chunk, encoding, cb) {
            cb(new Error('_write() is not implemented'))
          }

          Writable.prototype._writev = null

          Writable.prototype.end = function (chunk, encoding, cb) {
            var state = this._writableState

            if (typeof chunk === 'function') {
              cb = chunk
              chunk = null
              encoding = null
            } else if (typeof encoding === 'function') {
              cb = encoding
              encoding = null
            }

            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding)

            // .end() fully uncorks
            if (state.corked) {
              state.corked = 1
              this.uncork()
            }

            // ignore unnecessary end() calls.
            if (!state.ending) endWritable(this, state, cb)
          }

          function needFinish(state) {
            return (
              state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing
            )
          }
          function callFinal(stream, state) {
            stream._final(function (err) {
              state.pendingcb--
              if (err) {
                stream.emit('error', err)
              }
              state.prefinished = true
              stream.emit('prefinish')
              finishMaybe(stream, state)
            })
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === 'function') {
                state.pendingcb++
                state.finalCalled = true
                pna.nextTick(callFinal, stream, state)
              } else {
                state.prefinished = true
                stream.emit('prefinish')
              }
            }
          }

          function finishMaybe(stream, state) {
            var need = needFinish(state)
            if (need) {
              prefinish(stream, state)
              if (state.pendingcb === 0) {
                state.finished = true
                stream.emit('finish')
              }
            }
            return need
          }

          function endWritable(stream, state, cb) {
            state.ending = true
            finishMaybe(stream, state)
            if (cb) {
              if (state.finished) pna.nextTick(cb)
              else stream.once('finish', cb)
            }
            state.ended = true
            stream.writable = false
          }

          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry
            corkReq.entry = null
            while (entry) {
              var cb = entry.callback
              state.pendingcb--
              cb(err)
              entry = entry.next
            }

            // reuse the free corkReq.
            state.corkedRequestsFree.next = corkReq
          }

          Object.defineProperty(Writable.prototype, 'destroyed', {
            get: function () {
              if (this._writableState === undefined) {
                return false
              }
              return this._writableState.destroyed
            },
            set: function (value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._writableState.destroyed = value
            }
          })

          Writable.prototype.destroy = destroyImpl.destroy
          Writable.prototype._undestroy = destroyImpl.undestroy
          Writable.prototype._destroy = function (err, cb) {
            this.end()
            cb(err)
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js':
        /*!********************************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \********************************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          var Buffer = __webpack_require__(
            /*! safe-buffer */ './node_modules/jszip/node_modules/safe-buffer/index.js'
          ).Buffer
          var util = __webpack_require__(/*! util */ 'util')

          function copyBuffer(src, target, offset) {
            src.copy(target, offset)
          }

          module.exports = (function () {
            function BufferList() {
              _classCallCheck(this, BufferList)

              this.head = null
              this.tail = null
              this.length = 0
            }

            BufferList.prototype.push = function push(v) {
              var entry = { data: v, next: null }
              if (this.length > 0) this.tail.next = entry
              else this.head = entry
              this.tail = entry
              ++this.length
            }

            BufferList.prototype.unshift = function unshift(v) {
              var entry = { data: v, next: this.head }
              if (this.length === 0) this.tail = entry
              this.head = entry
              ++this.length
            }

            BufferList.prototype.shift = function shift() {
              if (this.length === 0) return
              var ret = this.head.data
              if (this.length === 1) this.head = this.tail = null
              else this.head = this.head.next
              --this.length
              return ret
            }

            BufferList.prototype.clear = function clear() {
              this.head = this.tail = null
              this.length = 0
            }

            BufferList.prototype.join = function join(s) {
              if (this.length === 0) return ''
              var p = this.head
              var ret = '' + p.data
              while ((p = p.next)) {
                ret += s + p.data
              }
              return ret
            }

            BufferList.prototype.concat = function concat(n) {
              if (this.length === 0) return Buffer.alloc(0)
              var ret = Buffer.allocUnsafe(n >>> 0)
              var p = this.head
              var i = 0
              while (p) {
                copyBuffer(p.data, ret, i)
                i += p.data.length
                p = p.next
              }
              return ret
            }

            return BufferList
          })()

          if (util && util.inspect && util.inspect.custom) {
            module.exports.prototype[util.inspect.custom] = function () {
              var obj = util.inspect({ length: this.length })
              return this.constructor.name + ' ' + obj
            }
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js':
        /*!*****************************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \*****************************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          /*<replacement>*/

          var pna = __webpack_require__(
            /*! process-nextick-args */ './node_modules/process-nextick-args/index.js'
          )
          /*</replacement>*/

          // undocumented cb() API, needed for core, not for public API
          function destroy(err, cb) {
            var _this = this

            var readableDestroyed = this._readableState && this._readableState.destroyed
            var writableDestroyed = this._writableState && this._writableState.destroyed

            if (readableDestroyed || writableDestroyed) {
              if (cb) {
                cb(err)
              } else if (err) {
                if (!this._writableState) {
                  pna.nextTick(emitErrorNT, this, err)
                } else if (!this._writableState.errorEmitted) {
                  this._writableState.errorEmitted = true
                  pna.nextTick(emitErrorNT, this, err)
                }
              }

              return this
            }

            // we set destroyed to true before firing error callbacks in order
            // to make it re-entrance safe in case destroy() is called within callbacks

            if (this._readableState) {
              this._readableState.destroyed = true
            }

            // if this is a duplex stream mark the writable part as destroyed as well
            if (this._writableState) {
              this._writableState.destroyed = true
            }

            this._destroy(err || null, function (err) {
              if (!cb && err) {
                if (!_this._writableState) {
                  pna.nextTick(emitErrorNT, _this, err)
                } else if (!_this._writableState.errorEmitted) {
                  _this._writableState.errorEmitted = true
                  pna.nextTick(emitErrorNT, _this, err)
                }
              } else if (cb) {
                cb(err)
              }
            })

            return this
          }

          function undestroy() {
            if (this._readableState) {
              this._readableState.destroyed = false
              this._readableState.reading = false
              this._readableState.ended = false
              this._readableState.endEmitted = false
            }

            if (this._writableState) {
              this._writableState.destroyed = false
              this._writableState.ended = false
              this._writableState.ending = false
              this._writableState.finalCalled = false
              this._writableState.prefinished = false
              this._writableState.finished = false
              this._writableState.errorEmitted = false
            }
          }

          function emitErrorNT(self, err) {
            self.emit('error', err)
          }

          module.exports = {
            destroy: destroy,
            undestroy: undestroy
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js':
        /*!****************************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \****************************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          module.exports = __webpack_require__(/*! stream */ 'stream')

          /***/
        },

      /***/ './node_modules/jszip/node_modules/readable-stream/readable.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/jszip/node_modules/readable-stream/readable.js ***!
  \*********************************************************************/
        /***/ (module, exports, __webpack_require__) => {
          var Stream = __webpack_require__(/*! stream */ 'stream')
          if (process.env.READABLE_STREAM === 'disable' && Stream) {
            module.exports = Stream
            exports = module.exports = Stream.Readable
            exports.Readable = Stream.Readable
            exports.Writable = Stream.Writable
            exports.Duplex = Stream.Duplex
            exports.Transform = Stream.Transform
            exports.PassThrough = Stream.PassThrough
            exports.Stream = Stream
          } else {
            exports = module.exports = __webpack_require__(
              /*! ./lib/_stream_readable.js */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js'
            )
            exports.Stream = Stream || exports
            exports.Readable = exports
            exports.Writable = __webpack_require__(
              /*! ./lib/_stream_writable.js */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js'
            )
            exports.Duplex = __webpack_require__(
              /*! ./lib/_stream_duplex.js */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js'
            )
            exports.Transform = __webpack_require__(
              /*! ./lib/_stream_transform.js */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js'
            )
            exports.PassThrough = __webpack_require__(
              /*! ./lib/_stream_passthrough.js */ './node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js'
            )
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/safe-buffer/index.js':
        /*!**************************************************************!*\
  !*** ./node_modules/jszip/node_modules/safe-buffer/index.js ***!
  \**************************************************************/
        /***/ (module, exports, __webpack_require__) => {
          /* eslint-disable node/no-deprecated-api */
          var buffer = __webpack_require__(/*! buffer */ 'buffer')
          var Buffer = buffer.Buffer

          // alternative to using Object.keys for old browsers
          function copyProps(src, dst) {
            for (var key in src) {
              dst[key] = src[key]
            }
          }
          if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
            module.exports = buffer
          } else {
            // Copy properties from require('buffer')
            copyProps(buffer, exports)
            exports.Buffer = SafeBuffer
          }

          function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length)
          }

          // Copy static methods from Buffer
          copyProps(Buffer, SafeBuffer)

          SafeBuffer.from = function (arg, encodingOrOffset, length) {
            if (typeof arg === 'number') {
              throw new TypeError('Argument must not be a number')
            }
            return Buffer(arg, encodingOrOffset, length)
          }

          SafeBuffer.alloc = function (size, fill, encoding) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number')
            }
            var buf = Buffer(size)
            if (fill !== undefined) {
              if (typeof encoding === 'string') {
                buf.fill(fill, encoding)
              } else {
                buf.fill(fill)
              }
            } else {
              buf.fill(0)
            }
            return buf
          }

          SafeBuffer.allocUnsafe = function (size) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number')
            }
            return Buffer(size)
          }

          SafeBuffer.allocUnsafeSlow = function (size) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number')
            }
            return buffer.SlowBuffer(size)
          }

          /***/
        },

      /***/ './node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js':
        /*!******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js ***!
  \******************************************************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          /*<replacement>*/

          var Buffer = __webpack_require__(
            /*! safe-buffer */ './node_modules/jszip/node_modules/safe-buffer/index.js'
          ).Buffer
          /*</replacement>*/

          var isEncoding =
            Buffer.isEncoding ||
            function (encoding) {
              encoding = '' + encoding
              switch (encoding && encoding.toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                case 'raw':
                  return true
                default:
                  return false
              }
            }

          function _normalizeEncoding(enc) {
            if (!enc) return 'utf8'
            var retried
            while (true) {
              switch (enc) {
                case 'utf8':
                case 'utf-8':
                  return 'utf8'
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return 'utf16le'
                case 'latin1':
                case 'binary':
                  return 'latin1'
                case 'base64':
                case 'ascii':
                case 'hex':
                  return enc
                default:
                  if (retried) return // undefined
                  enc = ('' + enc).toLowerCase()
                  retried = true
              }
            }
          }

          // Do not cache `Buffer.isEncoding` when checking encoding names as some
          // modules monkey-patch it to support additional encodings
          function normalizeEncoding(enc) {
            var nenc = _normalizeEncoding(enc)
            if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
              throw new Error('Unknown encoding: ' + enc)
            return nenc || enc
          }

          // StringDecoder provides an interface for efficiently splitting a series of
          // buffers into a series of JS strings without breaking apart multi-byte
          // characters.
          exports.StringDecoder = StringDecoder
          function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding)
            var nb
            switch (this.encoding) {
              case 'utf16le':
                this.text = utf16Text
                this.end = utf16End
                nb = 4
                break
              case 'utf8':
                this.fillLast = utf8FillLast
                nb = 4
                break
              case 'base64':
                this.text = base64Text
                this.end = base64End
                nb = 3
                break
              default:
                this.write = simpleWrite
                this.end = simpleEnd
                return
            }
            this.lastNeed = 0
            this.lastTotal = 0
            this.lastChar = Buffer.allocUnsafe(nb)
          }

          StringDecoder.prototype.write = function (buf) {
            if (buf.length === 0) return ''
            var r
            var i
            if (this.lastNeed) {
              r = this.fillLast(buf)
              if (r === undefined) return ''
              i = this.lastNeed
              this.lastNeed = 0
            } else {
              i = 0
            }
            if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i)
            return r || ''
          }

          StringDecoder.prototype.end = utf8End

          // Returns only complete characters in a Buffer
          StringDecoder.prototype.text = utf8Text

          // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
          StringDecoder.prototype.fillLast = function (buf) {
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed)
              return this.lastChar.toString(this.encoding, 0, this.lastTotal)
            }
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length)
            this.lastNeed -= buf.length
          }

          // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
          // continuation byte. If an invalid byte is detected, -2 is returned.
          function utf8CheckByte(byte) {
            if (byte <= 0x7f) return 0
            else if (byte >> 5 === 0x06) return 2
            else if (byte >> 4 === 0x0e) return 3
            else if (byte >> 3 === 0x1e) return 4
            return byte >> 6 === 0x02 ? -1 : -2
          }

          // Checks at most 3 bytes at the end of a Buffer in order to detect an
          // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
          // needed to complete the UTF-8 character (if applicable) are returned.
          function utf8CheckIncomplete(self, buf, i) {
            var j = buf.length - 1
            if (j < i) return 0
            var nb = utf8CheckByte(buf[j])
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 1
              return nb
            }
            if (--j < i || nb === -2) return 0
            nb = utf8CheckByte(buf[j])
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 2
              return nb
            }
            if (--j < i || nb === -2) return 0
            nb = utf8CheckByte(buf[j])
            if (nb >= 0) {
              if (nb > 0) {
                if (nb === 2) nb = 0
                else self.lastNeed = nb - 3
              }
              return nb
            }
            return 0
          }

          // Validates as many continuation bytes for a multi-byte UTF-8 character as
          // needed or are available. If we see a non-continuation byte where we expect
          // one, we "replace" the validated continuation bytes we've seen so far with
          // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
          // behavior. The continuation byte check is included three times in the case
          // where all of the continuation bytes for a character exist in the same buffer.
          // It is also done this way as a slight performance increase instead of using a
          // loop.
          function utf8CheckExtraBytes(self, buf, p) {
            if ((buf[0] & 0xc0) !== 0x80) {
              self.lastNeed = 0
              return '\ufffd'
            }
            if (self.lastNeed > 1 && buf.length > 1) {
              if ((buf[1] & 0xc0) !== 0x80) {
                self.lastNeed = 1
                return '\ufffd'
              }
              if (self.lastNeed > 2 && buf.length > 2) {
                if ((buf[2] & 0xc0) !== 0x80) {
                  self.lastNeed = 2
                  return '\ufffd'
                }
              }
            }
          }

          // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
          function utf8FillLast(buf) {
            var p = this.lastTotal - this.lastNeed
            var r = utf8CheckExtraBytes(this, buf, p)
            if (r !== undefined) return r
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, p, 0, this.lastNeed)
              return this.lastChar.toString(this.encoding, 0, this.lastTotal)
            }
            buf.copy(this.lastChar, p, 0, buf.length)
            this.lastNeed -= buf.length
          }

          // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
          // partial character, the character's bytes are buffered until the required
          // number of bytes are available.
          function utf8Text(buf, i) {
            var total = utf8CheckIncomplete(this, buf, i)
            if (!this.lastNeed) return buf.toString('utf8', i)
            this.lastTotal = total
            var end = buf.length - (total - this.lastNeed)
            buf.copy(this.lastChar, 0, end)
            return buf.toString('utf8', i, end)
          }

          // For UTF-8, a replacement character is added when ending on a partial
          // character.
          function utf8End(buf) {
            var r = buf && buf.length ? this.write(buf) : ''
            if (this.lastNeed) return r + '\ufffd'
            return r
          }

          // UTF-16LE typically needs two bytes per character, but even if we have an even
          // number of bytes available, we need to check if we end on a leading/high
          // surrogate. In that case, we need to wait for the next two bytes in order to
          // decode the last character properly.
          function utf16Text(buf, i) {
            if ((buf.length - i) % 2 === 0) {
              var r = buf.toString('utf16le', i)
              if (r) {
                var c = r.charCodeAt(r.length - 1)
                if (c >= 0xd800 && c <= 0xdbff) {
                  this.lastNeed = 2
                  this.lastTotal = 4
                  this.lastChar[0] = buf[buf.length - 2]
                  this.lastChar[1] = buf[buf.length - 1]
                  return r.slice(0, -1)
                }
              }
              return r
            }
            this.lastNeed = 1
            this.lastTotal = 2
            this.lastChar[0] = buf[buf.length - 1]
            return buf.toString('utf16le', i, buf.length - 1)
          }

          // For UTF-16LE we do not explicitly append special replacement characters if we
          // end on a partial character, we simply let v8 handle that.
          function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : ''
            if (this.lastNeed) {
              var end = this.lastTotal - this.lastNeed
              return r + this.lastChar.toString('utf16le', 0, end)
            }
            return r
          }

          function base64Text(buf, i) {
            var n = (buf.length - i) % 3
            if (n === 0) return buf.toString('base64', i)
            this.lastNeed = 3 - n
            this.lastTotal = 3
            if (n === 1) {
              this.lastChar[0] = buf[buf.length - 1]
            } else {
              this.lastChar[0] = buf[buf.length - 2]
              this.lastChar[1] = buf[buf.length - 1]
            }
            return buf.toString('base64', i, buf.length - n)
          }

          function base64End(buf) {
            var r = buf && buf.length ? this.write(buf) : ''
            if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed)
            return r
          }

          // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
          function simpleWrite(buf) {
            return buf.toString(this.encoding)
          }

          function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : ''
          }

          /***/
        },

      /***/ './node_modules/lie/lib/index.js':
        /*!***************************************!*\
  !*** ./node_modules/lie/lib/index.js ***!
  \***************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          var immediate = __webpack_require__(
            /*! immediate */ './node_modules/immediate/lib/index.js'
          )

          /* istanbul ignore next */
          function INTERNAL() {}

          var handlers = {}

          var REJECTED = ['REJECTED']
          var FULFILLED = ['FULFILLED']
          var PENDING = ['PENDING']
          /* istanbul ignore else */
          if (!process.browser) {
            // in which we actually take advantage of JS scoping
            var UNHANDLED = ['UNHANDLED']
          }

          module.exports = Promise

          function Promise(resolver) {
            if (typeof resolver !== 'function') {
              throw new TypeError('resolver must be a function')
            }
            this.state = PENDING
            this.queue = []
            this.outcome = void 0
            /* istanbul ignore else */
            if (!process.browser) {
              this.handled = UNHANDLED
            }
            if (resolver !== INTERNAL) {
              safelyResolveThenable(this, resolver)
            }
          }

          Promise.prototype.finally = function (callback) {
            if (typeof callback !== 'function') {
              return this
            }
            var p = this.constructor
            return this.then(resolve, reject)

            function resolve(value) {
              function yes() {
                return value
              }
              return p.resolve(callback()).then(yes)
            }
            function reject(reason) {
              function no() {
                throw reason
              }
              return p.resolve(callback()).then(no)
            }
          }
          Promise.prototype.catch = function (onRejected) {
            return this.then(null, onRejected)
          }
          Promise.prototype.then = function (onFulfilled, onRejected) {
            if (
              (typeof onFulfilled !== 'function' && this.state === FULFILLED) ||
              (typeof onRejected !== 'function' && this.state === REJECTED)
            ) {
              return this
            }
            var promise = new this.constructor(INTERNAL)
            /* istanbul ignore else */
            if (!process.browser) {
              if (this.handled === UNHANDLED) {
                this.handled = null
              }
            }
            if (this.state !== PENDING) {
              var resolver = this.state === FULFILLED ? onFulfilled : onRejected
              unwrap(promise, resolver, this.outcome)
            } else {
              this.queue.push(new QueueItem(promise, onFulfilled, onRejected))
            }

            return promise
          }
          function QueueItem(promise, onFulfilled, onRejected) {
            this.promise = promise
            if (typeof onFulfilled === 'function') {
              this.onFulfilled = onFulfilled
              this.callFulfilled = this.otherCallFulfilled
            }
            if (typeof onRejected === 'function') {
              this.onRejected = onRejected
              this.callRejected = this.otherCallRejected
            }
          }
          QueueItem.prototype.callFulfilled = function (value) {
            handlers.resolve(this.promise, value)
          }
          QueueItem.prototype.otherCallFulfilled = function (value) {
            unwrap(this.promise, this.onFulfilled, value)
          }
          QueueItem.prototype.callRejected = function (value) {
            handlers.reject(this.promise, value)
          }
          QueueItem.prototype.otherCallRejected = function (value) {
            unwrap(this.promise, this.onRejected, value)
          }

          function unwrap(promise, func, value) {
            immediate(function () {
              var returnValue
              try {
                returnValue = func(value)
              } catch (e) {
                return handlers.reject(promise, e)
              }
              if (returnValue === promise) {
                handlers.reject(promise, new TypeError('Cannot resolve promise with itself'))
              } else {
                handlers.resolve(promise, returnValue)
              }
            })
          }

          handlers.resolve = function (self, value) {
            var result = tryCatch(getThen, value)
            if (result.status === 'error') {
              return handlers.reject(self, result.value)
            }
            var thenable = result.value

            if (thenable) {
              safelyResolveThenable(self, thenable)
            } else {
              self.state = FULFILLED
              self.outcome = value
              var i = -1
              var len = self.queue.length
              while (++i < len) {
                self.queue[i].callFulfilled(value)
              }
            }
            return self
          }
          handlers.reject = function (self, error) {
            self.state = REJECTED
            self.outcome = error
            /* istanbul ignore else */
            if (!process.browser) {
              if (self.handled === UNHANDLED) {
                immediate(function () {
                  if (self.handled === UNHANDLED) {
                    process.emit('unhandledRejection', error, self)
                  }
                })
              }
            }
            var i = -1
            var len = self.queue.length
            while (++i < len) {
              self.queue[i].callRejected(error)
            }
            return self
          }

          function getThen(obj) {
            // Make sure we only access the accessor once as required by the spec
            var then = obj && obj.then
            if (
              obj &&
              (typeof obj === 'object' || typeof obj === 'function') &&
              typeof then === 'function'
            ) {
              return function appyThen() {
                then.apply(obj, arguments)
              }
            }
          }

          function safelyResolveThenable(self, thenable) {
            // Either fulfill, reject or reject with error
            var called = false
            function onError(value) {
              if (called) {
                return
              }
              called = true
              handlers.reject(self, value)
            }

            function onSuccess(value) {
              if (called) {
                return
              }
              called = true
              handlers.resolve(self, value)
            }

            function tryToUnwrap() {
              thenable(onSuccess, onError)
            }

            var result = tryCatch(tryToUnwrap)
            if (result.status === 'error') {
              onError(result.value)
            }
          }

          function tryCatch(func, value) {
            var out = {}
            try {
              out.value = func(value)
              out.status = 'success'
            } catch (e) {
              out.status = 'error'
              out.value = e
            }
            return out
          }

          Promise.resolve = resolve
          function resolve(value) {
            if (value instanceof this) {
              return value
            }
            return handlers.resolve(new this(INTERNAL), value)
          }

          Promise.reject = reject
          function reject(reason) {
            var promise = new this(INTERNAL)
            return handlers.reject(promise, reason)
          }

          Promise.all = all
          function all(iterable) {
            var self = this
            if (Object.prototype.toString.call(iterable) !== '[object Array]') {
              return this.reject(new TypeError('must be an array'))
            }

            var len = iterable.length
            var called = false
            if (!len) {
              return this.resolve([])
            }

            var values = new Array(len)
            var resolved = 0
            var i = -1
            var promise = new this(INTERNAL)

            while (++i < len) {
              allResolver(iterable[i], i)
            }
            return promise
            function allResolver(value, i) {
              self.resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                  called = true
                  handlers.reject(promise, error)
                }
              })
              function resolveFromAll(outValue) {
                values[i] = outValue
                if (++resolved === len && !called) {
                  called = true
                  handlers.resolve(promise, values)
                }
              }
            }
          }

          Promise.race = race
          function race(iterable) {
            var self = this
            if (Object.prototype.toString.call(iterable) !== '[object Array]') {
              return this.reject(new TypeError('must be an array'))
            }

            var len = iterable.length
            var called = false
            if (!len) {
              return this.resolve([])
            }

            var i = -1
            var promise = new this(INTERNAL)

            while (++i < len) {
              resolver(iterable[i])
            }
            return promise
            function resolver(value) {
              self.resolve(value).then(
                function (response) {
                  if (!called) {
                    called = true
                    handlers.resolve(promise, response)
                  }
                },
                function (error) {
                  if (!called) {
                    called = true
                    handlers.reject(promise, error)
                  }
                }
              )
            }
          }

          /***/
        },

      /***/ './node_modules/minimatch/minimatch.js':
        /*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          module.exports = minimatch
          minimatch.Minimatch = Minimatch

          var path = (function () {
            try {
              return __webpack_require__(/*! path */ 'path')
            } catch (e) {}
          })() || {
            sep: '/'
          }
          minimatch.sep = path.sep

          var GLOBSTAR = (minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {})
          var expand = __webpack_require__(
            /*! brace-expansion */ './node_modules/brace-expansion/index.js'
          )

          var plTypes = {
            '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
            '?': { open: '(?:', close: ')?' },
            '+': { open: '(?:', close: ')+' },
            '*': { open: '(?:', close: ')*' },
            '@': { open: '(?:', close: ')' }
          }

          // any single thing other than /
          // don't need to escape / when using new RegExp()
          var qmark = '[^/]'

          // * => any number of characters
          var star = qmark + '*?'

          // ** when dots are allowed.  Anything goes, except .. and .
          // not (^ or / followed by one or two dots followed by $ or /),
          // followed by anything, any number of times.
          var twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?'

          // not a ^ or / followed by a dot,
          // followed by anything, any number of times.
          var twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?'

          // characters that need to be escaped in RegExp.
          var reSpecials = charSet('().*{}+?[]^$\\!')

          // "abc" -> { a:true, b:true, c:true }
          function charSet(s) {
            return s.split('').reduce(function (set, c) {
              set[c] = true
              return set
            }, {})
          }

          // normalizes slashes.
          var slashSplit = /\/+/

          minimatch.filter = filter
          function filter(pattern, options) {
            options = options || {}
            return function (p, i, list) {
              return minimatch(p, pattern, options)
            }
          }

          function ext(a, b) {
            b = b || {}
            var t = {}
            Object.keys(a).forEach(function (k) {
              t[k] = a[k]
            })
            Object.keys(b).forEach(function (k) {
              t[k] = b[k]
            })
            return t
          }

          minimatch.defaults = function (def) {
            if (!def || typeof def !== 'object' || !Object.keys(def).length) {
              return minimatch
            }

            var orig = minimatch

            var m = function minimatch(p, pattern, options) {
              return orig(p, pattern, ext(def, options))
            }

            m.Minimatch = function Minimatch(pattern, options) {
              return new orig.Minimatch(pattern, ext(def, options))
            }
            m.Minimatch.defaults = function defaults(options) {
              return orig.defaults(ext(def, options)).Minimatch
            }

            m.filter = function filter(pattern, options) {
              return orig.filter(pattern, ext(def, options))
            }

            m.defaults = function defaults(options) {
              return orig.defaults(ext(def, options))
            }

            m.makeRe = function makeRe(pattern, options) {
              return orig.makeRe(pattern, ext(def, options))
            }

            m.braceExpand = function braceExpand(pattern, options) {
              return orig.braceExpand(pattern, ext(def, options))
            }

            m.match = function (list, pattern, options) {
              return orig.match(list, pattern, ext(def, options))
            }

            return m
          }

          Minimatch.defaults = function (def) {
            return minimatch.defaults(def).Minimatch
          }

          function minimatch(p, pattern, options) {
            assertValidPattern(pattern)

            if (!options) options = {}

            // shortcut: comments match nothing.
            if (!options.nocomment && pattern.charAt(0) === '#') {
              return false
            }

            return new Minimatch(pattern, options).match(p)
          }

          function Minimatch(pattern, options) {
            if (!(this instanceof Minimatch)) {
              return new Minimatch(pattern, options)
            }

            assertValidPattern(pattern)

            if (!options) options = {}

            pattern = pattern.trim()

            // windows support: need to use /, not \
            if (!options.allowWindowsEscape && path.sep !== '/') {
              pattern = pattern.split(path.sep).join('/')
            }

            this.options = options
            this.set = []
            this.pattern = pattern
            this.regexp = null
            this.negate = false
            this.comment = false
            this.empty = false
            this.partial = !!options.partial

            // make the set of regexps etc.
            this.make()
          }

          Minimatch.prototype.debug = function () {}

          Minimatch.prototype.make = make
          function make() {
            var pattern = this.pattern
            var options = this.options

            // empty patterns and comments match nothing.
            if (!options.nocomment && pattern.charAt(0) === '#') {
              this.comment = true
              return
            }
            if (!pattern) {
              this.empty = true
              return
            }

            // step 1: figure out negation, etc.
            this.parseNegate()

            // step 2: expand braces
            var set = (this.globSet = this.braceExpand())

            if (options.debug)
              this.debug = function debug() {
                console.error.apply(console, arguments)
              }

            this.debug(this.pattern, set)

            // step 3: now we have a set, so turn each one into a series of path-portion
            // matching patterns.
            // These will be regexps, except in the case of "**", which is
            // set to the GLOBSTAR object for globstar behavior,
            // and will not contain any / characters
            set = this.globParts = set.map(function (s) {
              return s.split(slashSplit)
            })

            this.debug(this.pattern, set)

            // glob --> regexps
            set = set.map(function (s, si, set) {
              return s.map(this.parse, this)
            }, this)

            this.debug(this.pattern, set)

            // filter out everything that didn't compile properly.
            set = set.filter(function (s) {
              return s.indexOf(false) === -1
            })

            this.debug(this.pattern, set)

            this.set = set
          }

          Minimatch.prototype.parseNegate = parseNegate
          function parseNegate() {
            var pattern = this.pattern
            var negate = false
            var options = this.options
            var negateOffset = 0

            if (options.nonegate) return

            for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
              negate = !negate
              negateOffset++
            }

            if (negateOffset) this.pattern = pattern.substr(negateOffset)
            this.negate = negate
          }

          // Brace expansion:
          // a{b,c}d -> abd acd
          // a{b,}c -> abc ac
          // a{0..3}d -> a0d a1d a2d a3d
          // a{b,c{d,e}f}g -> abg acdfg acefg
          // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
          //
          // Invalid sets are not expanded.
          // a{2..}b -> a{2..}b
          // a{b}c -> a{b}c
          minimatch.braceExpand = function (pattern, options) {
            return braceExpand(pattern, options)
          }

          Minimatch.prototype.braceExpand = braceExpand

          function braceExpand(pattern, options) {
            if (!options) {
              if (this instanceof Minimatch) {
                options = this.options
              } else {
                options = {}
              }
            }

            pattern = typeof pattern === 'undefined' ? this.pattern : pattern

            assertValidPattern(pattern)

            // Thanks to Yeting Li <https://github.com/yetingli> for
            // improving this regexp to avoid a ReDOS vulnerability.
            if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
              // shortcut. no need to expand.
              return [pattern]
            }

            return expand(pattern)
          }

          var MAX_PATTERN_LENGTH = 1024 * 64
          var assertValidPattern = function (pattern) {
            if (typeof pattern !== 'string') {
              throw new TypeError('invalid pattern')
            }

            if (pattern.length > MAX_PATTERN_LENGTH) {
              throw new TypeError('pattern is too long')
            }
          }

          // parse a component of the expanded set.
          // At this point, no pattern may contain "/" in it
          // so we're going to return a 2d array, where each entry is the full
          // pattern, split on '/', and then turned into a regular expression.
          // A regexp is made at the end which joins each array with an
          // escaped /, and another full one which joins each regexp with |.
          //
          // Following the lead of Bash 4.1, note that "**" only has special meaning
          // when it is the *only* thing in a path portion.  Otherwise, any series
          // of * is equivalent to a single *.  Globstar behavior is enabled by
          // default, and can be disabled by setting options.noglobstar.
          Minimatch.prototype.parse = parse
          var SUBPARSE = {}
          function parse(pattern, isSub) {
            assertValidPattern(pattern)

            var options = this.options

            // shortcuts
            if (pattern === '**') {
              if (!options.noglobstar) return GLOBSTAR
              else pattern = '*'
            }
            if (pattern === '') return ''

            var re = ''
            var hasMagic = !!options.nocase
            var escaping = false
            // ? => one single character
            var patternListStack = []
            var negativeLists = []
            var stateChar
            var inClass = false
            var reClassStart = -1
            var classStart = -1
            // . and .. never match anything that doesn't start with .,
            // even when options.dot is set.
            var patternStart =
              pattern.charAt(0) === '.'
                ? '' // anything
                : // not (start or / followed by . or .. followed by / or end)
                options.dot
                ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
                : '(?!\\.)'
            var self = this

            function clearStateChar() {
              if (stateChar) {
                // we had some state-tracking character
                // that wasn't consumed by this pass.
                switch (stateChar) {
                  case '*':
                    re += star
                    hasMagic = true
                    break
                  case '?':
                    re += qmark
                    hasMagic = true
                    break
                  default:
                    re += '\\' + stateChar
                    break
                }
                self.debug('clearStateChar %j %j', stateChar, re)
                stateChar = false
              }
            }

            for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
              this.debug('%s\t%s %s %j', pattern, i, re, c)

              // skip over any that are escaped.
              if (escaping && reSpecials[c]) {
                re += '\\' + c
                escaping = false
                continue
              }

              switch (c) {
                /* istanbul ignore next */
                case '/': {
                  // completely not allowed, even escaped.
                  // Should already be path-split by now.
                  return false
                }

                case '\\':
                  clearStateChar()
                  escaping = true
                  continue

                // the various stateChar values
                // for the "extglob" stuff.
                case '?':
                case '*':
                case '+':
                case '@':
                case '!':
                  this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

                  // all of those are literals inside a class, except that
                  // the glob [!a] means [^a] in regexp
                  if (inClass) {
                    this.debug('  in class')
                    if (c === '!' && i === classStart + 1) c = '^'
                    re += c
                    continue
                  }

                  // if we already have a stateChar, then it means
                  // that there was something like ** or +? in there.
                  // Handle the stateChar, then proceed with this one.
                  self.debug('call clearStateChar %j', stateChar)
                  clearStateChar()
                  stateChar = c
                  // if extglob is disabled, then +(asdf|foo) isn't a thing.
                  // just clear the statechar *now*, rather than even diving into
                  // the patternList stuff.
                  if (options.noext) clearStateChar()
                  continue

                case '(':
                  if (inClass) {
                    re += '('
                    continue
                  }

                  if (!stateChar) {
                    re += '\\('
                    continue
                  }

                  patternListStack.push({
                    type: stateChar,
                    start: i - 1,
                    reStart: re.length,
                    open: plTypes[stateChar].open,
                    close: plTypes[stateChar].close
                  })
                  // negation is (?:(?!js)[^/]*)
                  re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
                  this.debug('plType %j %j', stateChar, re)
                  stateChar = false
                  continue

                case ')':
                  if (inClass || !patternListStack.length) {
                    re += '\\)'
                    continue
                  }

                  clearStateChar()
                  hasMagic = true
                  var pl = patternListStack.pop()
                  // negation is (?:(?!js)[^/]*)
                  // The others are (?:<pattern>)<type>
                  re += pl.close
                  if (pl.type === '!') {
                    negativeLists.push(pl)
                  }
                  pl.reEnd = re.length
                  continue

                case '|':
                  if (inClass || !patternListStack.length || escaping) {
                    re += '\\|'
                    escaping = false
                    continue
                  }

                  clearStateChar()
                  re += '|'
                  continue

                // these are mostly the same in regexp and glob
                case '[':
                  // swallow any state-tracking char before the [
                  clearStateChar()

                  if (inClass) {
                    re += '\\' + c
                    continue
                  }

                  inClass = true
                  classStart = i
                  reClassStart = re.length
                  re += c
                  continue

                case ']':
                  //  a right bracket shall lose its special
                  //  meaning and represent itself in
                  //  a bracket expression if it occurs
                  //  first in the list.  -- POSIX.2 2.8.3.2
                  if (i === classStart + 1 || !inClass) {
                    re += '\\' + c
                    escaping = false
                    continue
                  }

                  // handle the case where we left a class open.
                  // "[z-a]" is valid, equivalent to "\[z-a\]"
                  // split where the last [ was, make sure we don't have
                  // an invalid re. if so, re-walk the contents of the
                  // would-be class to re-translate any characters that
                  // were passed through as-is
                  // TODO: It would probably be faster to determine this
                  // without a try/catch and a new RegExp, but it's tricky
                  // to do safely.  For now, this is safe and works.
                  var cs = pattern.substring(classStart + 1, i)
                  try {
                    RegExp('[' + cs + ']')
                  } catch (er) {
                    // not a valid class!
                    var sp = this.parse(cs, SUBPARSE)
                    re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
                    hasMagic = hasMagic || sp[1]
                    inClass = false
                    continue
                  }

                  // finish up the class.
                  hasMagic = true
                  inClass = false
                  re += c
                  continue

                default:
                  // swallow any state char that wasn't consumed
                  clearStateChar()

                  if (escaping) {
                    // no need
                    escaping = false
                  } else if (reSpecials[c] && !(c === '^' && inClass)) {
                    re += '\\'
                  }

                  re += c
              } // switch
            } // for

            // handle the case where we left a class open.
            // "[abc" is valid, equivalent to "\[abc"
            if (inClass) {
              // split where the last [ was, and escape it
              // this is a huge pita.  We now have to re-walk
              // the contents of the would-be class to re-translate
              // any characters that were passed through as-is
              cs = pattern.substr(classStart + 1)
              sp = this.parse(cs, SUBPARSE)
              re = re.substr(0, reClassStart) + '\\[' + sp[0]
              hasMagic = hasMagic || sp[1]
            }

            // handle the case where we had a +( thing at the *end*
            // of the pattern.
            // each pattern list stack adds 3 chars, and we need to go through
            // and escape any | chars that were passed through as-is for the regexp.
            // Go through and escape them, taking care not to double-escape any
            // | chars that were already escaped.
            for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
              var tail = re.slice(pl.reStart + pl.open.length)
              this.debug('setting tail', re, pl)
              // maybe some even number of \, then maybe 1 \, followed by a |
              tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
                if (!$2) {
                  // the | isn't already escaped, so escape it.
                  $2 = '\\'
                }

                // need to escape all those slashes *again*, without escaping the
                // one that we need for escaping the | character.  As it works out,
                // escaping an even number of slashes can be done by simply repeating
                // it exactly after itself.  That's why this trick works.
                //
                // I am sorry that you have to see this.
                return $1 + $1 + $2 + '|'
              })

              this.debug('tail=%j\n   %s', tail, tail, pl, re)
              var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type

              hasMagic = true
              re = re.slice(0, pl.reStart) + t + '\\(' + tail
            }

            // handle trailing things that only matter at the very end.
            clearStateChar()
            if (escaping) {
              // trailing \\
              re += '\\\\'
            }

            // only need to apply the nodot start if the re starts with
            // something that could conceivably capture a dot
            var addPatternStart = false
            switch (re.charAt(0)) {
              case '[':
              case '.':
              case '(':
                addPatternStart = true
            }

            // Hack to work around lack of negative lookbehind in JS
            // A pattern like: *.!(x).!(y|z) needs to ensure that a name
            // like 'a.xyz.yz' doesn't match.  So, the first negative
            // lookahead, has to look ALL the way ahead, to the end of
            // the pattern.
            for (var n = negativeLists.length - 1; n > -1; n--) {
              var nl = negativeLists[n]

              var nlBefore = re.slice(0, nl.reStart)
              var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
              var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
              var nlAfter = re.slice(nl.reEnd)

              nlLast += nlAfter

              // Handle nested stuff like *(*.js|!(*.json)), where open parens
              // mean that we should *not* include the ) in the bit that is considered
              // "after" the negated section.
              var openParensBefore = nlBefore.split('(').length - 1
              var cleanAfter = nlAfter
              for (i = 0; i < openParensBefore; i++) {
                cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
              }
              nlAfter = cleanAfter

              var dollar = ''
              if (nlAfter === '' && isSub !== SUBPARSE) {
                dollar = '$'
              }
              var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
              re = newRe
            }

            // if the re is not "" at this point, then we need to make sure
            // it doesn't match against an empty path part.
            // Otherwise a/* will match a/, which it should not.
            if (re !== '' && hasMagic) {
              re = '(?=.)' + re
            }

            if (addPatternStart) {
              re = patternStart + re
            }

            // parsing just a piece of a larger pattern.
            if (isSub === SUBPARSE) {
              return [re, hasMagic]
            }

            // skip the regexp for non-magical patterns
            // unescape anything in it, though, so that it'll be
            // an exact match against a file etc.
            if (!hasMagic) {
              return globUnescape(pattern)
            }

            var flags = options.nocase ? 'i' : ''
            try {
              var regExp = new RegExp('^' + re + '$', flags)
            } catch (er) /* istanbul ignore next - should be impossible */ {
              // If it was an invalid regular expression, then it can't match
              // anything.  This trick looks for a character after the end of
              // the string, which is of course impossible, except in multi-line
              // mode, but it's not a /m regex.
              return new RegExp('$.')
            }

            regExp._glob = pattern
            regExp._src = re

            return regExp
          }

          minimatch.makeRe = function (pattern, options) {
            return new Minimatch(pattern, options || {}).makeRe()
          }

          Minimatch.prototype.makeRe = makeRe
          function makeRe() {
            if (this.regexp || this.regexp === false) return this.regexp

            // at this point, this.set is a 2d array of partial
            // pattern strings, or "**".
            //
            // It's better to use .match().  This function shouldn't
            // be used, really, but it's pretty convenient sometimes,
            // when you just want to work with a regex.
            var set = this.set

            if (!set.length) {
              this.regexp = false
              return this.regexp
            }
            var options = this.options

            var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot
            var flags = options.nocase ? 'i' : ''

            var re = set
              .map(function (pattern) {
                return pattern
                  .map(function (p) {
                    return p === GLOBSTAR
                      ? twoStar
                      : typeof p === 'string'
                      ? regExpEscape(p)
                      : p._src
                  })
                  .join('\\/')
              })
              .join('|')

            // must match entire pattern
            // ending in a * or ** will make it less strict.
            re = '^(?:' + re + ')$'

            // can match anything, as long as it's not this.
            if (this.negate) re = '^(?!' + re + ').*$'

            try {
              this.regexp = new RegExp(re, flags)
            } catch (ex) /* istanbul ignore next - should be impossible */ {
              this.regexp = false
            }
            return this.regexp
          }

          minimatch.match = function (list, pattern, options) {
            options = options || {}
            var mm = new Minimatch(pattern, options)
            list = list.filter(function (f) {
              return mm.match(f)
            })
            if (mm.options.nonull && !list.length) {
              list.push(pattern)
            }
            return list
          }

          Minimatch.prototype.match = function match(f, partial) {
            if (typeof partial === 'undefined') partial = this.partial
            this.debug('match', f, this.pattern)
            // short-circuit in the case of busted things.
            // comments, etc.
            if (this.comment) return false
            if (this.empty) return f === ''

            if (f === '/' && partial) return true

            var options = this.options

            // windows: need to use /, not \
            if (path.sep !== '/') {
              f = f.split(path.sep).join('/')
            }

            // treat the test path as a set of pathparts.
            f = f.split(slashSplit)
            this.debug(this.pattern, 'split', f)

            // just ONE of the pattern sets in this.set needs to match
            // in order for it to be valid.  If negating, then just one
            // match means that we have failed.
            // Either way, return on the first hit.

            var set = this.set
            this.debug(this.pattern, 'set', set)

            // Find the basename of the path by looking for the last non-empty segment
            var filename
            var i
            for (i = f.length - 1; i >= 0; i--) {
              filename = f[i]
              if (filename) break
            }

            for (i = 0; i < set.length; i++) {
              var pattern = set[i]
              var file = f
              if (options.matchBase && pattern.length === 1) {
                file = [filename]
              }
              var hit = this.matchOne(file, pattern, partial)
              if (hit) {
                if (options.flipNegate) return true
                return !this.negate
              }
            }

            // didn't get any hits.  this is success if it's a negative
            // pattern, failure otherwise.
            if (options.flipNegate) return false
            return this.negate
          }

          // set partial to true to test if, for example,
          // "/a/b" matches the start of "/*/b/*/d"
          // Partial means, if you run out of file before you run
          // out of pattern, then that's fine, as long as all
          // the parts match.
          Minimatch.prototype.matchOne = function (file, pattern, partial) {
            var options = this.options

            this.debug('matchOne', { this: this, file: file, pattern: pattern })

            this.debug('matchOne', file.length, pattern.length)

            for (
              var fi = 0, pi = 0, fl = file.length, pl = pattern.length;
              fi < fl && pi < pl;
              fi++, pi++
            ) {
              this.debug('matchOne loop')
              var p = pattern[pi]
              var f = file[fi]

              this.debug(pattern, p, f)

              // should be impossible.
              // some invalid regexp stuff in the set.
              /* istanbul ignore if */
              if (p === false) return false

              if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f])

                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi
                var pr = pi + 1
                if (pr === pl) {
                  this.debug('** at the end')
                  // a ** at the end will just swallow the rest.
                  // We have found a match.
                  // however, it will not swallow /.x, unless
                  // options.dot is set.
                  // . and .. are *never* matched by **, for explosively
                  // exponential reasons.
                  for (; fi < fl; fi++) {
                    if (
                      file[fi] === '.' ||
                      file[fi] === '..' ||
                      (!options.dot && file[fi].charAt(0) === '.')
                    )
                      return false
                  }
                  return true
                }

                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                  var swallowee = file[fr]

                  this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

                  // XXX remove this slice.  Just pass the start index.
                  if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                    this.debug('globstar found match!', fr, fl, swallowee)
                    // found a match.
                    return true
                  } else {
                    // can't swallow "." or ".." ever.
                    // can only swallow ".foo" when explicitly asked.
                    if (
                      swallowee === '.' ||
                      swallowee === '..' ||
                      (!options.dot && swallowee.charAt(0) === '.')
                    ) {
                      this.debug('dot detected!', file, fr, pattern, pr)
                      break
                    }

                    // ** swallows a segment, and continue.
                    this.debug('globstar swallow a segment, and continue')
                    fr++
                  }
                }

                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                // If there's more *pattern* left, then
                /* istanbul ignore if */
                if (partial) {
                  // ran out of file
                  this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
                  if (fr === fl) return true
                }
                return false
              }

              // something other than **
              // non-magic patterns just have to match exactly
              // patterns with magic have been turned into regexps.
              var hit
              if (typeof p === 'string') {
                hit = f === p
                this.debug('string match', p, f, hit)
              } else {
                hit = f.match(p)
                this.debug('pattern match', p, f, hit)
              }

              if (!hit) return false
            }

            // Note: ending in / means that we'll get a final ""
            // at the end of the pattern.  This can only match a
            // corresponding "" at the end of the file.
            // If the file ends in /, then it can only match a
            // a pattern that ends in /, unless the pattern just
            // doesn't have any more for it. But, a/b/ should *not*
            // match "a/b/*", even though "" matches against the
            // [^/]*? pattern, except in partial mode, where it might
            // simply not be reached yet.
            // However, a/b/ should still satisfy a/*

            // now either we fell off the end of the pattern, or we're done.
            if (fi === fl && pi === pl) {
              // ran out of pattern and filename at the same time.
              // an exact hit!
              return true
            } else if (fi === fl) {
              // ran out of file, but still had pattern left.
              // this is ok if we're doing the match as part of
              // a glob fs traversal.
              return partial
            } /* istanbul ignore else */ else if (pi === pl) {
              // ran out of pattern, still have file left.
              // this is only acceptable if we're on the very last
              // empty segment of a file with a trailing slash.
              // a/* should match a/b/
              return fi === fl - 1 && file[fi] === ''
            }

            // should be unreachable.
            /* istanbul ignore next */
            throw new Error('wtf?')
          }

          // replace stuff like \* with *
          function globUnescape(s) {
            return s.replace(/\\(.)/g, '$1')
          }

          function regExpEscape(s) {
            return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
          }

          /***/
        },

      /***/ './node_modules/once/once.js':
        /*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          var wrappy = __webpack_require__(/*! wrappy */ './node_modules/wrappy/wrappy.js')
          module.exports = wrappy(once)
          module.exports.strict = wrappy(onceStrict)

          once.proto = once(function () {
            Object.defineProperty(Function.prototype, 'once', {
              value: function () {
                return once(this)
              },
              configurable: true
            })

            Object.defineProperty(Function.prototype, 'onceStrict', {
              value: function () {
                return onceStrict(this)
              },
              configurable: true
            })
          })

          function once(fn) {
            var f = function () {
              if (f.called) return f.value
              f.called = true
              return (f.value = fn.apply(this, arguments))
            }
            f.called = false
            return f
          }

          function onceStrict(fn) {
            var f = function () {
              if (f.called) throw new Error(f.onceError)
              f.called = true
              return (f.value = fn.apply(this, arguments))
            }
            var name = fn.name || 'Function wrapped with `once`'
            f.onceError = name + " shouldn't be called more than once"
            f.called = false
            return f
          }

          /***/
        },

      /***/ './node_modules/pako/index.js':
        /*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Top level file is just a mixin of submodules & constants

          var assign = __webpack_require__(
            /*! ./lib/utils/common */ './node_modules/pako/lib/utils/common.js'
          ).assign

          var deflate = __webpack_require__(
            /*! ./lib/deflate */ './node_modules/pako/lib/deflate.js'
          )
          var inflate = __webpack_require__(
            /*! ./lib/inflate */ './node_modules/pako/lib/inflate.js'
          )
          var constants = __webpack_require__(
            /*! ./lib/zlib/constants */ './node_modules/pako/lib/zlib/constants.js'
          )

          var pako = {}

          assign(pako, deflate, inflate, constants)

          module.exports = pako

          /***/
        },

      /***/ './node_modules/pako/lib/deflate.js':
        /*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var zlib_deflate = __webpack_require__(
            /*! ./zlib/deflate */ './node_modules/pako/lib/zlib/deflate.js'
          )
          var utils = __webpack_require__(
            /*! ./utils/common */ './node_modules/pako/lib/utils/common.js'
          )
          var strings = __webpack_require__(
            /*! ./utils/strings */ './node_modules/pako/lib/utils/strings.js'
          )
          var msg = __webpack_require__(
            /*! ./zlib/messages */ './node_modules/pako/lib/zlib/messages.js'
          )
          var ZStream = __webpack_require__(
            /*! ./zlib/zstream */ './node_modules/pako/lib/zlib/zstream.js'
          )

          var toString = Object.prototype.toString

          /* Public constants ==========================================================*/
          /* ===========================================================================*/

          var Z_NO_FLUSH = 0
          var Z_FINISH = 4

          var Z_OK = 0
          var Z_STREAM_END = 1
          var Z_SYNC_FLUSH = 2

          var Z_DEFAULT_COMPRESSION = -1

          var Z_DEFAULT_STRATEGY = 0

          var Z_DEFLATED = 8

          /* ===========================================================================*/

          /**
           * class Deflate
           *
           * Generic JS-style wrapper for zlib calls. If you don't need
           * streaming behaviour - use more simple functions: [[deflate]],
           * [[deflateRaw]] and [[gzip]].
           **/

          /* internal
           * Deflate.chunks -> Array
           *
           * Chunks of output data, if [[Deflate#onData]] not overridden.
           **/

          /**
           * Deflate.result -> Uint8Array|Array
           *
           * Compressed result, generated by default [[Deflate#onData]]
           * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
           * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
           * push a chunk with explicit flush (call [[Deflate#push]] with
           * `Z_SYNC_FLUSH` param).
           **/

          /**
           * Deflate.err -> Number
           *
           * Error code after deflate finished. 0 (Z_OK) on success.
           * You will not need it in real life, because deflate errors
           * are possible only on wrong options or bad `onData` / `onEnd`
           * custom handlers.
           **/

          /**
           * Deflate.msg -> String
           *
           * Error message, if [[Deflate.err]] != 0
           **/

          /**
           * new Deflate(options)
           * - options (Object): zlib deflate options.
           *
           * Creates new deflator instance with specified params. Throws exception
           * on bad params. Supported options:
           *
           * - `level`
           * - `windowBits`
           * - `memLevel`
           * - `strategy`
           * - `dictionary`
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information on these.
           *
           * Additional options, for internal needs:
           *
           * - `chunkSize` - size of generated data chunks (16K by default)
           * - `raw` (Boolean) - do raw deflate
           * - `gzip` (Boolean) - create gzip wrapper
           * - `to` (String) - if equal to 'string', then result will be "binary string"
           *    (each char code [0..255])
           * - `header` (Object) - custom header for gzip
           *   - `text` (Boolean) - true if compressed data believed to be text
           *   - `time` (Number) - modification time, unix timestamp
           *   - `os` (Number) - operation system code
           *   - `extra` (Array) - array of bytes with extra data (max 65536)
           *   - `name` (String) - file name (binary string)
           *   - `comment` (String) - comment (binary string)
           *   - `hcrc` (Boolean) - true if header crc should be added
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
           *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
           *
           * var deflate = new pako.Deflate({ level: 3});
           *
           * deflate.push(chunk1, false);
           * deflate.push(chunk2, true);  // true -> last chunk
           *
           * if (deflate.err) { throw new Error(deflate.err); }
           *
           * console.log(deflate.result);
           * ```
           **/
          function Deflate(options) {
            if (!(this instanceof Deflate)) return new Deflate(options)

            this.options = utils.assign(
              {
                level: Z_DEFAULT_COMPRESSION,
                method: Z_DEFLATED,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Z_DEFAULT_STRATEGY,
                to: ''
              },
              options || {}
            )

            var opt = this.options

            if (opt.raw && opt.windowBits > 0) {
              opt.windowBits = -opt.windowBits
            } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
              opt.windowBits += 16
            }

            this.err = 0 // error code, if happens (0 = Z_OK)
            this.msg = '' // error message
            this.ended = false // used to avoid multiple onEnd() calls
            this.chunks = [] // chunks of compressed data

            this.strm = new ZStream()
            this.strm.avail_out = 0

            var status = zlib_deflate.deflateInit2(
              this.strm,
              opt.level,
              opt.method,
              opt.windowBits,
              opt.memLevel,
              opt.strategy
            )

            if (status !== Z_OK) {
              throw new Error(msg[status])
            }

            if (opt.header) {
              zlib_deflate.deflateSetHeader(this.strm, opt.header)
            }

            if (opt.dictionary) {
              var dict
              // Convert data if needed
              if (typeof opt.dictionary === 'string') {
                // If we need to compress text, change encoding to utf8.
                dict = strings.string2buf(opt.dictionary)
              } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
                dict = new Uint8Array(opt.dictionary)
              } else {
                dict = opt.dictionary
              }

              status = zlib_deflate.deflateSetDictionary(this.strm, dict)

              if (status !== Z_OK) {
                throw new Error(msg[status])
              }

              this._dict_set = true
            }
          }

          /**
           * Deflate#push(data[, mode]) -> Boolean
           * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
           *   converted to utf8 byte sequence.
           * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
           *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
           *
           * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
           * new compressed chunks. Returns `true` on success. The last data block must have
           * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
           * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
           * can use mode Z_SYNC_FLUSH, keeping the compression context.
           *
           * On fail call [[Deflate#onEnd]] with error code and return false.
           *
           * We strongly recommend to use `Uint8Array` on input for best speed (output
           * array format is detected automatically). Also, don't skip last param and always
           * use the same type in your code (boolean or number). That will improve JS speed.
           *
           * For regular `Array`-s make sure all elements are [0..255].
           *
           * ##### Example
           *
           * ```javascript
           * push(chunk, false); // push one of data chunks
           * ...
           * push(chunk, true);  // push last chunk
           * ```
           **/
          Deflate.prototype.push = function (data, mode) {
            var strm = this.strm
            var chunkSize = this.options.chunkSize
            var status, _mode

            if (this.ended) {
              return false
            }

            _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH

            // Convert data if needed
            if (typeof data === 'string') {
              // If we need to compress text, change encoding to utf8.
              strm.input = strings.string2buf(data)
            } else if (toString.call(data) === '[object ArrayBuffer]') {
              strm.input = new Uint8Array(data)
            } else {
              strm.input = data
            }

            strm.next_in = 0
            strm.avail_in = strm.input.length

            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize)
                strm.next_out = 0
                strm.avail_out = chunkSize
              }
              status = zlib_deflate.deflate(strm, _mode) /* no bad return value */

              if (status !== Z_STREAM_END && status !== Z_OK) {
                this.onEnd(status)
                this.ended = true
                return false
              }
              if (
                strm.avail_out === 0 ||
                (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))
              ) {
                if (this.options.to === 'string') {
                  this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)))
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out))
                }
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END)

            // Finalize on the last chunk.
            if (_mode === Z_FINISH) {
              status = zlib_deflate.deflateEnd(this.strm)
              this.onEnd(status)
              this.ended = true
              return status === Z_OK
            }

            // callback interim results if Z_SYNC_FLUSH.
            if (_mode === Z_SYNC_FLUSH) {
              this.onEnd(Z_OK)
              strm.avail_out = 0
              return true
            }

            return true
          }

          /**
           * Deflate#onData(chunk) -> Void
           * - chunk (Uint8Array|Array|String): output data. Type of array depends
           *   on js engine support. When string output requested, each chunk
           *   will be string.
           *
           * By default, stores data blocks in `chunks[]` property and glue
           * those in `onEnd`. Override this handler, if you need another behaviour.
           **/
          Deflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk)
          }

          /**
           * Deflate#onEnd(status) -> Void
           * - status (Number): deflate status. 0 (Z_OK) on success,
           *   other if not.
           *
           * Called once after you tell deflate that the input stream is
           * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
           * or if an error happened. By default - join collected chunks,
           * free memory and fill `results` / `err` properties.
           **/
          Deflate.prototype.onEnd = function (status) {
            // On success - join
            if (status === Z_OK) {
              if (this.options.to === 'string') {
                this.result = this.chunks.join('')
              } else {
                this.result = utils.flattenChunks(this.chunks)
              }
            }
            this.chunks = []
            this.err = status
            this.msg = this.strm.msg
          }

          /**
           * deflate(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to compress.
           * - options (Object): zlib deflate options.
           *
           * Compress `data` with deflate algorithm and `options`.
           *
           * Supported options are:
           *
           * - level
           * - windowBits
           * - memLevel
           * - strategy
           * - dictionary
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information on these.
           *
           * Sugar (options):
           *
           * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
           *   negative windowBits implicitly.
           * - `to` (String) - if equal to 'string', then result will be "binary string"
           *    (each char code [0..255])
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
           *
           * console.log(pako.deflate(data));
           * ```
           **/
          function deflate(input, options) {
            var deflator = new Deflate(options)

            deflator.push(input, true)

            // That will never happens, if you don't cheat with options :)
            if (deflator.err) {
              throw deflator.msg || msg[deflator.err]
            }

            return deflator.result
          }

          /**
           * deflateRaw(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to compress.
           * - options (Object): zlib deflate options.
           *
           * The same as [[deflate]], but creates raw data, without wrapper
           * (header and adler32 crc).
           **/
          function deflateRaw(input, options) {
            options = options || {}
            options.raw = true
            return deflate(input, options)
          }

          /**
           * gzip(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to compress.
           * - options (Object): zlib deflate options.
           *
           * The same as [[deflate]], but create gzip wrapper instead of
           * deflate one.
           **/
          function gzip(input, options) {
            options = options || {}
            options.gzip = true
            return deflate(input, options)
          }

          exports.Deflate = Deflate
          exports.deflate = deflate
          exports.deflateRaw = deflateRaw
          exports.gzip = gzip

          /***/
        },

      /***/ './node_modules/pako/lib/inflate.js':
        /*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          var zlib_inflate = __webpack_require__(
            /*! ./zlib/inflate */ './node_modules/pako/lib/zlib/inflate.js'
          )
          var utils = __webpack_require__(
            /*! ./utils/common */ './node_modules/pako/lib/utils/common.js'
          )
          var strings = __webpack_require__(
            /*! ./utils/strings */ './node_modules/pako/lib/utils/strings.js'
          )
          var c = __webpack_require__(
            /*! ./zlib/constants */ './node_modules/pako/lib/zlib/constants.js'
          )
          var msg = __webpack_require__(
            /*! ./zlib/messages */ './node_modules/pako/lib/zlib/messages.js'
          )
          var ZStream = __webpack_require__(
            /*! ./zlib/zstream */ './node_modules/pako/lib/zlib/zstream.js'
          )
          var GZheader = __webpack_require__(
            /*! ./zlib/gzheader */ './node_modules/pako/lib/zlib/gzheader.js'
          )

          var toString = Object.prototype.toString

          /**
           * class Inflate
           *
           * Generic JS-style wrapper for zlib calls. If you don't need
           * streaming behaviour - use more simple functions: [[inflate]]
           * and [[inflateRaw]].
           **/

          /* internal
           * inflate.chunks -> Array
           *
           * Chunks of output data, if [[Inflate#onData]] not overridden.
           **/

          /**
           * Inflate.result -> Uint8Array|Array|String
           *
           * Uncompressed result, generated by default [[Inflate#onData]]
           * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
           * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
           * push a chunk with explicit flush (call [[Inflate#push]] with
           * `Z_SYNC_FLUSH` param).
           **/

          /**
           * Inflate.err -> Number
           *
           * Error code after inflate finished. 0 (Z_OK) on success.
           * Should be checked if broken data possible.
           **/

          /**
           * Inflate.msg -> String
           *
           * Error message, if [[Inflate.err]] != 0
           **/

          /**
           * new Inflate(options)
           * - options (Object): zlib inflate options.
           *
           * Creates new inflator instance with specified params. Throws exception
           * on bad params. Supported options:
           *
           * - `windowBits`
           * - `dictionary`
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information on these.
           *
           * Additional options, for internal needs:
           *
           * - `chunkSize` - size of generated data chunks (16K by default)
           * - `raw` (Boolean) - do raw inflate
           * - `to` (String) - if equal to 'string', then result will be converted
           *   from utf8 to utf16 (javascript) string. When string output requested,
           *   chunk length can differ from `chunkSize`, depending on content.
           *
           * By default, when no options set, autodetect deflate/gzip data format via
           * wrapper header.
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
           *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
           *
           * var inflate = new pako.Inflate({ level: 3});
           *
           * inflate.push(chunk1, false);
           * inflate.push(chunk2, true);  // true -> last chunk
           *
           * if (inflate.err) { throw new Error(inflate.err); }
           *
           * console.log(inflate.result);
           * ```
           **/
          function Inflate(options) {
            if (!(this instanceof Inflate)) return new Inflate(options)

            this.options = utils.assign(
              {
                chunkSize: 16384,
                windowBits: 0,
                to: ''
              },
              options || {}
            )

            var opt = this.options

            // Force window size for `raw` data, if not set directly,
            // because we have no header for autodetect.
            if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
              opt.windowBits = -opt.windowBits
              if (opt.windowBits === 0) {
                opt.windowBits = -15
              }
            }

            // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
            if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
              opt.windowBits += 32
            }

            // Gzip header has no info about windows size, we can do autodetect only
            // for deflate. So, if window size not set, force it to max when gzip possible
            if (opt.windowBits > 15 && opt.windowBits < 48) {
              // bit 3 (16) -> gzipped data
              // bit 4 (32) -> autodetect gzip/deflate
              if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15
              }
            }

            this.err = 0 // error code, if happens (0 = Z_OK)
            this.msg = '' // error message
            this.ended = false // used to avoid multiple onEnd() calls
            this.chunks = [] // chunks of compressed data

            this.strm = new ZStream()
            this.strm.avail_out = 0

            var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits)

            if (status !== c.Z_OK) {
              throw new Error(msg[status])
            }

            this.header = new GZheader()

            zlib_inflate.inflateGetHeader(this.strm, this.header)

            // Setup dictionary
            if (opt.dictionary) {
              // Convert data if needed
              if (typeof opt.dictionary === 'string') {
                opt.dictionary = strings.string2buf(opt.dictionary)
              } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
                opt.dictionary = new Uint8Array(opt.dictionary)
              }
              if (opt.raw) {
                //In raw mode we need to set the dictionary early
                status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary)
                if (status !== c.Z_OK) {
                  throw new Error(msg[status])
                }
              }
            }
          }

          /**
           * Inflate#push(data[, mode]) -> Boolean
           * - data (Uint8Array|Array|ArrayBuffer|String): input data
           * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
           *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
           *
           * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
           * new output chunks. Returns `true` on success. The last data block must have
           * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
           * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
           * can use mode Z_SYNC_FLUSH, keeping the decompression context.
           *
           * On fail call [[Inflate#onEnd]] with error code and return false.
           *
           * We strongly recommend to use `Uint8Array` on input for best speed (output
           * format is detected automatically). Also, don't skip last param and always
           * use the same type in your code (boolean or number). That will improve JS speed.
           *
           * For regular `Array`-s make sure all elements are [0..255].
           *
           * ##### Example
           *
           * ```javascript
           * push(chunk, false); // push one of data chunks
           * ...
           * push(chunk, true);  // push last chunk
           * ```
           **/
          Inflate.prototype.push = function (data, mode) {
            var strm = this.strm
            var chunkSize = this.options.chunkSize
            var dictionary = this.options.dictionary
            var status, _mode
            var next_out_utf8, tail, utf8str

            // Flag to properly process Z_BUF_ERROR on testing inflate call
            // when we check that all output data was flushed.
            var allowBufError = false

            if (this.ended) {
              return false
            }
            _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH

            // Convert data if needed
            if (typeof data === 'string') {
              // Only binary strings can be decompressed on practice
              strm.input = strings.binstring2buf(data)
            } else if (toString.call(data) === '[object ArrayBuffer]') {
              strm.input = new Uint8Array(data)
            } else {
              strm.input = data
            }

            strm.next_in = 0
            strm.avail_in = strm.input.length

            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize)
                strm.next_out = 0
                strm.avail_out = chunkSize
              }

              status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH) /* no bad return value */

              if (status === c.Z_NEED_DICT && dictionary) {
                status = zlib_inflate.inflateSetDictionary(this.strm, dictionary)
              }

              if (status === c.Z_BUF_ERROR && allowBufError === true) {
                status = c.Z_OK
                allowBufError = false
              }

              if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                this.onEnd(status)
                this.ended = true
                return false
              }

              if (strm.next_out) {
                if (
                  strm.avail_out === 0 ||
                  status === c.Z_STREAM_END ||
                  (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))
                ) {
                  if (this.options.to === 'string') {
                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out)

                    tail = strm.next_out - next_out_utf8
                    utf8str = strings.buf2string(strm.output, next_out_utf8)

                    // move tail
                    strm.next_out = tail
                    strm.avail_out = chunkSize - tail
                    if (tail) {
                      utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0)
                    }

                    this.onData(utf8str)
                  } else {
                    this.onData(utils.shrinkBuf(strm.output, strm.next_out))
                  }
                }
              }

              // When no more input data, we should check that internal inflate buffers
              // are flushed. The only way to do it when avail_out = 0 - run one more
              // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
              // Here we set flag to process this error properly.
              //
              // NOTE. Deflate does not return error in this case and does not needs such
              // logic.
              if (strm.avail_in === 0 && strm.avail_out === 0) {
                allowBufError = true
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END)

            if (status === c.Z_STREAM_END) {
              _mode = c.Z_FINISH
            }

            // Finalize on the last chunk.
            if (_mode === c.Z_FINISH) {
              status = zlib_inflate.inflateEnd(this.strm)
              this.onEnd(status)
              this.ended = true
              return status === c.Z_OK
            }

            // callback interim results if Z_SYNC_FLUSH.
            if (_mode === c.Z_SYNC_FLUSH) {
              this.onEnd(c.Z_OK)
              strm.avail_out = 0
              return true
            }

            return true
          }

          /**
           * Inflate#onData(chunk) -> Void
           * - chunk (Uint8Array|Array|String): output data. Type of array depends
           *   on js engine support. When string output requested, each chunk
           *   will be string.
           *
           * By default, stores data blocks in `chunks[]` property and glue
           * those in `onEnd`. Override this handler, if you need another behaviour.
           **/
          Inflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk)
          }

          /**
           * Inflate#onEnd(status) -> Void
           * - status (Number): inflate status. 0 (Z_OK) on success,
           *   other if not.
           *
           * Called either after you tell inflate that the input stream is
           * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
           * or if an error happened. By default - join collected chunks,
           * free memory and fill `results` / `err` properties.
           **/
          Inflate.prototype.onEnd = function (status) {
            // On success - join
            if (status === c.Z_OK) {
              if (this.options.to === 'string') {
                // Glue & convert here, until we teach pako to send
                // utf8 aligned strings to onData
                this.result = this.chunks.join('')
              } else {
                this.result = utils.flattenChunks(this.chunks)
              }
            }
            this.chunks = []
            this.err = status
            this.msg = this.strm.msg
          }

          /**
           * inflate(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to decompress.
           * - options (Object): zlib inflate options.
           *
           * Decompress `data` with inflate/ungzip and `options`. Autodetect
           * format via wrapper header by default. That's why we don't provide
           * separate `ungzip` method.
           *
           * Supported options are:
           *
           * - windowBits
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information.
           *
           * Sugar (options):
           *
           * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
           *   negative windowBits implicitly.
           * - `to` (String) - if equal to 'string', then result will be converted
           *   from utf8 to utf16 (javascript) string. When string output requested,
           *   chunk length can differ from `chunkSize`, depending on content.
           *
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
           *   , output;
           *
           * try {
           *   output = pako.inflate(input);
           * } catch (err)
           *   console.log(err);
           * }
           * ```
           **/
          function inflate(input, options) {
            var inflator = new Inflate(options)

            inflator.push(input, true)

            // That will never happens, if you don't cheat with options :)
            if (inflator.err) {
              throw inflator.msg || msg[inflator.err]
            }

            return inflator.result
          }

          /**
           * inflateRaw(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to decompress.
           * - options (Object): zlib inflate options.
           *
           * The same as [[inflate]], but creates raw data, without wrapper
           * (header and adler32 crc).
           **/
          function inflateRaw(input, options) {
            options = options || {}
            options.raw = true
            return inflate(input, options)
          }

          /**
           * ungzip(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to decompress.
           * - options (Object): zlib inflate options.
           *
           * Just shortcut to [[inflate]], because it autodetects format
           * by header.content. Done for convenience.
           **/

          exports.Inflate = Inflate
          exports.inflate = inflate
          exports.inflateRaw = inflateRaw
          exports.ungzip = inflate

          /***/
        },

      /***/ './node_modules/pako/lib/utils/common.js':
        /*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
        /***/ (__unused_webpack_module, exports) => {
          'use strict'

          var TYPED_OK =
            typeof Uint8Array !== 'undefined' &&
            typeof Uint16Array !== 'undefined' &&
            typeof Int32Array !== 'undefined'

          function _has(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key)
          }

          exports.assign = function (obj /*from1, from2, from3, ...*/) {
            var sources = Array.prototype.slice.call(arguments, 1)
            while (sources.length) {
              var source = sources.shift()
              if (!source) {
                continue
              }

              if (typeof source !== 'object') {
                throw new TypeError(source + 'must be non-object')
              }

              for (var p in source) {
                if (_has(source, p)) {
                  obj[p] = source[p]
                }
              }
            }

            return obj
          }

          // reduce buffer size, avoiding mem copy
          exports.shrinkBuf = function (buf, size) {
            if (buf.length === size) {
              return buf
            }
            if (buf.subarray) {
              return buf.subarray(0, size)
            }
            buf.length = size
            return buf
          }

          var fnTyped = {
            arraySet: function (dest, src, src_offs, len, dest_offs) {
              if (src.subarray && dest.subarray) {
                dest.set(src.subarray(src_offs, src_offs + len), dest_offs)
                return
              }
              // Fallback to ordinary array
              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i]
              }
            },
            // Join array of chunks to single array.
            flattenChunks: function (chunks) {
              var i, l, len, pos, chunk, result

              // calculate data length
              len = 0
              for (i = 0, l = chunks.length; i < l; i++) {
                len += chunks[i].length
              }

              // join chunks
              result = new Uint8Array(len)
              pos = 0
              for (i = 0, l = chunks.length; i < l; i++) {
                chunk = chunks[i]
                result.set(chunk, pos)
                pos += chunk.length
              }

              return result
            }
          }

          var fnUntyped = {
            arraySet: function (dest, src, src_offs, len, dest_offs) {
              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i]
              }
            },
            // Join array of chunks to single array.
            flattenChunks: function (chunks) {
              return [].concat.apply([], chunks)
            }
          }

          // Enable/Disable typed arrays use, for testing
          //
          exports.setTyped = function (on) {
            if (on) {
              exports.Buf8 = Uint8Array
              exports.Buf16 = Uint16Array
              exports.Buf32 = Int32Array
              exports.assign(exports, fnTyped)
            } else {
              exports.Buf8 = Array
              exports.Buf16 = Array
              exports.Buf32 = Array
              exports.assign(exports, fnUntyped)
            }
          }

          exports.setTyped(TYPED_OK)

          /***/
        },

      /***/ './node_modules/pako/lib/utils/strings.js':
        /*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'
          // String encode/decode helpers

          var utils = __webpack_require__(/*! ./common */ './node_modules/pako/lib/utils/common.js')

          // Quick check if we can use fast array to bin string conversion
          //
          // - apply(Array) can fail on Android 2.2
          // - apply(Uint8Array) can fail on iOS 5.1 Safari
          //
          var STR_APPLY_OK = true
          var STR_APPLY_UIA_OK = true

          try {
            String.fromCharCode.apply(null, [0])
          } catch (__) {
            STR_APPLY_OK = false
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1))
          } catch (__) {
            STR_APPLY_UIA_OK = false
          }

          // Table with utf8 lengths (calculated by first byte of sequence)
          // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
          // because max possible codepoint is 0x10ffff
          var _utf8len = new utils.Buf8(256)
          for (var q = 0; q < 256; q++) {
            _utf8len[q] =
              q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1
          }
          _utf8len[254] = _utf8len[254] = 1 // Invalid sequence start

          // convert string to array (typed, when possible)
          exports.string2buf = function (str) {
            var buf,
              c,
              c2,
              m_pos,
              i,
              str_len = str.length,
              buf_len = 0

            // count binary size
            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos)
              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1)
                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)
                  m_pos++
                }
              }
              buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4
            }

            // allocate buffer
            buf = new utils.Buf8(buf_len)

            // convert
            for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos)
              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1)
                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)
                  m_pos++
                }
              }
              if (c < 0x80) {
                /* one byte */
                buf[i++] = c
              } else if (c < 0x800) {
                /* two bytes */
                buf[i++] = 0xc0 | (c >>> 6)
                buf[i++] = 0x80 | (c & 0x3f)
              } else if (c < 0x10000) {
                /* three bytes */
                buf[i++] = 0xe0 | (c >>> 12)
                buf[i++] = 0x80 | ((c >>> 6) & 0x3f)
                buf[i++] = 0x80 | (c & 0x3f)
              } else {
                /* four bytes */
                buf[i++] = 0xf0 | (c >>> 18)
                buf[i++] = 0x80 | ((c >>> 12) & 0x3f)
                buf[i++] = 0x80 | ((c >>> 6) & 0x3f)
                buf[i++] = 0x80 | (c & 0x3f)
              }
            }

            return buf
          }

          // Helper (used in 2 places)
          function buf2binstring(buf, len) {
            // On Chrome, the arguments in a function call that are allowed is `65534`.
            // If the length of the buffer is smaller than that, we can use this optimization,
            // otherwise we will take a slower path.
            if (len < 65534) {
              if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
                return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len))
              }
            }

            var result = ''
            for (var i = 0; i < len; i++) {
              result += String.fromCharCode(buf[i])
            }
            return result
          }

          // Convert byte array to binary string
          exports.buf2binstring = function (buf) {
            return buf2binstring(buf, buf.length)
          }

          // Convert binary string (typed, when possible)
          exports.binstring2buf = function (str) {
            var buf = new utils.Buf8(str.length)
            for (var i = 0, len = buf.length; i < len; i++) {
              buf[i] = str.charCodeAt(i)
            }
            return buf
          }

          // convert array to string
          exports.buf2string = function (buf, max) {
            var i, out, c, c_len
            var len = max || buf.length

            // Reserve max possible length (2 words per char)
            // NB: by unknown reasons, Array is significantly faster for
            //     String.fromCharCode.apply than Uint16Array.
            var utf16buf = new Array(len * 2)

            for (out = 0, i = 0; i < len; ) {
              c = buf[i++]
              // quick process ascii
              if (c < 0x80) {
                utf16buf[out++] = c
                continue
              }

              c_len = _utf8len[c]
              // skip 5 & 6 byte codes
              if (c_len > 4) {
                utf16buf[out++] = 0xfffd
                i += c_len - 1
                continue
              }

              // apply mask on first byte
              c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07
              // join the rest
              while (c_len > 1 && i < len) {
                c = (c << 6) | (buf[i++] & 0x3f)
                c_len--
              }

              // terminated by end of string?
              if (c_len > 1) {
                utf16buf[out++] = 0xfffd
                continue
              }

              if (c < 0x10000) {
                utf16buf[out++] = c
              } else {
                c -= 0x10000
                utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff)
                utf16buf[out++] = 0xdc00 | (c & 0x3ff)
              }
            }

            return buf2binstring(utf16buf, out)
          }

          // Calculate max possible position in utf8 buffer,
          // that will not break sequence. If that's not possible
          // - (very small limits) return max size as is.
          //
          // buf[] - utf8 bytes array
          // max   - length limit (mandatory);
          exports.utf8border = function (buf, max) {
            var pos

            max = max || buf.length
            if (max > buf.length) {
              max = buf.length
            }

            // go back from last position, until start of sequence found
            pos = max - 1
            while (pos >= 0 && (buf[pos] & 0xc0) === 0x80) {
              pos--
            }

            // Very small and broken sequence,
            // return max, because we should return something anyway.
            if (pos < 0) {
              return max
            }

            // If we came to start of buffer - that means buffer is too small,
            // return max too.
            if (pos === 0) {
              return max
            }

            return pos + _utf8len[buf[pos]] > max ? pos : max
          }

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/adler32.js':
        /*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
        /***/ (module) => {
          'use strict'

          // Note: adler32 takes 12% for level 0 and 2% for level 6.
          // It isn't worth it to make additional optimizations as in original.
          // Small size is preferable.

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          function adler32(adler, buf, len, pos) {
            var s1 = (adler & 0xffff) | 0,
              s2 = ((adler >>> 16) & 0xffff) | 0,
              n = 0

            while (len !== 0) {
              // Set limit ~ twice less than 5552, to keep
              // s2 in 31-bits, because we force signed ints.
              // in other case %= will fail.
              n = len > 2000 ? 2000 : len
              len -= n

              do {
                s1 = (s1 + buf[pos++]) | 0
                s2 = (s2 + s1) | 0
              } while (--n)

              s1 %= 65521
              s2 %= 65521
            }

            return s1 | (s2 << 16) | 0
          }

          module.exports = adler32

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/constants.js':
        /*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
        /***/ (module) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          module.exports = {
            /* Allowed flush values; see deflate() and inflate() below for details */
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,

            /* Return codes for the compression/decompression functions. Negative values
             * are errors, positive values are used for special but normal events.
             */
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            //Z_MEM_ERROR:     -4,
            Z_BUF_ERROR: -5,
            //Z_VERSION_ERROR: -6,

            /* compression levels */
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,

            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,

            /* Possible values of the data_type field (though see inflate()) */
            Z_BINARY: 0,
            Z_TEXT: 1,
            //Z_ASCII:                1, // = Z_TEXT (deprecated)
            Z_UNKNOWN: 2,

            /* The deflate compression method */
            Z_DEFLATED: 8
            //Z_NULL:                 null // Use -1 or null inline, depending on var type
          }

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/crc32.js':
        /*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
        /***/ (module) => {
          'use strict'

          // Note: we can't get significant speed boost here.
          // So write code to minimize size - no pregenerated tables
          // and array tools dependencies.

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          // Use ordinary array, since untyped makes no boost here
          function makeTable() {
            var c,
              table = []

            for (var n = 0; n < 256; n++) {
              c = n
              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1
              }
              table[n] = c
            }

            return table
          }

          // Create table on load. Just 255 signed longs. Not a problem.
          var crcTable = makeTable()

          function crc32(crc, buf, len, pos) {
            var t = crcTable,
              end = pos + len

            crc ^= -1

            for (var i = pos; i < end; i++) {
              crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff]
            }

            return crc ^ -1 // >>> 0;
          }

          module.exports = crc32

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/deflate.js':
        /*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          var utils = __webpack_require__(
            /*! ../utils/common */ './node_modules/pako/lib/utils/common.js'
          )
          var trees = __webpack_require__(/*! ./trees */ './node_modules/pako/lib/zlib/trees.js')
          var adler32 = __webpack_require__(
            /*! ./adler32 */ './node_modules/pako/lib/zlib/adler32.js'
          )
          var crc32 = __webpack_require__(/*! ./crc32 */ './node_modules/pako/lib/zlib/crc32.js')
          var msg = __webpack_require__(
            /*! ./messages */ './node_modules/pako/lib/zlib/messages.js'
          )

          /* Public constants ==========================================================*/
          /* ===========================================================================*/

          /* Allowed flush values; see deflate() and inflate() below for details */
          var Z_NO_FLUSH = 0
          var Z_PARTIAL_FLUSH = 1
          //var Z_SYNC_FLUSH    = 2;
          var Z_FULL_FLUSH = 3
          var Z_FINISH = 4
          var Z_BLOCK = 5
          //var Z_TREES         = 6;

          /* Return codes for the compression/decompression functions. Negative values
           * are errors, positive values are used for special but normal events.
           */
          var Z_OK = 0
          var Z_STREAM_END = 1
          //var Z_NEED_DICT     = 2;
          //var Z_ERRNO         = -1;
          var Z_STREAM_ERROR = -2
          var Z_DATA_ERROR = -3
          //var Z_MEM_ERROR     = -4;
          var Z_BUF_ERROR = -5
          //var Z_VERSION_ERROR = -6;

          /* compression levels */
          //var Z_NO_COMPRESSION      = 0;
          //var Z_BEST_SPEED          = 1;
          //var Z_BEST_COMPRESSION    = 9;
          var Z_DEFAULT_COMPRESSION = -1

          var Z_FILTERED = 1
          var Z_HUFFMAN_ONLY = 2
          var Z_RLE = 3
          var Z_FIXED = 4
          var Z_DEFAULT_STRATEGY = 0

          /* Possible values of the data_type field (though see inflate()) */
          //var Z_BINARY              = 0;
          //var Z_TEXT                = 1;
          //var Z_ASCII               = 1; // = Z_TEXT
          var Z_UNKNOWN = 2

          /* The deflate compression method */
          var Z_DEFLATED = 8

          /*============================================================================*/

          var MAX_MEM_LEVEL = 9
          /* Maximum value for memLevel in deflateInit2 */
          var MAX_WBITS = 15
          /* 32K LZ77 window */
          var DEF_MEM_LEVEL = 8

          var LENGTH_CODES = 29
          /* number of length codes, not counting the special END_BLOCK code */
          var LITERALS = 256
          /* number of literal bytes 0..255 */
          var L_CODES = LITERALS + 1 + LENGTH_CODES
          /* number of Literal or Length codes, including the END_BLOCK code */
          var D_CODES = 30
          /* number of distance codes */
          var BL_CODES = 19
          /* number of codes used to transfer the bit lengths */
          var HEAP_SIZE = 2 * L_CODES + 1
          /* maximum heap size */
          var MAX_BITS = 15
          /* All codes must not exceed MAX_BITS bits */

          var MIN_MATCH = 3
          var MAX_MATCH = 258
          var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1

          var PRESET_DICT = 0x20

          var INIT_STATE = 42
          var EXTRA_STATE = 69
          var NAME_STATE = 73
          var COMMENT_STATE = 91
          var HCRC_STATE = 103
          var BUSY_STATE = 113
          var FINISH_STATE = 666

          var BS_NEED_MORE = 1 /* block not completed, need more input or more output */
          var BS_BLOCK_DONE = 2 /* block flush performed */
          var BS_FINISH_STARTED = 3 /* finish started, need only more output at next deflate */
          var BS_FINISH_DONE = 4 /* finish done, accept no more input or output */

          var OS_CODE = 0x03 // Unix :) . Don't detect, use this default.

          function err(strm, errorCode) {
            strm.msg = msg[errorCode]
            return errorCode
          }

          function rank(f) {
            return (f << 1) - (f > 4 ? 9 : 0)
          }

          function zero(buf) {
            var len = buf.length
            while (--len >= 0) {
              buf[len] = 0
            }
          }

          /* =========================================================================
           * Flush as much pending output as possible. All deflate() output goes
           * through this function so some applications may wish to modify it
           * to avoid allocating a large strm->output buffer and copying into it.
           * (See also read_buf()).
           */
          function flush_pending(strm) {
            var s = strm.state

            //_tr_flush_bits(s);
            var len = s.pending
            if (len > strm.avail_out) {
              len = strm.avail_out
            }
            if (len === 0) {
              return
            }

            utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out)
            strm.next_out += len
            s.pending_out += len
            strm.total_out += len
            strm.avail_out -= len
            s.pending -= len
            if (s.pending === 0) {
              s.pending_out = 0
            }
          }

          function flush_block_only(s, last) {
            trees._tr_flush_block(
              s,
              s.block_start >= 0 ? s.block_start : -1,
              s.strstart - s.block_start,
              last
            )
            s.block_start = s.strstart
            flush_pending(s.strm)
          }

          function put_byte(s, b) {
            s.pending_buf[s.pending++] = b
          }

          /* =========================================================================
           * Put a short in the pending buffer. The 16-bit value is put in MSB order.
           * IN assertion: the stream state is correct and there is enough room in
           * pending_buf.
           */
          function putShortMSB(s, b) {
            //  put_byte(s, (Byte)(b >> 8));
            //  put_byte(s, (Byte)(b & 0xff));
            s.pending_buf[s.pending++] = (b >>> 8) & 0xff
            s.pending_buf[s.pending++] = b & 0xff
          }

          /* ===========================================================================
           * Read a new buffer from the current input stream, update the adler32
           * and total number of bytes read.  All deflate() input goes through
           * this function so some applications may wish to modify it to avoid
           * allocating a large strm->input buffer and copying from it.
           * (See also flush_pending()).
           */
          function read_buf(strm, buf, start, size) {
            var len = strm.avail_in

            if (len > size) {
              len = size
            }
            if (len === 0) {
              return 0
            }

            strm.avail_in -= len

            // zmemcpy(buf, strm->next_in, len);
            utils.arraySet(buf, strm.input, strm.next_in, len, start)
            if (strm.state.wrap === 1) {
              strm.adler = adler32(strm.adler, buf, len, start)
            } else if (strm.state.wrap === 2) {
              strm.adler = crc32(strm.adler, buf, len, start)
            }

            strm.next_in += len
            strm.total_in += len

            return len
          }

          /* ===========================================================================
           * Set match_start to the longest match starting at the given string and
           * return its length. Matches shorter or equal to prev_length are discarded,
           * in which case the result is equal to prev_length and match_start is
           * garbage.
           * IN assertions: cur_match is the head of the hash chain for the current
           *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
           * OUT assertion: the match length is not greater than s->lookahead.
           */
          function longest_match(s, cur_match) {
            var chain_length = s.max_chain_length /* max hash chain length */
            var scan = s.strstart /* current string */
            var match /* matched string */
            var len /* length of current match */
            var best_len = s.prev_length /* best match length so far */
            var nice_match = s.nice_match /* stop if match long enough */
            var limit =
              s.strstart > s.w_size - MIN_LOOKAHEAD
                ? s.strstart - (s.w_size - MIN_LOOKAHEAD)
                : 0 /*NIL*/

            var _win = s.window // shortcut

            var wmask = s.w_mask
            var prev = s.prev

            /* Stop when cur_match becomes <= limit. To simplify the code,
             * we prevent matches with the string of window index 0.
             */

            var strend = s.strstart + MAX_MATCH
            var scan_end1 = _win[scan + best_len - 1]
            var scan_end = _win[scan + best_len]

            /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
             * It is easy to get rid of this optimization if necessary.
             */
            // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

            /* Do not waste too much time if we already have a good match: */
            if (s.prev_length >= s.good_match) {
              chain_length >>= 2
            }
            /* Do not look for matches beyond the end of the input. This is necessary
             * to make deflate deterministic.
             */
            if (nice_match > s.lookahead) {
              nice_match = s.lookahead
            }

            // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

            do {
              // Assert(cur_match < s->strstart, "no future");
              match = cur_match

              /* Skip to next match if the match length cannot increase
               * or if the match length is less than 2.  Note that the checks below
               * for insufficient lookahead only occur occasionally for performance
               * reasons.  Therefore uninitialized memory will be accessed, and
               * conditional jumps will be made that depend on those values.
               * However the length of the match is limited to the lookahead, so
               * the output of deflate is not affected by the uninitialized values.
               */

              if (
                _win[match + best_len] !== scan_end ||
                _win[match + best_len - 1] !== scan_end1 ||
                _win[match] !== _win[scan] ||
                _win[++match] !== _win[scan + 1]
              ) {
                continue
              }

              /* The check at best_len-1 can be removed because it will be made
               * again later. (This heuristic is not always a win.)
               * It is not necessary to compare scan[2] and match[2] since they
               * are always equal when the other bytes match, given that
               * the hash keys are equal and that HASH_BITS >= 8.
               */
              scan += 2
              match++
              // Assert(*scan == *match, "match[2]?");

              /* We check for insufficient lookahead only every 8th comparison;
               * the 256th check will be made at strstart+258.
               */
              do {
                /*jshint noempty:false*/
              } while (
                _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] &&
                scan < strend
              )

              // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

              len = MAX_MATCH - (strend - scan)
              scan = strend - MAX_MATCH

              if (len > best_len) {
                s.match_start = cur_match
                best_len = len
                if (len >= nice_match) {
                  break
                }
                scan_end1 = _win[scan + best_len - 1]
                scan_end = _win[scan + best_len]
              }
            } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)

            if (best_len <= s.lookahead) {
              return best_len
            }
            return s.lookahead
          }

          /* ===========================================================================
           * Fill the window when the lookahead becomes insufficient.
           * Updates strstart and lookahead.
           *
           * IN assertion: lookahead < MIN_LOOKAHEAD
           * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
           *    At least one byte has been read, or avail_in == 0; reads are
           *    performed for at least two bytes (required for the zip translate_eol
           *    option -- not supported here).
           */
          function fill_window(s) {
            var _w_size = s.w_size
            var p, n, m, more, str

            //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

            do {
              more = s.window_size - s.lookahead - s.strstart

              // JS ints have 32 bit, block below not needed
              /* Deal with !@#$% 64K limit: */
              //if (sizeof(int) <= 2) {
              //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
              //        more = wsize;
              //
              //  } else if (more == (unsigned)(-1)) {
              //        /* Very unlikely, but possible on 16 bit machine if
              //         * strstart == 0 && lookahead == 1 (input done a byte at time)
              //         */
              //        more--;
              //    }
              //}

              /* If the window is almost full and there is insufficient lookahead,
               * move the upper half to the lower one to make room in the upper half.
               */
              if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                utils.arraySet(s.window, s.window, _w_size, _w_size, 0)
                s.match_start -= _w_size
                s.strstart -= _w_size
                /* we now have strstart >= MAX_DIST */
                s.block_start -= _w_size

                /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

                n = s.hash_size
                p = n
                do {
                  m = s.head[--p]
                  s.head[p] = m >= _w_size ? m - _w_size : 0
                } while (--n)

                n = _w_size
                p = n
                do {
                  m = s.prev[--p]
                  s.prev[p] = m >= _w_size ? m - _w_size : 0
                  /* If n is not on any hash chain, prev[n] is garbage but
                   * its value will never be used.
                   */
                } while (--n)

                more += _w_size
              }
              if (s.strm.avail_in === 0) {
                break
              }

              /* If there was no sliding:
               *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
               *    more == window_size - lookahead - strstart
               * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
               * => more >= window_size - 2*WSIZE + 2
               * In the BIG_MEM or MMAP case (not yet supported),
               *   window_size == input_size + MIN_LOOKAHEAD  &&
               *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
               * Otherwise, window_size == 2*WSIZE so more >= 2.
               * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
               */
              //Assert(more >= 2, "more < 2");
              n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more)
              s.lookahead += n

              /* Initialize the hash value now that we have some input: */
              if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert
                s.ins_h = s.window[str]

                /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask
                //#if MIN_MATCH != 3
                //        Call update_hash() MIN_MATCH-3 more times
                //#endif
                while (s.insert) {
                  /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                  s.ins_h =
                    ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask

                  s.prev[str & s.w_mask] = s.head[s.ins_h]
                  s.head[s.ins_h] = str
                  str++
                  s.insert--
                  if (s.lookahead + s.insert < MIN_MATCH) {
                    break
                  }
                }
              }
              /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
               * but this is not important since only literal bytes will be emitted.
               */
            } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)

            /* If the WIN_INIT bytes after the end of the current data have never been
             * written, then zero those bytes in order to avoid memory check reports of
             * the use of uninitialized (or uninitialised as Julian writes) bytes by
             * the longest match routines.  Update the high water mark for the next
             * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
             * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
             */
            //  if (s.high_water < s.window_size) {
            //    var curr = s.strstart + s.lookahead;
            //    var init = 0;
            //
            //    if (s.high_water < curr) {
            //      /* Previous high water mark below current data -- zero WIN_INIT
            //       * bytes or up to end of window, whichever is less.
            //       */
            //      init = s.window_size - curr;
            //      if (init > WIN_INIT)
            //        init = WIN_INIT;
            //      zmemzero(s->window + curr, (unsigned)init);
            //      s->high_water = curr + init;
            //    }
            //    else if (s->high_water < (ulg)curr + WIN_INIT) {
            //      /* High water mark at or above current data, but below current data
            //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
            //       * to end of window, whichever is less.
            //       */
            //      init = (ulg)curr + WIN_INIT - s->high_water;
            //      if (init > s->window_size - s->high_water)
            //        init = s->window_size - s->high_water;
            //      zmemzero(s->window + s->high_water, (unsigned)init);
            //      s->high_water += init;
            //    }
            //  }
            //
            //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
            //    "not enough room for search");
          }

          /* ===========================================================================
           * Copy without compression as much as possible from the input stream, return
           * the current block state.
           * This function does not insert new strings in the dictionary since
           * uncompressible data is probably not useful. This function is used
           * only for the level=0 compression option.
           * NOTE: this function should be optimized to avoid extra copying from
           * window to pending_buf.
           */
          function deflate_stored(s, flush) {
            /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
             * to pending_buf_size, and each stored block has a 5 byte header:
             */
            var max_block_size = 0xffff

            if (max_block_size > s.pending_buf_size - 5) {
              max_block_size = s.pending_buf_size - 5
            }

            /* Copy as much as possible from input to output: */
            for (;;) {
              /* Fill the window as much as possible: */
              if (s.lookahead <= 1) {
                //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                //  s->block_start >= (long)s->w_size, "slide too late");
                //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
                //        s.block_start >= s.w_size)) {
                //        throw  new Error("slide too late");
                //      }

                fill_window(s)
                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE
                }

                if (s.lookahead === 0) {
                  break
                }
                /* flush the current block */
              }
              //Assert(s->block_start >= 0L, "block gone");
              //    if (s.block_start < 0) throw new Error("block gone");

              s.strstart += s.lookahead
              s.lookahead = 0

              /* Emit a stored block if pending_buf will be full: */
              var max_start = s.block_start + max_block_size

              if (s.strstart === 0 || s.strstart >= max_start) {
                /* strstart == 0 is possible when wraparound on 16-bit machine */
                s.lookahead = s.strstart - max_start
                s.strstart = max_start
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false)
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE
                }
                /***/
              }
              /* Flush if we may have to slide, otherwise block_start may become
               * negative and the data will be gone:
               */
              if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false)
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE
                }
                /***/
              }
            }

            s.insert = 0

            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true)
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED
              }
              /***/
              return BS_FINISH_DONE
            }

            if (s.strstart > s.block_start) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false)
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
              /***/
            }

            return BS_NEED_MORE
          }

          /* ===========================================================================
           * Compress as much as possible from the input stream, return the current
           * block state.
           * This function does not perform lazy evaluation of matches and inserts
           * new strings in the dictionary only for unmatched strings or for short
           * matches. It is used only for the fast compression options.
           */
          function deflate_fast(s, flush) {
            var hash_head /* head of the hash chain */
            var bflush /* set if current block must be flushed */

            for (;;) {
              /* Make sure that we always have enough lookahead, except
               * at the end of the input file. We need MAX_MATCH bytes
               * for the next match, plus MIN_MATCH bytes to insert the
               * string following the next match.
               */
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s)
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE
                }
                if (s.lookahead === 0) {
                  break /* flush the current block */
                }
              }

              /* Insert the string window[strstart .. strstart+2] in the
               * dictionary, and set hash_head to the head of the hash chain:
               */
              hash_head = 0 /*NIL*/
              if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h =
                  ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
                s.head[s.ins_h] = s.strstart
                /***/
              }

              /* Find the longest match, discarding those <= prev_length.
               * At this point we have always match_length < MIN_MATCH
               */
              if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                /* To simplify the code, we prevent matches with the string
                 * of window index 0 (in particular we have to avoid a match
                 * of the string with itself at the start of the input file).
                 */
                s.match_length = longest_match(s, hash_head)
                /* longest_match() sets match_start */
              }
              if (s.match_length >= MIN_MATCH) {
                // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

                /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH)

                s.lookahead -= s.match_length

                /* Insert new strings in the hash table only if the match length
                 * is not too large. This saves time but degrades compression.
                 */
                if (
                  s.match_length <= s.max_lazy_match /*max_insert_length*/ &&
                  s.lookahead >= MIN_MATCH
                ) {
                  s.match_length-- /* string at strstart already in table */
                  do {
                    s.strstart++
                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                    s.ins_h =
                      ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &
                      s.hash_mask
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
                    s.head[s.ins_h] = s.strstart
                    /***/
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                  } while (--s.match_length !== 0)
                  s.strstart++
                } else {
                  s.strstart += s.match_length
                  s.match_length = 0
                  s.ins_h = s.window[s.strstart]
                  /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
                  s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask

                  //#if MIN_MATCH != 3
                  //                Call UPDATE_HASH() MIN_MATCH-3 more times
                  //#endif
                  /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                   * matter since it will be recomputed at next deflate call.
                   */
                }
              } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s.window[s.strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart])

                s.lookahead--
                s.strstart++
              }
              if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false)
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE
                }
                /***/
              }
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1
            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true)
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED
              }
              /***/
              return BS_FINISH_DONE
            }
            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false)
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
              /***/
            }
            return BS_BLOCK_DONE
          }

          /* ===========================================================================
           * Same as above, but achieves better compression. We use a lazy
           * evaluation for matches: a match is finally adopted only if there is
           * no better match at the next window position.
           */
          function deflate_slow(s, flush) {
            var hash_head /* head of hash chain */
            var bflush /* set if current block must be flushed */

            var max_insert

            /* Process the input block. */
            for (;;) {
              /* Make sure that we always have enough lookahead, except
               * at the end of the input file. We need MAX_MATCH bytes
               * for the next match, plus MIN_MATCH bytes to insert the
               * string following the next match.
               */
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s)
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE
                }
                if (s.lookahead === 0) {
                  break
                } /* flush the current block */
              }

              /* Insert the string window[strstart .. strstart+2] in the
               * dictionary, and set hash_head to the head of the hash chain:
               */
              hash_head = 0 /*NIL*/
              if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h =
                  ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
                s.head[s.ins_h] = s.strstart
                /***/
              }

              /* Find the longest match, discarding those <= prev_length.
               */
              s.prev_length = s.match_length
              s.prev_match = s.match_start
              s.match_length = MIN_MATCH - 1

              if (
                hash_head !== 0 /*NIL*/ &&
                s.prev_length < s.max_lazy_match &&
                s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/
              ) {
                /* To simplify the code, we prevent matches with the string
                 * of window index 0 (in particular we have to avoid a match
                 * of the string with itself at the start of the input file).
                 */
                s.match_length = longest_match(s, hash_head)
                /* longest_match() sets match_start */

                if (
                  s.match_length <= 5 &&
                  (s.strategy === Z_FILTERED ||
                    (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) /*TOO_FAR*/
                ) {
                  /* If prev_match is also MIN_MATCH, match_start is garbage
                   * but we will ignore the current match anyway.
                   */
                  s.match_length = MIN_MATCH - 1
                }
              }
              /* If there was a match at the previous step and the current
               * match is not better, output the previous match:
               */
              if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH
                /* Do not insert strings in hash table beyond this. */

                //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

                /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
                bflush = trees._tr_tally(
                  s,
                  s.strstart - 1 - s.prev_match,
                  s.prev_length - MIN_MATCH
                )
                /* Insert in hash table all strings up to the end of the match.
                 * strstart-1 and strstart are already inserted. If there is not
                 * enough lookahead, the last two strings are not inserted in
                 * the hash table.
                 */
                s.lookahead -= s.prev_length - 1
                s.prev_length -= 2
                do {
                  if (++s.strstart <= max_insert) {
                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                    s.ins_h =
                      ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &
                      s.hash_mask
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
                    s.head[s.ins_h] = s.strstart
                    /***/
                  }
                } while (--s.prev_length !== 0)
                s.match_available = 0
                s.match_length = MIN_MATCH - 1
                s.strstart++

                if (bflush) {
                  /*** FLUSH_BLOCK(s, 0); ***/
                  flush_block_only(s, false)
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE
                  }
                  /***/
                }
              } else if (s.match_available) {
                /* If there was no match at the previous position, output a
                 * single literal. If there was a match but the current match
                 * is longer, truncate the previous match to a single literal.
                 */
                //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])

                if (bflush) {
                  /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                  flush_block_only(s, false)
                  /***/
                }
                s.strstart++
                s.lookahead--
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE
                }
              } else {
                /* There is no previous match to compare with, wait for
                 * the next step to decide.
                 */
                s.match_available = 1
                s.strstart++
                s.lookahead--
              }
            }
            //Assert (flush != Z_NO_FLUSH, "no flush?");
            if (s.match_available) {
              //Tracevv((stderr,"%c", s->window[s->strstart-1]));
              /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])

              s.match_available = 0
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1
            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true)
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED
              }
              /***/
              return BS_FINISH_DONE
            }
            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false)
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
              /***/
            }

            return BS_BLOCK_DONE
          }

          /* ===========================================================================
           * For Z_RLE, simply look for runs of bytes, generate matches only of distance
           * one.  Do not maintain a hash table.  (It will be regenerated if this run of
           * deflate switches away from Z_RLE.)
           */
          function deflate_rle(s, flush) {
            var bflush /* set if current block must be flushed */
            var prev /* byte at distance one to match */
            var scan, strend /* scan goes up to strend for length of run */

            var _win = s.window

            for (;;) {
              /* Make sure that we always have enough lookahead, except
               * at the end of the input file. We need MAX_MATCH bytes
               * for the longest run, plus one for the unrolled loop.
               */
              if (s.lookahead <= MAX_MATCH) {
                fill_window(s)
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE
                }
                if (s.lookahead === 0) {
                  break
                } /* flush the current block */
              }

              /* See how many times the previous byte repeats */
              s.match_length = 0
              if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1
                prev = _win[scan]
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                  strend = s.strstart + MAX_MATCH
                  do {
                    /*jshint noempty:false*/
                  } while (
                    prev === _win[++scan] &&
                    prev === _win[++scan] &&
                    prev === _win[++scan] &&
                    prev === _win[++scan] &&
                    prev === _win[++scan] &&
                    prev === _win[++scan] &&
                    prev === _win[++scan] &&
                    prev === _win[++scan] &&
                    scan < strend
                  )
                  s.match_length = MAX_MATCH - (strend - scan)
                  if (s.match_length > s.lookahead) {
                    s.match_length = s.lookahead
                  }
                }
                //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
              }

              /* Emit match if have run of MIN_MATCH or longer, else emit literal */
              if (s.match_length >= MIN_MATCH) {
                //check_match(s, s.strstart, s.strstart - 1, s.match_length);

                /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH)

                s.lookahead -= s.match_length
                s.strstart += s.match_length
                s.match_length = 0
              } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s->window[s->strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart])

                s.lookahead--
                s.strstart++
              }
              if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false)
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE
                }
                /***/
              }
            }
            s.insert = 0
            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true)
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED
              }
              /***/
              return BS_FINISH_DONE
            }
            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false)
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
              /***/
            }
            return BS_BLOCK_DONE
          }

          /* ===========================================================================
           * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
           * (It will be regenerated if this run of deflate switches away from Huffman.)
           */
          function deflate_huff(s, flush) {
            var bflush /* set if current block must be flushed */

            for (;;) {
              /* Make sure that we have a literal to write. */
              if (s.lookahead === 0) {
                fill_window(s)
                if (s.lookahead === 0) {
                  if (flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE
                  }
                  break /* flush the current block */
                }
              }

              /* Output a literal byte */
              s.match_length = 0
              //Tracevv((stderr,"%c", s->window[s->strstart]));
              /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
              bflush = trees._tr_tally(s, 0, s.window[s.strstart])
              s.lookahead--
              s.strstart++
              if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false)
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE
                }
                /***/
              }
            }
            s.insert = 0
            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true)
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED
              }
              /***/
              return BS_FINISH_DONE
            }
            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false)
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
              /***/
            }
            return BS_BLOCK_DONE
          }

          /* Values for max_lazy_match, good_match and max_chain_length, depending on
           * the desired pack level (0..9). The values given below have been tuned to
           * exclude worst case performance for pathological files. Better values may be
           * found for specific files.
           */
          function Config(good_length, max_lazy, nice_length, max_chain, func) {
            this.good_length = good_length
            this.max_lazy = max_lazy
            this.nice_length = nice_length
            this.max_chain = max_chain
            this.func = func
          }

          var configuration_table

          configuration_table = [
            /*      good lazy nice chain */
            new Config(0, 0, 0, 0, deflate_stored) /* 0 store only */,
            new Config(4, 4, 8, 4, deflate_fast) /* 1 max speed, no lazy matches */,
            new Config(4, 5, 16, 8, deflate_fast) /* 2 */,
            new Config(4, 6, 32, 32, deflate_fast) /* 3 */,

            new Config(4, 4, 16, 16, deflate_slow) /* 4 lazy matches */,
            new Config(8, 16, 32, 32, deflate_slow) /* 5 */,
            new Config(8, 16, 128, 128, deflate_slow) /* 6 */,
            new Config(8, 32, 128, 256, deflate_slow) /* 7 */,
            new Config(32, 128, 258, 1024, deflate_slow) /* 8 */,
            new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
          ]

          /* ===========================================================================
           * Initialize the "longest match" routines for a new zlib stream
           */
          function lm_init(s) {
            s.window_size = 2 * s.w_size

            /*** CLEAR_HASH(s); ***/
            zero(s.head) // Fill with NIL (= 0);

            /* Set the default configuration parameters:
             */
            s.max_lazy_match = configuration_table[s.level].max_lazy
            s.good_match = configuration_table[s.level].good_length
            s.nice_match = configuration_table[s.level].nice_length
            s.max_chain_length = configuration_table[s.level].max_chain

            s.strstart = 0
            s.block_start = 0
            s.lookahead = 0
            s.insert = 0
            s.match_length = s.prev_length = MIN_MATCH - 1
            s.match_available = 0
            s.ins_h = 0
          }

          function DeflateState() {
            this.strm = null /* pointer back to this zlib stream */
            this.status = 0 /* as the name implies */
            this.pending_buf = null /* output still pending */
            this.pending_buf_size = 0 /* size of pending_buf */
            this.pending_out = 0 /* next pending byte to output to the stream */
            this.pending = 0 /* nb of bytes in the pending buffer */
            this.wrap = 0 /* bit 0 true for zlib, bit 1 true for gzip */
            this.gzhead = null /* gzip header information to write */
            this.gzindex = 0 /* where in extra, name, or comment */
            this.method = Z_DEFLATED /* can only be DEFLATED */
            this.last_flush = -1 /* value of flush param for previous deflate call */

            this.w_size = 0 /* LZ77 window size (32K by default) */
            this.w_bits = 0 /* log2(w_size)  (8..16) */
            this.w_mask = 0 /* w_size - 1 */

            this.window = null
            /* Sliding window. Input bytes are read into the second half of the window,
             * and move to the first half later to keep a dictionary of at least wSize
             * bytes. With this organization, matches are limited to a distance of
             * wSize-MAX_MATCH bytes, but this ensures that IO is always
             * performed with a length multiple of the block size.
             */

            this.window_size = 0
            /* Actual size of window: 2*wSize, except when the user input buffer
             * is directly used as sliding window.
             */

            this.prev = null
            /* Link to older string with same hash index. To limit the size of this
             * array to 64K, this link is maintained only for the last 32K strings.
             * An index in this array is thus a window index modulo 32K.
             */

            this.head = null /* Heads of the hash chains or NIL. */

            this.ins_h = 0 /* hash index of string to be inserted */
            this.hash_size = 0 /* number of elements in hash table */
            this.hash_bits = 0 /* log2(hash_size) */
            this.hash_mask = 0 /* hash_size-1 */

            this.hash_shift = 0
            /* Number of bits by which ins_h must be shifted at each input
             * step. It must be such that after MIN_MATCH steps, the oldest
             * byte no longer takes part in the hash key, that is:
             *   hash_shift * MIN_MATCH >= hash_bits
             */

            this.block_start = 0
            /* Window position at the beginning of the current output block. Gets
             * negative when the window is moved backwards.
             */

            this.match_length = 0 /* length of best match */
            this.prev_match = 0 /* previous match */
            this.match_available = 0 /* set if previous match exists */
            this.strstart = 0 /* start of string to insert */
            this.match_start = 0 /* start of matching string */
            this.lookahead = 0 /* number of valid bytes ahead in window */

            this.prev_length = 0
            /* Length of the best match at previous step. Matches not greater than this
             * are discarded. This is used in the lazy match evaluation.
             */

            this.max_chain_length = 0
            /* To speed up deflation, hash chains are never searched beyond this
             * length.  A higher limit improves compression ratio but degrades the
             * speed.
             */

            this.max_lazy_match = 0
            /* Attempt to find a better match only when the current match is strictly
             * smaller than this value. This mechanism is used only for compression
             * levels >= 4.
             */
            // That's alias to max_lazy_match, don't use directly
            //this.max_insert_length = 0;
            /* Insert new strings in the hash table only if the match length is not
             * greater than this length. This saves time but degrades compression.
             * max_insert_length is used only for compression levels <= 3.
             */

            this.level = 0 /* compression level (1..9) */
            this.strategy = 0 /* favor or force Huffman coding*/

            this.good_match = 0
            /* Use a faster search when the previous match is longer than this */

            this.nice_match = 0 /* Stop searching when current match exceeds this */

            /* used by trees.c: */

            /* Didn't use ct_data typedef below to suppress compiler warning */

            // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
            // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
            // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

            // Use flat array of DOUBLE size, with interleaved fata,
            // because JS does not support effective
            this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2)
            this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2)
            this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2)
            zero(this.dyn_ltree)
            zero(this.dyn_dtree)
            zero(this.bl_tree)

            this.l_desc = null /* desc. for literal tree */
            this.d_desc = null /* desc. for distance tree */
            this.bl_desc = null /* desc. for bit length tree */

            //ush bl_count[MAX_BITS+1];
            this.bl_count = new utils.Buf16(MAX_BITS + 1)
            /* number of codes at each bit length for an optimal tree */

            //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
            this.heap = new utils.Buf16(2 * L_CODES + 1) /* heap used to build the Huffman trees */
            zero(this.heap)

            this.heap_len = 0 /* number of elements in the heap */
            this.heap_max = 0 /* element of largest frequency */
            /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
             * The same heap array is used to build all trees.
             */

            this.depth = new utils.Buf16(2 * L_CODES + 1) //uch depth[2*L_CODES+1];
            zero(this.depth)
            /* Depth of each subtree used as tie breaker for trees of equal frequency
             */

            this.l_buf = 0 /* buffer index for literals or lengths */

            this.lit_bufsize = 0
            /* Size of match buffer for literals/lengths.  There are 4 reasons for
             * limiting lit_bufsize to 64K:
             *   - frequencies can be kept in 16 bit counters
             *   - if compression is not successful for the first block, all input
             *     data is still in the window so we can still emit a stored block even
             *     when input comes from standard input.  (This can also be done for
             *     all blocks if lit_bufsize is not greater than 32K.)
             *   - if compression is not successful for a file smaller than 64K, we can
             *     even emit a stored file instead of a stored block (saving 5 bytes).
             *     This is applicable only for zip (not gzip or zlib).
             *   - creating new Huffman trees less frequently may not provide fast
             *     adaptation to changes in the input data statistics. (Take for
             *     example a binary file with poorly compressible code followed by
             *     a highly compressible string table.) Smaller buffer sizes give
             *     fast adaptation but have of course the overhead of transmitting
             *     trees more frequently.
             *   - I can't count above 4
             */

            this.last_lit = 0 /* running index in l_buf */

            this.d_buf = 0
            /* Buffer index for distances. To simplify the code, d_buf and l_buf have
             * the same number of elements. To use different lengths, an extra flag
             * array would be necessary.
             */

            this.opt_len = 0 /* bit length of current block with optimal trees */
            this.static_len = 0 /* bit length of current block with static trees */
            this.matches = 0 /* number of string matches in current block */
            this.insert = 0 /* bytes at end of window left to insert */

            this.bi_buf = 0
            /* Output buffer. bits are inserted starting at the bottom (least
             * significant bits).
             */
            this.bi_valid = 0
            /* Number of valid bits in bi_buf.  All bits above the last valid bit
             * are always zero.
             */

            // Used for window memory init. We safely ignore it for JS. That makes
            // sense only for pointers and memory check tools.
            //this.high_water = 0;
            /* High water mark offset in window for initialized bytes -- bytes above
             * this are set to zero in order to avoid memory check warnings when
             * longest match routines access bytes past the input.  This is then
             * updated to the new high water mark.
             */
          }

          function deflateResetKeep(strm) {
            var s

            if (!strm || !strm.state) {
              return err(strm, Z_STREAM_ERROR)
            }

            strm.total_in = strm.total_out = 0
            strm.data_type = Z_UNKNOWN

            s = strm.state
            s.pending = 0
            s.pending_out = 0

            if (s.wrap < 0) {
              s.wrap = -s.wrap
              /* was made negative by deflate(..., Z_FINISH); */
            }
            s.status = s.wrap ? INIT_STATE : BUSY_STATE
            strm.adler =
              s.wrap === 2
                ? 0 // crc32(0, Z_NULL, 0)
                : 1 // adler32(0, Z_NULL, 0)
            s.last_flush = Z_NO_FLUSH
            trees._tr_init(s)
            return Z_OK
          }

          function deflateReset(strm) {
            var ret = deflateResetKeep(strm)
            if (ret === Z_OK) {
              lm_init(strm.state)
            }
            return ret
          }

          function deflateSetHeader(strm, head) {
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR
            }
            if (strm.state.wrap !== 2) {
              return Z_STREAM_ERROR
            }
            strm.state.gzhead = head
            return Z_OK
          }

          function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
            if (!strm) {
              // === Z_NULL
              return Z_STREAM_ERROR
            }
            var wrap = 1

            if (level === Z_DEFAULT_COMPRESSION) {
              level = 6
            }

            if (windowBits < 0) {
              /* suppress zlib wrapper */
              wrap = 0
              windowBits = -windowBits
            } else if (windowBits > 15) {
              wrap = 2 /* write gzip wrapper instead */
              windowBits -= 16
            }

            if (
              memLevel < 1 ||
              memLevel > MAX_MEM_LEVEL ||
              method !== Z_DEFLATED ||
              windowBits < 8 ||
              windowBits > 15 ||
              level < 0 ||
              level > 9 ||
              strategy < 0 ||
              strategy > Z_FIXED
            ) {
              return err(strm, Z_STREAM_ERROR)
            }

            if (windowBits === 8) {
              windowBits = 9
            }
            /* until 256-byte window bug fixed */

            var s = new DeflateState()

            strm.state = s
            s.strm = strm

            s.wrap = wrap
            s.gzhead = null
            s.w_bits = windowBits
            s.w_size = 1 << s.w_bits
            s.w_mask = s.w_size - 1

            s.hash_bits = memLevel + 7
            s.hash_size = 1 << s.hash_bits
            s.hash_mask = s.hash_size - 1
            s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH)

            s.window = new utils.Buf8(s.w_size * 2)
            s.head = new utils.Buf16(s.hash_size)
            s.prev = new utils.Buf16(s.w_size)

            // Don't need mem init magic for JS.
            //s.high_water = 0;  /* nothing written to s->window yet */

            s.lit_bufsize = 1 << (memLevel + 6) /* 16K elements by default */

            s.pending_buf_size = s.lit_bufsize * 4

            //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
            //s->pending_buf = (uchf *) overlay;
            s.pending_buf = new utils.Buf8(s.pending_buf_size)

            // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
            //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
            s.d_buf = 1 * s.lit_bufsize

            //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
            s.l_buf = (1 + 2) * s.lit_bufsize

            s.level = level
            s.strategy = strategy
            s.method = method

            return deflateReset(strm)
          }

          function deflateInit(strm, level) {
            return deflateInit2(
              strm,
              level,
              Z_DEFLATED,
              MAX_WBITS,
              DEF_MEM_LEVEL,
              Z_DEFAULT_STRATEGY
            )
          }

          function deflate(strm, flush) {
            var old_flush, s
            var beg, val // for gzip header write only

            if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
              return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR
            }

            s = strm.state

            if (
              !strm.output ||
              (!strm.input && strm.avail_in !== 0) ||
              (s.status === FINISH_STATE && flush !== Z_FINISH)
            ) {
              return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)
            }

            s.strm = strm /* just in case */
            old_flush = s.last_flush
            s.last_flush = flush

            /* Write the header */
            if (s.status === INIT_STATE) {
              if (s.wrap === 2) {
                // GZIP header
                strm.adler = 0 //crc32(0L, Z_NULL, 0);
                put_byte(s, 31)
                put_byte(s, 139)
                put_byte(s, 8)
                if (!s.gzhead) {
                  // s->gzhead == Z_NULL
                  put_byte(s, 0)
                  put_byte(s, 0)
                  put_byte(s, 0)
                  put_byte(s, 0)
                  put_byte(s, 0)
                  put_byte(
                    s,
                    s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0
                  )
                  put_byte(s, OS_CODE)
                  s.status = BUSY_STATE
                } else {
                  put_byte(
                    s,
                    (s.gzhead.text ? 1 : 0) +
                      (s.gzhead.hcrc ? 2 : 0) +
                      (!s.gzhead.extra ? 0 : 4) +
                      (!s.gzhead.name ? 0 : 8) +
                      (!s.gzhead.comment ? 0 : 16)
                  )
                  put_byte(s, s.gzhead.time & 0xff)
                  put_byte(s, (s.gzhead.time >> 8) & 0xff)
                  put_byte(s, (s.gzhead.time >> 16) & 0xff)
                  put_byte(s, (s.gzhead.time >> 24) & 0xff)
                  put_byte(
                    s,
                    s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0
                  )
                  put_byte(s, s.gzhead.os & 0xff)
                  if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 0xff)
                    put_byte(s, (s.gzhead.extra.length >> 8) & 0xff)
                  }
                  if (s.gzhead.hcrc) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)
                  }
                  s.gzindex = 0
                  s.status = EXTRA_STATE
                }
              } // DEFLATE header
              else {
                var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8
                var level_flags = -1

                if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                  level_flags = 0
                } else if (s.level < 6) {
                  level_flags = 1
                } else if (s.level === 6) {
                  level_flags = 2
                } else {
                  level_flags = 3
                }
                header |= level_flags << 6
                if (s.strstart !== 0) {
                  header |= PRESET_DICT
                }
                header += 31 - (header % 31)

                s.status = BUSY_STATE
                putShortMSB(s, header)

                /* Save the adler32 of the preset dictionary: */
                if (s.strstart !== 0) {
                  putShortMSB(s, strm.adler >>> 16)
                  putShortMSB(s, strm.adler & 0xffff)
                }
                strm.adler = 1 // adler32(0L, Z_NULL, 0);
              }
            }

            //#ifdef GZIP
            if (s.status === EXTRA_STATE) {
              if (s.gzhead.extra /* != Z_NULL*/) {
                beg = s.pending /* start of bytes to update crc */

                while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                    }
                    flush_pending(strm)
                    beg = s.pending
                    if (s.pending === s.pending_buf_size) {
                      break
                    }
                  }
                  put_byte(s, s.gzhead.extra[s.gzindex] & 0xff)
                  s.gzindex++
                }
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                if (s.gzindex === s.gzhead.extra.length) {
                  s.gzindex = 0
                  s.status = NAME_STATE
                }
              } else {
                s.status = NAME_STATE
              }
            }
            if (s.status === NAME_STATE) {
              if (s.gzhead.name /* != Z_NULL*/) {
                beg = s.pending /* start of bytes to update crc */
                //int val;

                do {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                    }
                    flush_pending(strm)
                    beg = s.pending
                    if (s.pending === s.pending_buf_size) {
                      val = 1
                      break
                    }
                  }
                  // JS specific: little magic to add zero terminator to end of string
                  if (s.gzindex < s.gzhead.name.length) {
                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff
                  } else {
                    val = 0
                  }
                  put_byte(s, val)
                } while (val !== 0)

                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                if (val === 0) {
                  s.gzindex = 0
                  s.status = COMMENT_STATE
                }
              } else {
                s.status = COMMENT_STATE
              }
            }
            if (s.status === COMMENT_STATE) {
              if (s.gzhead.comment /* != Z_NULL*/) {
                beg = s.pending /* start of bytes to update crc */
                //int val;

                do {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                    }
                    flush_pending(strm)
                    beg = s.pending
                    if (s.pending === s.pending_buf_size) {
                      val = 1
                      break
                    }
                  }
                  // JS specific: little magic to add zero terminator to end of string
                  if (s.gzindex < s.gzhead.comment.length) {
                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff
                  } else {
                    val = 0
                  }
                  put_byte(s, val)
                } while (val !== 0)

                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                if (val === 0) {
                  s.status = HCRC_STATE
                }
              } else {
                s.status = HCRC_STATE
              }
            }
            if (s.status === HCRC_STATE) {
              if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                  flush_pending(strm)
                }
                if (s.pending + 2 <= s.pending_buf_size) {
                  put_byte(s, strm.adler & 0xff)
                  put_byte(s, (strm.adler >> 8) & 0xff)
                  strm.adler = 0 //crc32(0L, Z_NULL, 0);
                  s.status = BUSY_STATE
                }
              } else {
                s.status = BUSY_STATE
              }
            }
            //#endif

            /* Flush as much pending output as possible */
            if (s.pending !== 0) {
              flush_pending(strm)
              if (strm.avail_out === 0) {
                /* Since avail_out is 0, deflate will be called again with
                 * more output space, but possibly with both pending and
                 * avail_in equal to zero. There won't be anything to do,
                 * but this is not an error situation so make sure we
                 * return OK instead of BUF_ERROR at next call of deflate:
                 */
                s.last_flush = -1
                return Z_OK
              }

              /* Make sure there is something to do and avoid duplicate consecutive
               * flushes. For repeated and useless calls with Z_FINISH, we keep
               * returning Z_STREAM_END instead of Z_BUF_ERROR.
               */
            } else if (
              strm.avail_in === 0 &&
              rank(flush) <= rank(old_flush) &&
              flush !== Z_FINISH
            ) {
              return err(strm, Z_BUF_ERROR)
            }

            /* User must not provide more input after the first FINISH: */
            if (s.status === FINISH_STATE && strm.avail_in !== 0) {
              return err(strm, Z_BUF_ERROR)
            }

            /* Start a new block or continue the current one.
             */
            if (
              strm.avail_in !== 0 ||
              s.lookahead !== 0 ||
              (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)
            ) {
              var bstate =
                s.strategy === Z_HUFFMAN_ONLY
                  ? deflate_huff(s, flush)
                  : s.strategy === Z_RLE
                  ? deflate_rle(s, flush)
                  : configuration_table[s.level].func(s, flush)

              if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE
              }
              if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                  s.last_flush = -1
                  /* avoid BUF_ERROR next call, see above */
                }
                return Z_OK
                /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                 * of deflate should use the same flush parameter to make sure
                 * that the flush is complete. So we don't have to output an
                 * empty block here, this will be done at next call. This also
                 * ensures that for a very small output buffer, we emit at most
                 * one empty block.
                 */
              }
              if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                  trees._tr_align(s)
                } else if (flush !== Z_BLOCK) {
                  /* FULL_FLUSH or SYNC_FLUSH */

                  trees._tr_stored_block(s, 0, 0, false)
                  /* For a full flush, this empty block will be recognized
                   * as a special marker by inflate_sync().
                   */
                  if (flush === Z_FULL_FLUSH) {
                    /*** CLEAR_HASH(s); ***/ /* forget history */
                    zero(s.head) // Fill with NIL (= 0);

                    if (s.lookahead === 0) {
                      s.strstart = 0
                      s.block_start = 0
                      s.insert = 0
                    }
                  }
                }
                flush_pending(strm)
                if (strm.avail_out === 0) {
                  s.last_flush = -1 /* avoid BUF_ERROR at next call, see above */
                  return Z_OK
                }
              }
            }
            //Assert(strm->avail_out > 0, "bug2");
            //if (strm.avail_out <= 0) { throw new Error("bug2");}

            if (flush !== Z_FINISH) {
              return Z_OK
            }
            if (s.wrap <= 0) {
              return Z_STREAM_END
            }

            /* Write the trailer */
            if (s.wrap === 2) {
              put_byte(s, strm.adler & 0xff)
              put_byte(s, (strm.adler >> 8) & 0xff)
              put_byte(s, (strm.adler >> 16) & 0xff)
              put_byte(s, (strm.adler >> 24) & 0xff)
              put_byte(s, strm.total_in & 0xff)
              put_byte(s, (strm.total_in >> 8) & 0xff)
              put_byte(s, (strm.total_in >> 16) & 0xff)
              put_byte(s, (strm.total_in >> 24) & 0xff)
            } else {
              putShortMSB(s, strm.adler >>> 16)
              putShortMSB(s, strm.adler & 0xffff)
            }

            flush_pending(strm)
            /* If avail_out is zero, the application will call deflate again
             * to flush the rest.
             */
            if (s.wrap > 0) {
              s.wrap = -s.wrap
            }
            /* write the trailer only once! */
            return s.pending !== 0 ? Z_OK : Z_STREAM_END
          }

          function deflateEnd(strm) {
            var status

            if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
              return Z_STREAM_ERROR
            }

            status = strm.state.status
            if (
              status !== INIT_STATE &&
              status !== EXTRA_STATE &&
              status !== NAME_STATE &&
              status !== COMMENT_STATE &&
              status !== HCRC_STATE &&
              status !== BUSY_STATE &&
              status !== FINISH_STATE
            ) {
              return err(strm, Z_STREAM_ERROR)
            }

            strm.state = null

            return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK
          }

          /* =========================================================================
           * Initializes the compression dictionary from the given byte
           * sequence without producing any compressed output.
           */
          function deflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length

            var s
            var str, n
            var wrap
            var avail
            var next
            var input
            var tmpDict

            if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
              return Z_STREAM_ERROR
            }

            s = strm.state
            wrap = s.wrap

            if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
              return Z_STREAM_ERROR
            }

            /* when using zlib wrappers, compute Adler-32 for provided dictionary */
            if (wrap === 1) {
              /* adler32(strm->adler, dictionary, dictLength); */
              strm.adler = adler32(strm.adler, dictionary, dictLength, 0)
            }

            s.wrap = 0 /* avoid computing Adler-32 in read_buf */

            /* if dictionary would fill window, just replace the history */
            if (dictLength >= s.w_size) {
              if (wrap === 0) {
                /* already empty otherwise */
                /*** CLEAR_HASH(s); ***/
                zero(s.head) // Fill with NIL (= 0);
                s.strstart = 0
                s.block_start = 0
                s.insert = 0
              }
              /* use the tail */
              // dictionary = dictionary.slice(dictLength - s.w_size);
              tmpDict = new utils.Buf8(s.w_size)
              utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0)
              dictionary = tmpDict
              dictLength = s.w_size
            }
            /* insert dictionary into window and hash */
            avail = strm.avail_in
            next = strm.next_in
            input = strm.input
            strm.avail_in = dictLength
            strm.next_in = 0
            strm.input = dictionary
            fill_window(s)
            while (s.lookahead >= MIN_MATCH) {
              str = s.strstart
              n = s.lookahead - (MIN_MATCH - 1)
              do {
                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask

                s.prev[str & s.w_mask] = s.head[s.ins_h]

                s.head[s.ins_h] = str
                str++
              } while (--n)
              s.strstart = str
              s.lookahead = MIN_MATCH - 1
              fill_window(s)
            }
            s.strstart += s.lookahead
            s.block_start = s.strstart
            s.insert = s.lookahead
            s.lookahead = 0
            s.match_length = s.prev_length = MIN_MATCH - 1
            s.match_available = 0
            strm.next_in = next
            strm.input = input
            strm.avail_in = avail
            s.wrap = wrap
            return Z_OK
          }

          exports.deflateInit = deflateInit
          exports.deflateInit2 = deflateInit2
          exports.deflateReset = deflateReset
          exports.deflateResetKeep = deflateResetKeep
          exports.deflateSetHeader = deflateSetHeader
          exports.deflate = deflate
          exports.deflateEnd = deflateEnd
          exports.deflateSetDictionary = deflateSetDictionary
          exports.deflateInfo = 'pako deflate (from Nodeca project)'

          /* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/gzheader.js':
        /*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
        /***/ (module) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          function GZheader() {
            /* true if compressed data believed to be text */
            this.text = 0
            /* modification time */
            this.time = 0
            /* extra flags (not used when writing a gzip file) */
            this.xflags = 0
            /* operating system */
            this.os = 0
            /* pointer to extra field or Z_NULL if none */
            this.extra = null
            /* extra field length (valid if extra != Z_NULL) */
            this.extra_len = 0 // Actually, we don't need it in JS,
            // but leave for few code modifications

            //
            // Setup limits is not necessary because in js we should not preallocate memory
            // for inflate use constant limit in 65536 bytes
            //

            /* space at extra (only when reading header) */
            // this.extra_max  = 0;
            /* pointer to zero-terminated file name or Z_NULL */
            this.name = ''
            /* space at name (only when reading header) */
            // this.name_max   = 0;
            /* pointer to zero-terminated comment or Z_NULL */
            this.comment = ''
            /* space at comment (only when reading header) */
            // this.comm_max   = 0;
            /* true if there was or will be a header crc */
            this.hcrc = 0
            /* true when done reading gzip header (not used when writing a gzip file) */
            this.done = false
          }

          module.exports = GZheader

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/inffast.js':
        /*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
        /***/ (module) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          // See state defs from inflate.js
          var BAD = 30 /* got a data error -- remain here until reset */
          var TYPE = 12 /* i: waiting for type bits, including last-flag bit */

          /*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
          module.exports = function inflate_fast(strm, start) {
            var state
            var _in /* local strm.input */
            var last /* have enough input while in < last */
            var _out /* local strm.output */
            var beg /* inflate()'s initial strm.output */
            var end /* while out < end, enough space available */
            //#ifdef INFLATE_STRICT
            var dmax /* maximum distance from zlib header */
            //#endif
            var wsize /* window size or zero if not using window */
            var whave /* valid bytes in the window */
            var wnext /* window write index */
            // Use `s_window` instead `window`, avoid conflict with instrumentation tools
            var s_window /* allocated sliding window, if wsize != 0 */
            var hold /* local strm.hold */
            var bits /* local strm.bits */
            var lcode /* local strm.lencode */
            var dcode /* local strm.distcode */
            var lmask /* mask for first level of length codes */
            var dmask /* mask for first level of distance codes */
            var here /* retrieved table entry */
            var op /* code bits, operation, extra bits, or */
            /*  window position, window bytes to copy */
            var len /* match length, unused bytes */
            var dist /* match distance */
            var from /* where to copy match from */
            var from_source

            var input, output // JS specific, because we have no pointers

            /* copy state to local variables */
            state = strm.state
            //here = state.here;
            _in = strm.next_in
            input = strm.input
            last = _in + (strm.avail_in - 5)
            _out = strm.next_out
            output = strm.output
            beg = _out - (start - strm.avail_out)
            end = _out + (strm.avail_out - 257)
            //#ifdef INFLATE_STRICT
            dmax = state.dmax
            //#endif
            wsize = state.wsize
            whave = state.whave
            wnext = state.wnext
            s_window = state.window
            hold = state.hold
            bits = state.bits
            lcode = state.lencode
            dcode = state.distcode
            lmask = (1 << state.lenbits) - 1
            dmask = (1 << state.distbits) - 1

            /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

            top: do {
              if (bits < 15) {
                hold += input[_in++] << bits
                bits += 8
                hold += input[_in++] << bits
                bits += 8
              }

              here = lcode[hold & lmask]

              dolen: for (;;) {
                // Goto emulation
                op = here >>> 24 /*here.bits*/
                hold >>>= op
                bits -= op
                op = (here >>> 16) & 0xff /*here.op*/
                if (op === 0) {
                  /* literal */
                  //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                  //        "inflate:         literal '%c'\n" :
                  //        "inflate:         literal 0x%02x\n", here.val));
                  output[_out++] = here & 0xffff /*here.val*/
                } else if (op & 16) {
                  /* length base */
                  len = here & 0xffff /*here.val*/
                  op &= 15 /* number of extra bits */
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits
                      bits += 8
                    }
                    len += hold & ((1 << op) - 1)
                    hold >>>= op
                    bits -= op
                  }
                  //Tracevv((stderr, "inflate:         length %u\n", len));
                  if (bits < 15) {
                    hold += input[_in++] << bits
                    bits += 8
                    hold += input[_in++] << bits
                    bits += 8
                  }
                  here = dcode[hold & dmask]

                  dodist: for (;;) {
                    // goto emulation
                    op = here >>> 24 /*here.bits*/
                    hold >>>= op
                    bits -= op
                    op = (here >>> 16) & 0xff /*here.op*/

                    if (op & 16) {
                      /* distance base */
                      dist = here & 0xffff /*here.val*/
                      op &= 15 /* number of extra bits */
                      if (bits < op) {
                        hold += input[_in++] << bits
                        bits += 8
                        if (bits < op) {
                          hold += input[_in++] << bits
                          bits += 8
                        }
                      }
                      dist += hold & ((1 << op) - 1)
                      //#ifdef INFLATE_STRICT
                      if (dist > dmax) {
                        strm.msg = 'invalid distance too far back'
                        state.mode = BAD
                        break top
                      }
                      //#endif
                      hold >>>= op
                      bits -= op
                      //Tracevv((stderr, "inflate:         distance %u\n", dist));
                      op = _out - beg /* max distance in output */
                      if (dist > op) {
                        /* see if copy from window */
                        op = dist - op /* distance back in window */
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = 'invalid distance too far back'
                            state.mode = BAD
                            break top
                          }

                          // (!) This block is disabled in zlib defaults,
                          // don't enable it for binary compatibility
                          //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                          //                if (len <= op - whave) {
                          //                  do {
                          //                    output[_out++] = 0;
                          //                  } while (--len);
                          //                  continue top;
                          //                }
                          //                len -= op - whave;
                          //                do {
                          //                  output[_out++] = 0;
                          //                } while (--op > whave);
                          //                if (op === 0) {
                          //                  from = _out - dist;
                          //                  do {
                          //                    output[_out++] = output[from++];
                          //                  } while (--len);
                          //                  continue top;
                          //                }
                          //#endif
                        }
                        from = 0 // window index
                        from_source = s_window
                        if (wnext === 0) {
                          /* very common case */
                          from += wsize - op
                          if (op < len) {
                            /* some from window */
                            len -= op
                            do {
                              output[_out++] = s_window[from++]
                            } while (--op)
                            from = _out - dist /* rest from output */
                            from_source = output
                          }
                        } else if (wnext < op) {
                          /* wrap around window */
                          from += wsize + wnext - op
                          op -= wnext
                          if (op < len) {
                            /* some from end of window */
                            len -= op
                            do {
                              output[_out++] = s_window[from++]
                            } while (--op)
                            from = 0
                            if (wnext < len) {
                              /* some from start of window */
                              op = wnext
                              len -= op
                              do {
                                output[_out++] = s_window[from++]
                              } while (--op)
                              from = _out - dist /* rest from output */
                              from_source = output
                            }
                          }
                        } else {
                          /* contiguous in window */
                          from += wnext - op
                          if (op < len) {
                            /* some from window */
                            len -= op
                            do {
                              output[_out++] = s_window[from++]
                            } while (--op)
                            from = _out - dist /* rest from output */
                            from_source = output
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++]
                          output[_out++] = from_source[from++]
                          output[_out++] = from_source[from++]
                          len -= 3
                        }
                        if (len) {
                          output[_out++] = from_source[from++]
                          if (len > 1) {
                            output[_out++] = from_source[from++]
                          }
                        }
                      } else {
                        from = _out - dist /* copy direct from output */
                        do {
                          /* minimum length is three */
                          output[_out++] = output[from++]
                          output[_out++] = output[from++]
                          output[_out++] = output[from++]
                          len -= 3
                        } while (len > 2)
                        if (len) {
                          output[_out++] = output[from++]
                          if (len > 1) {
                            output[_out++] = output[from++]
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      /* 2nd level distance code */
                      here = dcode[(here & 0xffff) /*here.val*/ + (hold & ((1 << op) - 1))]
                      continue dodist
                    } else {
                      strm.msg = 'invalid distance code'
                      state.mode = BAD
                      break top
                    }

                    break // need to emulate goto via "continue"
                  }
                } else if ((op & 64) === 0) {
                  /* 2nd level length code */
                  here = lcode[(here & 0xffff) /*here.val*/ + (hold & ((1 << op) - 1))]
                  continue dolen
                } else if (op & 32) {
                  /* end-of-block */
                  //Tracevv((stderr, "inflate:         end of block\n"));
                  state.mode = TYPE
                  break top
                } else {
                  strm.msg = 'invalid literal/length code'
                  state.mode = BAD
                  break top
                }

                break // need to emulate goto via "continue"
              }
            } while (_in < last && _out < end)

            /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
            len = bits >> 3
            _in -= len
            bits -= len << 3
            hold &= (1 << bits) - 1

            /* update state and return */
            strm.next_in = _in
            strm.next_out = _out
            strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last)
            strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end)
            state.hold = hold
            state.bits = bits
            return
          }

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/inflate.js':
        /*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          var utils = __webpack_require__(
            /*! ../utils/common */ './node_modules/pako/lib/utils/common.js'
          )
          var adler32 = __webpack_require__(
            /*! ./adler32 */ './node_modules/pako/lib/zlib/adler32.js'
          )
          var crc32 = __webpack_require__(/*! ./crc32 */ './node_modules/pako/lib/zlib/crc32.js')
          var inflate_fast = __webpack_require__(
            /*! ./inffast */ './node_modules/pako/lib/zlib/inffast.js'
          )
          var inflate_table = __webpack_require__(
            /*! ./inftrees */ './node_modules/pako/lib/zlib/inftrees.js'
          )

          var CODES = 0
          var LENS = 1
          var DISTS = 2

          /* Public constants ==========================================================*/
          /* ===========================================================================*/

          /* Allowed flush values; see deflate() and inflate() below for details */
          //var Z_NO_FLUSH      = 0;
          //var Z_PARTIAL_FLUSH = 1;
          //var Z_SYNC_FLUSH    = 2;
          //var Z_FULL_FLUSH    = 3;
          var Z_FINISH = 4
          var Z_BLOCK = 5
          var Z_TREES = 6

          /* Return codes for the compression/decompression functions. Negative values
           * are errors, positive values are used for special but normal events.
           */
          var Z_OK = 0
          var Z_STREAM_END = 1
          var Z_NEED_DICT = 2
          //var Z_ERRNO         = -1;
          var Z_STREAM_ERROR = -2
          var Z_DATA_ERROR = -3
          var Z_MEM_ERROR = -4
          var Z_BUF_ERROR = -5
          //var Z_VERSION_ERROR = -6;

          /* The deflate compression method */
          var Z_DEFLATED = 8

          /* STATES ====================================================================*/
          /* ===========================================================================*/

          var HEAD = 1 /* i: waiting for magic header */
          var FLAGS = 2 /* i: waiting for method and flags (gzip) */
          var TIME = 3 /* i: waiting for modification time (gzip) */
          var OS = 4 /* i: waiting for extra flags and operating system (gzip) */
          var EXLEN = 5 /* i: waiting for extra length (gzip) */
          var EXTRA = 6 /* i: waiting for extra bytes (gzip) */
          var NAME = 7 /* i: waiting for end of file name (gzip) */
          var COMMENT = 8 /* i: waiting for end of comment (gzip) */
          var HCRC = 9 /* i: waiting for header crc (gzip) */
          var DICTID = 10 /* i: waiting for dictionary check value */
          var DICT = 11 /* waiting for inflateSetDictionary() call */
          var TYPE = 12 /* i: waiting for type bits, including last-flag bit */
          var TYPEDO = 13 /* i: same, but skip check to exit inflate on new block */
          var STORED = 14 /* i: waiting for stored size (length and complement) */
          var COPY_ = 15 /* i/o: same as COPY below, but only first time in */
          var COPY = 16 /* i/o: waiting for input or output to copy stored block */
          var TABLE = 17 /* i: waiting for dynamic block table lengths */
          var LENLENS = 18 /* i: waiting for code length code lengths */
          var CODELENS = 19 /* i: waiting for length/lit and distance code lengths */
          var LEN_ = 20 /* i: same as LEN below, but only first time in */
          var LEN = 21 /* i: waiting for length/lit/eob code */
          var LENEXT = 22 /* i: waiting for length extra bits */
          var DIST = 23 /* i: waiting for distance code */
          var DISTEXT = 24 /* i: waiting for distance extra bits */
          var MATCH = 25 /* o: waiting for output space to copy string */
          var LIT = 26 /* o: waiting for output space to write literal */
          var CHECK = 27 /* i: waiting for 32-bit check value */
          var LENGTH = 28 /* i: waiting for 32-bit length (gzip) */
          var DONE = 29 /* finished check, done -- remain here until reset */
          var BAD = 30 /* got a data error -- remain here until reset */
          var MEM = 31 /* got an inflate() memory error -- remain here until reset */
          var SYNC = 32 /* looking for synchronization bytes to restart inflate() */

          /* ===========================================================================*/

          var ENOUGH_LENS = 852
          var ENOUGH_DISTS = 592
          //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

          var MAX_WBITS = 15
          /* 32K LZ77 window */
          var DEF_WBITS = MAX_WBITS

          function zswap32(q) {
            return (
              ((q >>> 24) & 0xff) + ((q >>> 8) & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24)
            )
          }

          function InflateState() {
            this.mode = 0 /* current inflate mode */
            this.last = false /* true if processing last block */
            this.wrap = 0 /* bit 0 true for zlib, bit 1 true for gzip */
            this.havedict = false /* true if dictionary provided */
            this.flags = 0 /* gzip header method and flags (0 if zlib) */
            this.dmax = 0 /* zlib header max distance (INFLATE_STRICT) */
            this.check = 0 /* protected copy of check value */
            this.total = 0 /* protected copy of output count */
            // TODO: may be {}
            this.head = null /* where to save gzip header information */

            /* sliding window */
            this.wbits = 0 /* log base 2 of requested window size */
            this.wsize = 0 /* window size or zero if not using window */
            this.whave = 0 /* valid bytes in the window */
            this.wnext = 0 /* window write index */
            this.window = null /* allocated sliding window, if needed */

            /* bit accumulator */
            this.hold = 0 /* input bit accumulator */
            this.bits = 0 /* number of bits in "in" */

            /* for string and stored block copying */
            this.length = 0 /* literal or length of data to copy */
            this.offset = 0 /* distance back to copy string from */

            /* for table and code decoding */
            this.extra = 0 /* extra bits needed */

            /* fixed and dynamic code tables */
            this.lencode = null /* starting table for length/literal codes */
            this.distcode = null /* starting table for distance codes */
            this.lenbits = 0 /* index bits for lencode */
            this.distbits = 0 /* index bits for distcode */

            /* dynamic table building */
            this.ncode = 0 /* number of code length code lengths */
            this.nlen = 0 /* number of length code lengths */
            this.ndist = 0 /* number of distance code lengths */
            this.have = 0 /* number of code lengths in lens[] */
            this.next = null /* next available space in codes[] */

            this.lens = new utils.Buf16(320) /* temporary storage for code lengths */
            this.work = new utils.Buf16(288) /* work area for code table building */

            /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
            //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
            this.lendyn = null /* dynamic table for length/literal codes (JS specific) */
            this.distdyn = null /* dynamic table for distance codes (JS specific) */
            this.sane = 0 /* if false, allow invalid distance too far */
            this.back = 0 /* bits back of last unprocessed length/lit */
            this.was = 0 /* initial length of match */
          }

          function inflateResetKeep(strm) {
            var state

            if (!strm || !strm.state) {
              return Z_STREAM_ERROR
            }
            state = strm.state
            strm.total_in = strm.total_out = state.total = 0
            strm.msg = '' /*Z_NULL*/
            if (state.wrap) {
              /* to support ill-conceived Java test suite */
              strm.adler = state.wrap & 1
            }
            state.mode = HEAD
            state.last = 0
            state.havedict = 0
            state.dmax = 32768
            state.head = null /*Z_NULL*/
            state.hold = 0
            state.bits = 0
            //state.lencode = state.distcode = state.next = state.codes;
            state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS)
            state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS)

            state.sane = 1
            state.back = -1
            //Tracev((stderr, "inflate: reset\n"));
            return Z_OK
          }

          function inflateReset(strm) {
            var state

            if (!strm || !strm.state) {
              return Z_STREAM_ERROR
            }
            state = strm.state
            state.wsize = 0
            state.whave = 0
            state.wnext = 0
            return inflateResetKeep(strm)
          }

          function inflateReset2(strm, windowBits) {
            var wrap
            var state

            /* get the state */
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR
            }
            state = strm.state

            /* extract wrap request from windowBits parameter */
            if (windowBits < 0) {
              wrap = 0
              windowBits = -windowBits
            } else {
              wrap = (windowBits >> 4) + 1
              if (windowBits < 48) {
                windowBits &= 15
              }
            }

            /* set number of window bits, free window if different */
            if (windowBits && (windowBits < 8 || windowBits > 15)) {
              return Z_STREAM_ERROR
            }
            if (state.window !== null && state.wbits !== windowBits) {
              state.window = null
            }

            /* update state and reset the rest of it */
            state.wrap = wrap
            state.wbits = windowBits
            return inflateReset(strm)
          }

          function inflateInit2(strm, windowBits) {
            var ret
            var state

            if (!strm) {
              return Z_STREAM_ERROR
            }
            //strm.msg = Z_NULL;                 /* in case we return an error */

            state = new InflateState()

            //if (state === Z_NULL) return Z_MEM_ERROR;
            //Tracev((stderr, "inflate: allocated\n"));
            strm.state = state
            state.window = null /*Z_NULL*/
            ret = inflateReset2(strm, windowBits)
            if (ret !== Z_OK) {
              strm.state = null /*Z_NULL*/
            }
            return ret
          }

          function inflateInit(strm) {
            return inflateInit2(strm, DEF_WBITS)
          }

          /*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
          var virgin = true

          var lenfix, distfix // We have no pointers in JS, so keep tables separate

          function fixedtables(state) {
            /* build fixed huffman tables if first call (may not be thread safe) */
            if (virgin) {
              var sym

              lenfix = new utils.Buf32(512)
              distfix = new utils.Buf32(32)

              /* literal/length table */
              sym = 0
              while (sym < 144) {
                state.lens[sym++] = 8
              }
              while (sym < 256) {
                state.lens[sym++] = 9
              }
              while (sym < 280) {
                state.lens[sym++] = 7
              }
              while (sym < 288) {
                state.lens[sym++] = 8
              }

              inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 })

              /* distance table */
              sym = 0
              while (sym < 32) {
                state.lens[sym++] = 5
              }

              inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 })

              /* do this just once */
              virgin = false
            }

            state.lencode = lenfix
            state.lenbits = 9
            state.distcode = distfix
            state.distbits = 5
          }

          /*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
          function updatewindow(strm, src, end, copy) {
            var dist
            var state = strm.state

            /* if it hasn't been done already, allocate space for the window */
            if (state.window === null) {
              state.wsize = 1 << state.wbits
              state.wnext = 0
              state.whave = 0

              state.window = new utils.Buf8(state.wsize)
            }

            /* copy state->wsize or less output bytes into the circular window */
            if (copy >= state.wsize) {
              utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0)
              state.wnext = 0
              state.whave = state.wsize
            } else {
              dist = state.wsize - state.wnext
              if (dist > copy) {
                dist = copy
              }
              //zmemcpy(state->window + state->wnext, end - copy, dist);
              utils.arraySet(state.window, src, end - copy, dist, state.wnext)
              copy -= dist
              if (copy) {
                //zmemcpy(state->window, end - copy, copy);
                utils.arraySet(state.window, src, end - copy, copy, 0)
                state.wnext = copy
                state.whave = state.wsize
              } else {
                state.wnext += dist
                if (state.wnext === state.wsize) {
                  state.wnext = 0
                }
                if (state.whave < state.wsize) {
                  state.whave += dist
                }
              }
            }
            return 0
          }

          function inflate(strm, flush) {
            var state
            var input, output // input/output buffers
            var next /* next input INDEX */
            var put /* next output INDEX */
            var have, left /* available input and output */
            var hold /* bit buffer */
            var bits /* bits in bit buffer */
            var _in, _out /* save starting available input and output */
            var copy /* number of stored or match bytes to copy */
            var from /* where to copy match bytes from */
            var from_source
            var here = 0 /* current decoding table entry */
            var here_bits, here_op, here_val // paked "here" denormalized (JS specific)
            //var last;                   /* parent table entry */
            var last_bits, last_op, last_val // paked "last" denormalized (JS specific)
            var len /* length to copy for repeats, bits to drop */
            var ret /* return code */
            var hbuf = new utils.Buf8(4) /* buffer for gzip header crc calculation */
            var opts

            var n // temporary var for NEED_BITS

            var order =
              /* permutation of code lengths */
              [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]

            if (!strm || !strm.state || !strm.output || (!strm.input && strm.avail_in !== 0)) {
              return Z_STREAM_ERROR
            }

            state = strm.state
            if (state.mode === TYPE) {
              state.mode = TYPEDO
            } /* skip check */

            //--- LOAD() ---
            put = strm.next_out
            output = strm.output
            left = strm.avail_out
            next = strm.next_in
            input = strm.input
            have = strm.avail_in
            hold = state.hold
            bits = state.bits
            //---

            _in = have
            _out = left
            ret = Z_OK

            // goto emulation
            inf_leave: for (;;) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO
                    break
                  }
                  //=== NEEDBITS(16);
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  if (state.wrap & 2 && hold === 0x8b1f) {
                    /* gzip header */
                    state.check = 0 /*crc32(0L, Z_NULL, 0)*/
                    //=== CRC2(state.check, hold);
                    hbuf[0] = hold & 0xff
                    hbuf[1] = (hold >>> 8) & 0xff
                    state.check = crc32(state.check, hbuf, 2, 0)
                    //===//

                    //=== INITBITS();
                    hold = 0
                    bits = 0
                    //===//
                    state.mode = FLAGS
                    break
                  }
                  state.flags = 0 /* expect zlib header */
                  if (state.head) {
                    state.head.done = false
                  }
                  if (
                    !(state.wrap & 1) /* check if zlib header allowed */ ||
                    (((hold & 0xff) /*BITS(8)*/ << 8) + (hold >> 8)) % 31
                  ) {
                    strm.msg = 'incorrect header check'
                    state.mode = BAD
                    break
                  }
                  if ((hold & 0x0f) /*BITS(4)*/ !== Z_DEFLATED) {
                    strm.msg = 'unknown compression method'
                    state.mode = BAD
                    break
                  }
                  //--- DROPBITS(4) ---//
                  hold >>>= 4
                  bits -= 4
                  //---//
                  len = (hold & 0x0f) /*BITS(4)*/ + 8
                  if (state.wbits === 0) {
                    state.wbits = len
                  } else if (len > state.wbits) {
                    strm.msg = 'invalid window size'
                    state.mode = BAD
                    break
                  }
                  state.dmax = 1 << len
                  //Tracev((stderr, "inflate:   zlib header ok\n"));
                  strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/
                  state.mode = hold & 0x200 ? DICTID : TYPE
                  //=== INITBITS();
                  hold = 0
                  bits = 0
                  //===//
                  break
                case FLAGS:
                  //=== NEEDBITS(16); */
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  state.flags = hold
                  if ((state.flags & 0xff) !== Z_DEFLATED) {
                    strm.msg = 'unknown compression method'
                    state.mode = BAD
                    break
                  }
                  if (state.flags & 0xe000) {
                    strm.msg = 'unknown header flags set'
                    state.mode = BAD
                    break
                  }
                  if (state.head) {
                    state.head.text = (hold >> 8) & 1
                  }
                  if (state.flags & 0x0200) {
                    //=== CRC2(state.check, hold);
                    hbuf[0] = hold & 0xff
                    hbuf[1] = (hold >>> 8) & 0xff
                    state.check = crc32(state.check, hbuf, 2, 0)
                    //===//
                  }
                  //=== INITBITS();
                  hold = 0
                  bits = 0
                  //===//
                  state.mode = TIME
                /* falls through */
                case TIME:
                  //=== NEEDBITS(32); */
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  if (state.head) {
                    state.head.time = hold
                  }
                  if (state.flags & 0x0200) {
                    //=== CRC4(state.check, hold)
                    hbuf[0] = hold & 0xff
                    hbuf[1] = (hold >>> 8) & 0xff
                    hbuf[2] = (hold >>> 16) & 0xff
                    hbuf[3] = (hold >>> 24) & 0xff
                    state.check = crc32(state.check, hbuf, 4, 0)
                    //===
                  }
                  //=== INITBITS();
                  hold = 0
                  bits = 0
                  //===//
                  state.mode = OS
                /* falls through */
                case OS:
                  //=== NEEDBITS(16); */
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  if (state.head) {
                    state.head.xflags = hold & 0xff
                    state.head.os = hold >> 8
                  }
                  if (state.flags & 0x0200) {
                    //=== CRC2(state.check, hold);
                    hbuf[0] = hold & 0xff
                    hbuf[1] = (hold >>> 8) & 0xff
                    state.check = crc32(state.check, hbuf, 2, 0)
                    //===//
                  }
                  //=== INITBITS();
                  hold = 0
                  bits = 0
                  //===//
                  state.mode = EXLEN
                /* falls through */
                case EXLEN:
                  if (state.flags & 0x0400) {
                    //=== NEEDBITS(16); */
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                    }
                    //===//
                    state.length = hold
                    if (state.head) {
                      state.head.extra_len = hold
                    }
                    if (state.flags & 0x0200) {
                      //=== CRC2(state.check, hold);
                      hbuf[0] = hold & 0xff
                      hbuf[1] = (hold >>> 8) & 0xff
                      state.check = crc32(state.check, hbuf, 2, 0)
                      //===//
                    }
                    //=== INITBITS();
                    hold = 0
                    bits = 0
                    //===//
                  } else if (state.head) {
                    state.head.extra = null /*Z_NULL*/
                  }
                  state.mode = EXTRA
                /* falls through */
                case EXTRA:
                  if (state.flags & 0x0400) {
                    copy = state.length
                    if (copy > have) {
                      copy = have
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length
                        if (!state.head.extra) {
                          // Use untyped array for more convenient processing later
                          state.head.extra = new Array(state.head.extra_len)
                        }
                        utils.arraySet(
                          state.head.extra,
                          input,
                          next,
                          // extra field is limited to 65536 bytes
                          // - no need for additional size check
                          copy,
                          /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                          len
                        )
                        //zmemcpy(state.head.extra + len, next,
                        //        len + copy > state.head.extra_max ?
                        //        state.head.extra_max - len : copy);
                      }
                      if (state.flags & 0x0200) {
                        state.check = crc32(state.check, input, copy, next)
                      }
                      have -= copy
                      next += copy
                      state.length -= copy
                    }
                    if (state.length) {
                      break inf_leave
                    }
                  }
                  state.length = 0
                  state.mode = NAME
                /* falls through */
                case NAME:
                  if (state.flags & 0x0800) {
                    if (have === 0) {
                      break inf_leave
                    }
                    copy = 0
                    do {
                      // TODO: 2 or 1 bytes?
                      len = input[next + copy++]
                      /* use constant limit because in js we should not preallocate memory */
                      if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
                        state.head.name += String.fromCharCode(len)
                      }
                    } while (len && copy < have)

                    if (state.flags & 0x0200) {
                      state.check = crc32(state.check, input, copy, next)
                    }
                    have -= copy
                    next += copy
                    if (len) {
                      break inf_leave
                    }
                  } else if (state.head) {
                    state.head.name = null
                  }
                  state.length = 0
                  state.mode = COMMENT
                /* falls through */
                case COMMENT:
                  if (state.flags & 0x1000) {
                    if (have === 0) {
                      break inf_leave
                    }
                    copy = 0
                    do {
                      len = input[next + copy++]
                      /* use constant limit because in js we should not preallocate memory */
                      if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
                        state.head.comment += String.fromCharCode(len)
                      }
                    } while (len && copy < have)
                    if (state.flags & 0x0200) {
                      state.check = crc32(state.check, input, copy, next)
                    }
                    have -= copy
                    next += copy
                    if (len) {
                      break inf_leave
                    }
                  } else if (state.head) {
                    state.head.comment = null
                  }
                  state.mode = HCRC
                /* falls through */
                case HCRC:
                  if (state.flags & 0x0200) {
                    //=== NEEDBITS(16); */
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                    }
                    //===//
                    if (hold !== (state.check & 0xffff)) {
                      strm.msg = 'header crc mismatch'
                      state.mode = BAD
                      break
                    }
                    //=== INITBITS();
                    hold = 0
                    bits = 0
                    //===//
                  }
                  if (state.head) {
                    state.head.hcrc = (state.flags >> 9) & 1
                    state.head.done = true
                  }
                  strm.adler = state.check = 0
                  state.mode = TYPE
                  break
                case DICTID:
                  //=== NEEDBITS(32); */
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  strm.adler = state.check = zswap32(hold)
                  //=== INITBITS();
                  hold = 0
                  bits = 0
                  //===//
                  state.mode = DICT
                /* falls through */
                case DICT:
                  if (state.havedict === 0) {
                    //--- RESTORE() ---
                    strm.next_out = put
                    strm.avail_out = left
                    strm.next_in = next
                    strm.avail_in = have
                    state.hold = hold
                    state.bits = bits
                    //---
                    return Z_NEED_DICT
                  }
                  strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/
                  state.mode = TYPE
                /* falls through */
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave
                  }
                /* falls through */
                case TYPEDO:
                  if (state.last) {
                    //--- BYTEBITS() ---//
                    hold >>>= bits & 7
                    bits -= bits & 7
                    //---//
                    state.mode = CHECK
                    break
                  }
                  //=== NEEDBITS(3); */
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  state.last = hold & 0x01 /*BITS(1)*/
                  //--- DROPBITS(1) ---//
                  hold >>>= 1
                  bits -= 1
                  //---//

                  switch (hold & 0x03 /*BITS(2)*/) {
                    case 0 /* stored block */:
                      //Tracev((stderr, "inflate:     stored block%s\n",
                      //        state.last ? " (last)" : ""));
                      state.mode = STORED
                      break
                    case 1 /* fixed block */:
                      fixedtables(state)
                      //Tracev((stderr, "inflate:     fixed codes block%s\n",
                      //        state.last ? " (last)" : ""));
                      state.mode = LEN_ /* decode codes */
                      if (flush === Z_TREES) {
                        //--- DROPBITS(2) ---//
                        hold >>>= 2
                        bits -= 2
                        //---//
                        break inf_leave
                      }
                      break
                    case 2 /* dynamic block */:
                      //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                      //        state.last ? " (last)" : ""));
                      state.mode = TABLE
                      break
                    case 3:
                      strm.msg = 'invalid block type'
                      state.mode = BAD
                  }
                  //--- DROPBITS(2) ---//
                  hold >>>= 2
                  bits -= 2
                  //---//
                  break
                case STORED:
                  //--- BYTEBITS() ---// /* go to byte boundary */
                  hold >>>= bits & 7
                  bits -= bits & 7
                  //---//
                  //=== NEEDBITS(32); */
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                    strm.msg = 'invalid stored block lengths'
                    state.mode = BAD
                    break
                  }
                  state.length = hold & 0xffff
                  //Tracev((stderr, "inflate:       stored length %u\n",
                  //        state.length));
                  //=== INITBITS();
                  hold = 0
                  bits = 0
                  //===//
                  state.mode = COPY_
                  if (flush === Z_TREES) {
                    break inf_leave
                  }
                /* falls through */
                case COPY_:
                  state.mode = COPY
                /* falls through */
                case COPY:
                  copy = state.length
                  if (copy) {
                    if (copy > have) {
                      copy = have
                    }
                    if (copy > left) {
                      copy = left
                    }
                    if (copy === 0) {
                      break inf_leave
                    }
                    //--- zmemcpy(put, next, copy); ---
                    utils.arraySet(output, input, next, copy, put)
                    //---//
                    have -= copy
                    next += copy
                    left -= copy
                    put += copy
                    state.length -= copy
                    break
                  }
                  //Tracev((stderr, "inflate:       stored end\n"));
                  state.mode = TYPE
                  break
                case TABLE:
                  //=== NEEDBITS(14); */
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                  }
                  //===//
                  state.nlen = (hold & 0x1f) /*BITS(5)*/ + 257
                  //--- DROPBITS(5) ---//
                  hold >>>= 5
                  bits -= 5
                  //---//
                  state.ndist = (hold & 0x1f) /*BITS(5)*/ + 1
                  //--- DROPBITS(5) ---//
                  hold >>>= 5
                  bits -= 5
                  //---//
                  state.ncode = (hold & 0x0f) /*BITS(4)*/ + 4
                  //--- DROPBITS(4) ---//
                  hold >>>= 4
                  bits -= 4
                  //---//
                  //#ifndef PKZIP_BUG_WORKAROUND
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = 'too many length or distance symbols'
                    state.mode = BAD
                    break
                  }
                  //#endif
                  //Tracev((stderr, "inflate:       table sizes ok\n"));
                  state.have = 0
                  state.mode = LENLENS
                /* falls through */
                case LENLENS:
                  while (state.have < state.ncode) {
                    //=== NEEDBITS(3);
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                    }
                    //===//
                    state.lens[order[state.have++]] = hold & 0x07 //BITS(3);
                    //--- DROPBITS(3) ---//
                    hold >>>= 3
                    bits -= 3
                    //---//
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0
                  }
                  // We have separate tables & no pointers. 2 commented lines below not needed.
                  //state.next = state.codes;
                  //state.lencode = state.next;
                  // Switch to use dynamic table
                  state.lencode = state.lendyn
                  state.lenbits = 7

                  opts = { bits: state.lenbits }
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts)
                  state.lenbits = opts.bits

                  if (ret) {
                    strm.msg = 'invalid code lengths set'
                    state.mode = BAD
                    break
                  }
                  //Tracev((stderr, "inflate:       code lengths ok\n"));
                  state.have = 0
                  state.mode = CODELENS
                /* falls through */
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (;;) {
                      here =
                        state.lencode[hold & ((1 << state.lenbits) - 1)] /*BITS(state.lenbits)*/
                      here_bits = here >>> 24
                      here_op = (here >>> 16) & 0xff
                      here_val = here & 0xffff

                      if (here_bits <= bits) {
                        break
                      }
                      //--- PULLBYTE() ---//
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                      //---//
                    }
                    if (here_val < 16) {
                      //--- DROPBITS(here.bits) ---//
                      hold >>>= here_bits
                      bits -= here_bits
                      //---//
                      state.lens[state.have++] = here_val
                    } else {
                      if (here_val === 16) {
                        //=== NEEDBITS(here.bits + 2);
                        n = here_bits + 2
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave
                          }
                          have--
                          hold += input[next++] << bits
                          bits += 8
                        }
                        //===//
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits
                        bits -= here_bits
                        //---//
                        if (state.have === 0) {
                          strm.msg = 'invalid bit length repeat'
                          state.mode = BAD
                          break
                        }
                        len = state.lens[state.have - 1]
                        copy = 3 + (hold & 0x03) //BITS(2);
                        //--- DROPBITS(2) ---//
                        hold >>>= 2
                        bits -= 2
                        //---//
                      } else if (here_val === 17) {
                        //=== NEEDBITS(here.bits + 3);
                        n = here_bits + 3
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave
                          }
                          have--
                          hold += input[next++] << bits
                          bits += 8
                        }
                        //===//
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits
                        bits -= here_bits
                        //---//
                        len = 0
                        copy = 3 + (hold & 0x07) //BITS(3);
                        //--- DROPBITS(3) ---//
                        hold >>>= 3
                        bits -= 3
                        //---//
                      } else {
                        //=== NEEDBITS(here.bits + 7);
                        n = here_bits + 7
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave
                          }
                          have--
                          hold += input[next++] << bits
                          bits += 8
                        }
                        //===//
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits
                        bits -= here_bits
                        //---//
                        len = 0
                        copy = 11 + (hold & 0x7f) //BITS(7);
                        //--- DROPBITS(7) ---//
                        hold >>>= 7
                        bits -= 7
                        //---//
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = 'invalid bit length repeat'
                        state.mode = BAD
                        break
                      }
                      while (copy--) {
                        state.lens[state.have++] = len
                      }
                    }
                  }

                  /* handle error breaks in while */
                  if (state.mode === BAD) {
                    break
                  }

                  /* check for end-of-block code (better have one) */
                  if (state.lens[256] === 0) {
                    strm.msg = 'invalid code -- missing end-of-block'
                    state.mode = BAD
                    break
                  }

                  /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
                  state.lenbits = 9

                  opts = { bits: state.lenbits }
                  ret = inflate_table(
                    LENS,
                    state.lens,
                    0,
                    state.nlen,
                    state.lencode,
                    0,
                    state.work,
                    opts
                  )
                  // We have separate tables & no pointers. 2 commented lines below not needed.
                  // state.next_index = opts.table_index;
                  state.lenbits = opts.bits
                  // state.lencode = state.next;

                  if (ret) {
                    strm.msg = 'invalid literal/lengths set'
                    state.mode = BAD
                    break
                  }

                  state.distbits = 6
                  //state.distcode.copy(state.codes);
                  // Switch to use dynamic table
                  state.distcode = state.distdyn
                  opts = { bits: state.distbits }
                  ret = inflate_table(
                    DISTS,
                    state.lens,
                    state.nlen,
                    state.ndist,
                    state.distcode,
                    0,
                    state.work,
                    opts
                  )
                  // We have separate tables & no pointers. 2 commented lines below not needed.
                  // state.next_index = opts.table_index;
                  state.distbits = opts.bits
                  // state.distcode = state.next;

                  if (ret) {
                    strm.msg = 'invalid distances set'
                    state.mode = BAD
                    break
                  }
                  //Tracev((stderr, 'inflate:       codes ok\n'));
                  state.mode = LEN_
                  if (flush === Z_TREES) {
                    break inf_leave
                  }
                /* falls through */
                case LEN_:
                  state.mode = LEN
                /* falls through */
                case LEN:
                  if (have >= 6 && left >= 258) {
                    //--- RESTORE() ---
                    strm.next_out = put
                    strm.avail_out = left
                    strm.next_in = next
                    strm.avail_in = have
                    state.hold = hold
                    state.bits = bits
                    //---
                    inflate_fast(strm, _out)
                    //--- LOAD() ---
                    put = strm.next_out
                    output = strm.output
                    left = strm.avail_out
                    next = strm.next_in
                    input = strm.input
                    have = strm.avail_in
                    hold = state.hold
                    bits = state.bits
                    //---

                    if (state.mode === TYPE) {
                      state.back = -1
                    }
                    break
                  }
                  state.back = 0
                  for (;;) {
                    here = state.lencode[hold & ((1 << state.lenbits) - 1)] /*BITS(state.lenbits)*/
                    here_bits = here >>> 24
                    here_op = (here >>> 16) & 0xff
                    here_val = here & 0xffff

                    if (here_bits <= bits) {
                      break
                    }
                    //--- PULLBYTE() ---//
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                    //---//
                  }
                  if (here_op && (here_op & 0xf0) === 0) {
                    last_bits = here_bits
                    last_op = here_op
                    last_val = here_val
                    for (;;) {
                      here =
                        state.lencode[
                          last_val +
                            ((hold &
                              ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >>
                              last_bits)
                        ]
                      here_bits = here >>> 24
                      here_op = (here >>> 16) & 0xff
                      here_val = here & 0xffff

                      if (last_bits + here_bits <= bits) {
                        break
                      }
                      //--- PULLBYTE() ---//
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                      //---//
                    }
                    //--- DROPBITS(last.bits) ---//
                    hold >>>= last_bits
                    bits -= last_bits
                    //---//
                    state.back += last_bits
                  }
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits
                  bits -= here_bits
                  //---//
                  state.back += here_bits
                  state.length = here_val
                  if (here_op === 0) {
                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                    //        "inflate:         literal '%c'\n" :
                    //        "inflate:         literal 0x%02x\n", here.val));
                    state.mode = LIT
                    break
                  }
                  if (here_op & 32) {
                    //Tracevv((stderr, "inflate:         end of block\n"));
                    state.back = -1
                    state.mode = TYPE
                    break
                  }
                  if (here_op & 64) {
                    strm.msg = 'invalid literal/length code'
                    state.mode = BAD
                    break
                  }
                  state.extra = here_op & 15
                  state.mode = LENEXT
                /* falls through */
                case LENEXT:
                  if (state.extra) {
                    //=== NEEDBITS(state.extra);
                    n = state.extra
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                    }
                    //===//
                    state.length += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/
                    //--- DROPBITS(state.extra) ---//
                    hold >>>= state.extra
                    bits -= state.extra
                    //---//
                    state.back += state.extra
                  }
                  //Tracevv((stderr, "inflate:         length %u\n", state.length));
                  state.was = state.length
                  state.mode = DIST
                /* falls through */
                case DIST:
                  for (;;) {
                    here =
                      state.distcode[hold & ((1 << state.distbits) - 1)] /*BITS(state.distbits)*/
                    here_bits = here >>> 24
                    here_op = (here >>> 16) & 0xff
                    here_val = here & 0xffff

                    if (here_bits <= bits) {
                      break
                    }
                    //--- PULLBYTE() ---//
                    if (have === 0) {
                      break inf_leave
                    }
                    have--
                    hold += input[next++] << bits
                    bits += 8
                    //---//
                  }
                  if ((here_op & 0xf0) === 0) {
                    last_bits = here_bits
                    last_op = here_op
                    last_val = here_val
                    for (;;) {
                      here =
                        state.distcode[
                          last_val +
                            ((hold &
                              ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >>
                              last_bits)
                        ]
                      here_bits = here >>> 24
                      here_op = (here >>> 16) & 0xff
                      here_val = here & 0xffff

                      if (last_bits + here_bits <= bits) {
                        break
                      }
                      //--- PULLBYTE() ---//
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                      //---//
                    }
                    //--- DROPBITS(last.bits) ---//
                    hold >>>= last_bits
                    bits -= last_bits
                    //---//
                    state.back += last_bits
                  }
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits
                  bits -= here_bits
                  //---//
                  state.back += here_bits
                  if (here_op & 64) {
                    strm.msg = 'invalid distance code'
                    state.mode = BAD
                    break
                  }
                  state.offset = here_val
                  state.extra = here_op & 15
                  state.mode = DISTEXT
                /* falls through */
                case DISTEXT:
                  if (state.extra) {
                    //=== NEEDBITS(state.extra);
                    n = state.extra
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                    }
                    //===//
                    state.offset += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/
                    //--- DROPBITS(state.extra) ---//
                    hold >>>= state.extra
                    bits -= state.extra
                    //---//
                    state.back += state.extra
                  }
                  //#ifdef INFLATE_STRICT
                  if (state.offset > state.dmax) {
                    strm.msg = 'invalid distance too far back'
                    state.mode = BAD
                    break
                  }
                  //#endif
                  //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
                  state.mode = MATCH
                /* falls through */
                case MATCH:
                  if (left === 0) {
                    break inf_leave
                  }
                  copy = _out - left
                  if (state.offset > copy) {
                    /* copy from window */
                    copy = state.offset - copy
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = 'invalid distance too far back'
                        state.mode = BAD
                        break
                      }
                      // (!) This block is disabled in zlib defaults,
                      // don't enable it for binary compatibility
                      //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                      //          Trace((stderr, "inflate.c too far\n"));
                      //          copy -= state.whave;
                      //          if (copy > state.length) { copy = state.length; }
                      //          if (copy > left) { copy = left; }
                      //          left -= copy;
                      //          state.length -= copy;
                      //          do {
                      //            output[put++] = 0;
                      //          } while (--copy);
                      //          if (state.length === 0) { state.mode = LEN; }
                      //          break;
                      //#endif
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext
                      from = state.wsize - copy
                    } else {
                      from = state.wnext - copy
                    }
                    if (copy > state.length) {
                      copy = state.length
                    }
                    from_source = state.window
                  } else {
                    /* copy from output */
                    from_source = output
                    from = put - state.offset
                    copy = state.length
                  }
                  if (copy > left) {
                    copy = left
                  }
                  left -= copy
                  state.length -= copy
                  do {
                    output[put++] = from_source[from++]
                  } while (--copy)
                  if (state.length === 0) {
                    state.mode = LEN
                  }
                  break
                case LIT:
                  if (left === 0) {
                    break inf_leave
                  }
                  output[put++] = state.length
                  left--
                  state.mode = LEN
                  break
                case CHECK:
                  if (state.wrap) {
                    //=== NEEDBITS(32);
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      // Use '|' instead of '+' to make sure that result is signed
                      hold |= input[next++] << bits
                      bits += 8
                    }
                    //===//
                    _out -= left
                    strm.total_out += _out
                    state.total += _out
                    if (_out) {
                      strm.adler = state.check =
                        /*UPDATE(state.check, put - _out, _out);*/
                        state.flags
                          ? crc32(state.check, output, _out, put - _out)
                          : adler32(state.check, output, _out, put - _out)
                    }
                    _out = left
                    // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = 'incorrect data check'
                      state.mode = BAD
                      break
                    }
                    //=== INITBITS();
                    hold = 0
                    bits = 0
                    //===//
                    //Tracev((stderr, "inflate:   check matches trailer\n"));
                  }
                  state.mode = LENGTH
                /* falls through */
                case LENGTH:
                  if (state.wrap && state.flags) {
                    //=== NEEDBITS(32);
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--
                      hold += input[next++] << bits
                      bits += 8
                    }
                    //===//
                    if (hold !== (state.total & 0xffffffff)) {
                      strm.msg = 'incorrect length check'
                      state.mode = BAD
                      break
                    }
                    //=== INITBITS();
                    hold = 0
                    bits = 0
                    //===//
                    //Tracev((stderr, "inflate:   length matches trailer\n"));
                  }
                  state.mode = DONE
                /* falls through */
                case DONE:
                  ret = Z_STREAM_END
                  break inf_leave
                case BAD:
                  ret = Z_DATA_ERROR
                  break inf_leave
                case MEM:
                  return Z_MEM_ERROR
                case SYNC:
                /* falls through */
                default:
                  return Z_STREAM_ERROR
              }
            }

            // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

            /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

            //--- RESTORE() ---
            strm.next_out = put
            strm.avail_out = left
            strm.next_in = next
            strm.avail_in = have
            state.hold = hold
            state.bits = bits
            //---

            if (
              state.wsize ||
              (_out !== strm.avail_out &&
                state.mode < BAD &&
                (state.mode < CHECK || flush !== Z_FINISH))
            ) {
              if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                state.mode = MEM
                return Z_MEM_ERROR
              }
            }
            _in -= strm.avail_in
            _out -= strm.avail_out
            strm.total_in += _in
            strm.total_out += _out
            state.total += _out
            if (state.wrap && _out) {
              strm.adler = state.check =
                /*UPDATE(state.check, strm.next_out - _out, _out);*/
                state.flags
                  ? crc32(state.check, output, _out, strm.next_out - _out)
                  : adler32(state.check, output, _out, strm.next_out - _out)
            }
            strm.data_type =
              state.bits +
              (state.last ? 64 : 0) +
              (state.mode === TYPE ? 128 : 0) +
              (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0)
            if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
              ret = Z_BUF_ERROR
            }
            return ret
          }

          function inflateEnd(strm) {
            if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
              return Z_STREAM_ERROR
            }

            var state = strm.state
            if (state.window) {
              state.window = null
            }
            strm.state = null
            return Z_OK
          }

          function inflateGetHeader(strm, head) {
            var state

            /* check state */
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR
            }
            state = strm.state
            if ((state.wrap & 2) === 0) {
              return Z_STREAM_ERROR
            }

            /* save header structure */
            state.head = head
            head.done = false
            return Z_OK
          }

          function inflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length

            var state
            var dictid
            var ret

            /* check state */
            if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) {
              return Z_STREAM_ERROR
            }
            state = strm.state

            if (state.wrap !== 0 && state.mode !== DICT) {
              return Z_STREAM_ERROR
            }

            /* check for correct dictionary identifier */
            if (state.mode === DICT) {
              dictid = 1 /* adler32(0, null, 0)*/
              /* dictid = adler32(dictid, dictionary, dictLength); */
              dictid = adler32(dictid, dictionary, dictLength, 0)
              if (dictid !== state.check) {
                return Z_DATA_ERROR
              }
            }
            /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
            ret = updatewindow(strm, dictionary, dictLength, dictLength)
            if (ret) {
              state.mode = MEM
              return Z_MEM_ERROR
            }
            state.havedict = 1
            // Tracev((stderr, "inflate:   dictionary set\n"));
            return Z_OK
          }

          exports.inflateReset = inflateReset
          exports.inflateReset2 = inflateReset2
          exports.inflateResetKeep = inflateResetKeep
          exports.inflateInit = inflateInit
          exports.inflateInit2 = inflateInit2
          exports.inflate = inflate
          exports.inflateEnd = inflateEnd
          exports.inflateGetHeader = inflateGetHeader
          exports.inflateSetDictionary = inflateSetDictionary
          exports.inflateInfo = 'pako inflate (from Nodeca project)'

          /* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/inftrees.js':
        /*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          var utils = __webpack_require__(
            /*! ../utils/common */ './node_modules/pako/lib/utils/common.js'
          )

          var MAXBITS = 15
          var ENOUGH_LENS = 852
          var ENOUGH_DISTS = 592
          //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

          var CODES = 0
          var LENS = 1
          var DISTS = 2

          var lbase = [
            /* Length codes 257..285 base */ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27,
            31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
          ]

          var lext = [
            /* Length codes 257..285 extra */ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18,
            18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
          ]

          var dbase = [
            /* Distance codes 0..29 base */ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129,
            193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577,
            0, 0
          ]

          var dext = [
            /* Distance codes 0..29 extra */ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21,
            22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64
          ]

          module.exports = function inflate_table(
            type,
            lens,
            lens_index,
            codes,
            table,
            table_index,
            work,
            opts
          ) {
            var bits = opts.bits
            //here = opts.here; /* table entry for duplication */

            var len = 0 /* a code's length in bits */
            var sym = 0 /* index of code symbols */
            var min = 0,
              max = 0 /* minimum and maximum code lengths */
            var root = 0 /* number of index bits for root table */
            var curr = 0 /* number of index bits for current table */
            var drop = 0 /* code bits to drop for sub-table */
            var left = 0 /* number of prefix codes available */
            var used = 0 /* code entries in table used */
            var huff = 0 /* Huffman code */
            var incr /* for incrementing code, index */
            var fill /* index for replicating entries */
            var low /* low bits for current root entry */
            var mask /* mask for low root bits */
            var next /* next available space in table */
            var base = null /* base value table to use */
            var base_index = 0
            //  var shoextra;    /* extra bits table to use */
            var end /* use base and extra for symbol > end */
            var count = new utils.Buf16(MAXBITS + 1) //[MAXBITS+1];    /* number of codes of each length */
            var offs = new utils.Buf16(MAXBITS + 1) //[MAXBITS+1];     /* offsets in table for each length */
            var extra = null
            var extra_index = 0

            var here_bits, here_op, here_val

            /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

            /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
            for (len = 0; len <= MAXBITS; len++) {
              count[len] = 0
            }
            for (sym = 0; sym < codes; sym++) {
              count[lens[lens_index + sym]]++
            }

            /* bound code lengths, force root to be within code lengths */
            root = bits
            for (max = MAXBITS; max >= 1; max--) {
              if (count[max] !== 0) {
                break
              }
            }
            if (root > max) {
              root = max
            }
            if (max === 0) {
              /* no symbols to code at all */
              //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
              //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
              //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
              table[table_index++] = (1 << 24) | (64 << 16) | 0

              //table.op[opts.table_index] = 64;
              //table.bits[opts.table_index] = 1;
              //table.val[opts.table_index++] = 0;
              table[table_index++] = (1 << 24) | (64 << 16) | 0

              opts.bits = 1
              return 0 /* no symbols, but wait for decoding to report error */
            }
            for (min = 1; min < max; min++) {
              if (count[min] !== 0) {
                break
              }
            }
            if (root < min) {
              root = min
            }

            /* check for an over-subscribed or incomplete set of lengths */
            left = 1
            for (len = 1; len <= MAXBITS; len++) {
              left <<= 1
              left -= count[len]
              if (left < 0) {
                return -1
              } /* over-subscribed */
            }
            if (left > 0 && (type === CODES || max !== 1)) {
              return -1 /* incomplete set */
            }

            /* generate offsets into symbol table for each length for sorting */
            offs[1] = 0
            for (len = 1; len < MAXBITS; len++) {
              offs[len + 1] = offs[len] + count[len]
            }

            /* sort symbols by length, by symbol order within each length */
            for (sym = 0; sym < codes; sym++) {
              if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym
              }
            }

            /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

            /* set up for code type */
            // poor man optimization - use if-else instead of switch,
            // to avoid deopts in old v8
            if (type === CODES) {
              base = extra = work /* dummy value--not used */
              end = 19
            } else if (type === LENS) {
              base = lbase
              base_index -= 257
              extra = lext
              extra_index -= 257
              end = 256
            } else {
              /* DISTS */
              base = dbase
              extra = dext
              end = -1
            }

            /* initialize opts for loop */
            huff = 0 /* starting code */
            sym = 0 /* starting code symbol */
            len = min /* starting code length */
            next = table_index /* current table to fill in */
            curr = root /* current table index bits */
            drop = 0 /* current bits to drop from code for index */
            low = -1 /* trigger new sub-table when len > root */
            used = 1 << root /* use root table entries */
            mask = used - 1 /* mask for comparing low */

            /* check available table space */
            if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {
              return 1
            }

            /* process all codes and make table entries */
            for (;;) {
              /* create table entry */
              here_bits = len - drop
              if (work[sym] < end) {
                here_op = 0
                here_val = work[sym]
              } else if (work[sym] > end) {
                here_op = extra[extra_index + work[sym]]
                here_val = base[base_index + work[sym]]
              } else {
                here_op = 32 + 64 /* end of block */
                here_val = 0
              }

              /* replicate for those indices with low len bits equal to huff */
              incr = 1 << (len - drop)
              fill = 1 << curr
              min = fill /* save offset to next table */
              do {
                fill -= incr
                table[next + (huff >> drop) + fill] =
                  (here_bits << 24) | (here_op << 16) | here_val | 0
              } while (fill !== 0)

              /* backwards increment the len-bit code huff */
              incr = 1 << (len - 1)
              while (huff & incr) {
                incr >>= 1
              }
              if (incr !== 0) {
                huff &= incr - 1
                huff += incr
              } else {
                huff = 0
              }

              /* go to next symbol, update count, len */
              sym++
              if (--count[len] === 0) {
                if (len === max) {
                  break
                }
                len = lens[lens_index + work[sym]]
              }

              /* create new sub-table if needed */
              if (len > root && (huff & mask) !== low) {
                /* if first time, transition to sub-tables */
                if (drop === 0) {
                  drop = root
                }

                /* increment past last table */
                next += min /* here min is 1 << curr */

                /* determine length of next table */
                curr = len - drop
                left = 1 << curr
                while (curr + drop < max) {
                  left -= count[curr + drop]
                  if (left <= 0) {
                    break
                  }
                  curr++
                  left <<= 1
                }

                /* check for enough space */
                used += 1 << curr
                if (
                  (type === LENS && used > ENOUGH_LENS) ||
                  (type === DISTS && used > ENOUGH_DISTS)
                ) {
                  return 1
                }

                /* point entry in root table to sub-table */
                low = huff & mask
                /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
                table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0
              }
            }

            /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
            if (huff !== 0) {
              //table.op[next + huff] = 64;            /* invalid code marker */
              //table.bits[next + huff] = len - drop;
              //table.val[next + huff] = 0;
              table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0
            }

            /* set return parameters */
            //opts.table_index += used;
            opts.bits = root
            return 0
          }

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/messages.js':
        /*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
        /***/ (module) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          module.exports = {
            2: 'need dictionary' /* Z_NEED_DICT       2  */,
            1: 'stream end' /* Z_STREAM_END      1  */,
            0: '' /* Z_OK              0  */,
            '-1': 'file error' /* Z_ERRNO         (-1) */,
            '-2': 'stream error' /* Z_STREAM_ERROR  (-2) */,
            '-3': 'data error' /* Z_DATA_ERROR    (-3) */,
            '-4': 'insufficient memory' /* Z_MEM_ERROR     (-4) */,
            '-5': 'buffer error' /* Z_BUF_ERROR     (-5) */,
            '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
          }

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/trees.js':
        /*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          /* eslint-disable space-unary-ops */

          var utils = __webpack_require__(
            /*! ../utils/common */ './node_modules/pako/lib/utils/common.js'
          )

          /* Public constants ==========================================================*/
          /* ===========================================================================*/

          //var Z_FILTERED          = 1;
          //var Z_HUFFMAN_ONLY      = 2;
          //var Z_RLE               = 3;
          var Z_FIXED = 4
          //var Z_DEFAULT_STRATEGY  = 0;

          /* Possible values of the data_type field (though see inflate()) */
          var Z_BINARY = 0
          var Z_TEXT = 1
          //var Z_ASCII             = 1; // = Z_TEXT
          var Z_UNKNOWN = 2

          /*============================================================================*/

          function zero(buf) {
            var len = buf.length
            while (--len >= 0) {
              buf[len] = 0
            }
          }

          // From zutil.h

          var STORED_BLOCK = 0
          var STATIC_TREES = 1
          var DYN_TREES = 2
          /* The three kinds of block type */

          var MIN_MATCH = 3
          var MAX_MATCH = 258
          /* The minimum and maximum match lengths */

          // From deflate.h
          /* ===========================================================================
           * Internal compression state.
           */

          var LENGTH_CODES = 29
          /* number of length codes, not counting the special END_BLOCK code */

          var LITERALS = 256
          /* number of literal bytes 0..255 */

          var L_CODES = LITERALS + 1 + LENGTH_CODES
          /* number of Literal or Length codes, including the END_BLOCK code */

          var D_CODES = 30
          /* number of distance codes */

          var BL_CODES = 19
          /* number of codes used to transfer the bit lengths */

          var HEAP_SIZE = 2 * L_CODES + 1
          /* maximum heap size */

          var MAX_BITS = 15
          /* All codes must not exceed MAX_BITS bits */

          var Buf_size = 16
          /* size of bit buffer in bi_buf */

          /* ===========================================================================
           * Constants
           */

          var MAX_BL_BITS = 7
          /* Bit length codes must not exceed MAX_BL_BITS bits */

          var END_BLOCK = 256
          /* end of block literal code */

          var REP_3_6 = 16
          /* repeat previous bit length 3-6 times (2 bits of repeat count) */

          var REPZ_3_10 = 17
          /* repeat a zero length 3-10 times  (3 bits of repeat count) */

          var REPZ_11_138 = 18
          /* repeat a zero length 11-138 times  (7 bits of repeat count) */

          /* eslint-disable comma-spacing,array-bracket-spacing */
          var extra_lbits =
            /* extra bits for each length code */
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]

          var extra_dbits =
            /* extra bits for each distance code */
            [
              0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12,
              12, 13, 13
            ]

          var extra_blbits =
            /* extra bits for each bit length code */
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]

          var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          /* eslint-enable comma-spacing,array-bracket-spacing */

          /* The lengths of the bit length codes are sent in order of decreasing
           * probability, to avoid transmitting the lengths for unused bit length codes.
           */

          /* ===========================================================================
           * Local data. These are initialized only once.
           */

          // We pre-fill arrays with 0 to avoid uninitialized gaps

          var DIST_CODE_LEN = 512 /* see definition of array dist_code below */

          // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
          var static_ltree = new Array((L_CODES + 2) * 2)
          zero(static_ltree)
          /* The static literal tree. Since the bit lengths are imposed, there is no
           * need for the L_CODES extra codes used during heap construction. However
           * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
           * below).
           */

          var static_dtree = new Array(D_CODES * 2)
          zero(static_dtree)
          /* The static distance tree. (Actually a trivial tree since all codes use
           * 5 bits.)
           */

          var _dist_code = new Array(DIST_CODE_LEN)
          zero(_dist_code)
          /* Distance codes. The first 256 values correspond to the distances
           * 3 .. 258, the last 256 values correspond to the top 8 bits of
           * the 15 bit distances.
           */

          var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1)
          zero(_length_code)
          /* length code for each normalized match length (0 == MIN_MATCH) */

          var base_length = new Array(LENGTH_CODES)
          zero(base_length)
          /* First normalized length for each code (0 = MIN_MATCH) */

          var base_dist = new Array(D_CODES)
          zero(base_dist)
          /* First normalized distance for each code (0 = distance of 1) */

          function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
            this.static_tree = static_tree /* static tree or NULL */
            this.extra_bits = extra_bits /* extra bits for each code or NULL */
            this.extra_base = extra_base /* base index for extra_bits */
            this.elems = elems /* max number of elements in the tree */
            this.max_length = max_length /* max bit length for the codes */

            // show if `static_tree` has data or dummy - needed for monomorphic objects
            this.has_stree = static_tree && static_tree.length
          }

          var static_l_desc
          var static_d_desc
          var static_bl_desc

          function TreeDesc(dyn_tree, stat_desc) {
            this.dyn_tree = dyn_tree /* the dynamic tree */
            this.max_code = 0 /* largest code with non zero frequency */
            this.stat_desc = stat_desc /* the corresponding static tree */
          }

          function d_code(dist) {
            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
          }

          /* ===========================================================================
           * Output a short LSB first on the stream.
           * IN assertion: there is enough room in pendingBuf.
           */
          function put_short(s, w) {
            //    put_byte(s, (uch)((w) & 0xff));
            //    put_byte(s, (uch)((ush)(w) >> 8));
            s.pending_buf[s.pending++] = w & 0xff
            s.pending_buf[s.pending++] = (w >>> 8) & 0xff
          }

          /* ===========================================================================
           * Send a value on a given number of bits.
           * IN assertion: length <= 16 and value fits in length bits.
           */
          function send_bits(s, value, length) {
            if (s.bi_valid > Buf_size - length) {
              s.bi_buf |= (value << s.bi_valid) & 0xffff
              put_short(s, s.bi_buf)
              s.bi_buf = value >> (Buf_size - s.bi_valid)
              s.bi_valid += length - Buf_size
            } else {
              s.bi_buf |= (value << s.bi_valid) & 0xffff
              s.bi_valid += length
            }
          }

          function send_code(s, c, tree) {
            send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/)
          }

          /* ===========================================================================
           * Reverse the first len bits of a code, using straightforward code (a faster
           * method would use a table)
           * IN assertion: 1 <= len <= 15
           */
          function bi_reverse(code, len) {
            var res = 0
            do {
              res |= code & 1
              code >>>= 1
              res <<= 1
            } while (--len > 0)
            return res >>> 1
          }

          /* ===========================================================================
           * Flush the bit buffer, keeping at most 7 bits in it.
           */
          function bi_flush(s) {
            if (s.bi_valid === 16) {
              put_short(s, s.bi_buf)
              s.bi_buf = 0
              s.bi_valid = 0
            } else if (s.bi_valid >= 8) {
              s.pending_buf[s.pending++] = s.bi_buf & 0xff
              s.bi_buf >>= 8
              s.bi_valid -= 8
            }
          }

          /* ===========================================================================
           * Compute the optimal bit lengths for a tree and update the total bit length
           * for the current block.
           * IN assertion: the fields freq and dad are set, heap[heap_max] and
           *    above are the tree nodes sorted by increasing frequency.
           * OUT assertions: the field len is set to the optimal bit length, the
           *     array bl_count contains the frequencies for each bit length.
           *     The length opt_len is updated; static_len is also updated if stree is
           *     not null.
           */
          function gen_bitlen(s, desc) {
            //    deflate_state *s;
            //    tree_desc *desc;    /* the tree descriptor */
            var tree = desc.dyn_tree
            var max_code = desc.max_code
            var stree = desc.stat_desc.static_tree
            var has_stree = desc.stat_desc.has_stree
            var extra = desc.stat_desc.extra_bits
            var base = desc.stat_desc.extra_base
            var max_length = desc.stat_desc.max_length
            var h /* heap index */
            var n, m /* iterate over the tree elements */
            var bits /* bit length */
            var xbits /* extra bits */
            var f /* frequency */
            var overflow = 0 /* number of elements with bit length too large */

            for (bits = 0; bits <= MAX_BITS; bits++) {
              s.bl_count[bits] = 0
            }

            /* In a first pass, compute the optimal bit lengths (which may
             * overflow in the case of the bit length tree).
             */
            tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0 /* root of the heap */

            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
              n = s.heap[h]
              bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1
              if (bits > max_length) {
                bits = max_length
                overflow++
              }
              tree[n * 2 + 1] /*.Len*/ = bits
              /* We overwrite tree[n].Dad which is no longer needed */

              if (n > max_code) {
                continue
              } /* not a leaf node */

              s.bl_count[bits]++
              xbits = 0
              if (n >= base) {
                xbits = extra[n - base]
              }
              f = tree[n * 2] /*.Freq*/
              s.opt_len += f * (bits + xbits)
              if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits)
              }
            }
            if (overflow === 0) {
              return
            }

            // Trace((stderr,"\nbit length overflow\n"));
            /* This happens for example on obj2 and pic of the Calgary corpus */

            /* Find the first bit length which could increase: */
            do {
              bits = max_length - 1
              while (s.bl_count[bits] === 0) {
                bits--
              }
              s.bl_count[bits]-- /* move one leaf down the tree */
              s.bl_count[bits + 1] += 2 /* move one overflow item as its brother */
              s.bl_count[max_length]--
              /* The brother of the overflow item also moves one step up,
               * but this does not affect bl_count[max_length]
               */
              overflow -= 2
            } while (overflow > 0)

            /* Now recompute all bit lengths, scanning in increasing frequency.
             * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
             * lengths instead of fixing only the wrong ones. This idea is taken
             * from 'ar' written by Haruhiko Okumura.)
             */
            for (bits = max_length; bits !== 0; bits--) {
              n = s.bl_count[bits]
              while (n !== 0) {
                m = s.heap[--h]
                if (m > max_code) {
                  continue
                }
                if (tree[m * 2 + 1] /*.Len*/ !== bits) {
                  // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                  s.opt_len += (bits - tree[m * 2 + 1]) /*.Len*/ * tree[m * 2] /*.Freq*/
                  tree[m * 2 + 1] /*.Len*/ = bits
                }
                n--
              }
            }
          }

          /* ===========================================================================
           * Generate the codes for a given tree and bit counts (which need not be
           * optimal).
           * IN assertion: the array bl_count contains the bit length statistics for
           * the given tree and the field len is set for all tree elements.
           * OUT assertion: the field code is set for all tree elements of non
           *     zero code length.
           */
          function gen_codes(tree, max_code, bl_count) {
            //    ct_data *tree;             /* the tree to decorate */
            //    int max_code;              /* largest code with non zero frequency */
            //    ushf *bl_count;            /* number of codes at each bit length */
            var next_code = new Array(MAX_BITS + 1) /* next code value for each bit length */
            var code = 0 /* running code value */
            var bits /* bit index */
            var n /* code index */

            /* The distribution counts are first used to generate the code values
             * without bit reversal.
             */
            for (bits = 1; bits <= MAX_BITS; bits++) {
              next_code[bits] = code = (code + bl_count[bits - 1]) << 1
            }
            /* Check that the bit counts in bl_count are consistent. The last code
             * must be all ones.
             */
            //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            //        "inconsistent bit counts");
            //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

            for (n = 0; n <= max_code; n++) {
              var len = tree[n * 2 + 1] /*.Len*/
              if (len === 0) {
                continue
              }
              /* Now reverse the bits */
              tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len)

              //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
              //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
            }
          }

          /* ===========================================================================
           * Initialize the various 'constant' tables.
           */
          function tr_static_init() {
            var n /* iterates over tree elements */
            var bits /* bit counter */
            var length /* length value */
            var code /* code value */
            var dist /* distance index */
            var bl_count = new Array(MAX_BITS + 1)
            /* number of codes at each bit length for an optimal tree */

            // do check in _tr_init()
            //if (static_init_done) return;

            /* For some embedded targets, global variables are not initialized: */
            /*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

            /* Initialize the mapping length (0..255) -> length code (0..28) */
            length = 0
            for (code = 0; code < LENGTH_CODES - 1; code++) {
              base_length[code] = length
              for (n = 0; n < 1 << extra_lbits[code]; n++) {
                _length_code[length++] = code
              }
            }
            //Assert (length == 256, "tr_static_init: length != 256");
            /* Note that the length 255 (match length 258) can be represented
             * in two different ways: code 284 + 5 bits or code 285, so we
             * overwrite length_code[255] to use the best encoding:
             */
            _length_code[length - 1] = code

            /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
            dist = 0
            for (code = 0; code < 16; code++) {
              base_dist[code] = dist
              for (n = 0; n < 1 << extra_dbits[code]; n++) {
                _dist_code[dist++] = code
              }
            }
            //Assert (dist == 256, "tr_static_init: dist != 256");
            dist >>= 7 /* from now on, all distances are divided by 128 */
            for (; code < D_CODES; code++) {
              base_dist[code] = dist << 7
              for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {
                _dist_code[256 + dist++] = code
              }
            }
            //Assert (dist == 256, "tr_static_init: 256+dist != 512");

            /* Construct the codes of the static literal tree */
            for (bits = 0; bits <= MAX_BITS; bits++) {
              bl_count[bits] = 0
            }

            n = 0
            while (n <= 143) {
              static_ltree[n * 2 + 1] /*.Len*/ = 8
              n++
              bl_count[8]++
            }
            while (n <= 255) {
              static_ltree[n * 2 + 1] /*.Len*/ = 9
              n++
              bl_count[9]++
            }
            while (n <= 279) {
              static_ltree[n * 2 + 1] /*.Len*/ = 7
              n++
              bl_count[7]++
            }
            while (n <= 287) {
              static_ltree[n * 2 + 1] /*.Len*/ = 8
              n++
              bl_count[8]++
            }
            /* Codes 286 and 287 do not exist, but we must include them in the
             * tree construction to get a canonical Huffman tree (longest code
             * all ones)
             */
            gen_codes(static_ltree, L_CODES + 1, bl_count)

            /* The static distance tree is trivial: */
            for (n = 0; n < D_CODES; n++) {
              static_dtree[n * 2 + 1] /*.Len*/ = 5
              static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5)
            }

            // Now data ready and we can init static trees
            static_l_desc = new StaticTreeDesc(
              static_ltree,
              extra_lbits,
              LITERALS + 1,
              L_CODES,
              MAX_BITS
            )
            static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS)
            static_bl_desc = new StaticTreeDesc(
              new Array(0),
              extra_blbits,
              0,
              BL_CODES,
              MAX_BL_BITS
            )

            //static_init_done = true;
          }

          /* ===========================================================================
           * Initialize a new block.
           */
          function init_block(s) {
            var n /* iterates over tree elements */

            /* Initialize the trees. */
            for (n = 0; n < L_CODES; n++) {
              s.dyn_ltree[n * 2] /*.Freq*/ = 0
            }
            for (n = 0; n < D_CODES; n++) {
              s.dyn_dtree[n * 2] /*.Freq*/ = 0
            }
            for (n = 0; n < BL_CODES; n++) {
              s.bl_tree[n * 2] /*.Freq*/ = 0
            }

            s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1
            s.opt_len = s.static_len = 0
            s.last_lit = s.matches = 0
          }

          /* ===========================================================================
           * Flush the bit buffer and align the output on a byte boundary
           */
          function bi_windup(s) {
            if (s.bi_valid > 8) {
              put_short(s, s.bi_buf)
            } else if (s.bi_valid > 0) {
              //put_byte(s, (Byte)s->bi_buf);
              s.pending_buf[s.pending++] = s.bi_buf
            }
            s.bi_buf = 0
            s.bi_valid = 0
          }

          /* ===========================================================================
           * Copy a stored block, storing first the length and its
           * one's complement if requested.
           */
          function copy_block(s, buf, len, header) {
            //DeflateState *s;
            //charf    *buf;    /* the input data */
            //unsigned len;     /* its length */
            //int      header;  /* true if block header must be written */
            bi_windup(s) /* align on byte boundary */

            if (header) {
              put_short(s, len)
              put_short(s, ~len)
            }
            //  while (len--) {
            //    put_byte(s, *buf++);
            //  }
            utils.arraySet(s.pending_buf, s.window, buf, len, s.pending)
            s.pending += len
          }

          /* ===========================================================================
           * Compares to subtrees, using the tree depth as tie breaker when
           * the subtrees have equal frequency. This minimizes the worst case length.
           */
          function smaller(tree, n, m, depth) {
            var _n2 = n * 2
            var _m2 = m * 2
            return (
              tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ ||
              (tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m])
            )
          }

          /* ===========================================================================
           * Restore the heap property by moving down the tree starting at node k,
           * exchanging a node with the smallest of its two sons if necessary, stopping
           * when the heap property is re-established (each father smaller than its
           * two sons).
           */
          function pqdownheap(s, tree, k) {
            //    deflate_state *s;
            //    ct_data *tree;  /* the tree to restore */
            //    int k;               /* node to move down */
            var v = s.heap[k]
            var j = k << 1 /* left son of k */
            while (j <= s.heap_len) {
              /* Set j to the smallest of the two sons: */
              if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++
              }
              /* Exit if v is smaller than both sons */
              if (smaller(tree, v, s.heap[j], s.depth)) {
                break
              }

              /* Exchange v with the smallest son */
              s.heap[k] = s.heap[j]
              k = j

              /* And continue down the tree, setting j to the left son of k */
              j <<= 1
            }
            s.heap[k] = v
          }

          // inlined manually
          // var SMALLEST = 1;

          /* ===========================================================================
           * Send the block data compressed using the given Huffman trees
           */
          function compress_block(s, ltree, dtree) {
            //    deflate_state *s;
            //    const ct_data *ltree; /* literal tree */
            //    const ct_data *dtree; /* distance tree */
            var dist /* distance of matched string */
            var lc /* match length or unmatched char (if dist == 0) */
            var lx = 0 /* running index in l_buf */
            var code /* the code to send */
            var extra /* number of extra bits to send */

            if (s.last_lit !== 0) {
              do {
                dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1]
                lc = s.pending_buf[s.l_buf + lx]
                lx++

                if (dist === 0) {
                  send_code(s, lc, ltree) /* send a literal byte */
                  //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                } else {
                  /* Here, lc is the match length - MIN_MATCH */
                  code = _length_code[lc]
                  send_code(s, code + LITERALS + 1, ltree) /* send the length code */
                  extra = extra_lbits[code]
                  if (extra !== 0) {
                    lc -= base_length[code]
                    send_bits(s, lc, extra) /* send the extra length bits */
                  }
                  dist-- /* dist is now the match distance - 1 */
                  code = d_code(dist)
                  //Assert (code < D_CODES, "bad d_code");

                  send_code(s, code, dtree) /* send the distance code */
                  extra = extra_dbits[code]
                  if (extra !== 0) {
                    dist -= base_dist[code]
                    send_bits(s, dist, extra) /* send the extra distance bits */
                  }
                } /* literal or match pair ? */

                /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                //       "pendingBuf overflow");
              } while (lx < s.last_lit)
            }

            send_code(s, END_BLOCK, ltree)
          }

          /* ===========================================================================
           * Construct one Huffman tree and assigns the code bit strings and lengths.
           * Update the total bit length for the current block.
           * IN assertion: the field freq is set for all tree elements.
           * OUT assertions: the fields len and code are set to the optimal bit length
           *     and corresponding code. The length opt_len is updated; static_len is
           *     also updated if stree is not null. The field max_code is set.
           */
          function build_tree(s, desc) {
            //    deflate_state *s;
            //    tree_desc *desc; /* the tree descriptor */
            var tree = desc.dyn_tree
            var stree = desc.stat_desc.static_tree
            var has_stree = desc.stat_desc.has_stree
            var elems = desc.stat_desc.elems
            var n, m /* iterate over heap elements */
            var max_code = -1 /* largest code with non zero frequency */
            var node /* new node being created */

            /* Construct the initial heap, with least frequent element in
             * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
             * heap[0] is not used.
             */
            s.heap_len = 0
            s.heap_max = HEAP_SIZE

            for (n = 0; n < elems; n++) {
              if (tree[n * 2] /*.Freq*/ !== 0) {
                s.heap[++s.heap_len] = max_code = n
                s.depth[n] = 0
              } else {
                tree[n * 2 + 1] /*.Len*/ = 0
              }
            }

            /* The pkzip format requires that at least one distance code exists,
             * and that at least one bit should be sent even if there is only one
             * possible code. So to avoid special checks later on we force at least
             * two codes of non zero frequency.
             */
            while (s.heap_len < 2) {
              node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0
              tree[node * 2] /*.Freq*/ = 1
              s.depth[node] = 0
              s.opt_len--

              if (has_stree) {
                s.static_len -= stree[node * 2 + 1] /*.Len*/
              }
              /* node is 0 or 1 so it does not have extra bits */
            }
            desc.max_code = max_code

            /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
             * establish sub-heaps of increasing lengths:
             */
            for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
              pqdownheap(s, tree, n)
            }

            /* Construct the Huffman tree by repeatedly combining the least two
             * frequent nodes.
             */
            node = elems /* next internal node of the tree */
            do {
              //pqremove(s, tree, n);  /* n = node of least frequency */
              /*** pqremove ***/
              n = s.heap[1 /*SMALLEST*/]
              s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--]
              pqdownheap(s, tree, 1 /*SMALLEST*/)
              /***/

              m = s.heap[1 /*SMALLEST*/] /* m = node of next least frequency */

              s.heap[--s.heap_max] = n /* keep the nodes sorted by frequency */
              s.heap[--s.heap_max] = m

              /* Create a new node father of n and m */
              tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/
              s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1
              tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node

              /* and insert the new node in the heap */
              s.heap[1 /*SMALLEST*/] = node++
              pqdownheap(s, tree, 1 /*SMALLEST*/)
            } while (s.heap_len >= 2)

            s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/]

            /* At this point, the fields freq and dad are set. We can now
             * generate the bit lengths.
             */
            gen_bitlen(s, desc)

            /* The field len is now set, we can generate the bit codes */
            gen_codes(tree, max_code, s.bl_count)
          }

          /* ===========================================================================
           * Scan a literal or distance tree to determine the frequencies of the codes
           * in the bit length tree.
           */
          function scan_tree(s, tree, max_code) {
            //    deflate_state *s;
            //    ct_data *tree;   /* the tree to be scanned */
            //    int max_code;    /* and its largest code of non zero frequency */
            var n /* iterates over all tree elements */
            var prevlen = -1 /* last emitted length */
            var curlen /* length of current code */

            var nextlen = tree[0 * 2 + 1] /*.Len*/ /* length of next code */

            var count = 0 /* repeat count of the current code */
            var max_count = 7 /* max repeat count */
            var min_count = 4 /* min repeat count */

            if (nextlen === 0) {
              max_count = 138
              min_count = 3
            }
            tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff /* guard */

            for (n = 0; n <= max_code; n++) {
              curlen = nextlen
              nextlen = tree[(n + 1) * 2 + 1] /*.Len*/

              if (++count < max_count && curlen === nextlen) {
                continue
              } else if (count < min_count) {
                s.bl_tree[curlen * 2] /*.Freq*/ += count
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  s.bl_tree[curlen * 2] /*.Freq*/++
                }
                s.bl_tree[REP_3_6 * 2] /*.Freq*/++
              } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++
              } else {
                s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++
              }

              count = 0
              prevlen = curlen

              if (nextlen === 0) {
                max_count = 138
                min_count = 3
              } else if (curlen === nextlen) {
                max_count = 6
                min_count = 3
              } else {
                max_count = 7
                min_count = 4
              }
            }
          }

          /* ===========================================================================
           * Send a literal or distance tree in compressed form, using the codes in
           * bl_tree.
           */
          function send_tree(s, tree, max_code) {
            //    deflate_state *s;
            //    ct_data *tree; /* the tree to be scanned */
            //    int max_code;       /* and its largest code of non zero frequency */
            var n /* iterates over all tree elements */
            var prevlen = -1 /* last emitted length */
            var curlen /* length of current code */

            var nextlen = tree[0 * 2 + 1] /*.Len*/ /* length of next code */

            var count = 0 /* repeat count of the current code */
            var max_count = 7 /* max repeat count */
            var min_count = 4 /* min repeat count */

            /* tree[max_code+1].Len = -1; */ /* guard already set */
            if (nextlen === 0) {
              max_count = 138
              min_count = 3
            }

            for (n = 0; n <= max_code; n++) {
              curlen = nextlen
              nextlen = tree[(n + 1) * 2 + 1] /*.Len*/

              if (++count < max_count && curlen === nextlen) {
                continue
              } else if (count < min_count) {
                do {
                  send_code(s, curlen, s.bl_tree)
                } while (--count !== 0)
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  send_code(s, curlen, s.bl_tree)
                  count--
                }
                //Assert(count >= 3 && count <= 6, " 3_6?");
                send_code(s, REP_3_6, s.bl_tree)
                send_bits(s, count - 3, 2)
              } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree)
                send_bits(s, count - 3, 3)
              } else {
                send_code(s, REPZ_11_138, s.bl_tree)
                send_bits(s, count - 11, 7)
              }

              count = 0
              prevlen = curlen
              if (nextlen === 0) {
                max_count = 138
                min_count = 3
              } else if (curlen === nextlen) {
                max_count = 6
                min_count = 3
              } else {
                max_count = 7
                min_count = 4
              }
            }
          }

          /* ===========================================================================
           * Construct the Huffman tree for the bit lengths and return the index in
           * bl_order of the last bit length code to send.
           */
          function build_bl_tree(s) {
            var max_blindex /* index of last bit length code of non zero freq */

            /* Determine the bit length frequencies for literal and distance trees */
            scan_tree(s, s.dyn_ltree, s.l_desc.max_code)
            scan_tree(s, s.dyn_dtree, s.d_desc.max_code)

            /* Build the bit length tree: */
            build_tree(s, s.bl_desc)
            /* opt_len now includes the length of the tree representations, except
             * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
             */

            /* Determine the number of bit length codes to send. The pkzip format
             * requires that at least 4 bit length codes be sent. (appnote.txt says
             * 3 but the actual value used is 4.)
             */
            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
              if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
                break
              }
            }
            /* Update opt_len to include the bit length tree and counts */
            s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4
            //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            //        s->opt_len, s->static_len));

            return max_blindex
          }

          /* ===========================================================================
           * Send the header for a block using dynamic Huffman trees: the counts, the
           * lengths of the bit length codes, the literal tree and the distance tree.
           * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
           */
          function send_all_trees(s, lcodes, dcodes, blcodes) {
            //    deflate_state *s;
            //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
            var rank /* index in bl_order */

            //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
            //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            //        "too many codes");
            //Tracev((stderr, "\nbl counts: "));
            send_bits(s, lcodes - 257, 5) /* not +255 as stated in appnote.txt */
            send_bits(s, dcodes - 1, 5)
            send_bits(s, blcodes - 4, 4) /* not -3 as stated in appnote.txt */
            for (rank = 0; rank < blcodes; rank++) {
              //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
              send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3)
            }
            //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

            send_tree(s, s.dyn_ltree, lcodes - 1) /* literal tree */
            //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

            send_tree(s, s.dyn_dtree, dcodes - 1) /* distance tree */
            //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
          }

          /* ===========================================================================
           * Check if the data type is TEXT or BINARY, using the following algorithm:
           * - TEXT if the two conditions below are satisfied:
           *    a) There are no non-portable control characters belonging to the
           *       "black list" (0..6, 14..25, 28..31).
           *    b) There is at least one printable character belonging to the
           *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
           * - BINARY otherwise.
           * - The following partially-portable control characters form a
           *   "gray list" that is ignored in this detection algorithm:
           *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
           * IN assertion: the fields Freq of dyn_ltree are set.
           */
          function detect_data_type(s) {
            /* black_mask is the bit mask of black-listed bytes
             * set bits 0..6, 14..25, and 28..31
             * 0xf3ffc07f = binary 11110011111111111100000001111111
             */
            var black_mask = 0xf3ffc07f
            var n

            /* Check for non-textual ("black-listed") bytes. */
            for (n = 0; n <= 31; n++, black_mask >>>= 1) {
              if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
                return Z_BINARY
              }
            }

            /* Check for textual ("white-listed") bytes. */
            if (
              s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 ||
              s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 ||
              s.dyn_ltree[13 * 2] /*.Freq*/ !== 0
            ) {
              return Z_TEXT
            }
            for (n = 32; n < LITERALS; n++) {
              if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
                return Z_TEXT
              }
            }

            /* There are no "black-listed" or "white-listed" bytes:
             * this stream either is empty or has tolerated ("gray-listed") bytes only.
             */
            return Z_BINARY
          }

          var static_init_done = false

          /* ===========================================================================
           * Initialize the tree data structures for a new zlib stream.
           */
          function _tr_init(s) {
            if (!static_init_done) {
              tr_static_init()
              static_init_done = true
            }

            s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc)
            s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc)
            s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc)

            s.bi_buf = 0
            s.bi_valid = 0

            /* Initialize the first block of the first file: */
            init_block(s)
          }

          /* ===========================================================================
           * Send a stored block
           */
          function _tr_stored_block(s, buf, stored_len, last) {
            //DeflateState *s;
            //charf *buf;       /* input block */
            //ulg stored_len;   /* length of input block */
            //int last;         /* one if this is the last block for a file */
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3) /* send block type */
            copy_block(s, buf, stored_len, true) /* with header */
          }

          /* ===========================================================================
           * Send one empty static block to give enough lookahead for inflate.
           * This takes 10 bits, of which 7 may remain in the bit buffer.
           */
          function _tr_align(s) {
            send_bits(s, STATIC_TREES << 1, 3)
            send_code(s, END_BLOCK, static_ltree)
            bi_flush(s)
          }

          /* ===========================================================================
           * Determine the best encoding for the current block: dynamic trees, static
           * trees or store, and output the encoded block to the zip file.
           */
          function _tr_flush_block(s, buf, stored_len, last) {
            //DeflateState *s;
            //charf *buf;       /* input block, or NULL if too old */
            //ulg stored_len;   /* length of input block */
            //int last;         /* one if this is the last block for a file */
            var opt_lenb, static_lenb /* opt_len and static_len in bytes */
            var max_blindex = 0 /* index of last bit length code of non zero freq */

            /* Build the Huffman trees unless a stored block is forced */
            if (s.level > 0) {
              /* Check if the file is binary or text */
              if (s.strm.data_type === Z_UNKNOWN) {
                s.strm.data_type = detect_data_type(s)
              }

              /* Construct the literal and distance trees */
              build_tree(s, s.l_desc)
              // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
              //        s->static_len));

              build_tree(s, s.d_desc)
              // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
              //        s->static_len));
              /* At this point, opt_len and static_len are the total bit lengths of
               * the compressed block data, excluding the tree representations.
               */

              /* Build the bit length tree for the above two trees, and get the index
               * in bl_order of the last bit length code to send.
               */
              max_blindex = build_bl_tree(s)

              /* Determine the best encoding. Compute the block lengths in bytes. */
              opt_lenb = (s.opt_len + 3 + 7) >>> 3
              static_lenb = (s.static_len + 3 + 7) >>> 3

              // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
              //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
              //        s->last_lit));

              if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb
              }
            } else {
              // Assert(buf != (char*)0, "lost buf");
              opt_lenb = static_lenb = stored_len + 5 /* force a stored block */
            }

            if (stored_len + 4 <= opt_lenb && buf !== -1) {
              /* 4: two words for the lengths */

              /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
               * Otherwise we can't have processed more than WSIZE input bytes since
               * the last block flush, because compression would have been
               * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
               * transform a block into a stored block.
               */
              _tr_stored_block(s, buf, stored_len, last)
            } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
              send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3)
              compress_block(s, static_ltree, static_dtree)
            } else {
              send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3)
              send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1)
              compress_block(s, s.dyn_ltree, s.dyn_dtree)
            }
            // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
            /* The above check is made mod 2^32, for files larger than 512 MB
             * and uLong implemented on 32 bits.
             */
            init_block(s)

            if (last) {
              bi_windup(s)
            }
            // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
            //       s->compressed_len-7*last));
          }

          /* ===========================================================================
           * Save the match info and tally the frequency counts. Return true if
           * the current block must be flushed.
           */
          function _tr_tally(s, dist, lc) {
            //    deflate_state *s;
            //    unsigned dist;  /* distance of matched string */
            //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
            //var out_length, in_length, dcode;

            s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff
            s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff

            s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff
            s.last_lit++

            if (dist === 0) {
              /* lc is the unmatched char */
              s.dyn_ltree[lc * 2] /*.Freq*/++
            } else {
              s.matches++
              /* Here, lc is the match length - MIN_MATCH */
              dist-- /* dist = match distance - 1 */
              //Assert((ush)dist < (ush)MAX_DIST(s) &&
              //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
              //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

              s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++
              s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++
            }

            // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility

            //#ifdef TRUNCATE_BLOCK
            //  /* Try to guess if it is profitable to stop the current block here */
            //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
            //    /* Compute an upper bound for the compressed length */
            //    out_length = s.last_lit*8;
            //    in_length = s.strstart - s.block_start;
            //
            //    for (dcode = 0; dcode < D_CODES; dcode++) {
            //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
            //    }
            //    out_length >>>= 3;
            //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
            //    //       s->last_lit, in_length, out_length,
            //    //       100L - out_length*100L/in_length));
            //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
            //      return true;
            //    }
            //  }
            //#endif

            return s.last_lit === s.lit_bufsize - 1
            /* We avoid equality with lit_bufsize because of wraparound at 64K
             * on 16 bit machines and because stored blocks are restricted to
             * 64K-1 bytes.
             */
          }

          exports._tr_init = _tr_init
          exports._tr_stored_block = _tr_stored_block
          exports._tr_flush_block = _tr_flush_block
          exports._tr_tally = _tr_tally
          exports._tr_align = _tr_align

          /***/
        },

      /***/ './node_modules/pako/lib/zlib/zstream.js':
        /*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
        /***/ (module) => {
          'use strict'

          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          function ZStream() {
            /* next input byte */
            this.input = null // JS specific, because we have no pointers
            this.next_in = 0
            /* number of bytes available at input */
            this.avail_in = 0
            /* total number of input bytes read so far */
            this.total_in = 0
            /* next output byte should be put there */
            this.output = null // JS specific, because we have no pointers
            this.next_out = 0
            /* remaining free space at output */
            this.avail_out = 0
            /* total number of bytes output so far */
            this.total_out = 0
            /* last error message, NULL if no error */
            this.msg = '' /*Z_NULL*/
            /* not visible by applications */
            this.state = null
            /* best guess about the data type: binary or text */
            this.data_type = 2 /*Z_UNKNOWN*/
            /* adler32 value of the uncompressed data */
            this.adler = 0
          }

          module.exports = ZStream

          /***/
        },

      /***/ './node_modules/path-is-absolute/index.js':
        /*!************************************************!*\
  !*** ./node_modules/path-is-absolute/index.js ***!
  \************************************************/
        /***/ (module) => {
          'use strict'

          function posix(path) {
            return path.charAt(0) === '/'
          }

          function win32(path) {
            // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
            var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
            var result = splitDeviceRe.exec(path)
            var device = result[1] || ''
            var isUnc = Boolean(device && device.charAt(1) !== ':')

            // UNC paths are always absolute
            return Boolean(result[2] || isUnc)
          }

          module.exports = process.platform === 'win32' ? win32 : posix
          module.exports.posix = posix
          module.exports.win32 = win32

          /***/
        },

      /***/ './node_modules/process-nextick-args/index.js':
        /*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
        /***/ (module) => {
          'use strict'

          if (
            typeof process === 'undefined' ||
            !process.version ||
            process.version.indexOf('v0.') === 0 ||
            (process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0)
          ) {
            module.exports = { nextTick: nextTick }
          } else {
            module.exports = process
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== 'function') {
              throw new TypeError('"callback" argument must be a function')
            }
            var len = arguments.length
            var args, i
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn)
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1)
                })
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2)
                })
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3)
                })
              default:
                args = new Array(len - 1)
                i = 0
                while (i < args.length) {
                  args[i++] = arguments[i]
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args)
                })
            }
          }

          /***/
        },

      /***/ './node_modules/rimraf/rimraf.js':
        /*!***************************************!*\
  !*** ./node_modules/rimraf/rimraf.js ***!
  \***************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          const assert = __webpack_require__(/*! assert */ 'assert')
          const path = __webpack_require__(/*! path */ 'path')
          const fs = __webpack_require__(/*! fs */ 'fs')
          let glob = undefined
          try {
            glob = __webpack_require__(/*! glob */ './node_modules/glob/glob.js')
          } catch (_err) {
            // treat glob as optional.
          }

          const defaultGlobOpts = {
            nosort: true,
            silent: true
          }

          // for EMFILE handling
          let timeout = 0

          const isWindows = process.platform === 'win32'

          const defaults = (options) => {
            const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir']
            methods.forEach((m) => {
              options[m] = options[m] || fs[m]
              m = m + 'Sync'
              options[m] = options[m] || fs[m]
            })

            options.maxBusyTries = options.maxBusyTries || 3
            options.emfileWait = options.emfileWait || 1000
            if (options.glob === false) {
              options.disableGlob = true
            }
            if (options.disableGlob !== true && glob === undefined) {
              throw Error(
                'glob dependency not found, set `options.disableGlob = true` if intentional'
              )
            }
            options.disableGlob = options.disableGlob || false
            options.glob = options.glob || defaultGlobOpts
          }

          const rimraf = (p, options, cb) => {
            if (typeof options === 'function') {
              cb = options
              options = {}
            }

            assert(p, 'rimraf: missing path')
            assert.equal(typeof p, 'string', 'rimraf: path should be a string')
            assert.equal(typeof cb, 'function', 'rimraf: callback function required')
            assert(options, 'rimraf: invalid options argument provided')
            assert.equal(typeof options, 'object', 'rimraf: options should be object')

            defaults(options)

            let busyTries = 0
            let errState = null
            let n = 0

            const next = (er) => {
              errState = errState || er
              if (--n === 0) cb(errState)
            }

            const afterGlob = (er, results) => {
              if (er) return cb(er)

              n = results.length
              if (n === 0) return cb()

              results.forEach((p) => {
                const CB = (er) => {
                  if (er) {
                    if (
                      (er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
                      busyTries < options.maxBusyTries
                    ) {
                      busyTries++
                      // try again, with the same exact callback as this one.
                      return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)
                    }

                    // this one won't happen if graceful-fs is used.
                    if (er.code === 'EMFILE' && timeout < options.emfileWait) {
                      return setTimeout(() => rimraf_(p, options, CB), timeout++)
                    }

                    // already gone
                    if (er.code === 'ENOENT') er = null
                  }

                  timeout = 0
                  next(er)
                }
                rimraf_(p, options, CB)
              })
            }

            if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [p])

            options.lstat(p, (er, stat) => {
              if (!er) return afterGlob(null, [p])

              glob(p, options.glob, afterGlob)
            })
          }

          // Two possible strategies.
          // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
          // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
          //
          // Both result in an extra syscall when you guess wrong.  However, there
          // are likely far more normal files in the world than directories.  This
          // is based on the assumption that a the average number of files per
          // directory is >= 1.
          //
          // If anyone ever complains about this, then I guess the strategy could
          // be made configurable somehow.  But until then, YAGNI.
          const rimraf_ = (p, options, cb) => {
            assert(p)
            assert(options)
            assert(typeof cb === 'function')

            // sunos lets the root user unlink directories, which is... weird.
            // so we have to lstat here and make sure it's not a dir.
            options.lstat(p, (er, st) => {
              if (er && er.code === 'ENOENT') return cb(null)

              // Windows can EPERM on stat.  Life is suffering.
              if (er && er.code === 'EPERM' && isWindows) fixWinEPERM(p, options, er, cb)

              if (st && st.isDirectory()) return rmdir(p, options, er, cb)

              options.unlink(p, (er) => {
                if (er) {
                  if (er.code === 'ENOENT') return cb(null)
                  if (er.code === 'EPERM')
                    return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb)
                  if (er.code === 'EISDIR') return rmdir(p, options, er, cb)
                }
                return cb(er)
              })
            })
          }

          const fixWinEPERM = (p, options, er, cb) => {
            assert(p)
            assert(options)
            assert(typeof cb === 'function')

            options.chmod(p, 0o666, (er2) => {
              if (er2) cb(er2.code === 'ENOENT' ? null : er)
              else
                options.stat(p, (er3, stats) => {
                  if (er3) cb(er3.code === 'ENOENT' ? null : er)
                  else if (stats.isDirectory()) rmdir(p, options, er, cb)
                  else options.unlink(p, cb)
                })
            })
          }

          const fixWinEPERMSync = (p, options, er) => {
            assert(p)
            assert(options)

            try {
              options.chmodSync(p, 0o666)
            } catch (er2) {
              if (er2.code === 'ENOENT') return
              else throw er
            }

            let stats
            try {
              stats = options.statSync(p)
            } catch (er3) {
              if (er3.code === 'ENOENT') return
              else throw er
            }

            if (stats.isDirectory()) rmdirSync(p, options, er)
            else options.unlinkSync(p)
          }

          const rmdir = (p, options, originalEr, cb) => {
            assert(p)
            assert(options)
            assert(typeof cb === 'function')

            // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
            // if we guessed wrong, and it's not a directory, then
            // raise the original error.
            options.rmdir(p, (er) => {
              if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM'))
                rmkids(p, options, cb)
              else if (er && er.code === 'ENOTDIR') cb(originalEr)
              else cb(er)
            })
          }

          const rmkids = (p, options, cb) => {
            assert(p)
            assert(options)
            assert(typeof cb === 'function')

            options.readdir(p, (er, files) => {
              if (er) return cb(er)
              let n = files.length
              if (n === 0) return options.rmdir(p, cb)
              let errState
              files.forEach((f) => {
                rimraf(path.join(p, f), options, (er) => {
                  if (errState) return
                  if (er) return cb((errState = er))
                  if (--n === 0) options.rmdir(p, cb)
                })
              })
            })
          }

          // this looks simpler, and is strictly *faster*, but will
          // tie up the JavaScript thread and fail on excessively
          // deep directory trees.
          const rimrafSync = (p, options) => {
            options = options || {}
            defaults(options)

            assert(p, 'rimraf: missing path')
            assert.equal(typeof p, 'string', 'rimraf: path should be a string')
            assert(options, 'rimraf: missing options')
            assert.equal(typeof options, 'object', 'rimraf: options should be object')

            let results

            if (options.disableGlob || !glob.hasMagic(p)) {
              results = [p]
            } else {
              try {
                options.lstatSync(p)
                results = [p]
              } catch (er) {
                results = glob.sync(p, options.glob)
              }
            }

            if (!results.length) return

            for (let i = 0; i < results.length; i++) {
              const p = results[i]

              let st
              try {
                st = options.lstatSync(p)
              } catch (er) {
                if (er.code === 'ENOENT') return

                // Windows can EPERM on stat.  Life is suffering.
                if (er.code === 'EPERM' && isWindows) fixWinEPERMSync(p, options, er)
              }

              try {
                // sunos lets the root user unlink directories, which is... weird.
                if (st && st.isDirectory()) rmdirSync(p, options, null)
                else options.unlinkSync(p)
              } catch (er) {
                if (er.code === 'ENOENT') return
                if (er.code === 'EPERM')
                  return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
                if (er.code !== 'EISDIR') throw er

                rmdirSync(p, options, er)
              }
            }
          }

          const rmdirSync = (p, options, originalEr) => {
            assert(p)
            assert(options)

            try {
              options.rmdirSync(p)
            } catch (er) {
              if (er.code === 'ENOENT') return
              if (er.code === 'ENOTDIR') throw originalEr
              if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')
                rmkidsSync(p, options)
            }
          }

          const rmkidsSync = (p, options) => {
            assert(p)
            assert(options)
            options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options))

            // We only end up here once we got ENOTEMPTY at least once, and
            // at this point, we are guaranteed to have removed all the kids.
            // So, we know that it won't be ENOENT or ENOTDIR or anything else.
            // try really hard to delete stuff on windows, because it has a
            // PROFOUNDLY annoying habit of not closing handles promptly when
            // files are deleted, resulting in spurious ENOTEMPTY errors.
            const retries = isWindows ? 100 : 1
            let i = 0
            do {
              let threw = true
              try {
                const ret = options.rmdirSync(p, options)
                threw = false
                return ret
              } finally {
                if (++i < retries && threw) continue
              }
            } while (true)
          }

          module.exports = rimraf
          rimraf.sync = rimrafSync

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/browsingContext.js':
        /*!*****************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/browsingContext.js ***!
  \*****************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { BrowsingContextInfo } = __webpack_require__(
            /*! ./browsingContextTypes */ './node_modules/selenium-webdriver/bidi/browsingContextTypes.js'
          )
          class BrowsingContext {
            constructor(driver) {
              this._driver = driver
            }

            async init({ browsingContextId, type, referenceContext }) {
              if (!(await this._driver.getCapabilities()).get('webSocketUrl')) {
                throw Error('WebDriver instance must support BiDi protocol')
              }

              if (type != undefined && !['window', 'tab'].includes(type)) {
                throw Error(`Valid types are 'window' & 'tab'. Received: ${type}`)
              }

              this.bidi = await this._driver.getBidi()
              this._id =
                browsingContextId == undefined
                  ? (await this.create(type, referenceContext))['result']['context']
                  : browsingContextId
            }

            /**
             * Creates a browsing context for the given type and referenceContext
             */
            async create(type, referenceContext) {
              const params = {
                method: 'browsingContext.create',
                params: {
                  type: type,
                  referenceContext: referenceContext
                }
              }
              return await this.bidi.send(params)
            }

            /**
             * @returns id
             */
            get id() {
              return this._id
            }

            /**
             * @param url the url to navigate to
             * @param readinessState type of readiness state: "none" / "interactive" / "complete"
             * @returns NavigateResult object
             */
            async navigate(url, readinessState = undefined) {
              if (
                readinessState != undefined &&
                !['none', 'interactive', 'complete'].includes(readinessState)
              ) {
                throw Error(
                  `Valid readiness states are 'none', 'interactive' & 'complete'. Received: ${readinessState}`
                )
              }

              const params = {
                method: 'browsingContext.navigate',
                params: {
                  context: this._id,
                  url: url,
                  wait: readinessState
                }
              }
              const navigateResult = (await this.bidi.send(params))['result']

              return new NavigateResult(navigateResult['url'], navigateResult['navigation'])
            }

            /**
             * @param maxDepth the max depth of the descendents of browsing context tree
             * @returns BrowsingContextInfo object
             */
            async getTree(maxDepth = undefined) {
              const params = {
                method: 'browsingContext.getTree',
                params: {
                  root: this._id,
                  maxDepth: maxDepth
                }
              }

              let result = await this.bidi.send(params)
              if ('error' in result) {
                throw Error(result['error'])
              }

              result = result['result']['contexts'][0]
              return new BrowsingContextInfo(
                result['context'],
                result['url'],
                result['children'],
                result['parent']
              )
            }

            /**
             * Closes the browing context
             * @returns {Promise<void>}
             */
            async close() {
              const params = {
                method: 'browsingContext.close',
                params: {
                  context: this._id
                }
              }
              await this.bidi.send(params)
            }

            /**
             * Prints PDF of the webpage
             * @param options print options given by the user
             * @returns PrintResult object
             */
            async printPage(options = {}) {
              let params = {
                method: 'browsingContext.print',
                // Setting default values for parameters
                params: {
                  context: this._id,
                  background: false,
                  margin: {
                    bottom: 1.0,
                    left: 1.0,
                    right: 1.0,
                    top: 1.0
                  },
                  orientation: 'portrait',
                  page: {
                    height: 27.94,
                    width: 21.59
                  },
                  pageRanges: [],
                  scale: 1.0,
                  shrinkToFit: true
                }
              }

              // Updating parameter values based on the options passed
              params.params = this._driver.validatePrintPageParams(options, params.params)

              const response = await this.bidi.send(params)
              return new PrintResult(response.result.data)
            }
          }

          class NavigateResult {
            constructor(url, navigationId) {
              this._url = url
              this._navigationId = navigationId
            }

            get url() {
              return this._url
            }

            get navigationId() {
              return this._navigationId
            }
          }

          class PrintResult {
            constructor(data) {
              this._data = data
            }

            get data() {
              return this._data
            }
          }

          /**
           * initiate browsing context instance and return
           * @param driver
           * @param browsingContextId The browsing context of current window/tab
           * @param type "window" or "tab"
           * @param referenceContext To get a browsing context for this reference if passed
           * @returns {Promise<BrowsingContext>}
           */
          async function getBrowsingContextInstance(
            driver,
            { browsingContextId, type, referenceContext }
          ) {
            let instance = new BrowsingContext(driver)
            await instance.init({ browsingContextId, type, referenceContext })
            return instance
          }

          /**
           * API
           * @type {function(*, {*,*,*}): Promise<BrowsingContext>}
           */
          module.exports = getBrowsingContextInstance

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/browsingContextInspector.js':
        /*!**************************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/browsingContextInspector.js ***!
  \**************************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { BrowsingContextInfo, NavigationInfo } = __webpack_require__(
            /*! ./browsingContextTypes */ './node_modules/selenium-webdriver/bidi/browsingContextTypes.js'
          )

          class BrowsingContextInspector {
            constructor(driver, browsingContextIds) {
              this._driver = driver
              this._browsingContextIds = browsingContextIds
            }

            async init() {
              this.bidi = await this._driver.getBidi()
            }

            async onBrowsingContextCreated(callback) {
              await this.subscribeAndHandleEvent('browsingContext.contextCreated', callback)
            }

            async onDomContentLoaded(callback) {
              await this.subscribeAndHandleEvent('browsingContext.domContentLoaded', callback)
            }

            async onBrowsingContextLoaded(callback) {
              await this.subscribeAndHandleEvent('browsingContext.load', callback)
            }

            async subscribeAndHandleEvent(eventType, callback) {
              if (this._browsingContextIds != null) {
                await this.bidi.subscribe(eventType, this._browsingContextIds)
              } else {
                await this.bidi.subscribe(eventType)
              }
              this._on(callback)
            }

            async _on(callback) {
              this.ws = await this.bidi.socket
              this.ws.on('message', (event) => {
                const { params } = JSON.parse(Buffer.from(event.toString()))
                if (params) {
                  let response = null
                  if ('navigation' in params) {
                    response = new NavigationInfo(
                      params.context,
                      params.navigation,
                      params.timestamp,
                      params.url
                    )
                  } else if ('accepted' in params) {
                    /* Needs to be updated when browsers implement other events */
                  } else {
                    response = new BrowsingContextInfo(
                      params.context,
                      params.url,
                      params.children,
                      params.parent
                    )
                  }
                  callback(response)
                }
              })
            }
          }

          async function getBrowsingContextInstance(driver, browsingContextIds = null) {
            let instance = new BrowsingContextInspector(driver, browsingContextIds)
            await instance.init()
            return instance
          }

          module.exports = getBrowsingContextInstance

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/browsingContextTypes.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/browsingContextTypes.js ***!
  \**********************************************************************/
        /***/ (module) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          class BrowsingContextInfo {
            constructor(id, url, children, parentBrowsingContext) {
              this._id = id
              this._url = url
              this._children = children
              this._parentBrowsingContext = parentBrowsingContext
            }

            get id() {
              return this._id
            }

            get url() {
              return this._url
            }

            get children() {
              return this._children
            }

            get parentBrowsingContext() {
              return this._parentBrowsingContext
            }
          }

          class NavigationInfo {
            constructor(browsingContextId, navigationId, timestamp, url) {
              this.browsingContextId = browsingContextId
              this.navigationId = navigationId
              this.timestamp = timestamp
              this.url = url
            }
          }

          module.exports = { BrowsingContextInfo, NavigationInfo }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/evaluateResult.js':
        /*!****************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/evaluateResult.js ***!
  \****************************************************************/
        /***/ (module) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const EvaluateResultType = {
            SUCCESS: 'success',
            EXCEPTION: 'exception'
          }

          class EvaluateResultSuccess {
            constructor(realmId, value) {
              this.resultType = EvaluateResultType.SUCCESS
              this.realmId = realmId
              this.result = value
            }
          }

          class EvaluateResultException {
            constructor(realmId, exceptionDetails) {
              this.resultType = EvaluateResultType.EXCEPTION
              this.realmId = realmId
              this.exceptionDetails = exceptionDetails
            }
          }

          class ExceptionDetails {
            constructor(exceptionDetails) {
              this.columnNumber =
                'columnNumber' in exceptionDetails ? exceptionDetails['columnNumber'] : null
              this.exception =
                'exception' in exceptionDetails ? exceptionDetails['exception'] : null
              this.lineNumber =
                'lineNumber' in exceptionDetails ? exceptionDetails['lineNumber'] : null
              this.stackTrace =
                'stackTrace' in exceptionDetails ? exceptionDetails['stackTrace'] : null
              this.text = 'text' in exceptionDetails ? exceptionDetails['text'] : null
            }
          }

          module.exports = {
            EvaluateResultType,
            EvaluateResultSuccess,
            EvaluateResultException,
            ExceptionDetails
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/filterBy.js':
        /*!**********************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/filterBy.js ***!
  \**********************************************************/
        /***/ (module) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          class FilterBy {
            constructor(level) {
              this.level_ = level
            }

            static logLevel(level) {
              if (
                level === undefined ||
                (level != undefined && !['debug', 'error', 'info', 'warning'].includes(level))
              ) {
                throw Error(
                  `Please pass valid log level. Valid log levels are 'debug', 'error', 'info' and 'warning'. Received: ${level}`
                )
              }

              return new FilterBy(level)
            }

            getLevel() {
              return this.level_
            }
          }

          // PUBLIC API

          module.exports = {
            FilterBy
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/index.js':
        /*!*******************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/index.js ***!
  \*******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { EventEmitter } = __webpack_require__(/*! node:events */ 'node:events')
          const WebSocket = __webpack_require__(/*! ws */ './node_modules/ws/browser.js')

          const RESPONSE_TIMEOUT = 1000 * 30

          class Index extends EventEmitter {
            id = 0
            isConnected = false
            events = []
            browsingContexts = []

            /**
             * Create a new websocket connection
             * @param _webSocketUrl
             */
            constructor(_webSocketUrl) {
              super()
              this.isConnected = false
              this._ws = new WebSocket(_webSocketUrl)
              this._ws.on('open', () => {
                this.isConnected = true
              })
            }

            /**
             * Resolve connection
             * @returns {Promise<unknown>}
             */
            async waitForConnection() {
              return new Promise((resolve) => {
                if (this.isConnected) {
                  resolve()
                } else {
                  this._ws.once('open', () => {
                    resolve()
                  })
                }
              })
            }

            /**
             * @returns {WebSocket}
             */
            get socket() {
              return this._ws
            }

            /**
             * @returns {boolean|*}
             */
            get isConnected() {
              return this.isConnected
            }

            /**
             * Sends a bidi request
             * @param params
             * @returns {Promise<unknown>}
             */
            async send(params) {
              if (!this.isConnected) {
                await this.waitForConnection()
              }

              const id = ++this.id

              this._ws.send(JSON.stringify({ id, ...params }))

              return new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                  reject(new Error(`Request with id ${id} timed out`))
                  handler.off('message', listener)
                }, RESPONSE_TIMEOUT)

                const listener = (data) => {
                  try {
                    const payload = JSON.parse(data.toString())
                    if (payload.id === id) {
                      clearTimeout(timeoutId)
                      handler.off('message', listener)
                      resolve(payload)
                    }
                  } catch (err) {
                    log.error(`Failed parse message: ${err.message}`)
                  }
                }

                const handler = this._ws.on('message', listener)
              })
            }

            /**
             * Subscribe to events
             * @param events
             * @param browsingContexts
             * @returns {Promise<void>}
             */
            async subscribe(events, browsingContexts) {
              function toArray(arg) {
                if (arg === undefined) {
                  return []
                }

                return Array.isArray(arg) ? [...arg] : [arg]
              }

              const eventsArray = toArray(events)
              const contextsArray = toArray(browsingContexts)

              const params = {
                method: 'session.subscribe',
                params: {}
              }

              if (eventsArray.length && eventsArray.some((event) => typeof event !== 'string')) {
                throw new TypeError('events should be string or string array')
              }

              if (
                contextsArray.length &&
                contextsArray.some((context) => typeof context !== 'string')
              ) {
                throw new TypeError('browsingContexts should be string or string array')
              }

              if (eventsArray.length) {
                params.params.events = eventsArray
              }

              if (contextsArray.length) {
                params.params.contexts = contextsArray
              }

              await this.send(params)
            }

            /**
             * Unsubscribe to events
             * @param events
             * @param browsingContexts
             * @returns {Promise<void>}
             */
            async unsubscribe(events, browsingContexts) {
              if (typeof events === 'string') {
                this.events = this.events.filter((event) => event !== events)
              } else if (Array.isArray(events)) {
                this.events = this.events.filter((event) => !events.includes(event))
              }

              if (typeof browsingContexts === 'string') {
                this.browsingContexts.pop()
              } else if (Array.isArray(browsingContexts)) {
                this.browsingContexts = this.browsingContexts.filter(
                  (id) => !browsingContexts.includes(id)
                )
              }

              const params = {
                method: 'session.unsubscribe',
                params: {
                  events: this.events
                }
              }

              if (this.browsingContexts.length > 0) {
                params.params.contexts = this.browsingContexts
              }

              await this.send(params)
            }

            /**
             * Get Bidi Status
             * @returns {Promise<*>}
             */
            get status() {
              return this.send({
                method: 'session.status',
                params: {}
              })
            }

            /**
             * Close ws connection.
             * @returns {Promise<unknown>}
             */
            close() {
              const closeWebSocket = (callback) => {
                // don't close if it's already closed
                if (this._ws.readyState === 3) {
                  callback()
                } else {
                  // don't notify on user-initiated shutdown ('disconnect' event)
                  this._ws.removeAllListeners('close')
                  this._ws.once('close', () => {
                    this._ws.removeAllListeners()
                    callback()
                  })
                  this._ws.close()
                }
              }
              return new Promise((fulfill, reject) => {
                closeWebSocket(fulfill)
              })
            }
          }

          /**
           * API
           * @type {function(*): Promise<Index>}
           */
          module.exports = Index

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/logEntries.js':
        /*!************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/logEntries.js ***!
  \************************************************************/
        /***/ (module) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          class BaseLogEntry {
            constructor(level, text, timeStamp, stackTrace) {
              this._level = level
              this._text = text
              this._timeStamp = timeStamp
              this._stackTrace = stackTrace
            }

            get level() {
              return this._level
            }

            get text() {
              return this._text
            }

            get timeStamp() {
              return this._timeStamp
            }

            get stackTrace() {
              return this._stackTrace
            }
          }

          class GenericLogEntry extends BaseLogEntry {
            constructor(level, text, timeStamp, type, stackTrace) {
              super(level, text, timeStamp, stackTrace)
              this._type = type
            }

            get type() {
              return this._type
            }
          }

          class ConsoleLogEntry extends GenericLogEntry {
            constructor(level, text, timeStamp, type, method, realm, args, stackTrace) {
              super(level, text, timeStamp, type, stackTrace)
              this._method = method
              this._realm = realm
              this._args = args
            }

            get method() {
              return this._method
            }

            get realm() {
              return this._realm
            }

            get args() {
              return this._args
            }
          }

          class JavascriptLogEntry extends GenericLogEntry {
            constructor(level, text, timeStamp, type, stackTrace) {
              super(level, text, timeStamp, type, stackTrace)
            }
          }

          // PUBLIC API

          module.exports = {
            BaseLogEntry,
            GenericLogEntry,
            ConsoleLogEntry,
            JavascriptLogEntry
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/logInspector.js':
        /*!**************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/logInspector.js ***!
  \**************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { FilterBy } = __webpack_require__(
            /*! ./filterBy */ './node_modules/selenium-webdriver/bidi/filterBy.js'
          )
          const { ConsoleLogEntry, JavascriptLogEntry, GenericLogEntry } = __webpack_require__(
            /*! ./logEntries */ './node_modules/selenium-webdriver/bidi/logEntries.js'
          )

          const LOG = {
            TYPE_CONSOLE: 'console',
            TYPE_JS_LOGS: 'javascript'
          }

          class LogInspector {
            bidi
            ws

            constructor(driver, browsingContextIds) {
              this._driver = driver
              this._browsingContextIds = browsingContextIds
              this.listener = {}
            }

            /**
             * Subscribe to log event
             * @returns {Promise<void>}
             */
            async init() {
              this.bidi = await this._driver.getBidi()
              await this.bidi.subscribe('log.entryAdded', this._browsingContextIds)
            }

            /**
             * @param kind
             */
            logListener(kind) {
              if (!(kind in this.listener)) {
                this.listener[kind] = []
              }
            }

            /**
             * Listen to Console logs
             * @param callback
             * @returns {Promise<void>}
             */
            async onConsoleEntry(callback, filterBy = undefined) {
              if (filterBy != undefined && !(filterBy instanceof FilterBy)) {
                throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)
              }

              this.ws = await this.bidi.socket

              this.ws.on('message', (event) => {
                const { params } = JSON.parse(Buffer.from(event.toString()))

                if (params?.type === LOG.TYPE_CONSOLE) {
                  let consoleEntry = new ConsoleLogEntry(
                    params.level,
                    params.text,
                    params.timestamp,
                    params.type,
                    params.method,
                    params.realm,
                    params.args,
                    params.stackTrace
                  )

                  if (filterBy != undefined) {
                    if (params?.level === filterBy.getLevel()) {
                      callback(consoleEntry)
                    }
                    return
                  }

                  callback(consoleEntry)
                }
              })
            }

            /**
             * Listen to JS logs
             * @param callback
             * @returns {Promise<void>}
             */
            async onJavascriptLog(callback, filterBy = undefined) {
              if (filterBy != undefined && !(filterBy instanceof FilterBy)) {
                throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)
              }

              this.ws = await this.bidi.socket

              this.ws.on('message', (event) => {
                const { params } = JSON.parse(Buffer.from(event.toString()))

                if (params?.type === LOG.TYPE_JS_LOGS) {
                  let jsEntry = new JavascriptLogEntry(
                    params.level,
                    params.text,
                    params.timestamp,
                    params.type,
                    params.stackTrace
                  )

                  if (filterBy != undefined) {
                    if (params?.level === filterBy.getLevel()) {
                      callback(jsEntry)
                    }
                    return
                  }

                  callback(jsEntry)
                }
              })
            }

            /**
             * Listen to JS Exceptions
             * @param callback
             * @returns {Promise<void>}
             */
            async onJavascriptException(callback) {
              this.ws = await this.bidi.socket
              let enabled =
                LOG.TYPE_JS_EXCEPTION in this.listener || this.logListener(LOG.TYPE_JS_EXCEPTION)
              this.listener[LOG.TYPE_JS_EXCEPTION].push(callback)

              if (enabled) {
                return
              }

              this.ws.on('message', (event) => {
                const { params } = JSON.parse(Buffer.from(event.toString()))
                if (params?.type === 'javascript' && params?.level === 'error') {
                  let jsErrorEntry = new JavascriptLogEntry(
                    params.level,
                    params.text,
                    params.timestamp,
                    params.type,
                    params.stackTrace
                  )

                  this.listener[LOG.TYPE_JS_EXCEPTION].forEach((listener) => {
                    listener(jsErrorEntry)
                  })
                }
              })
            }

            /**
             * Listen to any logs
             * @param callback
             * @returns {Promise<void>}
             */
            async onLog(callback, filterBy = undefined) {
              if (filterBy != undefined && !(filterBy instanceof FilterBy)) {
                throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)
              }

              this.ws = await this.bidi.socket

              this.ws.on('message', (event) => {
                const { params } = JSON.parse(Buffer.from(event.toString()))
                if (params?.type === 'javascript') {
                  let jsEntry = new JavascriptLogEntry(
                    params.level,
                    params.text,
                    params.timestamp,
                    params.type,
                    params.stackTrace
                  )

                  if (filterBy != undefined) {
                    if (params?.level === filterBy.getLevel()) {
                      callback(jsEntry)
                    }
                    return
                  }

                  callback(jsEntry)
                  return
                }

                if (params?.type === 'console') {
                  let consoleEntry = new ConsoleLogEntry(
                    params.level,
                    params.text,
                    params.timestamp,
                    params.type,
                    params.method,
                    params.realm,
                    params.args,
                    params.stackTrace
                  )

                  if (filterBy != undefined) {
                    if (params?.level === filterBy.getLevel()) {
                      callback(consoleEntry)
                    }
                    return
                  }

                  callback(consoleEntry)
                  return
                }

                if (params != undefined && !['console', 'javascript'].includes(params?.type)) {
                  let genericEntry = new GenericLogEntry(
                    params.level,
                    params.text,
                    params.timestamp,
                    params.type,
                    params.stackTrace
                  )

                  if (filterBy != undefined) {
                    if (params?.level === filterBy.getLevel()) {
                      callback(genericEntry)
                    }
                    return
                  }

                  callback(genericEntry)
                }
              })
            }

            /**
             * Unsubscribe to log event
             * @returns {Promise<void>}
             */
            async close() {
              await this.bidi.unsubscribe('log.entryAdded', this._browsingContextIds)
            }
          }

          /**
           * initiate inspector instance and return
           * @param driver
           * @param browsingContextIds
           * @returns {Promise<LogInspector>}
           */
          async function getLogInspectorInstance(driver, browsingContextIds) {
            let instance = new LogInspector(driver, browsingContextIds)
            await instance.init()
            return instance
          }

          /**
           * API
           * @type {function(*, *): Promise<LogInspector>}
           */
          module.exports = getLogInspectorInstance

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/protocolType.js':
        /*!**************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/protocolType.js ***!
  \**************************************************************/
        /***/ (module) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const PrimitiveType = {
            UNDEFINED: 'undefined',
            NULL: 'null',
            STRING: 'string',
            NUMBER: 'number',
            SPECIAL_NUMBER: 'number',
            BOOLEAN: 'boolean',
            BIGINT: 'bigint',

            findByName(name) {
              return (
                Object.values(this).find((type) => {
                  return typeof type === 'string' && name.toLowerCase() === type.toLowerCase()
                }) || null
              )
            }
          }

          const NonPrimitiveType = {
            ARRAY: 'array',
            DATE: 'date',
            MAP: 'map',
            OBJECT: 'object',
            REGULAR_EXPRESSION: 'regexp',
            SET: 'set',

            findByName(name) {
              return (
                Object.values(this).find((type) => {
                  return typeof type === 'string' && name.toLowerCase() === type.toLowerCase()
                }) || null
              )
            }
          }

          const RemoteType = {
            SYMBOL: 'symbol',
            FUNCTION: 'function',
            WEAK_MAP: 'weakmap',
            WEAK_SET: 'weakset',
            ITERATOR: 'iterator',
            GENERATOR: 'generator',
            ERROR: 'error',
            PROXY: 'proxy',
            PROMISE: 'promise',
            TYPED_ARRAY: 'typedarray',
            ARRAY_BUFFER: 'arraybuffer',
            NODE_LIST: 'nodelist',
            HTML_COLLECTION: 'htmlcollection',
            NODE: 'node',
            WINDOW: 'window',

            findByName(name) {
              return (
                Object.values(this).find((type) => {
                  return typeof type === 'string' && name.toLowerCase() === type.toLowerCase()
                }) || null
              )
            }
          }

          const SpecialNumberType = {
            NAN: 'NaN',
            MINUS_ZERO: '-0',
            INFINITY: 'Infinity',
            MINUS_INFINITY: '-Infinity'
          }

          module.exports = {
            PrimitiveType,
            NonPrimitiveType,
            RemoteType,
            SpecialNumberType
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/protocolValue.js':
        /*!***************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/protocolValue.js ***!
  \***************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { PrimitiveType, NonPrimitiveType, RemoteType } = __webpack_require__(
            /*! ./protocolType */ './node_modules/selenium-webdriver/bidi/protocolType.js'
          )

          const TYPE_CONSTANT = 'type'
          const VALUE_CONSTANT = 'value'
          const RemoteReferenceType = {
            HANDLE: 'handle',
            SHARED_ID: 'shareId'
          }

          class LocalValue {
            constructor(type, value = null) {
              if (type === PrimitiveType.UNDEFINED || type === PrimitiveType.NULL) {
                this.type = type
              } else {
                this.type = type
                this.value = value
              }
            }

            static createStringValue(value) {
              return new LocalValue(PrimitiveType.STRING, value)
            }

            static createNumberValue(value) {
              return new LocalValue(PrimitiveType.NUMBER, value)
            }

            static createSpecialNumberValue(value) {
              return new LocalValue(PrimitiveType.SPECIAL_NUMBER, value)
            }

            static createUndefinedValue() {
              return new LocalValue(PrimitiveType.UNDEFINED)
            }

            static createNullValue() {
              return new LocalValue(PrimitiveType.NULL)
            }

            static createBooleanValue(value) {
              return new LocalValue(PrimitiveType.BOOLEAN, value)
            }

            static createBigIntValue(value) {
              return new LocalValue(PrimitiveType.BIGINT, value)
            }

            static createArrayValue(value) {
              return new LocalValue(NonPrimitiveType.ARRAY, value)
            }

            static createDateValue(value) {
              return new LocalValue(NonPrimitiveType.DATE, value)
            }

            static createMapValue(map) {
              let value = []
              Object.entries(map).forEach((entry) => {
                value.push(entry)
              })
              return new LocalValue(NonPrimitiveType.MAP, value)
            }

            static createObjectValue(map) {
              let value = []
              Object.entries(map).forEach((entry) => {
                value.push(entry)
              })
              return new LocalValue(NonPrimitiveType.OBJECT, value)
            }

            static createRegularExpressionValue(value) {
              return new LocalValue(NonPrimitiveType.REGULAR_EXPRESSION, value)
            }

            static createSetValue(value) {
              return new LocalValue(NonPrimitiveType.SET, value)
            }

            toJson() {
              let toReturn = {}
              toReturn[TYPE_CONSTANT] = this.type

              if (!(this.type === PrimitiveType.NULL || this.type === PrimitiveType.UNDEFINED)) {
                toReturn[VALUE_CONSTANT] = this.value
              }
              return toReturn
            }
          }

          class RemoteValue {
            constructor(remoteValue) {
              this.type = null
              this.handle = null
              this.internalId = null
              this.value = null
              this.sharedId = null

              if ('type' in remoteValue) {
                var typeString = remoteValue['type']
                if (PrimitiveType.findByName(typeString) != null) {
                  this.type = PrimitiveType.findByName(typeString)
                } else if (NonPrimitiveType.findByName(typeString) != null) {
                  this.type = NonPrimitiveType.findByName(typeString)
                } else {
                  this.type = RemoteType.findByName(typeString)
                }
              }

              if ('handle' in remoteValue) {
                this.handle = remoteValue['handle']
              }

              if ('internalId' in remoteValue) {
                this.internalId = remoteValue['internalId']
              }

              if ('value' in remoteValue) {
                this.value = remoteValue['value']
              }

              if ('sharedId' in remoteValue) {
                this.sharedId = remoteValue['sharedId']
              }

              if (this.value != null) {
                this.value = this.deserializeValue(this.value, this.type)
              }
            }

            deserializeValue(value, type) {
              if ([NonPrimitiveType.MAP, NonPrimitiveType.OBJECT].includes(type)) {
                return Object.fromEntries(value)
              } else if (type === NonPrimitiveType.REGULAR_EXPRESSION) {
                return new RegExpValue(value.pattern, value.flags)
              }
              return value
            }
          }

          class ReferenceValue {
            constructor(handle, shareId) {
              if (handle === RemoteReferenceType.HANDLE) {
                this.handle = shareId
              } else {
                this.handle = handle
                this.shareId = shareId
              }
            }

            asMap() {
              const toReturn = {}
              if (this.handle != null) {
                toReturn[RemoteReferenceType.HANDLE] = this.handle
              }

              if (this.shareId != null) {
                toReturn[RemoteReferenceType.SHARED_ID] = this.shareId
              }

              return toReturn
            }
          }

          class RegExpValue {
            constructor(pattern, flags = null) {
              this.pattern = pattern
              this.flags = flags
            }
          }

          module.exports = {
            LocalValue,
            RemoteValue,
            ReferenceValue,
            RemoteReferenceType,
            RegExpValue
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/realmInfo.js':
        /*!***********************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/realmInfo.js ***!
  \***********************************************************/
        /***/ (module) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const RealmType = {
            AUDIO_WORKLET: 'audio-worklet',
            DEDICATED_WORKER: 'dedicated-worker',
            PAINT_WORKLET: 'paint-worklet',
            SERVICE_WORKED: 'service-worker',
            SHARED_WORKED: 'shared-worker',
            WINDOW: 'window',
            WORKER: 'worker',
            WORKLET: 'worklet',

            findByName(name) {
              return (
                Object.values(this).find((type) => {
                  return typeof type === 'string' && name.toLowerCase() === type.toLowerCase()
                }) || null
              )
            }
          }

          class RealmInfo {
            constructor(realmId, origin, realmType) {
              this.realmId = realmId
              this.origin = origin
              this.realmType = realmType
            }

            static fromJson(input) {
              let realmId = null
              let origin = null
              let realmType = null
              let browsingContext = null
              let sandbox = null

              if ('type' in input) {
                let typeString = input['type']
                realmType = RealmType.findByName(typeString)
              }

              if ('realm' in input) {
                realmId = input['realm']
              }

              if ('origin' in input) {
                origin = input['origin']
              }

              if ('context' in input) {
                browsingContext = input['context']
              }

              if ('sandbox' in input) {
                sandbox = input['sandbox']
              }

              if (realmType === RealmType.WINDOW) {
                return new WindowRealmInfo(realmId, origin, realmType, browsingContext, sandbox)
              }

              return new RealmInfo(realmId, origin, realmType)
            }
          }

          class WindowRealmInfo extends RealmInfo {
            constructor(realmId, origin, realmType, browsingContext, sandbox = null) {
              super(realmId, origin, realmType)
              this.browsingContext = browsingContext
              this.sandbox = sandbox
            }
          }

          module.exports = {
            RealmInfo,
            RealmType
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/bidi/scriptManager.js':
        /*!***************************************************************!*\
  !*** ./node_modules/selenium-webdriver/bidi/scriptManager.js ***!
  \***************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const {
            EvaluateResultType,
            EvaluateResultSuccess,
            EvaluateResultException,
            ExceptionDetails
          } = __webpack_require__(
            /*! ./evaluateResult */ './node_modules/selenium-webdriver/bidi/evaluateResult.js'
          )
          const { RealmInfo } = __webpack_require__(
            /*! ./realmInfo */ './node_modules/selenium-webdriver/bidi/realmInfo.js'
          )
          const { RemoteValue } = __webpack_require__(
            /*! ./protocolValue */ './node_modules/selenium-webdriver/bidi/protocolValue.js'
          )
          const { WebDriverError } = __webpack_require__(
            /*! ../lib/error */ './node_modules/selenium-webdriver/lib/error.js'
          )

          class ScriptManager {
            constructor(driver) {
              this._driver = driver
            }

            async init(browsingContextId) {
              if (!(await this._driver.getCapabilities()).get('webSocketUrl')) {
                throw Error('WebDriver instance must support BiDi protocol')
              }

              this.bidi = await this._driver.getBidi()
              this._browsingContextId = browsingContextId
            }

            async disownRealmScript(realmId, handles) {
              const params = {
                method: 'script.disown',
                params: {
                  handles: handles,
                  target: {
                    realm: realmId
                  }
                }
              }

              await this.bidi.send(params)
            }

            async disownBrowsingContextScript(browsingContextId, handles, sandbox = null) {
              const params = {
                method: 'script.disown',
                params: {
                  handles: handles,
                  target: {
                    context: browsingContextId
                  }
                }
              }

              if (sandbox != null) {
                params.params.target['sandbox'] = sandbox
              }

              await this.bidi.send(params)
            }

            async callFunctionInRealm(
              realmId,
              functionDeclaration,
              awaitPromise,
              argumentValueList = null,
              thisParameter = null,
              resultOwnership = null
            ) {
              const params = this.getCallFunctionParams(
                'realm',
                realmId,
                null,
                functionDeclaration,
                awaitPromise,
                argumentValueList,
                thisParameter,
                resultOwnership
              )

              const command = {
                method: 'script.callFunction',
                params
              }

              let response = await this.bidi.send(command)
              return this.createEvaluateResult(response)
            }

            async callFunctionInBrowsingContext(
              browsingContextId,
              functionDeclaration,
              awaitPromise,
              argumentValueList = null,
              thisParameter = null,
              resultOwnership = null,
              sandbox = null
            ) {
              const params = this.getCallFunctionParams(
                'contextTarget',
                browsingContextId,
                sandbox,
                functionDeclaration,
                awaitPromise,
                argumentValueList,
                thisParameter,
                resultOwnership
              )

              const command = {
                method: 'script.callFunction',
                params
              }
              const response = await this.bidi.send(command)
              return this.createEvaluateResult(response)
            }

            async evaluateFunctionInRealm(
              realmId,
              expression,
              awaitPromise,
              resultOwnership = null
            ) {
              const params = this.getEvaluateParams(
                'realm',
                realmId,
                null,
                expression,
                awaitPromise,
                resultOwnership
              )

              const command = {
                method: 'script.evaluate',
                params
              }

              let response = await this.bidi.send(command)
              return this.createEvaluateResult(response)
            }

            async evaluateFunctionInBrowsingContext(
              browsingContextId,
              expression,
              awaitPromise,
              resultOwnership = null,
              sandbox = null
            ) {
              const params = this.getEvaluateParams(
                'contextTarget',
                browsingContextId,
                sandbox,
                expression,
                awaitPromise,
                resultOwnership
              )

              const command = {
                method: 'script.evaluate',
                params
              }

              let response = await this.bidi.send(command)
              return this.createEvaluateResult(response)
            }

            async addPreloadScript(functionDeclaration, argumentValueList = null, sandbox = null) {
              const params = {
                functionDeclaration: functionDeclaration,
                arguments: argumentValueList,
                sandbox: sandbox
              }

              const command = {
                method: 'script.addPreloadScript',
                params
              }

              let response = await this.bidi.send(command)
              return response.result.script
            }

            async removePreloadScript(script) {
              const params = { script: script }
              const command = {
                method: 'script.removePreloadScript',
                params
              }
              let response = await this.bidi.send(command)
              if ('error' in response) {
                throw new WebDriverError(response.error)
              }
              return response.result
            }

            getCallFunctionParams(
              targetType,
              id,
              sandbox,
              functionDeclaration,
              awaitPromise,
              argumentValueList = null,
              thisParameter = null,
              resultOwnership = null
            ) {
              const params = {
                functionDeclaration: functionDeclaration,
                awaitPromise: awaitPromise
              }
              if (targetType === 'contextTarget') {
                if (sandbox != null) {
                  params['target'] = { context: id, sandbox: sandbox }
                } else {
                  params['target'] = { context: id }
                }
              } else {
                params['target'] = { realm: id }
              }

              if (argumentValueList != null) {
                let argumentParams = []
                argumentValueList.forEach((argumentValue) => {
                  argumentParams.push(argumentValue.asMap())
                })
                params['arguments'] = argumentParams
              }

              if (thisParameter != null) {
                params['this'] = thisParameter
              }

              if (resultOwnership != null) {
                params['resultOwnership'] = resultOwnership
              }

              return params
            }

            getEvaluateParams(
              targetType,
              id,
              sandbox,
              expression,
              awaitPromise,
              resultOwnership = null
            ) {
              const params = {
                expression: expression,
                awaitPromise: awaitPromise
              }
              if (targetType === 'contextTarget') {
                if (sandbox != null) {
                  params['target'] = { context: id, sandbox: sandbox }
                } else {
                  params['target'] = { context: id }
                }
              } else {
                params['target'] = { realm: id }
              }
              if (resultOwnership != null) {
                params['resultOwnership'] = resultOwnership
              }

              return params
            }

            createEvaluateResult(response) {
              var type = response.result.type
              var realmId = response.result.realm
              var evaluateResult

              if (type === EvaluateResultType.SUCCESS) {
                var result = response.result.result
                evaluateResult = new EvaluateResultSuccess(realmId, new RemoteValue(result))
              } else {
                var exceptionDetails = response.result.exceptionDetails
                evaluateResult = new EvaluateResultException(
                  realmId,
                  new ExceptionDetails(exceptionDetails)
                )
              }
              return evaluateResult
            }

            realmInfoMapper(realms) {
              var realmsList = []
              realms.forEach((realm) => {
                realmsList.push(RealmInfo.fromJson(realm))
              })
              return realmsList
            }

            async getAllRealms() {
              const command = {
                method: 'script.getRealms',
                params: {}
              }
              let response = await this.bidi.send(command)
              return this.realmInfoMapper(response.result.realms)
            }

            async getRealmsByType(type) {
              const command = {
                method: 'script.getRealms',
                params: { type: type }
              }
              let response = await this.bidi.send(command)
              return this.realmInfoMapper(response.result.realms)
            }

            async getRealmsInBrowsingContext(browsingContext) {
              const command = {
                method: 'script.getRealms',
                params: { context: browsingContext }
              }
              let response = await this.bidi.send(command)
              return this.realmInfoMapper(response.result.realms)
            }

            async getRealmsInBrowsingContextByType(browsingContext, type) {
              const command = {
                method: 'script.getRealms',
                params: { context: browsingContext, type: type }
              }
              let response = await this.bidi.send(command)
              return this.realmInfoMapper(response.result.realms)
            }
          }

          async function getScriptManagerInstance(browsingContextId, driver) {
            let instance = new ScriptManager(driver)
            await instance.init(browsingContextId)
            return instance
          }

          module.exports = getScriptManagerInstance

          /***/
        },

      /***/ './node_modules/selenium-webdriver/chrome.js':
        /*!***************************************************!*\
  !*** ./node_modules/selenium-webdriver/chrome.js ***!
  \***************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines a {@linkplain Driver WebDriver} client for the Chrome
           * web browser. Before using this module, you must download the latest
           * [ChromeDriver release] and ensure it can be found on your system [PATH].
           *
           * There are three primary classes exported by this module:
           *
           * 1. {@linkplain ServiceBuilder}: configures the
           *     {@link selenium-webdriver/remote.DriverService remote.DriverService}
           *     that manages the [ChromeDriver] child process.
           *
           * 2. {@linkplain Options}: defines configuration options for each new Chrome
           *     session, such as which {@linkplain Options#setProxy proxy} to use,
           *     what {@linkplain Options#addExtensions extensions} to install, or
           *     what {@linkplain Options#addArguments command-line switches} to use when
           *     starting the browser.
           *
           * 3. {@linkplain Driver}: the WebDriver client; each new instance will control
           *     a unique browser session with a clean user profile (unless otherwise
           *     configured through the {@link Options} class).
           *
           * __Headless Chrome__ <a id="headless"></a>
           *
           * To start Chrome in headless mode, simply call
           * {@linkplain Options#headless Options.headless()}.
           *
           *     let chrome = require('selenium-webdriver/chrome');
           *     let {Builder} = require('selenium-webdriver');
           *
           *     let driver = new Builder()
           *         .forBrowser('chrome')
           *         .setChromeOptions(new chrome.Options().headless())
           *         .build();
           *
           * __Customizing the ChromeDriver Server__ <a id="custom-server"></a>
           *
           * By default, every Chrome session will use a single driver service, which is
           * started the first time a {@link Driver} instance is created and terminated
           * when this process exits. The default service will inherit its environment
           * from the current process and direct all output to /dev/null. You may obtain
           * a handle to this default service using
           * {@link #getDefaultService getDefaultService()} and change its configuration
           * with {@link #setDefaultService setDefaultService()}.
           *
           * You may also create a {@link Driver} with its own driver service. This is
           * useful if you need to capture the server's log output for a specific session:
           *
           *     let chrome = require('selenium-webdriver/chrome');
           *
           *     let service = new chrome.ServiceBuilder()
           *         .loggingTo('/my/log/file.txt')
           *         .enableVerboseLogging()
           *         .build();
           *
           *     let options = new chrome.Options();
           *     // configure browser options ...
           *
           *     let driver = chrome.Driver.createSession(options, service);
           *
           * Users should only instantiate the {@link Driver} class directly when they
           * need a custom driver service configuration (as shown above). For normal
           * operation, users should start Chrome using the
           * {@link selenium-webdriver.Builder}.
           *
           * __Working with Android__ <a id="android"></a>
           *
           * The [ChromeDriver][android] supports running tests on the Chrome browser as
           * well as [WebView apps][webview] starting in Android 4.4 (KitKat). In order to
           * work with Android, you must first start the adb
           *
           *     adb start-server
           *
           * By default, adb will start on port 5037. You may change this port, but this
           * will require configuring a [custom server](#custom-server) that will connect
           * to adb on the {@linkplain ServiceBuilder#setAdbPort correct port}:
           *
           *     let service = new chrome.ServiceBuilder()
           *         .setAdbPort(1234)
           *         build();
           *     // etc.
           *
           * The ChromeDriver may be configured to launch Chrome on Android using
           * {@link Options#androidChrome()}:
           *
           *     let driver = new Builder()
           *         .forBrowser('chrome')
           *         .setChromeOptions(new chrome.Options().androidChrome())
           *         .build();
           *
           * Alternatively, you can configure the ChromeDriver to launch an app with a
           * Chrome-WebView by setting the {@linkplain Options#androidActivity
           * androidActivity} option:
           *
           *     let driver = new Builder()
           *         .forBrowser('chrome')
           *         .setChromeOptions(new chrome.Options()
           *             .androidPackage('com.example')
           *             .androidActivity('com.example.Activity'))
           *         .build();
           *
           * [Refer to the ChromeDriver site] for more information on using the
           * [ChromeDriver with Android][android].
           *
           * [ChromeDriver]: https://chromedriver.chromium.org/
           * [ChromeDriver release]: http://chromedriver.storage.googleapis.com/index.html
           * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29
           * [android]: https://chromedriver.chromium.org/getting-started/getting-started---android
           * [webview]: https://developer.chrome.com/multidevice/webview/overview
           */

          const io = __webpack_require__(
            /*! ./io */ './node_modules/selenium-webdriver/io/index.js'
          )
          const { Browser } = __webpack_require__(
            /*! ./lib/capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )
          const chromium = __webpack_require__(
            /*! ./chromium */ './node_modules/selenium-webdriver/chromium.js'
          )

          /**
           * Name of the ChromeDriver executable.
           * @type {string}
           * @const
           */
          const CHROMEDRIVER_EXE =
            process.platform === 'win32' ? 'chromedriver.exe' : 'chromedriver'

          /** @type {remote.DriverService} */

          /**
           * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
           * a [ChromeDriver](https://chromedriver.chromium.org/)
           * server in a child process.
           */
          class ServiceBuilder extends chromium.ServiceBuilder {
            /**
             * @param {string=} opt_exe Path to the server executable to use. If omitted,
             *     the builder will attempt to locate the chromedriver on the current
             *     PATH. If the chromedriver is not available in path, selenium-manager will
             *     download the chromedriver
             * @throws {Error} If provided executable does not exist, or the chromedriver
             *     cannot be found on the PATH.
             */
            constructor(opt_exe) {
              let exe = opt_exe || locateSynchronously()
              super(exe)
            }
          }

          /**
           * Class for managing ChromeDriver specific options.
           */
          class Options extends chromium.Options {
            /**
             * Sets the path to the Chrome binary to use. On Mac OS X, this path should
             * reference the actual Chrome executable, not just the application binary
             * (e.g. "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome").
             *
             * The binary path be absolute or relative to the chromedriver server
             * executable, but it must exist on the machine that will launch Chrome.
             *
             * @param {string} path The path to the Chrome binary to use.
             * @return {!Options} A self reference.
             */
            setChromeBinaryPath(path) {
              return this.setBinaryPath(path)
            }

            /**
             * Configures the ChromeDriver to launch Chrome on Android via adb. This
             * function is shorthand for
             * {@link #androidPackage options.androidPackage('com.android.chrome')}.
             * @return {!Options} A self reference.
             */
            androidChrome() {
              return this.androidPackage('com.android.chrome')
            }

            /**
             * Sets the path to Chrome's log file. This path should exist on the machine
             * that will launch Chrome.
             * @param {string} path Path to the log file to use.
             * @return {!Options} A self reference.
             */
            setChromeLogFile(path) {
              return this.setBrowserLogFile(path)
            }

            /**
             * Sets the directory to store Chrome minidumps in. This option is only
             * supported when ChromeDriver is running on Linux.
             * @param {string} path The directory path.
             * @return {!Options} A self reference.
             */
            setChromeMinidumpPath(path) {
              return this.setBrowserMinidumpPath(path)
            }
          }

          /**
           * Creates a new WebDriver client for Chrome.
           */
          class Driver extends chromium.Driver {
            /**
             * Creates a new session with the ChromeDriver.
             *
             * @param {(Capabilities|Options)=} opt_config The configuration options.
             * @param {(remote.DriverService|http.Executor)=} opt_serviceExecutor Either
             *     a  DriverService to use for the remote end, or a preconfigured executor
             *     for an externally managed endpoint. If neither is provided, the
             *     {@linkplain ##getDefaultService default service} will be used by
             *     default.
             * @return {!Driver} A new driver instance.
             */
            static createSession(opt_config, opt_serviceExecutor) {
              let caps = opt_config || new Options()
              return /** @type {!Driver} */ (super.createSession(caps, opt_serviceExecutor))
            }

            /**
             * returns new instance chrome driver service
             * @returns {remote.DriverService}
             */
            static getDefaultService() {
              return new ServiceBuilder().build()
            }
          }

          /**
           * _Synchronously_ attempts to locate the chromedriver executable on the current
           * system.
           *
           * @return {?string} the located executable, or `null`.
           */
          function locateSynchronously() {
            return io.findInPath(CHROMEDRIVER_EXE, true)
          }

          Options.prototype.CAPABILITY_KEY = 'goog:chromeOptions'
          Options.prototype.BROWSER_NAME_VALUE = Browser.CHROME
          Driver.prototype.VENDOR_COMMAND_PREFIX = 'goog'

          // PUBLIC API
          module.exports = {
            Driver: Driver,
            Options,
            ServiceBuilder,
            locateSynchronously
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/chromium.js':
        /*!*****************************************************!*\
  !*** ./node_modules/selenium-webdriver/chromium.js ***!
  \*****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines an abstract {@linkplain Driver WebDriver} client for
           * Chromium-based web browsers. These classes should not be instantiated
           * directly.
           *
           * There are three primary classes exported by this module:
           *
           * 1. {@linkplain ServiceBuilder}: configures the
           *     {@link selenium-webdriver/remote.DriverService remote.DriverService}
           *     that manages a WebDriver server child process.
           *
           * 2. {@linkplain Options}: defines configuration options for each new Chromium
           *     session, such as which {@linkplain Options#setProxy proxy} to use,
           *     what {@linkplain Options#addExtensions extensions} to install, or
           *     what {@linkplain Options#addArguments command-line switches} to use when
           *     starting the browser.
           *
           * 3. {@linkplain Driver}: the WebDriver client; each new instance will control
           *     a unique browser session with a clean user profile (unless otherwise
           *     configured through the {@link Options} class).
           *
           * __Headless Chromium__ <a id="headless"></a>
           *
           * To start the browser in headless mode, simply call
           * {@linkplain Options#headless Options.headless()}.
           *
           *     let chrome = require('selenium-webdriver/chrome');
           *     let {Builder} = require('selenium-webdriver');
           *
           *     let driver = new Builder()
           *         .forBrowser('chrome')
           *         .setChromeOptions(new chrome.Options().headless())
           *         .build();
           *
           * __Customizing the Chromium WebDriver Server__ <a id="custom-server"></a>
           *
           * Subclasses of {@link Driver} are expected to provide a static
           * getDefaultService method. By default, this method will be called every time
           * a {@link Driver} instance is created to obtain the default driver service
           * for that specific browser (e.g. Chrome or Chromium Edge). Subclasses are
           * responsible for managing the lifetime of the default service.
           *
           * You may also create a {@link Driver} with its own driver service. This is
           * useful if you need to capture the server's log output for a specific session:
           *
           *     let chrome = require('selenium-webdriver/chrome');
           *
           *     let service = new chrome.ServiceBuilder()
           *         .loggingTo('/my/log/file.txt')
           *         .enableVerboseLogging()
           *         .build();
           *
           *     let options = new chrome.Options();
           *     // configure browser options ...
           *
           *     let driver = chrome.Driver.createSession(options, service);
           */

          const http = __webpack_require__(
            /*! ./http */ './node_modules/selenium-webdriver/http/index.js'
          )
          const io = __webpack_require__(
            /*! ./io */ './node_modules/selenium-webdriver/io/index.js'
          )
          const { Capabilities, Capability } = __webpack_require__(
            /*! ./lib/capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )
          const command = __webpack_require__(
            /*! ./lib/command */ './node_modules/selenium-webdriver/lib/command.js'
          )
          const error = __webpack_require__(
            /*! ./lib/error */ './node_modules/selenium-webdriver/lib/error.js'
          )
          const Symbols = __webpack_require__(
            /*! ./lib/symbols */ './node_modules/selenium-webdriver/lib/symbols.js'
          )
          const webdriver = __webpack_require__(
            /*! ./lib/webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
          )
          const remote = __webpack_require__(
            /*! ./remote */ './node_modules/selenium-webdriver/remote/index.js'
          )
          const { getPath } = __webpack_require__(
            /*! ./common/driverFinder */ './node_modules/selenium-webdriver/common/driverFinder.js'
          )

          /**
           * Custom command names supported by Chromium WebDriver.
           * @enum {string}
           */
          const Command = {
            LAUNCH_APP: 'launchApp',
            GET_NETWORK_CONDITIONS: 'getNetworkConditions',
            SET_NETWORK_CONDITIONS: 'setNetworkConditions',
            DELETE_NETWORK_CONDITIONS: 'deleteNetworkConditions',
            SEND_DEVTOOLS_COMMAND: 'sendDevToolsCommand',
            SEND_AND_GET_DEVTOOLS_COMMAND: 'sendAndGetDevToolsCommand',
            SET_PERMISSION: 'setPermission',
            GET_CAST_SINKS: 'getCastSinks',
            SET_CAST_SINK_TO_USE: 'setCastSinkToUse',
            START_CAST_DESKTOP_MIRRORING: 'startDesktopMirroring',
            START_CAST_TAB_MIRRORING: 'setCastTabMirroring',
            GET_CAST_ISSUE_MESSAGE: 'getCastIssueMessage',
            STOP_CASTING: 'stopCasting'
          }

          /**
           * Creates a command executor with support for Chromium's custom commands.
           * @param {!Promise<string>} url The server's URL.
           * @param vendorPrefix
           * @return {!command.Executor} The new command executor.
           */
          function createExecutor(url, vendorPrefix) {
            const agent = new http.Agent({ keepAlive: true })
            const client = url.then((url) => new http.HttpClient(url, agent))
            const executor = new http.Executor(client)
            configureExecutor(executor, vendorPrefix)
            return executor
          }

          /**
           * Configures the given executor with Chromium-specific commands.
           * @param {!http.Executor} executor the executor to configure.
           */
          function configureExecutor(executor, vendorPrefix) {
            executor.defineCommand(
              Command.LAUNCH_APP,
              'POST',
              '/session/:sessionId/chromium/launch_app'
            )
            executor.defineCommand(
              Command.GET_NETWORK_CONDITIONS,
              'GET',
              '/session/:sessionId/chromium/network_conditions'
            )
            executor.defineCommand(
              Command.SET_NETWORK_CONDITIONS,
              'POST',
              '/session/:sessionId/chromium/network_conditions'
            )
            executor.defineCommand(
              Command.DELETE_NETWORK_CONDITIONS,
              'DELETE',
              '/session/:sessionId/chromium/network_conditions'
            )
            executor.defineCommand(
              Command.SEND_DEVTOOLS_COMMAND,
              'POST',
              '/session/:sessionId/chromium/send_command'
            )
            executor.defineCommand(
              Command.SEND_AND_GET_DEVTOOLS_COMMAND,
              'POST',
              '/session/:sessionId/chromium/send_command_and_get_result'
            )
            executor.defineCommand(
              Command.SET_PERMISSION,
              'POST',
              '/session/:sessionId/permissions'
            )
            executor.defineCommand(
              Command.GET_CAST_SINKS,
              'GET',
              `/session/:sessionId/${vendorPrefix}/cast/get_sinks`
            )
            executor.defineCommand(
              Command.SET_CAST_SINK_TO_USE,
              'POST',
              `/session/:sessionId/${vendorPrefix}/cast/set_sink_to_use`
            )
            executor.defineCommand(
              Command.START_CAST_DESKTOP_MIRRORING,
              'POST',
              `/session/:sessionId/${vendorPrefix}/cast/start_desktop_mirroring`
            )
            executor.defineCommand(
              Command.START_CAST_TAB_MIRRORING,
              'POST',
              `/session/:sessionId/${vendorPrefix}/cast/start_tab_mirroring`
            )
            executor.defineCommand(
              Command.GET_CAST_ISSUE_MESSAGE,
              'GET',
              `/session/:sessionId/${vendorPrefix}/cast/get_issue_message`
            )
            executor.defineCommand(
              Command.STOP_CASTING,
              'POST',
              `/session/:sessionId/${vendorPrefix}/cast/stop_casting`
            )
          }

          /**
           * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
           * a WebDriver server in a child process.
           */
          class ServiceBuilder extends remote.DriverService.Builder {
            /**
             * @param {string=} exe Path to the server executable to use. Subclasses
             * should ensure a valid path to the appropriate exe is provided.
             */
            constructor(exe) {
              super(exe)
              this.setLoopback(true) // Required
            }

            /**
             * Sets which port adb is listening to. _The driver will connect to adb
             * if an {@linkplain Options#androidPackage Android session} is requested, but
             * adb **must** be started beforehand._
             *
             * @param {number} port Which port adb is running on.
             * @return {!ServiceBuilder} A self reference.
             */
            setAdbPort(port) {
              return this.addArguments('--adb-port=' + port)
            }

            /**
             * Sets the path of the log file the driver should log to. If a log file is
             * not specified, the driver will log to stderr.
             * @param {string} path Path of the log file to use.
             * @return {!ServiceBuilder} A self reference.
             */
            loggingTo(path) {
              return this.addArguments('--log-path=' + path)
            }

            /**
             * Enables Chrome logging.
             * @returns {!ServiceBuilder} A self reference.
             */
            enableChromeLogging() {
              return this.addArguments('--enable-chrome-logs')
            }

            /**
             * Enables verbose logging.
             * @return {!ServiceBuilder} A self reference.
             */
            enableVerboseLogging() {
              return this.addArguments('--verbose')
            }

            /**
             * Sets the number of threads the driver should use to manage HTTP requests.
             * By default, the driver will use 4 threads.
             * @param {number} n The number of threads to use.
             * @return {!ServiceBuilder} A self reference.
             */
            setNumHttpThreads(n) {
              return this.addArguments('--http-threads=' + n)
            }

            /**
             * @override
             */
            setPath(path) {
              super.setPath(path)
              return this.addArguments('--url-base=' + path)
            }
          }

          /**
           * Class for managing WebDriver options specific to a Chromium-based browser.
           */
          class Options extends Capabilities {
            /**
             * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of
             *     capabilities to initialize this instance from.
             */
            constructor(other = undefined) {
              super(other)

              /** @private {!Object} */
              this.options_ = this.get(this.CAPABILITY_KEY) || {}

              this.setBrowserName(this.BROWSER_NAME_VALUE)
              this.set(this.CAPABILITY_KEY, this.options_)
            }

            /**
             * Add additional command line arguments to use when launching the browser.
             * Each argument may be specified with or without the "--" prefix
             * (e.g. "--foo" and "foo"). Arguments with an associated value should be
             * delimited by an "=": "foo=bar".
             *
             * @param {...(string|!Array<string>)} args The arguments to add.
             * @return {!Options} A self reference.
             */
            addArguments(...args) {
              let newArgs = (this.options_.args || []).concat(...args)
              if (newArgs.length) {
                this.options_.args = newArgs
              }
              return this
            }

            /**
             * Sets the address of a Chromium remote debugging server to connect to.
             * Address should be of the form "{hostname|IP address}:port"
             * (e.g. "localhost:9222").
             *
             * @param {string} address The address to connect to.
             * @return {!Options} A self reference.
             */
            debuggerAddress(address) {
              this.options_.debuggerAddress = address
              return this
            }

            /**
             * @deprecated Use {@link Options#addArguments} instead.
             * @example
             * options.addArguments('--headless=chrome'); (or)
             * options.addArguments('--headless');
             * @example
             *
             * Recommended to use '--headless=chrome' as argument for browsers v94-108.
             * Recommended to use '--headless=new' as argument for browsers v109+.
             *
             * Configures the driver to start the browser in headless mode.
             *
             * > __NOTE:__ Resizing the browser window in headless mode is only supported
             * > in Chromium 60+. Users are encouraged to set an initial window size with
             * > the {@link #windowSize windowSize({width, height})} option.
             *
             * > __NOTE__: For security, Chromium disables downloads by default when
             * > in headless mode (to prevent sites from silently downloading files to
             * > your machine). After creating a session, you may call
             * > {@link ./chrome.Driver#setDownloadPath setDownloadPath} to re-enable
             * > downloads, saving files in the specified directory.
             *
             * @return {!Options} A self reference.
             */
            headless() {
              return this.addArguments('headless')
            }

            /**
             * Sets the initial window size.
             *
             * @param {{width: number, height: number}} size The desired window size.
             * @return {!Options} A self reference.
             * @throws {TypeError} if width or height is unspecified, not a number, or
             *     less than or equal to 0.
             */
            windowSize({ width, height }) {
              function checkArg(arg) {
                if (typeof arg !== 'number' || arg <= 0) {
                  throw TypeError('Arguments must be {width, height} with numbers > 0')
                }
              }
              checkArg(width)
              checkArg(height)
              return this.addArguments(`window-size=${width},${height}`)
            }

            /**
             * List of Chrome command line switches to exclude that ChromeDriver by default
             * passes when starting Chrome.  Do not prefix switches with "--".
             *
             * @param {...(string|!Array<string>)} args The switches to exclude.
             * @return {!Options} A self reference.
             */
            excludeSwitches(...args) {
              let switches = (this.options_.excludeSwitches || []).concat(...args)
              if (switches.length) {
                this.options_.excludeSwitches = switches
              }
              return this
            }

            /**
             * Add additional extensions to install when launching the browser. Each extension
             * should be specified as the path to the packed CRX file, or a Buffer for an
             * extension.
             * @param {...(string|!Buffer|!Array<(string|!Buffer)>)} args The
             *     extensions to add.
             * @return {!Options} A self reference.
             */
            addExtensions(...args) {
              let extensions = this.options_.extensions || new Extensions()
              extensions.add(...args)
              if (extensions.length) {
                this.options_.extensions = extensions
              }
              return this
            }

            /**
             * Sets the path to the browser binary to use. On Mac OS X, this path should
             * reference the actual Chromium executable, not just the application binary
             * (e.g. "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome").
             *
             * The binary path can be absolute or relative to the WebDriver server
             * executable, but it must exist on the machine that will launch the browser.
             *
             * @param {string} path The path to the browser binary to use.
             * @return {!Options} A self reference.
             */
            setBinaryPath(path) {
              this.options_.binary = path
              return this
            }

            /**
             * Sets whether to leave the started browser process running if the controlling
             * driver service is killed before {@link webdriver.WebDriver#quit()} is
             * called.
             * @param {boolean} detach Whether to leave the browser running if the
             *     driver service is killed before the session.
             * @return {!Options} A self reference.
             */
            detachDriver(detach) {
              this.options_.detach = detach
              return this
            }

            /**
             * Sets the user preferences for Chrome's user profile. See the "Preferences"
             * file in Chrome's user data directory for examples.
             * @param {!Object} prefs Dictionary of user preferences to use.
             * @return {!Options} A self reference.
             */
            setUserPreferences(prefs) {
              this.options_.prefs = prefs
              return this
            }

            /**
             * Sets the performance logging preferences. Options include:
             *
             * - `enableNetwork`: Whether or not to collect events from Network domain.
             * - `enablePage`: Whether or not to collect events from Page domain.
             * - `enableTimeline`: Whether or not to collect events from Timeline domain.
             *     Note: when tracing is enabled, Timeline domain is implicitly disabled,
             *     unless `enableTimeline` is explicitly set to true.
             * - `traceCategories`: A comma-separated string of Chromium tracing
             *     categories for which trace events should be collected. An unspecified
             *     or empty string disables tracing.
             * - `bufferUsageReportingInterval`: The requested number of milliseconds
             *     between DevTools trace buffer usage events. For example, if 1000, then
             *     once per second, DevTools will report how full the trace buffer is. If
             *     a report indicates the buffer usage is 100%, a warning will be issued.
             *
             * @param {{enableNetwork: boolean,
             *          enablePage: boolean,
             *          enableTimeline: boolean,
             *          traceCategories: string,
             *          bufferUsageReportingInterval: number}} prefs The performance
             *     logging preferences.
             * @return {!Options} A self reference.
             */
            setPerfLoggingPrefs(prefs) {
              this.options_.perfLoggingPrefs = prefs
              return this
            }

            /**
             * Sets preferences for the "Local State" file in Chrome's user data
             * directory.
             * @param {!Object} state Dictionary of local state preferences.
             * @return {!Options} A self reference.
             */
            setLocalState(state) {
              this.options_.localState = state
              return this
            }

            /**
             * Sets the name of the activity hosting a Chrome-based Android WebView. This
             * option must be set to connect to an [Android WebView](
             * https://chromedriver.chromium.org/getting-started/getting-started---android)
             *
             * @param {string} name The activity name.
             * @return {!Options} A self reference.
             */
            androidActivity(name) {
              this.options_.androidActivity = name
              return this
            }

            /**
             * Sets the device serial number to connect to via ADB. If not specified, the
             * WebDriver server will select an unused device at random. An error will be
             * returned if all devices already have active sessions.
             *
             * @param {string} serial The device serial number to connect to.
             * @return {!Options} A self reference.
             */
            androidDeviceSerial(serial) {
              this.options_.androidDeviceSerial = serial
              return this
            }

            /**
             * Sets the package name of the Chrome or WebView app.
             *
             * @param {?string} pkg The package to connect to, or `null` to disable Android
             *     and switch back to using desktop browser.
             * @return {!Options} A self reference.
             */
            androidPackage(pkg) {
              this.options_.androidPackage = pkg
              return this
            }

            /**
             * Sets the process name of the Activity hosting the WebView (as given by
             * `ps`). If not specified, the process name is assumed to be the same as
             * {@link #androidPackage}.
             *
             * @param {string} processName The main activity name.
             * @return {!Options} A self reference.
             */
            androidProcess(processName) {
              this.options_.androidProcess = processName
              return this
            }

            /**
             * Sets whether to connect to an already-running instead of the specified
             * {@linkplain #androidProcess app} instead of launching the app with a clean
             * data directory.
             *
             * @param {boolean} useRunning Whether to connect to a running instance.
             * @return {!Options} A self reference.
             */
            androidUseRunningApp(useRunning) {
              this.options_.androidUseRunningApp = useRunning
              return this
            }

            /**
             * Sets the path to the browser's log file. This path should exist on the machine
             * that will launch the browser.
             * @param {string} path Path to the log file to use.
             * @return {!Options} A self reference.
             */
            setBrowserLogFile(path) {
              this.options_.logPath = path
              return this
            }

            /**
             * Sets the directory to store browser minidumps in. This option is only
             * supported when the driver is running on Linux.
             * @param {string} path The directory path.
             * @return {!Options} A self reference.
             */
            setBrowserMinidumpPath(path) {
              this.options_.minidumpPath = path
              return this
            }

            /**
             * Configures the browser to emulate a mobile device. For more information, refer
             * to the ChromeDriver project page on [mobile emulation][em]. Configuration
             * options include:
             *
             * - `deviceName`: The name of a pre-configured [emulated device][devem]
             * - `width`: screen width, in pixels
             * - `height`: screen height, in pixels
             * - `pixelRatio`: screen pixel ratio
             *
             * __Example 1: Using a Pre-configured Device__
             *
             *     let options = new chrome.Options().setMobileEmulation(
             *         {deviceName: 'Google Nexus 5'});
             *
             *     let driver = chrome.Driver.createSession(options);
             *
             * __Example 2: Using Custom Screen Configuration__
             *
             *     let options = new chrome.Options().setMobileEmulation({deviceMetrics: {
             *         width: 360,
             *         height: 640,
             *         pixelRatio: 3.0
             *     }});
             *
             *     let driver = chrome.Driver.createSession(options);
             *
             *
             * [em]: https://chromedriver.chromium.org/mobile-emulation
             * [devem]: https://developer.chrome.com/devtools/docs/device-mode
             *
             * @param {?({deviceName: string}|
             *           {width: number, height: number, pixelRatio: number})} config The
             *     mobile emulation configuration, or `null` to disable emulation.
             * @return {!Options} A self reference.
             */
            setMobileEmulation(config) {
              this.options_.mobileEmulation = config
              return this
            }

            /**
             * Sets a list of the window types that will appear when getting window
             * handles. For access to <webview> elements, include "webview" in the list.
             * @param {...(string|!Array<string>)} args The window types that will appear
             * when getting window handles.
             * @return {!Options} A self reference.
             */
            windowTypes(...args) {
              let windowTypes = (this.options_.windowTypes || []).concat(...args)
              if (windowTypes.length) {
                this.options_.windowTypes = windowTypes
              }
              return this
            }

            /**
             * Enable bidi connection
             * @returns {!Capabilities}
             */
            enableBidi() {
              return this.set('webSocketUrl', true)
            }
          }

          /**
           * A list of extensions to install when launching the browser.
           */
          class Extensions {
            constructor() {
              this.extensions = []
            }

            /**
             * @return {number} The length of the extensions list.
             */
            get length() {
              return this.extensions.length
            }

            /**
             * Add additional extensions to install when launching the browser. Each
             * extension should be specified as the path to the packed CRX file, or a
             * Buffer for an extension.
             *
             * @param {...(string|!Buffer|!Array<(string|!Buffer)>)} args The
             *     extensions to add.
             */
            add(...args) {
              this.extensions = this.extensions.concat(...args)
            }

            /**
             * @return {!Object} A serialized representation of this Extensions object.
             */
            [Symbols.serialize]() {
              return this.extensions.map(function (extension) {
                if (Buffer.isBuffer(extension)) {
                  return extension.toString('base64')
                }
                return io
                  .read(/** @type {string} */ (extension))
                  .then((buffer) => buffer.toString('base64'))
              })
            }
          }

          /**
           * Creates a new WebDriver client for Chromium-based browsers.
           */
          class Driver extends webdriver.WebDriver {
            /**
             * Creates a new session with the WebDriver server.
             *
             * @param {(Capabilities|Options)=} opt_config The configuration options.
             * @param {(remote.DriverService|http.Executor)=} opt_serviceExecutor Either
             *     a  DriverService to use for the remote end, or a preconfigured executor
             *     for an externally managed endpoint. If neither is provided, the
             *     {@linkplain ##getDefaultService default service} will be used by
             *     default.
             * @return {!Driver} A new driver instance.
             */
            static createSession(caps, opt_serviceExecutor) {
              let executor
              let onQuit
              if (opt_serviceExecutor instanceof http.Executor) {
                executor = opt_serviceExecutor
                configureExecutor(executor, this.VENDOR_COMMAND_PREFIX)
              } else {
                let service = opt_serviceExecutor || this.getDefaultService()
                if (!service.getExecutable()) {
                  service.setExecutable(getPath(service, caps))
                }
                onQuit = () => service.kill()
                executor = createExecutor(service.start(), this.VENDOR_COMMAND_PREFIX)
              }

              // W3C spec requires noProxy value to be an array of strings, but Chromium
              // expects a single host as a string.
              let proxy = caps.get(Capability.PROXY)
              if (proxy && Array.isArray(proxy.noProxy)) {
                proxy.noProxy = proxy.noProxy[0]
                if (!proxy.noProxy) {
                  proxy.noProxy = undefined
                }
              }

              return /** @type {!Driver} */ (super.createSession(executor, caps, onQuit))
            }

            /**
             * This function is a no-op as file detectors are not supported by this
             * implementation.
             * @override
             */
            setFileDetector() {}

            /**
             * Schedules a command to launch Chrome App with given ID.
             * @param {string} id ID of the App to launch.
             * @return {!Promise<void>} A promise that will be resolved
             *     when app is launched.
             */
            launchApp(id) {
              return this.execute(new command.Command(Command.LAUNCH_APP).setParameter('id', id))
            }

            /**
             * Schedules a command to get Chromium network emulation settings.
             * @return {!Promise} A promise that will be resolved when network
             *     emulation settings are retrieved.
             */
            getNetworkConditions() {
              return this.execute(new command.Command(Command.GET_NETWORK_CONDITIONS))
            }

            /**
             * Schedules a command to delete Chromium network emulation settings.
             * @return {!Promise} A promise that will be resolved when network
             *     emulation settings have been deleted.
             */
            deleteNetworkConditions() {
              return this.execute(new command.Command(Command.DELETE_NETWORK_CONDITIONS))
            }

            /**
             * Schedules a command to set Chromium network emulation settings.
             *
             * __Sample Usage:__
             *
             *  driver.setNetworkConditions({
             *    offline: false,
             *    latency: 5, // Additional latency (ms).
             *    download_throughput: 500 * 1024, // Maximal aggregated download throughput.
             *    upload_throughput: 500 * 1024 // Maximal aggregated upload throughput.
             * });
             *
             * @param {Object} spec Defines the network conditions to set
             * @return {!Promise<void>} A promise that will be resolved when network
             *     emulation settings are set.
             */
            setNetworkConditions(spec) {
              if (!spec || typeof spec !== 'object') {
                throw TypeError('setNetworkConditions called with non-network-conditions parameter')
              }
              return this.execute(
                new command.Command(Command.SET_NETWORK_CONDITIONS).setParameter(
                  'network_conditions',
                  spec
                )
              )
            }

            /**
             * Sends an arbitrary devtools command to the browser.
             *
             * @param {string} cmd The name of the command to send.
             * @param {Object=} params The command parameters.
             * @return {!Promise<void>} A promise that will be resolved when the command
             *     has finished.
             * @see <https://chromedevtools.github.io/devtools-protocol/>
             */
            sendDevToolsCommand(cmd, params = {}) {
              return this.execute(
                new command.Command(Command.SEND_DEVTOOLS_COMMAND)
                  .setParameter('cmd', cmd)
                  .setParameter('params', params)
              )
            }

            /**
             * Sends an arbitrary devtools command to the browser and get the result.
             *
             * @param {string} cmd The name of the command to send.
             * @param {Object=} params The command parameters.
             * @return {!Promise<string>} A promise that will be resolved when the command
             *     has finished.
             * @see <https://chromedevtools.github.io/devtools-protocol/>
             */
            sendAndGetDevToolsCommand(cmd, params = {}) {
              return this.execute(
                new command.Command(Command.SEND_AND_GET_DEVTOOLS_COMMAND)
                  .setParameter('cmd', cmd)
                  .setParameter('params', params)
              )
            }

            /**
             * Set a permission state to the given value.
             *
             * @param {string} name A name of the permission to update.
             * @param {('granted'|'denied'|'prompt')} state State to set permission to.
             * @returns {!Promise<Object>} A promise that will be resolved when the
             *     command has finished.
             * @see <https://w3c.github.io/permissions/#permission-registry> for valid
             *     names
             */
            setPermission(name, state) {
              return this.execute(
                new command.Command(Command.SET_PERMISSION)
                  .setParameter('descriptor', { name })
                  .setParameter('state', state)
              )
            }

            /**
             * Sends a DevTools command to change the browser's download directory.
             *
             * @param {string} path The desired download directory.
             * @return {!Promise<void>} A promise that will be resolved when the command
             *     has finished.
             * @see #sendDevToolsCommand
             */
            async setDownloadPath(path) {
              if (!path || typeof path !== 'string') {
                throw new error.InvalidArgumentError('invalid download path')
              }
              const stat = await io.stat(path)
              if (!stat.isDirectory()) {
                throw new error.InvalidArgumentError('not a directory: ' + path)
              }
              return this.sendDevToolsCommand('Page.setDownloadBehavior', {
                behavior: 'allow',
                downloadPath: path
              })
            }

            /**
             * Returns the list of cast sinks (Cast devices) available to the Chrome media router.
             *
             * @return {!promise.Thenable<void>} A promise that will be resolved with an array of Strings
             *   containing the friendly device names of available cast sink targets.
             */
            getCastSinks() {
              return this.schedule(
                new command.Command(Command.GET_CAST_SINKS),
                'Driver.getCastSinks()'
              )
            }

            /**
             * Selects a cast sink (Cast device) as the recipient of media router intents (connect or play).
             *
             * @param {String} deviceName name of the target device.
             * @return {!promise.Thenable<void>} A promise that will be resolved
             *     when the target device has been selected to respond further webdriver commands.
             */
            setCastSinkToUse(deviceName) {
              return this.schedule(
                new command.Command(Command.SET_CAST_SINK_TO_USE).setParameter(
                  'sinkName',
                  deviceName
                ),
                'Driver.setCastSinkToUse(' + deviceName + ')'
              )
            }

            /**
             * Initiates desktop mirroring for the current browser tab on the specified device.
             *
             * @param {String} deviceName name of the target device.
             * @return {!promise.Thenable<void>} A promise that will be resolved
             *     when the mirror command has been issued to the device.
             */
            startDesktopMirroring(deviceName) {
              return this.schedule(
                new command.Command(Command.START_CAST_DESKTOP_MIRRORING).setParameter(
                  'sinkName',
                  deviceName
                ),
                'Driver.startDesktopMirroring(' + deviceName + ')'
              )
            }

            /**
             * Initiates tab mirroring for the current browser tab on the specified device.
             *
             * @param {String} deviceName name of the target device.
             * @return {!promise.Thenable<void>} A promise that will be resolved
             *     when the mirror command has been issued to the device.
             */
            startCastTabMirroring(deviceName) {
              return this.schedule(
                new command.Command(Command.START_CAST_TAB_MIRRORING).setParameter(
                  'sinkName',
                  deviceName
                ),
                'Driver.startCastTabMirroring(' + deviceName + ')'
              )
            }

            /**
             * Returns an error message when there is any issue in a Cast session.
             * @return {!promise.Thenable<void>} A promise that will be resolved
             *     when the mirror command has been issued to the device.
             */
            getCastIssueMessage() {
              return this.schedule(
                new command.Command(Command.GET_CAST_ISSUE_MESSAGE),
                'Driver.getCastIssueMessage()'
              )
            }

            /**
             * Stops casting from media router to the specified device, if connected.
             *
             * @param {String} deviceName name of the target device.
             * @return {!promise.Thenable<void>} A promise that will be resolved
             *     when the stop command has been issued to the device.
             */
            stopCasting(deviceName) {
              return this.schedule(
                new command.Command(Command.STOP_CASTING).setParameter('sinkName', deviceName),
                'Driver.stopCasting(' + deviceName + ')'
              )
            }
          }

          // PUBLIC API

          module.exports = {
            Driver,
            Options,
            ServiceBuilder
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/common/driverFinder.js':
        /*!****************************************************************!*\
  !*** ./node_modules/selenium-webdriver/common/driverFinder.js ***!
  \****************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           *  This implementation is still in beta, and may change.
           *
           *  Utility to find if a given file is present and executable.
           */

          const { driverLocation } = __webpack_require__(
            /*! ./seleniumManager */ './node_modules/selenium-webdriver/common/seleniumManager.js'
          )
          const fs = __webpack_require__(/*! fs */ 'fs')

          /**
           * Determines the path of the correct Selenium Manager binary
           * @returns {string}
           */
          function getPath(service, capabilities) {
            try {
              return pathExists(service.getExecutable()) || driverLocation(capabilities)
            } catch (e) {
              throw Error(
                `Unable to obtain browser driver.
        For more information on how to install drivers see
        https://www.selenium.dev/documentation/webdriver/getting_started/install_drivers/. ${e}`
              )
            }
          }

          /**
           * _Synchronously_ attempts to locate the driver executable on the current
           * system.
           *
           * @param {!string} driverPath
           *
           * @return {?string} the located executable, or `null`.
           */
          function pathExists(driverPath) {
            if (!driverPath || !fs.existsSync(driverPath)) {
              return null
            }
            return driverPath
          }

          // PUBLIC API
          module.exports = { getPath }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/common/seleniumManager.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/selenium-webdriver/common/seleniumManager.js ***!
  \*******************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           *  This implementation is still in beta, and may change.
           *
           *  Wrapper for getting information from the Selenium Manager binaries
           */

          const { platform } = __webpack_require__(/*! process */ 'process')
          const path = __webpack_require__(/*! path */ 'path')
          const fs = __webpack_require__(/*! fs */ 'fs')
          const spawnSync = __webpack_require__(/*! child_process */ 'child_process').spawnSync

          /**
           * currently supported browsers for selenium-manager
           * @type {string[]}
           */
          const Browser = ['chrome', 'firefox', 'edge', 'MicrosoftEdge', 'iexplorer']

          /**
           * Determines the path of the correct Selenium Manager binary
           * @returns {string}
           */
          function getBinary() {
            const directory = {
              darwin: 'macos',
              win32: 'windows',
              cygwin: 'windows',
              linux: 'linux'
            }[platform]

            const file = directory === 'windows' ? 'selenium-manager.exe' : 'selenium-manager'

            let seleniumManagerBasePath = path.join(__dirname, '..', '/bin')

            const filePath = path.join(seleniumManagerBasePath, directory, file)

            if (!fs.existsSync(filePath)) {
              throw new Error(`Unable to obtain Selenium Manager`)
            }

            return filePath
          }

          /**
           * Determines the path of the correct driver
           * @param {Capabilities} options browser options to fetch the driver
           * @returns {string} path of the driver location
           */

          function driverLocation(options) {
            if (!Browser.includes(options.getBrowserName().toLocaleString())) {
              throw new Error(
                `Unable to locate driver associated with browser name: ${options.getBrowserName()}`
              )
            }

            console.debug(
              'Applicable driver not found; attempting to install with Selenium Manager (Beta)'
            )

            let args = ['--browser', options.getBrowserName(), '--output', 'json']

            if (options.getBrowserVersion() && options.getBrowserVersion() !== '') {
              args.push('--browser-version', options.getBrowserVersion())
            }

            const vendorOptions =
              options.get('goog:chromeOptions') ||
              options.get('ms:edgeOptions') ||
              options.get('moz:firefoxOptions')
            if (vendorOptions && vendorOptions.binary && vendorOptions.binary !== '') {
              args.push('--browser-path', '"' + vendorOptions.binary + '"')
            }

            const proxyOptions = options.getProxy()

            // Check if proxyOptions exists and has properties
            if (proxyOptions && Object.keys(proxyOptions).length > 0) {
              const httpProxy = proxyOptions['httpProxy']
              const sslProxy = proxyOptions['sslProxy']

              if (httpProxy !== undefined) {
                args.push('--proxy', httpProxy)
              } else if (sslProxy !== undefined) {
                args.push('--proxy', sslProxy)
              }
            }

            const smBinary = getBinary()
            const spawnResult = spawnSync(smBinary, args)
            let output
            if (spawnResult.status) {
              let errorMessage
              if (spawnResult.stderr.toString()) {
                errorMessage = spawnResult.stderr.toString()
              }
              if (spawnResult.stdout.toString()) {
                try {
                  output = JSON.parse(spawnResult.stdout.toString())
                  errorMessage = output.result.message
                } catch (e) {
                  errorMessage = e.toString()
                }
              }
              throw new Error(
                `Error executing command for ${smBinary} with ${args}: ${errorMessage}`
              )
            }
            try {
              output = JSON.parse(spawnResult.stdout.toString())
            } catch (e) {
              throw new Error(
                `Error executing command for ${smBinary} with ${args}: ${e.toString()}`
              )
            }

            for (const key in output.logs) {
              if (output.logs[key].level === 'WARN') {
                console.warn(`${output.logs[key].message}`)
              }
            }

            return output.result.message
          }

          // PUBLIC API
          module.exports = { driverLocation }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/devtools/CDPConnection.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/selenium-webdriver/devtools/CDPConnection.js ***!
  \*******************************************************************/
        /***/ (__unused_webpack_module, exports) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const RESPONSE_TIMEOUT = 1000 * 30
          class CDPConnection {
            constructor(wsConnection) {
              this._wsConnection = wsConnection
              this.cmd_id = 0
              this.targetID = null
              this.sessionId = null
            }

            execute(method, params, callback) {
              let message = {
                method,
                id: this.cmd_id++
              }
              if (this.sessionId) {
                message['sessionId'] = this.sessionId
              }

              const mergedMessage = Object.assign({ params: params }, message)
              this._wsConnection.send(JSON.stringify(mergedMessage), callback)
            }

            async send(method, params) {
              let cdp_id = this.cmd_id++
              let message = {
                method,
                id: cdp_id
              }
              if (this.sessionId) {
                message['sessionId'] = this.sessionId
              }

              const mergedMessage = Object.assign({ params: params }, message)
              this._wsConnection.send(JSON.stringify(mergedMessage))

              return new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                  reject(new Error(`Request with id ${cdp_id} timed out`))
                  handler.off('message', listener)
                }, RESPONSE_TIMEOUT)

                const listener = (data) => {
                  try {
                    const payload = JSON.parse(data.toString())
                    if (payload.id === cdp_id) {
                      clearTimeout(timeoutId)
                      handler.off('message', listener)
                      resolve(payload)
                    }
                  } catch (err) {
                    console.error(`Failed parse message: ${err.message}`)
                  }
                }

                const handler = this._wsConnection.on('message', listener)
              })
            }
          }

          exports.CdpConnection = CDPConnection

          /***/
        },

      /***/ './node_modules/selenium-webdriver/edge.js':
        /*!*************************************************!*\
  !*** ./node_modules/selenium-webdriver/edge.js ***!
  \*************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
 * @fileoverview Defines a {@linkplain Driver WebDriver} client for
 * Microsoft's Edge web browser. Edge (Chromium) is supported and support
 * for Edge Legacy (EdgeHTML) as part of https://github.com/SeleniumHQ/selenium/issues/9166.
 * Before using this module, you must download and install the correct
 * [WebDriver](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/) server.
 *
 * Ensure that the msedgedriver (Chromium)
 * is on your [PATH](http://en.wikipedia.org/wiki/PATH_%28variable%29).
 *
 * You may use {@link Options} to specify whether Edge Chromium options should be used:

 *     const edge = require('selenium-webdriver/edge');
 *     const options = new edge.Options();

 * There are three primary classes exported by this module:
 *
 * 1. {@linkplain ServiceBuilder}: configures the
 *     {@link ./remote.DriverService remote.DriverService}
 *     that manages the [WebDriver] child process.
 *
 * 2. {@linkplain Options}: defines configuration options for each new
 *     WebDriver session, such as which
 *     {@linkplain Options#setProxy proxy} to use when starting the browser.
 *
 * 3. {@linkplain Driver}: the WebDriver client; each new instance will control
 *     a unique browser session.
 *
 * __Customizing the WebDriver Server__ <a id="custom-server"></a>
 *
 * By default, every MicrosoftEdge session will use a single driver service,
 * which is started the first time a {@link Driver} instance is created and
 * terminated when this process exits. The default service will inherit its
 * environment from the current process.
 * You may obtain a handle to this default service using
 * {@link #getDefaultService getDefaultService()} and change its configuration
 * with {@link #setDefaultService setDefaultService()}.
 *
 * You may also create a {@link Driver} with its own driver service. This is
 * useful if you need to capture the server's log output for a specific session:
 *
 *     const edge = require('selenium-webdriver/edge');
 *
 *     const service = new edge.ServiceBuilder()
 *         .setPort(55555)
 *         .build();
 *
 *     let options = new edge.Options();
 *     // configure browser options ...
 *
 *     let driver = edge.Driver.createSession(options, service);
 *
 * Users should only instantiate the {@link Driver} class directly when they
 * need a custom driver service configuration (as shown above). For normal
 * operation, users should start msedgedriver using the
 * {@link ./builder.Builder selenium-webdriver.Builder}.
 *
 * [WebDriver (Chromium)]: https://docs.microsoft.com/en-us/microsoft-edge/webdriver-chromium
 */

          const { Browser } = __webpack_require__(
            /*! ./lib/capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )
          const io = __webpack_require__(
            /*! ./io */ './node_modules/selenium-webdriver/io/index.js'
          )
          const chromium = __webpack_require__(
            /*! ./chromium */ './node_modules/selenium-webdriver/chromium.js'
          )

          /**
           * Name of the EdgeDriver executable.
           * @type {string}
           * @const
           */
          const EDGEDRIVER_CHROMIUM_EXE =
            process.platform === 'win32' ? 'msedgedriver.exe' : 'msedgedriver'

          /** @type {remote.DriverService} */

          /**
           * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
           * a [MSEdgeDriver](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/)
           * server in a child process.
           */
          class ServiceBuilder extends chromium.ServiceBuilder {
            /**
             * @param {string=} opt_exe Path to the server executable to use. If omitted,
             *     the builder will attempt to locate the msedgedriver on the current
             *     PATH.
             * @throws {Error} If provided executable does not exist, or the msedgedriver
             *     cannot be found on the PATH.
             */
            constructor(opt_exe) {
              let exe = opt_exe || locateSynchronously()
              super(exe)
              this.setLoopback(true)
            }
          }

          /**
           * Class for managing edge chromium specific options.
           */
          class Options extends chromium.Options {
            /**
             * Sets the path to the edge binary to use
             *
             * The binary path be absolute or relative to the msedgedriver server
             * executable, but it must exist on the machine that will launch edge chromium.
             *
             * @param {string} path The path to the msedgedriver binary to use.
             * @return {!Options} A self reference.
             */
            setEdgeChromiumBinaryPath(path) {
              return this.setBinaryPath(path)
            }

            /**
             * Changes the browser name to 'webview2' to enable
             * <a href="https://learn.microsoft.com/en-us/microsoft-edge/webview2/how-to/webdriver">
             *   test automation of WebView2 apps with Microsoft Edge WebDriver
             * </a>
             *
             * @param {boolean} enable  flag to enable or disable the 'webview2' usage
             */
            useWebView(enable) {
              const browserName = enable ? 'webview2' : Browser.EDGE
              return this.setBrowserName(browserName)
            }
          }

          /**
           * Creates a new WebDriver client for Microsoft's Edge.
           */
          class Driver extends chromium.Driver {
            /**
             * Creates a new browser session for Microsoft's Edge browser.
             *
             * @param {(Capabilities|Options)=} opt_config The configuration options.
             * @param {remote.DriverService=} opt_serviceExecutor The service to use; will create
             *     a new Legacy or Chromium service based on {@linkplain Options} by default.
             * @return {!Driver} A new driver instance.
             */
            static createSession(opt_config, opt_serviceExecutor) {
              let caps = opt_config || new Options()
              return /** @type {!Driver} */ (super.createSession(caps, opt_serviceExecutor))
            }

            /**
             * returns new instance of edge driver service
             * @returns {remote.DriverService}
             */
            static getDefaultService() {
              return new ServiceBuilder().build()
            }

            /**
             * This function is a no-op as file detectors are not supported by this
             * implementation.
             * @override
             */
            setFileDetector() {}
          }

          /**
           * _Synchronously_ attempts to locate the chromedriver executable on the current
           * system.
           *
           * @return {?string} the located executable, or `null`.
           */
          function locateSynchronously() {
            return io.findInPath(EDGEDRIVER_CHROMIUM_EXE, true)
          }

          Options.prototype.BROWSER_NAME_VALUE = Browser.EDGE
          Options.prototype.CAPABILITY_KEY = 'ms:edgeOptions'
          Driver.prototype.VENDOR_CAPABILITY_PREFIX = 'ms'

          // PUBLIC API

          module.exports = {
            Driver,
            Options,
            ServiceBuilder,
            locateSynchronously
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/firefox.js':
        /*!****************************************************!*\
  !*** ./node_modules/selenium-webdriver/firefox.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines the {@linkplain Driver WebDriver} client for Firefox.
           * Before using this module, you must download the latest
           * [geckodriver release] and ensure it can be found on your system [PATH].
           *
           * Each FirefoxDriver instance will be created with an anonymous profile,
           * ensuring browser historys do not share session data (cookies, history, cache,
           * offline storage, etc.)
           *
           * __Customizing the Firefox Profile__
           *
           * The profile used for each WebDriver session may be configured using the
           * {@linkplain Options} class. For example, you may install an extension, like
           * Firebug:
           *
           *     const {Builder} = require('selenium-webdriver');
           *     const firefox = require('selenium-webdriver/firefox');
           *
           *     let options = new firefox.Options()
           *         .addExtensions('/path/to/firebug.xpi')
           *         .setPreference('extensions.firebug.showChromeErrors', true);
           *
           *     let driver = new Builder()
           *         .forBrowser('firefox')
           *         .setFirefoxOptions(options)
           *         .build();
           *
           * The {@linkplain Options} class may also be used to configure WebDriver based
           * on a pre-existing browser profile:
           *
           *     let profile = '/usr/local/home/bob/.mozilla/firefox/3fgog75h.testing';
           *     let options = new firefox.Options().setProfile(profile);
           *
           * The FirefoxDriver will _never_ modify a pre-existing profile; instead it will
           * create a copy for it to modify. By extension, there are certain browser
           * preferences that are required for WebDriver to function properly and they
           * will always be overwritten.
           *
           * __Using a Custom Firefox Binary__
           *
           * On Windows and MacOS, the FirefoxDriver will search for Firefox in its
           * default installation location:
           *
           * - Windows: C:\Program Files and C:\Program Files (x86).
           * - MacOS: /Applications/Firefox.app
           *
           * For Linux, Firefox will always be located on the PATH: `$(where firefox)`.
           *
           * Several methods are provided for starting Firefox with a custom executable.
           * First, on Windows and MacOS, you may configure WebDriver to check the default
           * install location for a non-release channel. If the requested channel cannot
           * be found in its default location, WebDriver will fallback to searching your
           * PATH. _Note:_ on Linux, Firefox is _always_ located on your path, regardless
           * of the requested channel.
           *
           *     const {Builder} = require('selenium-webdriver');
           *     const firefox = require('selenium-webdriver/firefox');
           *
           *     let options = new firefox.Options().setBinary(firefox.Channel.NIGHTLY);
           *     let driver = new Builder()
           *         .forBrowser('firefox')
           *         .setFirefoxOptions(options)
           *         .build();
           *
           * On all platforms, you may configure WebDriver to use a Firefox specific
           * executable:
           *
           *     let options = new firefox.Options()
           *         .setBinary('/my/firefox/install/dir/firefox-bin');
           *
           * __Remote Testing__
           *
           * You may customize the Firefox binary and profile when running against a
           * remote Selenium server. Your custom profile will be packaged as a zip and
           * transferred to the remote host for use. The profile will be transferred
           * _once for each new session_. The performance impact should be minimal if
           * you've only configured a few extra browser preferences. If you have a large
           * profile with several extensions, you should consider installing it on the
           * remote host and defining its path via the {@link Options} class. Custom
           * binaries are never copied to remote machines and must be referenced by
           * installation path.
           *
           *     const {Builder} = require('selenium-webdriver');
           *     const firefox = require('selenium-webdriver/firefox');
           *
           *     let options = new firefox.Options()
           *         .setProfile('/profile/path/on/remote/host')
           *         .setBinary('/install/dir/on/remote/host/firefox-bin');
           *
           *     let driver = new Builder()
           *         .forBrowser('firefox')
           *         .usingServer('http://127.0.0.1:4444/wd/hub')
           *         .setFirefoxOptions(options)
           *         .build();
           *
           * [geckodriver release]: https://github.com/mozilla/geckodriver/releases/
           * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29
           */

          const fs = __webpack_require__(/*! fs */ 'fs')
          const path = __webpack_require__(/*! path */ 'path')
          const Symbols = __webpack_require__(
            /*! ./lib/symbols */ './node_modules/selenium-webdriver/lib/symbols.js'
          )
          const command = __webpack_require__(
            /*! ./lib/command */ './node_modules/selenium-webdriver/lib/command.js'
          )
          const http = __webpack_require__(
            /*! ./http */ './node_modules/selenium-webdriver/http/index.js'
          )
          const io = __webpack_require__(
            /*! ./io */ './node_modules/selenium-webdriver/io/index.js'
          )
          const remote = __webpack_require__(
            /*! ./remote */ './node_modules/selenium-webdriver/remote/index.js'
          )
          const webdriver = __webpack_require__(
            /*! ./lib/webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
          )
          const zip = __webpack_require__(
            /*! ./io/zip */ './node_modules/selenium-webdriver/io/zip.js'
          )
          const { Browser, Capabilities } = __webpack_require__(
            /*! ./lib/capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )
          const { Zip } = __webpack_require__(
            /*! ./io/zip */ './node_modules/selenium-webdriver/io/zip.js'
          )
          const { getPath } = __webpack_require__(
            /*! ./common/driverFinder */ './node_modules/selenium-webdriver/common/driverFinder.js'
          )

          /**
           * Thrown when there an add-on is malformed.
           * @final
           */
          class AddonFormatError extends Error {
            /** @param {string} msg The error message. */
            constructor(msg) {
              super(msg)
              /** @override */
              this.name = this.constructor.name
            }
          }

          /**
           * Installs an extension to the given directory.
           * @param {string} extension Path to the xpi extension file to install.
           * @param {string} dir Path to the directory to install the extension in.
           * @return {!Promise<string>} A promise for the add-on ID once
           *     installed.
           */
          async function installExtension(extension, dir) {
            const ext = extension.slice(-4)
            if (ext !== '.xpi' && ext !== '.zip') {
              throw Error('File name does not end in ".zip" or ".xpi": ' + ext)
            }

            let archive = await zip.load(extension)
            if (!archive.has('manifest.json')) {
              throw new AddonFormatError(`Couldn't find manifest.json in ${extension}`)
            }

            let buf = await archive.getFile('manifest.json')
            let parsedJSON = JSON.parse(buf.toString('utf8'))

            let { browser_specific_settings } =
              /** @type {{browser_specific_settings:{gecko:{id:string}}}} */
              parsedJSON

            if (browser_specific_settings && browser_specific_settings.gecko) {
              /* browser_specific_settings is an alternative to applications
               * It is meant to facilitate cross-browser plugins since Firefox48
               * see https://bugzilla.mozilla.org/show_bug.cgi?id=1262005
               */
              parsedJSON.applications = browser_specific_settings
            }

            let { applications } =
              /** @type {{applications:{gecko:{id:string}}}} */
              parsedJSON
            if (!(applications && applications.gecko && applications.gecko.id)) {
              throw new AddonFormatError(`Could not find add-on ID for ${extension}`)
            }

            await io.copy(extension, `${path.join(dir, applications.gecko.id)}.xpi`)
            return applications.gecko.id
          }

          class Profile {
            constructor() {
              /** @private {?string} */
              this.template_ = null

              /** @private {!Array<string>} */
              this.extensions_ = []
            }

            addExtensions(/** !Array<string> */ paths) {
              this.extensions_ = this.extensions_.concat(...paths)
            }

            /**
             * @return {(!Promise<string>|undefined)} a promise for a base64 encoded
             *     profile, or undefined if there's no data to include.
             */
            [Symbols.serialize]() {
              if (this.template_ || this.extensions_.length) {
                return buildProfile(this.template_, this.extensions_)
              }
              return undefined
            }
          }

          /**
           * @param {?string} template path to an existing profile to use as a template.
           * @param {!Array<string>} extensions paths to extensions to install in the new
           *     profile.
           * @return {!Promise<string>} a promise for the base64 encoded profile.
           */
          async function buildProfile(template, extensions) {
            let dir = template

            if (extensions.length) {
              dir = await io.tmpDir()
              if (template) {
                await io.copyDir(
                  /** @type {string} */ (template),
                  dir,
                  /(parent\.lock|lock|\.parentlock)/
                )
              }

              const extensionsDir = path.join(dir, 'extensions')
              await io.mkdir(extensionsDir)

              for (let i = 0; i < extensions.length; i++) {
                await installExtension(extensions[i], extensionsDir)
              }
            }

            let zip = new Zip()
            return zip
              .addDir(dir)
              .then(() => zip.toBuffer())
              .then((buf) => buf.toString('base64'))
          }

          /**
           * Configuration options for the FirefoxDriver.
           */
          class Options extends Capabilities {
            /**
             * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of
             *     capabilities to initialize this instance from.
             */
            constructor(other) {
              super(other)
              this.setBrowserName(Browser.FIREFOX)
            }

            /**
             * @return {!Object}
             * @private
             */
            firefoxOptions_() {
              let options = this.get('moz:firefoxOptions')
              if (!options) {
                options = {}
                this.set('moz:firefoxOptions', options)
              }
              return options
            }

            /**
             * @return {!Profile}
             * @private
             */
            profile_() {
              let options = this.firefoxOptions_()
              if (!options.profile) {
                options.profile = new Profile()
              }
              return options.profile
            }

            /**
             * Specify additional command line arguments that should be used when starting
             * the Firefox browser.
             *
             * @param {...(string|!Array<string>)} args The arguments to include.
             * @return {!Options} A self reference.
             */
            addArguments(...args) {
              if (args.length) {
                let options = this.firefoxOptions_()
                options.args = options.args ? options.args.concat(...args) : args
              }
              return this
            }

            /**
             * @deprecated Use {@link Options#addArguments} instead.
             * @example
             * options.addArguments('-headless');
             * @example
             * Configures the geckodriver to start Firefox in headless mode.
             *
             * @return {!Options} A self reference.
             */
            headless() {
              return this.addArguments('-headless')
            }

            /**
             * Sets the initial window size when running in
             * {@linkplain #headless headless} mode.
             *
             * @param {{width: number, height: number}} size The desired window size.
             * @return {!Options} A self reference.
             * @throws {TypeError} if width or height is unspecified, not a number, or
             *     less than or equal to 0.
             */
            windowSize({ width, height }) {
              function checkArg(arg) {
                if (typeof arg !== 'number' || arg <= 0) {
                  throw TypeError('Arguments must be {width, height} with numbers > 0')
                }
              }
              checkArg(width)
              checkArg(height)
              return this.addArguments(`--width=${width}`, `--height=${height}`)
            }

            /**
             * Add extensions that should be installed when starting Firefox.
             *
             * @param {...string} paths The paths to the extension XPI files to install.
             * @return {!Options} A self reference.
             */
            addExtensions(...paths) {
              this.profile_().addExtensions(paths)
              return this
            }

            /**
             * @param {string} key the preference key.
             * @param {(string|number|boolean)} value the preference value.
             * @return {!Options} A self reference.
             * @throws {TypeError} if either the key or value has an invalid type.
             */
            setPreference(key, value) {
              if (typeof key !== 'string') {
                throw TypeError(`key must be a string, but got ${typeof key}`)
              }
              if (
                typeof value !== 'string' &&
                typeof value !== 'number' &&
                typeof value !== 'boolean'
              ) {
                throw TypeError(
                  `value must be a string, number, or boolean, but got ${typeof value}`
                )
              }
              let options = this.firefoxOptions_()
              options.prefs = options.prefs || {}
              options.prefs[key] = value
              return this
            }

            /**
             * Sets the path to an existing profile to use as a template for new browser
             * sessions. This profile will be copied for each new session - changes will
             * not be applied to the profile itself.
             *
             * @param {string} profile The profile to use.
             * @return {!Options} A self reference.
             * @throws {TypeError} if profile is not a string.
             */
            setProfile(profile) {
              if (typeof profile !== 'string') {
                throw TypeError(`profile must be a string, but got ${typeof profile}`)
              }
              this.profile_().template_ = profile
              return this
            }

            /**
             * Sets the binary to use. The binary may be specified as the path to a
             * Firefox executable or a desired release {@link Channel}.
             *
             * @param {(string|!Channel)} binary The binary to use.
             * @return {!Options} A self reference.
             * @throws {TypeError} If `binary` is an invalid type.
             */
            setBinary(binary) {
              if (binary instanceof Channel || typeof binary === 'string') {
                this.firefoxOptions_().binary = binary
                return this
              }
              throw TypeError('binary must be a string path or Channel object')
            }

            /**
             * Enables Mobile start up features
             *
             * @param {string} androidPackage The package to use
             * @return {!Options} A self reference
             */
            enableMobile(
              androidPackage = 'org.mozilla.firefox',
              androidActivity = null,
              deviceSerial = null
            ) {
              this.firefoxOptions_().androidPackage = androidPackage

              if (androidActivity) {
                this.firefoxOptions_().androidActivity = androidActivity
              }
              if (deviceSerial) {
                this.firefoxOptions_().deviceSerial = deviceSerial
              }
              return this
            }

            /**
             * Enables moz:debuggerAddress for firefox cdp
             */
            enableDebugger() {
              return this.set('moz:debuggerAddress', true)
            }

            /**
             * Enable bidi connection
             * @returns {!Capabilities}
             */
            enableBidi() {
              return this.set('webSocketUrl', true)
            }
          }

          /**
           * Enum of available command contexts.
           *
           * Command contexts are specific to Marionette, and may be used with the
           * {@link #context=} method. Contexts allow you to direct all subsequent
           * commands to either "content" (default) or "chrome". The latter gives
           * you elevated security permissions.
           *
           * @enum {string}
           */
          const Context = {
            CONTENT: 'content',
            CHROME: 'chrome'
          }

          const GECKO_DRIVER_EXE = process.platform === 'win32' ? 'geckodriver.exe' : 'geckodriver'

          /**
           * _Synchronously_ attempts to locate the geckodriver executable on the current
           * system.
           *
           * @return {?string} the located executable, or `null`.
           */
          function locateSynchronously() {
            return io.findInPath(GECKO_DRIVER_EXE, true)
          }

          /**
           * @return {string} .
           * @throws {Error}
           */
          function findGeckoDriver() {
            return locateSynchronously()
          }

          /**
           * @param {string} file Path to the file to find, relative to the program files
           *     root.
           * @return {!Promise<?string>} A promise for the located executable.
           *     The promise will resolve to {@code null} if Firefox was not found.
           */
          function findInProgramFiles(file) {
            let files = [
              process.env['PROGRAMFILES'] || 'C:\\Program Files',
              process.env['PROGRAMFILES(X86)'] || 'C:\\Program Files (x86)'
            ].map((prefix) => path.join(prefix, file))
            return io.exists(files[0]).then(function (exists) {
              return exists
                ? files[0]
                : io.exists(files[1]).then(function (exists) {
                    return exists ? files[1] : null
                  })
            })
          }

          /** @enum {string} */
          const ExtensionCommand = {
            GET_CONTEXT: 'getContext',
            SET_CONTEXT: 'setContext',
            INSTALL_ADDON: 'install addon',
            UNINSTALL_ADDON: 'uninstall addon'
          }

          /**
           * Creates a command executor with support for Marionette's custom commands.
           * @param {!Promise<string>} serverUrl The server's URL.
           * @return {!command.Executor} The new command executor.
           */
          function createExecutor(serverUrl) {
            let client = serverUrl.then((url) => new http.HttpClient(url))
            let executor = new http.Executor(client)
            configureExecutor(executor)
            return executor
          }

          /**
           * Configures the given executor with Firefox-specific commands.
           * @param {!http.Executor} executor the executor to configure.
           */
          function configureExecutor(executor) {
            executor.defineCommand(
              ExtensionCommand.GET_CONTEXT,
              'GET',
              '/session/:sessionId/moz/context'
            )

            executor.defineCommand(
              ExtensionCommand.SET_CONTEXT,
              'POST',
              '/session/:sessionId/moz/context'
            )

            executor.defineCommand(
              ExtensionCommand.INSTALL_ADDON,
              'POST',
              '/session/:sessionId/moz/addon/install'
            )

            executor.defineCommand(
              ExtensionCommand.UNINSTALL_ADDON,
              'POST',
              '/session/:sessionId/moz/addon/uninstall'
            )
          }

          /**
           * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
           * a [geckodriver](https://github.com/mozilla/geckodriver) server in a child
           * process.
           */
          class ServiceBuilder extends remote.DriverService.Builder {
            /**
             * @param {string=} opt_exe Path to the server executable to use. If omitted,
             *     the builder will attempt to locate the geckodriver on the system PATH.
             */
            constructor(opt_exe) {
              super(opt_exe || findGeckoDriver())
              this.setLoopback(true) // Required.
            }

            /**
             * Enables verbose logging.
             *
             * @param {boolean=} opt_trace Whether to enable trace-level logging. By
             *     default, only debug logging is enabled.
             * @return {!ServiceBuilder} A self reference.
             */
            enableVerboseLogging(opt_trace) {
              return this.addArguments(opt_trace ? '-vv' : '-v')
            }
          }

          /**
           * A WebDriver client for Firefox.
           */
          class Driver extends webdriver.WebDriver {
            /**
             * Creates a new Firefox session.
             *
             * @param {(Options|Capabilities|Object)=} opt_config The
             *    configuration options for this driver, specified as either an
             *    {@link Options} or {@link Capabilities}, or as a raw hash object.
             * @param {(http.Executor|remote.DriverService)=} opt_executor Either a
             *   pre-configured command executor to use for communicating with an
             *   externally managed remote end (which is assumed to already be running),
             *   or the `DriverService` to use to start the geckodriver in a child
             *   process.
             *
             *   If an executor is provided, care should e taken not to use reuse it with
             *   other clients as its internal command mappings will be updated to support
             *   Firefox-specific commands.
             *
             *   _This parameter may only be used with Mozilla's GeckoDriver._
             *
             * @throws {Error} If a custom command executor is provided and the driver is
             *     configured to use the legacy FirefoxDriver from the Selenium project.
             * @return {!Driver} A new driver instance.
             */
            static createSession(opt_config, opt_executor) {
              let caps = opt_config instanceof Capabilities ? opt_config : new Options(opt_config)

              let executor
              let onQuit

              if (opt_executor instanceof http.Executor) {
                executor = opt_executor
                configureExecutor(executor)
              } else if (opt_executor instanceof remote.DriverService) {
                if (!opt_executor.getExecutable()) {
                  opt_executor.setExecutable(getPath(opt_executor, opt_config))
                }
                executor = createExecutor(opt_executor.start())
                onQuit = () => opt_executor.kill()
              } else {
                let service = new ServiceBuilder().build()
                if (!service.getExecutable()) {
                  service.setExecutable(getPath(service, opt_config))
                }
                executor = createExecutor(service.start())
                onQuit = () => service.kill()
              }

              return /** @type {!Driver} */ (super.createSession(executor, caps, onQuit))
            }

            /**
             * This function is a no-op as file detectors are not supported by this
             * implementation.
             * @override
             */
            setFileDetector() {}

            /**
             * Get the context that is currently in effect.
             *
             * @return {!Promise<Context>} Current context.
             */
            getContext() {
              return this.execute(new command.Command(ExtensionCommand.GET_CONTEXT))
            }

            /**
             * Changes target context for commands between chrome- and content.
             *
             * Changing the current context has a stateful impact on all subsequent
             * commands. The {@link Context.CONTENT} context has normal web
             * platform document permissions, as if you would evaluate arbitrary
             * JavaScript. The {@link Context.CHROME} context gets elevated
             * permissions that lets you manipulate the browser chrome itself,
             * with full access to the XUL toolkit.
             *
             * Use your powers wisely.
             *
             * @param {!Promise<void>} ctx The context to switch to.
             */
            setContext(ctx) {
              return this.execute(
                new command.Command(ExtensionCommand.SET_CONTEXT).setParameter('context', ctx)
              )
            }

            /**
             * Installs a new addon with the current session. This function will return an
             * ID that may later be used to {@linkplain #uninstallAddon uninstall} the
             * addon.
             *
             *
             * @param {string} path Path on the local filesystem to the web extension to
             *     install.
             * @param {boolean} temporary Flag indicating whether the extension should be
             *     installed temporarily - gets removed on restart
             * @return {!Promise<string>} A promise that will resolve to an ID for the
             *     newly installed addon.
             * @see #uninstallAddon
             */
            async installAddon(path, temporary = false) {
              let stats = fs.statSync(path)
              let buf
              if (stats.isDirectory()) {
                let zip = new Zip()
                await zip.addDir(path)
                buf = await zip.toBuffer('DEFLATE')
              } else {
                buf = await io.read(path)
              }
              return this.execute(
                new command.Command(ExtensionCommand.INSTALL_ADDON)
                  .setParameter('addon', buf.toString('base64'))
                  .setParameter('temporary', temporary)
              )
            }

            /**
             * Uninstalls an addon from the current browser session's profile.
             *
             * @param {(string|!Promise<string>)} id ID of the addon to uninstall.
             * @return {!Promise} A promise that will resolve when the operation has
             *     completed.
             * @see #installAddon
             */
            async uninstallAddon(id) {
              id = await Promise.resolve(id)
              return this.execute(
                new command.Command(ExtensionCommand.UNINSTALL_ADDON).setParameter('id', id)
              )
            }
          }

          /**
           * Provides methods for locating the executable for a Firefox release channel
           * on Windows and MacOS. For other systems (i.e. Linux), Firefox will always
           * be located on the system PATH.
           *
           * @final
           */
          class Channel {
            /**
             * @param {string} darwin The path to check when running on MacOS.
             * @param {string} win32 The path to check when running on Windows.
             */
            constructor(darwin, win32) {
              /** @private @const */ this.darwin_ = darwin
              /** @private @const */ this.win32_ = win32
              /** @private {Promise<string>} */
              this.found_ = null
            }

            /**
             * Attempts to locate the Firefox executable for this release channel. This
             * will first check the default installation location for the channel before
             * checking the user's PATH. The returned promise will be rejected if Firefox
             * can not be found.
             *
             * @return {!Promise<string>} A promise for the location of the located
             *     Firefox executable.
             */
            locate() {
              if (this.found_) {
                return this.found_
              }

              let found
              switch (process.platform) {
                case 'darwin':
                  found = io
                    .exists(this.darwin_)
                    .then((exists) => (exists ? this.darwin_ : io.findInPath('firefox')))
                  break

                case 'win32':
                  found = findInProgramFiles(this.win32_).then(
                    (found) => found || io.findInPath('firefox.exe')
                  )
                  break

                default:
                  found = Promise.resolve(io.findInPath('firefox'))
                  break
              }

              this.found_ = found.then((found) => {
                if (found) {
                  // TODO: verify version info.
                  return found
                }
                throw Error('Could not locate Firefox on the current system')
              })
              return this.found_
            }

            /** @return {!Promise<string>} */
            [Symbols.serialize]() {
              return this.locate()
            }
          }

          /**
           * Firefox's developer channel.
           * @const
           * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#aurora>
           */
          Channel.AURORA = new Channel(
            '/Applications/FirefoxDeveloperEdition.app/Contents/MacOS/firefox-bin',
            'Firefox Developer Edition\\firefox.exe'
          )

          /**
           * Firefox's beta channel. Note this is provided mainly for convenience as
           * the beta channel has the same installation location as the main release
           * channel.
           * @const
           * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#beta>
           */
          Channel.BETA = new Channel(
            '/Applications/Firefox.app/Contents/MacOS/firefox-bin',
            'Mozilla Firefox\\firefox.exe'
          )

          /**
           * Firefox's release channel.
           * @const
           * @see <https://www.mozilla.org/en-US/firefox/desktop/>
           */
          Channel.RELEASE = new Channel(
            '/Applications/Firefox.app/Contents/MacOS/firefox-bin',
            'Mozilla Firefox\\firefox.exe'
          )

          /**
           * Firefox's nightly release channel.
           * @const
           * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#nightly>
           */
          Channel.NIGHTLY = new Channel(
            '/Applications/Firefox Nightly.app/Contents/MacOS/firefox-bin',
            'Nightly\\firefox.exe'
          )

          // PUBLIC API

          module.exports = {
            Channel,
            Context,
            Driver,
            Options,
            ServiceBuilder,
            locateSynchronously
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/http/index.js':
        /*!*******************************************************!*\
  !*** ./node_modules/selenium-webdriver/http/index.js ***!
  \*******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines an {@linkplain cmd.Executor command executor} that
           * communicates with a remote end using HTTP + JSON.
           */

          const http = __webpack_require__(/*! http */ 'http')
          const https = __webpack_require__(/*! https */ 'https')
          const url = __webpack_require__(/*! url */ 'url')

          const httpLib = __webpack_require__(
            /*! ../lib/http */ './node_modules/selenium-webdriver/lib/http.js'
          )

          /**
           * @typedef {{protocol: (?string|undefined),
           *            auth: (?string|undefined),
           *            hostname: (?string|undefined),
           *            host: (?string|undefined),
           *            port: (?string|undefined),
           *            path: (?string|undefined),
           *            pathname: (?string|undefined)}}
           */
          let RequestOptions // eslint-disable-line

          /**
           * @param {string} aUrl The request URL to parse.
           * @return {RequestOptions} The request options.
           * @throws {Error} if the URL does not include a hostname.
           */
          function getRequestOptions(aUrl) {
            //eslint-disable-next-line node/no-deprecated-api
            let options = url.parse(aUrl)
            if (!options.hostname) {
              throw new Error('Invalid URL: ' + aUrl)
            }
            // Delete the search and has portions as they are not used.
            options.search = null
            options.hash = null
            options.path = options.pathname
            options.hostname = options.hostname === 'localhost' ? '127.0.0.1' : options.hostname // To support Node 17 and above. Refer https://github.com/nodejs/node/issues/40702 for details.
            return options
          }

          /** @const {string} */
          const USER_AGENT = (function () {
            const version = __webpack_require__(
              /*! ../package.json */ './node_modules/selenium-webdriver/package.json'
            ).version
            const platform = { darwin: 'mac', win32: 'windows' }[process.platform] || 'linux'
            return `selenium/${version} (js ${platform})`
          })()

          /**
           * A basic HTTP client used to send messages to a remote end.
           *
           * @implements {httpLib.Client}
           */
          class HttpClient {
            /**
             * @param {string} serverUrl URL for the WebDriver server to send commands to.
             * @param {http.Agent=} opt_agent The agent to use for each request.
             *     Defaults to `http.globalAgent`.
             * @param {?string=} opt_proxy The proxy to use for the connection to the
             *     server. Default is to use no proxy.
             * @param {?Object.<string,Object>} client_options
             */
            constructor(serverUrl, opt_agent, opt_proxy, client_options = {}) {
              /** @private {http.Agent} */
              this.agent_ = opt_agent || null

              /**
               * Base options for each request.
               * @private {RequestOptions}
               */
              this.options_ = getRequestOptions(serverUrl)

              /**
               * client options, header overrides
               */
              this.client_options = client_options

              /**
               * sets keep-alive for the agent
               * see https://stackoverflow.com/a/58332910
               */
              this.keepAlive = this.client_options['keep-alive']

              /**  @private {?RequestOptions} */
              this.proxyOptions_ = opt_proxy ? getRequestOptions(opt_proxy) : null
            }

            get keepAlive() {
              return this.agent_.keepAlive
            }

            set keepAlive(value) {
              if (value === 'true' || value === true) {
                this.agent_.keepAlive = true
              }
            }

            /** @override */
            send(httpRequest) {
              let data

              let headers = {}

              if (httpRequest.headers) {
                httpRequest.headers.forEach(function (value, name) {
                  headers[name] = value
                })
              }

              headers['User-Agent'] = this.client_options['user-agent'] || USER_AGENT
              headers['Content-Length'] = 0
              if (httpRequest.method == 'POST' || httpRequest.method == 'PUT') {
                data = JSON.stringify(httpRequest.data)
                headers['Content-Length'] = Buffer.byteLength(data, 'utf8')
                headers['Content-Type'] = 'application/json;charset=UTF-8'
              }

              let path = this.options_.path
              if (path.endsWith('/') && httpRequest.path.startsWith('/')) {
                path += httpRequest.path.substring(1)
              } else {
                path += httpRequest.path
              }
              //eslint-disable-next-line node/no-deprecated-api
              let parsedPath = url.parse(path)

              let options = {
                agent: this.agent_ || null,
                method: httpRequest.method,

                auth: this.options_.auth,
                hostname: this.options_.hostname,
                port: this.options_.port,
                protocol: this.options_.protocol,

                path: parsedPath.path,
                pathname: parsedPath.pathname,
                search: parsedPath.search,
                hash: parsedPath.hash,

                headers
              }

              return new Promise((fulfill, reject) => {
                sendRequest(options, fulfill, reject, data, this.proxyOptions_)
              })
            }
          }

          /**
           * Sends a single HTTP request.
           * @param {!Object} options The request options.
           * @param {function(!httpLib.Response)} onOk The function to call if the
           *     request succeeds.
           * @param {function(!Error)} onError The function to call if the request fails.
           * @param {?string=} opt_data The data to send with the request.
           * @param {?RequestOptions=} opt_proxy The proxy server to use for the request.
           * @param {number=} opt_retries The current number of retries.
           */
          function sendRequest(options, onOk, onError, opt_data, opt_proxy, opt_retries) {
            var hostname = options.hostname
            var port = options.port

            if (opt_proxy) {
              let proxy = /** @type {RequestOptions} */ (opt_proxy)

              // RFC 2616, section 5.1.2:
              // The absoluteURI form is REQUIRED when the request is being made to a
              // proxy.
              let absoluteUri = url.format(options)

              // RFC 2616, section 14.23:
              // An HTTP/1.1 proxy MUST ensure that any request message it forwards does
              // contain an appropriate Host header field that identifies the service
              // being requested by the proxy.
              let targetHost = options.hostname
              if (options.port) {
                targetHost += ':' + options.port
              }

              // Update the request options with our proxy info.
              options.headers['Host'] = targetHost
              options.path = absoluteUri
              options.host = proxy.host
              options.hostname = proxy.hostname
              options.port = proxy.port

              // Update the protocol to avoid EPROTO errors when the webdriver proxy
              // uses a different protocol from the remote selenium server.
              options.protocol = opt_proxy.protocol

              if (proxy.auth) {
                options.headers['Proxy-Authorization'] =
                  'Basic ' + Buffer.from(proxy.auth).toString('base64')
              }
            }

            let requestFn = options.protocol === 'https:' ? https.request : http.request
            var request = requestFn(options, function onResponse(response) {
              if (response.statusCode == 302 || response.statusCode == 303) {
                let location
                try {
                  // eslint-disable-next-line node/no-deprecated-api
                  location = url.parse(response.headers['location'])
                } catch (ex) {
                  onError(
                    Error(
                      'Failed to parse "Location" header for server redirect: ' +
                        ex.message +
                        '\nResponse was: \n' +
                        new httpLib.Response(response.statusCode, response.headers, '')
                    )
                  )
                  return
                }

                if (!location.hostname) {
                  location.hostname = hostname
                  location.port = port
                  location.auth = options.auth
                }

                request.destroy()
                sendRequest(
                  {
                    method: 'GET',
                    protocol: location.protocol || options.protocol,
                    hostname: location.hostname,
                    port: location.port,
                    path: location.path,
                    auth: location.auth,
                    pathname: location.pathname,
                    search: location.search,
                    hash: location.hash,
                    headers: {
                      Accept: 'application/json; charset=utf-8',
                      'User-Agent': options.headers['User-Agent'] || USER_AGENT
                    }
                  },
                  onOk,
                  onError,
                  undefined,
                  opt_proxy
                )
                return
              }

              const body = []
              response.on('data', body.push.bind(body))
              response.on('end', function () {
                const resp = new httpLib.Response(
                  /** @type {number} */ (response.statusCode),
                  /** @type {!Object<string>} */ (response.headers),
                  Buffer.concat(body).toString('utf8').replace(/\0/g, '')
                )
                onOk(resp)
              })
            })

            request.on('error', function (e) {
              if (typeof opt_retries === 'undefined') {
                opt_retries = 0
              }

              if (shouldRetryRequest(opt_retries, e)) {
                opt_retries += 1
                setTimeout(function () {
                  sendRequest(options, onOk, onError, opt_data, opt_proxy, opt_retries)
                }, 15)
              } else {
                let message = e.message
                if (e.code) {
                  message = e.code + ' ' + message
                }
                onError(new Error(message))
              }
            })

            if (opt_data) {
              request.write(opt_data)
            }

            request.end()
          }

          const MAX_RETRIES = 3

          /**
           * A retry is sometimes needed on Windows where we may quickly run out of
           * ephemeral ports. A more robust solution is bumping the MaxUserPort setting
           * as described here: http://msdn.microsoft.com/en-us/library/aa560610%28v=bts.20%29.aspx
           *
           * @param {!number} retries
           * @param {!Error} err
           * @return {boolean}
           */
          function shouldRetryRequest(retries, err) {
            return retries < MAX_RETRIES && isRetryableNetworkError(err)
          }

          /**
           * @param {!Error} err
           * @return {boolean}
           */
          function isRetryableNetworkError(err) {
            if (err && err.code) {
              return (
                err.code === 'ECONNABORTED' ||
                err.code === 'ECONNRESET' ||
                err.code === 'ECONNREFUSED' ||
                err.code === 'EADDRINUSE' ||
                err.code === 'EPIPE' ||
                err.code === 'ETIMEDOUT'
              )
            }

            return false
          }

          // PUBLIC API

          module.exports.Agent = http.Agent
          module.exports.Executor = httpLib.Executor
          module.exports.HttpClient = HttpClient
          module.exports.Request = httpLib.Request
          module.exports.Response = httpLib.Response

          /***/
        },

      /***/ './node_modules/selenium-webdriver/http/util.js':
        /*!******************************************************!*\
  !*** ./node_modules/selenium-webdriver/http/util.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Various HTTP utilities.
           */

          const Executor = __webpack_require__(
            /*! ./index */ './node_modules/selenium-webdriver/http/index.js'
          ).Executor
          const HttpClient = __webpack_require__(
            /*! ./index */ './node_modules/selenium-webdriver/http/index.js'
          ).HttpClient
          const HttpRequest = __webpack_require__(
            /*! ./index */ './node_modules/selenium-webdriver/http/index.js'
          ).Request
          const Command = __webpack_require__(
            /*! ../lib/command */ './node_modules/selenium-webdriver/lib/command.js'
          ).Command
          const CommandName = __webpack_require__(
            /*! ../lib/command */ './node_modules/selenium-webdriver/lib/command.js'
          ).Name
          const error = __webpack_require__(
            /*! ../lib/error */ './node_modules/selenium-webdriver/lib/error.js'
          )

          /**
           * Queries a WebDriver server for its current status.
           * @param {string} url Base URL of the server to query.
           * @return {!Promise<!Object>} A promise that resolves with
           *     a hash of the server status.
           */
          function getStatus(url) {
            const client = new HttpClient(url)
            const executor = new Executor(client)
            const command = new Command(CommandName.GET_SERVER_STATUS)
            return executor.execute(command)
          }

          class CancellationError {}

          /**
           * Waits for a WebDriver server to be healthy and accepting requests.
           * @param {string} url Base URL of the server to query.
           * @param {number} timeout How long to wait for the server.
           * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:
           *     if resolved before the server is ready, the wait will be terminated
           *     early with a {@link CancellationError}.
           * @return {!Promise} A promise that will resolve when the server is ready, or
           *     if the wait is cancelled.
           */
          function waitForServer(url, timeout, opt_cancelToken) {
            return new Promise((onResolve, onReject) => {
              let start = Date.now()

              let done = false
              let resolve = (status) => {
                done = true
                onResolve(status)
              }
              let reject = (err) => {
                done = true
                onReject(err)
              }

              if (opt_cancelToken) {
                opt_cancelToken.then((_) => reject(new CancellationError()))
              }

              checkServerStatus()
              function checkServerStatus() {
                return getStatus(url).then((status) => resolve(status), onError)
              }

              function onError(e) {
                // Some servers don't support the status command. If they are able to
                // response with an error, then can consider the server ready.
                if (e instanceof error.UnsupportedOperationError) {
                  resolve({})
                  return
                }

                if (Date.now() - start > timeout) {
                  reject(Error('Timed out waiting for the WebDriver server at ' + url))
                } else {
                  setTimeout(function () {
                    if (!done) {
                      checkServerStatus()
                    }
                  }, 50)
                }
              }
            })
          }

          /**
           * Polls a URL with GET requests until it returns a 2xx response or the
           * timeout expires.
           * @param {string} url The URL to poll.
           * @param {number} timeout How long to wait, in milliseconds.
           * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:
           *     if resolved before the a 2xx response is received, the wait will be
           *     terminated early with a {@link CancellationError}.
           * @return {!Promise} A promise that will resolve when a 2xx is received from
           *     the given URL, or if the wait is cancelled.
           */
          function waitForUrl(url, timeout, opt_cancelToken) {
            return new Promise((onResolve, onReject) => {
              let client = new HttpClient(url)
              let request = new HttpRequest('GET', '')
              let start = Date.now()

              let done = false
              let resolve = () => {
                done = true
                onResolve()
              }
              let reject = (err) => {
                done = true
                onReject(err)
              }

              if (opt_cancelToken) {
                opt_cancelToken.then((_) => reject(new CancellationError()))
              }

              testUrl()

              function testUrl() {
                client.send(request).then(onResponse, onError)
              }

              function onError() {
                if (Date.now() - start > timeout) {
                  reject(Error('Timed out waiting for the URL to return 2xx: ' + url))
                } else {
                  setTimeout(function () {
                    if (!done) {
                      testUrl()
                    }
                  }, 50)
                }
              }

              function onResponse(response) {
                if (done) {
                  return
                }
                if (response.status > 199 && response.status < 300) {
                  resolve()
                  return
                }
                onError()
              }
            })
          }

          // PUBLIC API
          module.exports.getStatus = getStatus
          module.exports.CancellationError = CancellationError
          module.exports.waitForServer = waitForServer
          module.exports.waitForUrl = waitForUrl

          /***/
        },

      /***/ './node_modules/selenium-webdriver/ie.js':
        /*!***********************************************!*\
  !*** ./node_modules/selenium-webdriver/ie.js ***!
  \***********************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines a {@linkplain Driver WebDriver} client for Microsoft's
           * Internet Explorer. Before using the IEDriver, you must download the latest
           * [IEDriverServer](https://www.selenium.dev/downloads/)
           * and place it on your
           * [PATH](http://en.wikipedia.org/wiki/PATH_%28variable%29). You must also apply
           * the system configuration outlined on the Selenium project
           * [wiki](https://github.com/SeleniumHQ/selenium/wiki/InternetExplorerDriver)
           */

          const fs = __webpack_require__(/*! fs */ 'fs')
          const http = __webpack_require__(
            /*! ./http */ './node_modules/selenium-webdriver/http/index.js'
          )
          const io = __webpack_require__(
            /*! ./io */ './node_modules/selenium-webdriver/io/index.js'
          )
          const portprober = __webpack_require__(
            /*! ./net/portprober */ './node_modules/selenium-webdriver/net/portprober.js'
          )
          const remote = __webpack_require__(
            /*! ./remote */ './node_modules/selenium-webdriver/remote/index.js'
          )
          const webdriver = __webpack_require__(
            /*! ./lib/webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
          )
          const { Browser, Capabilities } = __webpack_require__(
            /*! ./lib/capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )
          const error = __webpack_require__(
            /*! ./lib/error */ './node_modules/selenium-webdriver/lib/error.js'
          )
          const { getPath } = __webpack_require__(
            /*! ./common/driverFinder */ './node_modules/selenium-webdriver/common/driverFinder.js'
          )

          const IEDRIVER_EXE = 'IEDriverServer.exe'
          const OPTIONS_CAPABILITY_KEY = 'se:ieOptions'
          const SCROLL_BEHAVIOUR = {
            BOTTOM: 1,
            TOP: 0
          }

          /**
           * IEDriverServer logging levels.
           * @enum {string}
           */
          const Level = {
            FATAL: 'FATAL',
            ERROR: 'ERROR',
            WARN: 'WARN',
            INFO: 'INFO',
            DEBUG: 'DEBUG',
            TRACE: 'TRACE'
          }

          /**
           * Option keys:
           * https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities#ie-specific
           * @enum {string}
           */
          const Key = {
            IGNORE_PROTECTED_MODE_SETTINGS: 'ignoreProtectedModeSettings',
            IGNORE_ZOOM_SETTING: 'ignoreZoomSetting',
            INITIAL_BROWSER_URL: 'initialBrowserUrl',
            ENABLE_PERSISTENT_HOVER: 'enablePersistentHover',
            ENABLE_ELEMENT_CACHE_CLEANUP: 'enableElementCacheCleanup',
            ELEMENT_SCROLL_BEHAVIOR: 'elementScrollBehavior',
            REQUIRE_WINDOW_FOCUS: 'requireWindowFocus',
            BROWSER_ATTACH_TIMEOUT: 'browserAttachTimeout',
            FORCE_CREATE_PROCESS: 'ie.forceCreateProcessApi',
            BROWSER_COMMAND_LINE_SWITCHES: 'ie.browserCommandLineSwitches',
            USE_PER_PROCESS_PROXY: 'ie.usePerProcessProxy',
            ENSURE_CLEAN_SESSION: 'ie.ensureCleanSession',
            LOG_FILE: 'logFile',
            LOG_LEVEL: 'logLevel',
            HOST: 'host',
            EXTRACT_PATH: 'extractPath',
            SILENT: 'silent',
            FILE_UPLOAD_DIALOG_TIMEOUT: 'ie.fileUploadDialogTimeout',
            ATTACH_TO_EDGE_CHROMIUM: 'ie.edgechromium',
            EDGE_EXECUTABLE_PATH: 'ie.edgepath'
          }

          /**
           * Class for managing IEDriver specific options.
           */
          class Options extends Capabilities {
            /**
             * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of
             *     capabilities to initialize this instance from.
             */
            constructor(other = undefined) {
              super(other)

              /** @private {!Object} */
              this.options_ = this.get(OPTIONS_CAPABILITY_KEY) || {}

              this.set(OPTIONS_CAPABILITY_KEY, this.options_)
              this.setBrowserName(Browser.INTERNET_EXPLORER)
            }

            /**
             * Whether to disable the protected mode settings check when the session is
             * created. Disabling this setting may lead to significant instability as the
             * browser may become unresponsive/hang. Only "best effort" support is provided
             * when using this capability.
             *
             * For more information, refer to the IEDriver's
             * [required system configuration](http://goo.gl/eH0Yi3).
             *
             * @param {boolean} ignoreSettings Whether to ignore protected mode settings.
             * @return {!Options} A self reference.
             */
            introduceFlakinessByIgnoringProtectedModeSettings(ignoreSettings) {
              this.options_[Key.IGNORE_PROTECTED_MODE_SETTINGS] = !!ignoreSettings
              return this
            }

            /**
             * Indicates whether to skip the check that the browser's zoom level is set to
             * 100%.
             *
             * @param {boolean} ignore Whether to ignore the browser's zoom level settings.
             * @return {!Options} A self reference.
             */
            ignoreZoomSetting(ignore) {
              this.options_[Key.IGNORE_ZOOM_SETTING] = !!ignore
              return this
            }

            /**
             * Sets the initial URL loaded when IE starts. This is intended to be used with
             * {@link #introduceFlakinessByIgnoringProtectedModeSettings} to allow the user to initialize IE in
             * the proper Protected Mode zone. Setting this option may cause browser
             * instability or flaky and unresponsive code. Only "best effort" support is
             * provided when using this option.
             *
             * @param {string} url The initial browser URL.
             * @return {!Options} A self reference.
             */
            initialBrowserUrl(url) {
              this.options_[Key.INITIAL_BROWSER_URL] = url
              return this
            }

            /**
             * Configures whether to enable persistent mouse hovering (true by default).
             * Persistent hovering is achieved by continuously firing mouse over events at
             * the last location the mouse cursor has been moved to.
             *
             * @param {boolean} enable Whether to enable persistent hovering.
             * @return {!Options} A self reference.
             */
            enablePersistentHover(enable) {
              this.options_[Key.ENABLE_PERSISTENT_HOVER] = !!enable
              return this
            }

            /**
             * Configures whether the driver should attempt to remove obsolete
             * {@linkplain webdriver.WebElement WebElements} from its internal cache on
             * page navigation (true by default). Disabling this option will cause the
             * driver to run with a larger memory footprint.
             *
             * @param {boolean} enable Whether to enable element reference cleanup.
             * @return {!Options} A self reference.
             */
            enableElementCacheCleanup(enable) {
              this.options_[Key.ENABLE_ELEMENT_CACHE_CLEANUP] = !!enable
              return this
            }

            /**
             * Configures whether to require the IE window to have input focus before
             * performing any user interactions (i.e. mouse or keyboard events). This
             * option is disabled by default, but delivers much more accurate interaction
             * events when enabled.
             *
             * @param {boolean} require Whether to require window focus.
             * @return {!Options} A self reference.
             */
            requireWindowFocus(require) {
              this.options_[Key.REQUIRE_WINDOW_FOCUS] = !!require
              return this
            }

            /**
             * Configures the timeout, in milliseconds, that the driver will attempt to
             * located and attach to a newly opened instance of Internet Explorer. The
             * default is zero, which indicates waiting indefinitely.
             *
             * @param {number} timeout How long to wait for IE.
             * @return {!Options} A self reference.
             */
            browserAttachTimeout(timeout) {
              this.options_[Key.BROWSER_ATTACH_TIMEOUT] = Math.max(timeout, 0)
              return this
            }

            /**
             * Configures whether to launch Internet Explorer using the CreateProcess API.
             * If this option is not specified, IE is launched using IELaunchURL, if
             * available. For IE 8 and above, this option requires the TabProcGrowth
             * registry value to be set to 0.
             *
             * @param {boolean} force Whether to use the CreateProcess API.
             * @return {!Options} A self reference.
             */
            forceCreateProcessApi(force) {
              this.options_[Key.FORCE_CREATE_PROCESS] = !!force
              return this
            }

            /**
             * Specifies command-line switches to use when launching Internet Explorer.
             * This is only valid when used with {@link #forceCreateProcessApi}.
             *
             * @param {...(string|!Array.<string>)} args The arguments to add.
             * @return {!Options} A self reference.
             */

            addBrowserCommandSwitches(...args) {
              let current = this.options_[Key.BROWSER_COMMAND_LINE_SWITCHES] || []
              if (typeof current == 'string') current = current.split(' ')
              this.options_[Key.BROWSER_COMMAND_LINE_SWITCHES] = current.concat(args).join(' ')
              return this
            }

            /**
             * Specifies command-line switches to use when launching Internet Explorer.
             * This is only valid when used with {@link #forceCreateProcessApi}.
             *
             * @param {...(string|!Array.<string>)} args The arguments to add.
             * @deprecated Use {@link #addBrowserCommandSwitches} instead.
             * @return {!Options} A self reference.
             */

            addArguments(...args) {
              let current = this.options_[Key.BROWSER_COMMAND_LINE_SWITCHES] || []
              if (typeof current == 'string') current = current.split(' ')
              this.options_[Key.BROWSER_COMMAND_LINE_SWITCHES] = current.concat(args).join(' ')
              return this
            }

            /**
             * Configures whether proxies should be configured on a per-process basis. If
             * not set, setting a {@linkplain #setProxy proxy} will configure the system
             * proxy. The default behavior is to use the system proxy.
             *
             * @param {boolean} enable Whether to enable per-process proxy settings.
             * @return {!Options} A self reference.
             */
            usePerProcessProxy(enable) {
              this.options_[Key.USE_PER_PROCESS_PROXY] = !!enable
              return this
            }

            /**
             * Configures whether to clear the cache, cookies, history, and saved form data
             * before starting the browser. _Using this capability will clear session data
             * for all running instances of Internet Explorer, including those started
             * manually._
             *
             * @param {boolean} cleanSession Whether to clear all session data on startup.
             * @return {!Options} A self reference.
             */
            ensureCleanSession(cleanSession) {
              this.options_[Key.ENSURE_CLEAN_SESSION] = !!cleanSession
              return this
            }

            /**
             * Sets the path to the log file the driver should log to.
             * @param {string} file The log file path.
             * @return {!Options} A self reference.
             */
            setLogFile(file) {
              this.options_[Key.LOG_FILE] = file
              return this
            }

            /**
             * Sets the IEDriverServer's logging {@linkplain Level level}.
             * @param {Level} level The logging level.
             * @return {!Options} A self reference.
             */
            setLogLevel(level) {
              this.options_[Key.LOG_LEVEL] = level
              return this
            }

            /**
             * Sets the IP address of the driver's host adapter.
             * @param {string} host The IP address to use.
             * @return {!Options} A self reference.
             */
            setHost(host) {
              this.options_[Key.HOST] = host
              return this
            }

            /**
             * Sets the path of the temporary data directory to use.
             * @param {string} path The log file path.
             * @return {!Options} A self reference.
             */
            setExtractPath(path) {
              this.options_[Key.EXTRACT_PATH] = path
              return this
            }

            /**
             * Sets whether the driver should start in silent mode.
             * @param {boolean} silent Whether to run in silent mode.
             * @return {!Options} A self reference.
             */
            silent(silent) {
              this.options_[Key.SILENT] = silent
              return this
            }

            /**
             * The options File Upload Dialog Timeout in milliseconds
             *
             * @param {number} timeout How long to wait for IE.
             * @return {!Options} A self reference.
             */
            fileUploadDialogTimeout(timeout) {
              this.options_[Key.FILE_UPLOAD_DIALOG_TIMEOUT] = Math.max(timeout, 0)
              return this
            }

            /**
             * Sets the path of the EdgeChromium driver.
             * @param {string} path The EdgeChromium driver path.
             * @return {!Options} A self reference.
             */
            setEdgePath(path) {
              this.options_[Key.EDGE_EXECUTABLE_PATH] = path
              return this
            }

            /**
             * Sets the IEDriver to drive Chromium-based Edge in Internet Explorer mode.
             *
             * @param {boolean} attachEdgeChromium Whether to run in Chromium-based-Edge in IE mode
             * @return {!Options} A self reference.
             */
            setEdgeChromium(attachEdgeChromium) {
              this.options_[Key.ATTACH_TO_EDGE_CHROMIUM] = !!attachEdgeChromium
              return this
            }

            /**
             * Sets how elements should be scrolled into view for interaction.
             * @param {number} behavior The desired scroll behavior: either 0 to align with
             *     the top of the viewport or 1 to align with the bottom.
             * @return {!Options} A self reference.
             */
            setScrollBehavior(behavior) {
              if (
                behavior &&
                behavior !== SCROLL_BEHAVIOUR.TOP &&
                behavior !== SCROLL_BEHAVIOUR.BOTTOM
              ) {
                throw new error.InvalidArgumentError(`Element Scroll Behavior out of range.
      It should be either ${SCROLL_BEHAVIOUR.TOP} or ${SCROLL_BEHAVIOUR.BOTTOM}`)
              }
              this.options_[Key.ELEMENT_SCROLL_BEHAVIOR] = behavior
              return this
            }
          }

          /**
           * _Synchronously_ attempts to locate the IE driver executable on the current
           * system.
           *
           * @return {?string} the located executable, or `null`.
           */
          function locateSynchronously() {
            return process.platform === 'win32' ? io.findInPath(IEDRIVER_EXE, true) : null
          }

          function createServiceFromCapabilities(capabilities) {
            if (process.platform !== 'win32') {
              throw Error(
                'The IEDriver may only be used on Windows, but you appear to be on ' +
                  process.platform +
                  '. Did you mean to run against a remote ' +
                  'WebDriver server?'
              )
            }

            let exe = locateSynchronously()
            var args = []
            if (capabilities.has(Key.HOST)) {
              args.push('--host=' + capabilities.get(Key.HOST))
            }
            if (capabilities.has(Key.LOG_FILE)) {
              args.push('--log-file=' + capabilities.get(Key.LOG_FILE))
            }
            if (capabilities.has(Key.LOG_LEVEL)) {
              args.push('--log-level=' + capabilities.get(Key.LOG_LEVEL))
            }
            if (capabilities.has(Key.EXTRACT_PATH)) {
              args.push('--extract-path=' + capabilities.get(Key.EXTRACT_PATH))
            }
            if (capabilities.get(Key.SILENT)) {
              args.push('--silent')
            }

            var port = portprober.findFreePort()
            return new remote.DriverService(exe, {
              loopback: true,
              port: port,
              args: port.then(function (port) {
                return args.concat('--port=' + port)
              }),
              stdio: 'ignore'
            })
          }

          /**
           * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
           * an [IEDriverServer](https://github.com/SeleniumHQ/selenium/wiki/InternetExplorerDriver)
           * server in a child process.
           */
          class ServiceBuilder extends remote.DriverService.Builder {
            /**
             * @param {string=} opt_exe Path to the server executable to use. If omitted,
             *     the builder will attempt to locate the IEDriverServer on the system PATH.
             */
            constructor(opt_exe) {
              super(opt_exe || IEDRIVER_EXE)
              this.setLoopback(true) // Required.
            }
          }

          /**
           * A WebDriver client for Microsoft's Internet Explorer.
           */
          class Driver extends webdriver.WebDriver {
            /**
             * Creates a new session for Microsoft's Internet Explorer.
             *
             * @param {(Capabilities|Options)=} options The configuration options.
             * @param {(remote.DriverService)=} opt_service The `DriverService` to use
             *   to start the IEDriverServer in a child process, optionally.
             * @return {!Driver} A new driver instance.
             */
            static createSession(options, opt_service) {
              options = options || new Options()

              let service

              if (opt_service instanceof remote.DriverService) {
                service = opt_service
              } else {
                service = createServiceFromCapabilities(options)
              }
              if (!service.getExecutable()) {
                service.setExecutable(getPath(service, options))
              }

              let client = service.start().then((url) => new http.HttpClient(url))
              let executor = new http.Executor(client)

              return /** @type {!Driver} */ (
                super.createSession(executor, options, () => service.kill())
              )
            }

            /**
             * This function is a no-op as file detectors are not supported by this
             * implementation.
             * @override
             */
            setFileDetector() {}
          }

          // PUBLIC API

          exports.Driver = Driver
          exports.Options = Options
          exports.Level = Level
          exports.ServiceBuilder = ServiceBuilder
          exports.Key = Key
          exports.VENDOR_COMMAND_PREFIX = OPTIONS_CAPABILITY_KEY
          exports.Behavior = SCROLL_BEHAVIOUR
          exports.locateSynchronously = locateSynchronously

          /***/
        },

      /***/ './node_modules/selenium-webdriver/index.js':
        /*!**************************************************!*\
  !*** ./node_modules/selenium-webdriver/index.js ***!
  \**************************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview The main user facing module. Exports WebDriver's primary
           * public API and provides convenience assessors to certain sub-modules.
           */

          const _http = __webpack_require__(
            /*! ./http */ './node_modules/selenium-webdriver/http/index.js'
          )
          const by = __webpack_require__(
            /*! ./lib/by */ './node_modules/selenium-webdriver/lib/by.js'
          )
          const capabilities = __webpack_require__(
            /*! ./lib/capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )
          const chrome = __webpack_require__(
            /*! ./chrome */ './node_modules/selenium-webdriver/chrome.js'
          )
          const edge = __webpack_require__(
            /*! ./edge */ './node_modules/selenium-webdriver/edge.js'
          )
          const error = __webpack_require__(
            /*! ./lib/error */ './node_modules/selenium-webdriver/lib/error.js'
          )
          const firefox = __webpack_require__(
            /*! ./firefox */ './node_modules/selenium-webdriver/firefox.js'
          )
          const ie = __webpack_require__(/*! ./ie */ './node_modules/selenium-webdriver/ie.js')
          const input = __webpack_require__(
            /*! ./lib/input */ './node_modules/selenium-webdriver/lib/input.js'
          )
          const logging = __webpack_require__(
            /*! ./lib/logging */ './node_modules/selenium-webdriver/lib/logging.js'
          )
          const promise = __webpack_require__(
            /*! ./lib/promise */ './node_modules/selenium-webdriver/lib/promise.js'
          )
          const remote = __webpack_require__(
            /*! ./remote */ './node_modules/selenium-webdriver/remote/index.js'
          )
          const safari = __webpack_require__(
            /*! ./safari */ './node_modules/selenium-webdriver/safari.js'
          )
          const session = __webpack_require__(
            /*! ./lib/session */ './node_modules/selenium-webdriver/lib/session.js'
          )
          const until = __webpack_require__(
            /*! ./lib/until */ './node_modules/selenium-webdriver/lib/until.js'
          )
          const webdriver = __webpack_require__(
            /*! ./lib/webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
          )
          const select = __webpack_require__(
            /*! ./lib/select */ './node_modules/selenium-webdriver/lib/select.js'
          )
          const LogInspector = __webpack_require__(
            /*! ./bidi/logInspector */ './node_modules/selenium-webdriver/bidi/logInspector.js'
          )
          const BrowsingContext = __webpack_require__(
            /*! ./bidi/browsingContext */ './node_modules/selenium-webdriver/bidi/browsingContext.js'
          )
          const BrowsingConextInspector = __webpack_require__(
            /*! ./bidi/browsingContextInspector */ './node_modules/selenium-webdriver/bidi/browsingContextInspector.js'
          )
          const ScriptManager = __webpack_require__(
            /*! ./bidi/scriptManager */ './node_modules/selenium-webdriver/bidi/scriptManager.js'
          )

          const Browser = capabilities.Browser
          const Capabilities = capabilities.Capabilities
          const Capability = capabilities.Capability
          const WebDriver = webdriver.WebDriver

          let seleniumServer

          /**
           * Starts an instance of the Selenium server if not yet running.
           * @param {string} jar Path to the server jar to use.
           * @return {!Promise<string>} A promise for the server's
           *     address once started.
           */
          function startSeleniumServer(jar) {
            if (!seleniumServer) {
              seleniumServer = new remote.SeleniumServer(jar)
            }
            return seleniumServer.start()
          }

          /**
           * {@linkplain webdriver.WebDriver#setFileDetector WebDriver's setFileDetector}
           * method uses a non-standard command to transfer files from the local client
           * to the remote end hosting the browser. Many of the WebDriver sub-types, like
           * the {@link chrome.Driver} and {@link firefox.Driver}, do not support this
           * command. Thus, these classes override the `setFileDetector` to no-op.
           *
           * This function uses a mixin to re-enable `setFileDetector` by calling the
           * original method on the WebDriver prototype directly. This is used only when
           * the builder creates a Chrome or Firefox instance that communicates with a
           * remote end (and thus, support for remote file detectors is unknown).
           *
           * @param {function(new: webdriver.WebDriver, ...?)} ctor
           * @return {function(new: webdriver.WebDriver, ...?)}
           */
          function ensureFileDetectorsAreEnabled(ctor) {
            return class extends ctor {
              /** @param {input.FileDetector} detector */
              setFileDetector(detector) {
                webdriver.WebDriver.prototype.setFileDetector.call(this, detector)
              }
            }
          }

          /**
           * A thenable wrapper around a {@linkplain webdriver.IWebDriver IWebDriver}
           * instance that allows commands to be issued directly instead of having to
           * repeatedly call `then`:
           *
           *     let driver = new Builder().build();
           *     driver.then(d => d.get(url));  // You can do this...
           *     driver.get(url);               // ...or this
           *
           * If the driver instance fails to resolve (e.g. the session cannot be created),
           * every issued command will fail.
           *
           * @extends {webdriver.IWebDriver}
           * @extends {IThenable<!webdriver.IWebDriver>}
           * @interface
           */
          class ThenableWebDriver {
            /** @param {...?} args */
            static createSession(...args) {} // eslint-disable-line
          }

          /**
           * @const {!Map<function(new: WebDriver, !IThenable<!Session>, ...?),
           *              function(new: ThenableWebDriver, !IThenable<!Session>, ...?)>}
           */
          const THENABLE_DRIVERS = new Map()

          /**
           * @param {function(new: WebDriver, !IThenable<!Session>, ...?)} ctor
           * @param {...?} args
           * @return {!ThenableWebDriver}
           */
          function createDriver(ctor, ...args) {
            let thenableWebDriverProxy = THENABLE_DRIVERS.get(ctor)
            if (!thenableWebDriverProxy) {
              /**
               * @extends {WebDriver}  // Needed since `ctor` is dynamically typed.
               * @implements {ThenableWebDriver}
               */
              thenableWebDriverProxy = class extends ctor {
                /**
                 * @param {!IThenable<!Session>} session
                 * @param {...?} rest
                 */
                constructor(session, ...rest) {
                  super(session, ...rest)

                  const pd = this.getSession().then((session) => {
                    return new ctor(session, ...rest)
                  })

                  /** @override */
                  this.then = pd.then.bind(pd)

                  /** @override */
                  this.catch = pd.catch.bind(pd)
                }
              }
              THENABLE_DRIVERS.set(ctor, thenableWebDriverProxy)
            }
            return thenableWebDriverProxy.createSession(...args)
          }

          /**
           * Creates new {@link webdriver.WebDriver WebDriver} instances. The environment
           * variables listed below may be used to override a builder's configuration,
           * allowing quick runtime changes.
           *
           * - {@code SELENIUM_BROWSER}: defines the target browser in the form
           *   {@code browser[:version][:platform]}.
           *
           * - {@code SELENIUM_REMOTE_URL}: defines the remote URL for all builder
           *   instances. This environment variable should be set to a fully qualified
           *   URL for a WebDriver server (e.g. http://localhost:4444/wd/hub). This
           *   option always takes precedence over {@code SELENIUM_SERVER_JAR}.
           *
           * - {@code SELENIUM_SERVER_JAR}: defines the path to the
           *   <a href="https://www.selenium.dev/downloads/">
           *   standalone Selenium server</a> jar to use. The server will be started the
           *   first time a WebDriver instance and be killed when the process exits.
           *
           * Suppose you had mytest.js that created WebDriver with
           *
           *     var driver = new webdriver.Builder()
           *         .forBrowser('chrome')
           *         .build();
           *
           * This test could be made to use Firefox on the local machine by running with
           * `SELENIUM_BROWSER=firefox node mytest.js`. Rather than change the code to
           * target Google Chrome on a remote machine, you can simply set the
           * `SELENIUM_BROWSER` and `SELENIUM_REMOTE_URL` environment variables:
           *
           *     SELENIUM_BROWSER=chrome:36:LINUX \
           *     SELENIUM_REMOTE_URL=http://www.example.com:4444/wd/hub \
           *     node mytest.js
           *
           * You could also use a local copy of the standalone Selenium server:
           *
           *     SELENIUM_BROWSER=chrome:36:LINUX \
           *     SELENIUM_SERVER_JAR=/path/to/selenium-server-standalone.jar \
           *     node mytest.js
           */
          class Builder {
            constructor() {
              /** @private @const */
              this.log_ = logging.getLogger('webdriver.Builder')

              /** @private {string} */
              this.url_ = ''

              /** @private {?string} */
              this.proxy_ = null

              /** @private {!Capabilities} */
              this.capabilities_ = new Capabilities()

              /** @private {chrome.Options} */
              this.chromeOptions_ = null

              /** @private {chrome.ServiceBuilder} */
              this.chromeService_ = null

              /** @private {firefox.Options} */
              this.firefoxOptions_ = null

              /** @private {firefox.ServiceBuilder} */
              this.firefoxService_ = null

              /** @private {ie.Options} */
              this.ieOptions_ = null

              /** @private {ie.ServiceBuilder} */
              this.ieService_ = null

              /** @private {safari.Options} */
              this.safariOptions_ = null

              /** @private {edge.Options} */
              this.edgeOptions_ = null

              /** @private {remote.DriverService.Builder} */
              this.edgeService_ = null

              /** @private {boolean} */
              this.ignoreEnv_ = false

              /** @private {http.Agent} */
              this.agent_ = null
            }

            /**
             * Configures this builder to ignore any environment variable overrides and to
             * only use the configuration specified through this instance's API.
             *
             * @return {!Builder} A self reference.
             */
            disableEnvironmentOverrides() {
              this.ignoreEnv_ = true
              return this
            }

            /**
             * Sets the URL of a remote WebDriver server to use. Once a remote URL has
             * been specified, the builder direct all new clients to that server. If this
             * method is never called, the Builder will attempt to create all clients
             * locally.
             *
             * As an alternative to this method, you may also set the
             * `SELENIUM_REMOTE_URL` environment variable.
             *
             * @param {string} url The URL of a remote server to use.
             * @return {!Builder} A self reference.
             */
            usingServer(url) {
              this.url_ = url
              return this
            }

            /**
             * @return {string} The URL of the WebDriver server this instance is
             *     configured to use.
             */
            getServerUrl() {
              return this.url_
            }

            /**
             * Sets the URL of the proxy to use for the WebDriver's HTTP connections.
             * If this method is never called, the Builder will create a connection
             * without a proxy.
             *
             * @param {string} proxy The URL of a proxy to use.
             * @return {!Builder} A self reference.
             */
            usingWebDriverProxy(proxy) {
              this.proxy_ = proxy
              return this
            }

            /**
             * @return {?string} The URL of the proxy server to use for the WebDriver's
             *    HTTP connections, or `null` if not set.
             */
            getWebDriverProxy() {
              return this.proxy_
            }

            /**
             * Sets the http agent to use for each request.
             * If this method is not called, the Builder will use http.globalAgent by default.
             *
             * @param {http.Agent} agent The agent to use for each request.
             * @return {!Builder} A self reference.
             */
            usingHttpAgent(agent) {
              this.agent_ = agent
              return this
            }

            /**
             * @return {http.Agent} The http agent used for each request
             */
            getHttpAgent() {
              return this.agent_
            }

            /**
             * Recommended way is to use set*Options where * is the browser(eg setChromeOptions)
             *
             * Sets the desired capabilities when requesting a new session. This will
             * overwrite any previously set capabilities.
             * @param {!(Object|Capabilities)} capabilities The desired capabilities for
             *     a new session.
             * @return {!Builder} A self reference.
             */
            withCapabilities(capabilities) {
              this.capabilities_ = new Capabilities(capabilities)
              return this
            }

            /**
             * Returns the base set of capabilities this instance is currently configured
             * to use.
             * @return {!Capabilities} The current capabilities for this builder.
             */
            getCapabilities() {
              return this.capabilities_
            }

            /**
             * Sets the desired capability when requesting a new session.
             * If there is already a capability named key, its value will be overwritten with value.
             * This is a convenience wrapper around builder.getCapabilities().set(key, value) to support Builder method chaining.
             * @param {string} key The capability key.
             * @param {*} value The capability value.
             * @return {!Builder} A self reference.
             */
            setCapability(key, value) {
              this.capabilities_.set(key, value)
              return this
            }

            /**
             * Configures the target browser for clients created by this instance.
             * Any calls to {@link #withCapabilities} after this function will
             * overwrite these settings.
             *
             * You may also define the target browser using the {@code SELENIUM_BROWSER}
             * environment variable. If set, this environment variable should be of the
             * form `browser[:[version][:platform]]`.
             *
             * @param {(string|!Browser)} name The name of the target browser;
             *     common defaults are available on the {@link webdriver.Browser} enum.
             * @param {string=} opt_version A desired version; may be omitted if any
             *     version should be used.
             * @param {(string|!capabilities.Platform)=} opt_platform
             *     The desired platform; may be omitted if any platform may be used.
             * @return {!Builder} A self reference.
             */
            forBrowser(name, opt_version, opt_platform) {
              this.capabilities_.setBrowserName(name)
              if (opt_version) {
                this.capabilities_.setBrowserVersion(opt_version)
              }
              if (opt_platform) {
                this.capabilities_.setPlatform(opt_platform)
              }
              return this
            }

            /**
             * Sets the proxy configuration for the target browser.
             * Any calls to {@link #withCapabilities} after this function will
             * overwrite these settings.
             *
             * @param {!./lib/proxy.Config} config The configuration to use.
             * @return {!Builder} A self reference.
             */
            setProxy(config) {
              this.capabilities_.setProxy(config)
              return this
            }

            /**
             * Sets the logging preferences for the created session. Preferences may be
             * changed by repeated calls, or by calling {@link #withCapabilities}.
             * @param {!(./lib/logging.Preferences|Object<string, string>)} prefs The
             *     desired logging preferences.
             * @return {!Builder} A self reference.
             */
            setLoggingPrefs(prefs) {
              this.capabilities_.setLoggingPrefs(prefs)
              return this
            }

            /**
             * Sets the default action to take with an unexpected alert before returning
             * an error.
             *
             * @param {?capabilities.UserPromptHandler} behavior The desired behavior.
             * @return {!Builder} A self reference.
             * @see capabilities.Capabilities#setAlertBehavior
             */
            setAlertBehavior(behavior) {
              this.capabilities_.setAlertBehavior(behavior)
              return this
            }

            /**
             * Sets Chrome specific {@linkplain chrome.Options options} for drivers
             * created by this builder. Any logging or proxy settings defined on the given
             * options will take precedence over those set through
             * {@link #setLoggingPrefs} and {@link #setProxy}, respectively.
             *
             * @param {!chrome.Options} options The ChromeDriver options to use.
             * @return {!Builder} A self reference.
             */
            setChromeOptions(options) {
              this.chromeOptions_ = options
              return this
            }

            /**
             * @return {chrome.Options} the Chrome specific options currently configured
             *     for this builder.
             */
            getChromeOptions() {
              return this.chromeOptions_
            }

            /**
             * Sets the service builder to use for managing the chromedriver child process
             * when creating new Chrome sessions.
             *
             * @param {chrome.ServiceBuilder} service the service to use.
             * @return {!Builder} A self reference.
             */
            setChromeService(service) {
              if (service && !(service instanceof chrome.ServiceBuilder)) {
                throw TypeError('not a chrome.ServiceBuilder object')
              }
              this.chromeService_ = service
              return this
            }

            /**
             * Sets Firefox specific {@linkplain firefox.Options options} for drivers
             * created by this builder. Any logging or proxy settings defined on the given
             * options will take precedence over those set through
             * {@link #setLoggingPrefs} and {@link #setProxy}, respectively.
             *
             * @param {!firefox.Options} options The FirefoxDriver options to use.
             * @return {!Builder} A self reference.
             */
            setFirefoxOptions(options) {
              this.firefoxOptions_ = options
              return this
            }

            /**
             * @return {firefox.Options} the Firefox specific options currently configured
             *     for this instance.
             */
            getFirefoxOptions() {
              return this.firefoxOptions_
            }

            /**
             * Sets the {@link firefox.ServiceBuilder} to use to manage the geckodriver
             * child process when creating Firefox sessions locally.
             *
             * @param {firefox.ServiceBuilder} service the service to use.
             * @return {!Builder} a self reference.
             */
            setFirefoxService(service) {
              if (service && !(service instanceof firefox.ServiceBuilder)) {
                throw TypeError('not a firefox.ServiceBuilder object')
              }
              this.firefoxService_ = service
              return this
            }

            /**
             * Set Internet Explorer specific {@linkplain ie.Options options} for drivers
             * created by this builder. Any proxy settings defined on the given options
             * will take precedence over those set through {@link #setProxy}.
             *
             * @param {!ie.Options} options The IEDriver options to use.
             * @return {!Builder} A self reference.
             */
            setIeOptions(options) {
              this.ieOptions_ = options
              return this
            }

            /**
             * Sets the {@link ie.ServiceBuilder} to use to manage the geckodriver
             * child process when creating IE sessions locally.
             *
             * @param {ie.ServiceBuilder} service the service to use.
             * @return {!Builder} a self reference.
             */
            setIeService(service) {
              this.ieService_ = service
              return this
            }

            /**
             * Set {@linkplain edge.Options options} specific to Microsoft's Edge browser
             * for drivers created by this builder. Any proxy settings defined on the
             * given options will take precedence over those set through
             * {@link #setProxy}.
             *
             * @param {!edge.Options} options The MicrosoftEdgeDriver options to use.
             * @return {!Builder} A self reference.
             */
            setEdgeOptions(options) {
              this.edgeOptions_ = options
              return this
            }

            /**
             * Sets the {@link edge.ServiceBuilder} to use to manage the
             * MicrosoftEdgeDriver child process when creating sessions locally.
             *
             * @param {edge.ServiceBuilder} service the service to use.
             * @return {!Builder} a self reference.
             */
            setEdgeService(service) {
              if (service && !(service instanceof edge.ServiceBuilder)) {
                throw TypeError('not a edge.ServiceBuilder object')
              }
              this.edgeService_ = service
              return this
            }

            /**
             * Sets Safari specific {@linkplain safari.Options options} for drivers
             * created by this builder. Any logging settings defined on the given options
             * will take precedence over those set through {@link #setLoggingPrefs}.
             *
             * @param {!safari.Options} options The Safari options to use.
             * @return {!Builder} A self reference.
             */
            setSafariOptions(options) {
              this.safariOptions_ = options
              return this
            }

            /**
             * @return {safari.Options} the Safari specific options currently configured
             *     for this instance.
             */
            getSafariOptions() {
              return this.safariOptions_
            }

            /**
             * Creates a new WebDriver client based on this builder's current
             * configuration.
             *
             * This method will return a {@linkplain ThenableWebDriver} instance, allowing
             * users to issue commands directly without calling `then()`. The returned
             * thenable wraps a promise that will resolve to a concrete
             * {@linkplain webdriver.WebDriver WebDriver} instance. The promise will be
             * rejected if the remote end fails to create a new session.
             *
             * @return {!ThenableWebDriver} A new WebDriver instance.
             * @throws {Error} If the current configuration is invalid.
             */
            build() {
              // Create a copy for any changes we may need to make based on the current
              // environment.
              const capabilities = new Capabilities(this.capabilities_)

              let browser
              if (!this.ignoreEnv_ && process.env.SELENIUM_BROWSER) {
                this.log_.fine(`SELENIUM_BROWSER=${process.env.SELENIUM_BROWSER}`)
                browser = process.env.SELENIUM_BROWSER.split(/:/, 3)
                capabilities.setBrowserName(browser[0])

                browser[1] && capabilities.setBrowserVersion(browser[1])
                browser[2] && capabilities.setPlatform(browser[2])
              }

              browser = capabilities.get(Capability.BROWSER_NAME)

              if (typeof browser !== 'string') {
                throw TypeError(
                  `Target browser must be a string, but is <${typeof browser}>;` +
                    ' did you forget to call forBrowser()?'
                )
              }

              if (browser === 'ie') {
                browser = Browser.INTERNET_EXPLORER
              }

              // Apply browser specific overrides.
              if (browser === Browser.CHROME && this.chromeOptions_) {
                capabilities.merge(this.chromeOptions_)
              } else if (browser === Browser.FIREFOX && this.firefoxOptions_) {
                capabilities.merge(this.firefoxOptions_)
              } else if (browser === Browser.INTERNET_EXPLORER && this.ieOptions_) {
                capabilities.merge(this.ieOptions_)
              } else if (browser === Browser.SAFARI && this.safariOptions_) {
                capabilities.merge(this.safariOptions_)
              } else if (browser === Browser.EDGE && this.edgeOptions_) {
                capabilities.merge(this.edgeOptions_)
              }

              checkOptions(capabilities, 'chromeOptions', chrome.Options, 'setChromeOptions')
              checkOptions(capabilities, 'moz:firefoxOptions', firefox.Options, 'setFirefoxOptions')
              checkOptions(capabilities, 'safari.options', safari.Options, 'setSafariOptions')

              // Check for a remote browser.
              let url = this.url_
              if (!this.ignoreEnv_) {
                if (process.env.SELENIUM_REMOTE_URL) {
                  this.log_.fine(`SELENIUM_REMOTE_URL=${process.env.SELENIUM_REMOTE_URL}`)
                  url = process.env.SELENIUM_REMOTE_URL
                } else if (process.env.SELENIUM_SERVER_JAR) {
                  this.log_.fine(`SELENIUM_SERVER_JAR=${process.env.SELENIUM_SERVER_JAR}`)
                  url = startSeleniumServer(process.env.SELENIUM_SERVER_JAR)
                }
              }

              if (url) {
                this.log_.fine('Creating session on remote server')
                let client = Promise.resolve(url).then(
                  (url) => new _http.HttpClient(url, this.agent_, this.proxy_)
                )
                let executor = new _http.Executor(client)

                if (browser === Browser.CHROME) {
                  const driver = ensureFileDetectorsAreEnabled(chrome.Driver)
                  return createDriver(driver, capabilities, executor)
                }

                if (browser === Browser.FIREFOX) {
                  const driver = ensureFileDetectorsAreEnabled(firefox.Driver)
                  return createDriver(driver, capabilities, executor)
                }
                return createDriver(WebDriver, executor, capabilities)
              }

              // Check for a native browser.
              switch (browser) {
                case Browser.CHROME: {
                  let service = null
                  if (this.chromeService_) {
                    service = this.chromeService_.build()
                  }
                  return createDriver(chrome.Driver, capabilities, service)
                }

                case Browser.FIREFOX: {
                  let service = null
                  if (this.firefoxService_) {
                    service = this.firefoxService_.build()
                  }
                  return createDriver(firefox.Driver, capabilities, service)
                }

                case Browser.INTERNET_EXPLORER: {
                  let service = null
                  if (this.ieService_) {
                    service = this.ieService_.build()
                  }
                  return createDriver(ie.Driver, capabilities, service)
                }

                case Browser.EDGE: {
                  let service = null
                  if (this.edgeService_) {
                    service = this.edgeService_.build()
                  }
                  return createDriver(edge.Driver, capabilities, service)
                }

                case Browser.SAFARI:
                  return createDriver(safari.Driver, capabilities)

                default:
                  throw new Error(
                    'Do not know how to build driver: ' +
                      browser +
                      '; did you forget to call usingServer(url)?'
                  )
              }
            }
          }

          /**
           * In the 3.x releases, the various browser option classes
           * (e.g. firefox.Options) had to be manually set as an option using the
           * Capabilties class:
           *
           *     let ffo = new firefox.Options();
           *     // Configure firefox options...
           *
           *     let caps = new Capabilities();
           *     caps.set('moz:firefoxOptions', ffo);
           *
           *     let driver = new Builder()
           *         .withCapabilities(caps)
           *         .build();
           *
           * The options are now subclasses of Capabilities and can be used directly. A
           * direct translation of the above is:
           *
           *     let ffo = new firefox.Options();
           *     // Configure firefox options...
           *
           *     let driver = new Builder()
           *         .withCapabilities(ffo)
           *         .build();
           *
           * You can also set the options for various browsers at once and let the builder
           * choose the correct set at runtime (see Builder docs above):
           *
           *     let ffo = new firefox.Options();
           *     // Configure ...
           *
           *     let co = new chrome.Options();
           *     // Configure ...
           *
           *     let driver = new Builder()
           *         .setChromeOptions(co)
           *         .setFirefoxOptions(ffo)
           *         .build();
           *
           * @param {!Capabilities} caps
           * @param {string} key
           * @param {function(new: Capabilities)} optionType
           * @param {string} setMethod
           * @throws {error.InvalidArgumentError}
           */
          function checkOptions(caps, key, optionType, setMethod) {
            let val = caps.get(key)
            if (val instanceof optionType) {
              throw new error.InvalidArgumentError(
                'Options class extends Capabilities and should not be set as key ' +
                  `"${key}"; set browser-specific options with ` +
                  `Builder.${setMethod}(). For more information, see the ` +
                  'documentation attached to the function that threw this error'
              )
            }
          }

          // PUBLIC API

          exports.Browser = capabilities.Browser
          exports.Builder = Builder
          exports.Button = input.Button
          exports.By = by.By
          exports.RelativeBy = by.RelativeBy
          exports.withTagName = by.withTagName
          exports.locateWith = by.locateWith
          exports.Capabilities = capabilities.Capabilities
          exports.Capability = capabilities.Capability
          exports.Condition = webdriver.Condition
          exports.FileDetector = input.FileDetector
          exports.Key = input.Key
          exports.Origin = input.Origin
          exports.Session = session.Session
          exports.ThenableWebDriver = ThenableWebDriver
          exports.WebDriver = webdriver.WebDriver
          exports.WebElement = webdriver.WebElement
          exports.WebElementCondition = webdriver.WebElementCondition
          exports.WebElementPromise = webdriver.WebElementPromise
          exports.error = error
          exports.logging = logging
          exports.promise = promise
          exports.until = until
          exports.Select = select.Select
          exports.LogInspector = LogInspector
          exports.BrowsingContext = BrowsingContext
          exports.BrowsingConextInspector = BrowsingConextInspector
          exports.ScriptManager = ScriptManager

          /***/
        },

      /***/ './node_modules/selenium-webdriver/io/exec.js':
        /*!****************************************************!*\
  !*** ./node_modules/selenium-webdriver/io/exec.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const childProcess = __webpack_require__(/*! child_process */ 'child_process')

          /**
           * Options for configuring an executed command.
           *
           * @record
           */
          class Options {
            constructor() {
              /**
               * Command line arguments for the child process, if any.
               * @type (!Array<string>|undefined)
               */
              this.args

              /**
               * Environment variables for the spawned process. If unspecified, the
               * child will inherit this process' environment.
               *
               * @type {(!Object<string, string>|undefined)}
               */
              this.env

              /**
               * IO conifguration for the spawned server child process. If unspecified,
               * the child process' IO output will be ignored.
               *
               * @type {(string|!Array<string|number|!stream.Stream|null|undefined>|
               *           undefined)}
               * @see <https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html#child_process_options_stdio>
               */
              this.stdio
            }
          }

          /**
           * Describes a command's termination conditions.
           */
          class Result {
            /**
             * @param {?number} code The exit code, or {@code null} if the command did not
             *     exit normally.
             * @param {?string} signal The signal used to kill the command, or
             *     {@code null}.
             */
            constructor(code, signal) {
              /** @type {?number} */
              this.code = code

              /** @type {?string} */
              this.signal = signal
            }

            /** @override */
            toString() {
              return `Result(code=${this.code}, signal=${this.signal})`
            }
          }

          const COMMAND_RESULT = /** !WeakMap<!Command, !Promise<!Result>> */ new WeakMap()
          const KILL_HOOK = /** !WeakMap<!Command, function(string)> */ new WeakMap()

          /**
           * Represents a command running in a sub-process.
           */
          class Command {
            /**
             * @param {!Promise<!Result>} result The command result.
             * @param {function(string)} onKill The function to call when {@link #kill()}
             *     is called.
             */
            constructor(result, onKill) {
              COMMAND_RESULT.set(this, result)
              KILL_HOOK.set(this, onKill)
            }

            /**
             * @return {!Promise<!Result>} A promise for the result of this
             *     command.
             */
            result() {
              return /** @type {!Promise<!Result>} */ (COMMAND_RESULT.get(this))
            }

            /**
             * Sends a signal to the underlying process.
             * @param {string=} opt_signal The signal to send; defaults to `SIGTERM`.
             */
            kill(opt_signal) {
              KILL_HOOK.get(this)(opt_signal || 'SIGTERM')
            }
          }

          // PUBLIC API

          /**
           * Spawns a child process. The returned {@link Command} may be used to wait
           * for the process result or to send signals to the process.
           *
           * @param {string} command The executable to spawn.
           * @param {Options=} opt_options The command options.
           * @return {!Command} The launched command.
           */
          function exec(command, opt_options) {
            const options = opt_options || {}

            let proc = childProcess.spawn(command, options.args || [], {
              env: options.env || process.env,
              stdio: options.stdio || 'ignore'
            })

            // This process should not wait on the spawned child, however, we do
            // want to ensure the child is killed when this process exits.
            proc.unref()
            process.once('exit', onProcessExit)

            const result = new Promise((resolve, reject) => {
              proc.once('exit', (code, signal) => {
                proc = null
                process.removeListener('exit', onProcessExit)
                resolve(new Result(code, signal))
              })

              proc.once('error', (err) => {
                reject(err)
              })
            })
            return new Command(result, killCommand)

            function onProcessExit() {
              killCommand('SIGTERM')
            }

            function killCommand(signal) {
              process.removeListener('exit', onProcessExit)
              if (proc) {
                proc.kill(signal)
                proc = null
              }
            }
          }

          // Exported to improve generated API documentation.

          module.exports = {
            Command,
            Options,
            Result,
            exec
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/io/index.js':
        /*!*****************************************************!*\
  !*** ./node_modules/selenium-webdriver/io/index.js ***!
  \*****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const fs = __webpack_require__(/*! fs */ 'fs')
          const path = __webpack_require__(/*! path */ 'path')
          const tmp = __webpack_require__(/*! tmp */ './node_modules/tmp/lib/tmp.js')

          /**
           * @param {!Function} fn .
           * @return {!Promise<T>} .
           * @template T
           */
          function checkedCall(fn) {
            return new Promise((resolve, reject) => {
              try {
                fn((err, value) => {
                  if (err) {
                    reject(err)
                  } else {
                    resolve(value)
                  }
                })
              } catch (e) {
                reject(e)
              }
            })
          }

          /**
           * Recursively removes a directory and all of its contents. This is equivalent
           * to {@code rm -rf} on a POSIX system.
           * @param {string} dirPath Path to the directory to remove.
           * @return {!Promise} A promise to be resolved when the operation has
           *     completed.
           */
          function rmDir(dirPath) {
            return new Promise(function (fulfill, reject) {
              fs.rm(dirPath, { recursive: true, maxRetries: 2 }, function (err) {
                if (err && err.code === 'ENOENT') {
                  fulfill()
                } else if (err) {
                  reject(err)
                }
                fulfill()
              })
            })
          }

          /**
           * Copies one file to another.
           * @param {string} src The source file.
           * @param {string} dst The destination file.
           * @return {!Promise<string>} A promise for the copied file's path.
           */
          function copy(src, dst) {
            return new Promise(function (fulfill, reject) {
              const rs = fs.createReadStream(src)
              rs.on('error', reject)

              const ws = fs.createWriteStream(dst)
              ws.on('error', reject)
              ws.on('close', () => fulfill(dst))

              rs.pipe(ws)
            })
          }

          /**
           * Recursively copies the contents of one directory to another.
           * @param {string} src The source directory to copy.
           * @param {string} dst The directory to copy into.
           * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter
           *     as either a regex or predicate function. All files matching this filter
           *     will not be copied.
           * @return {!Promise<string>} A promise for the destination
           *     directory's path once all files have been copied.
           */
          function copyDir(src, dst, opt_exclude) {
            let predicate = opt_exclude
            if (opt_exclude && typeof opt_exclude !== 'function') {
              predicate = function (p) {
                return !opt_exclude.test(p)
              }
            }

            if (!fs.existsSync(dst)) {
              fs.mkdirSync(dst)
            }

            let files = fs.readdirSync(src)
            files = files.map(function (file) {
              return path.join(src, file)
            })

            if (predicate) {
              files = files.filter(/** @type {function(string): boolean} */ (predicate))
            }

            const results = []
            files.forEach(function (file) {
              const stats = fs.statSync(file)
              const target = path.join(dst, path.basename(file))

              if (stats.isDirectory()) {
                if (!fs.existsSync(target)) {
                  fs.mkdirSync(target, stats.mode)
                }
                results.push(copyDir(file, target, predicate))
              } else {
                results.push(copy(file, target))
              }
            })

            return Promise.all(results).then(() => dst)
          }

          /**
           * Tests if a file path exists.
           * @param {string} aPath The path to test.
           * @return {!Promise<boolean>} A promise for whether the file exists.
           */
          function exists(aPath) {
            return new Promise(function (fulfill, reject) {
              let type = typeof aPath
              if (type !== 'string') {
                reject(TypeError(`expected string path, but got ${type}`))
              } else {
                fulfill(fs.existsSync(aPath))
              }
            })
          }

          /**
           * Calls `stat(2)`.
           * @param {string} aPath The path to stat.
           * @return {!Promise<!fs.Stats>} A promise for the file stats.
           */
          function stat(aPath) {
            return checkedCall((callback) => fs.stat(aPath, callback))
          }

          /**
           * Deletes a name from the filesystem and possibly the file it refers to. Has
           * no effect if the file does not exist.
           * @param {string} aPath The path to remove.
           * @return {!Promise} A promise for when the file has been removed.
           */
          function unlink(aPath) {
            return new Promise(function (fulfill, reject) {
              const exists = fs.existsSync(aPath)
              if (exists) {
                fs.unlink(aPath, function (err) {
                  ;(err && reject(err)) || fulfill()
                })
              } else {
                fulfill()
              }
            })
          }

          /**
           * @return {!Promise<string>} A promise for the path to a temporary directory.
           * @see https://www.npmjs.org/package/tmp
           */
          function tmpDir() {
            return checkedCall((callback) => tmp.dir({ unsafeCleanup: true }, callback))
          }

          /**
           * @param {{postfix: string}=} opt_options Temporary file options.
           * @return {!Promise<string>} A promise for the path to a temporary file.
           * @see https://www.npmjs.org/package/tmp
           */
          function tmpFile(opt_options) {
            return checkedCall((callback) => {
              /**  check fixed in v > 0.2.1 if
               * (typeof options === 'function') {
               *     return [{}, options];
               * }
               */
              tmp.file(opt_options, callback)
            })
          }

          /**
           * Searches the {@code PATH} environment variable for the given file.
           * @param {string} file The file to locate on the PATH.
           * @param {boolean=} opt_checkCwd Whether to always start with the search with
           *     the current working directory, regardless of whether it is explicitly
           *     listed on the PATH.
           * @return {?string} Path to the located file, or {@code null} if it could
           *     not be found.
           */
          function findInPath(file, opt_checkCwd) {
            const dirs = []
            if (opt_checkCwd) {
              dirs.push(process.cwd())
            }
            dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter))

            let foundInDir = dirs.find((dir) => {
              let tmp = path.join(dir, file)
              try {
                let stats = fs.statSync(tmp)
                return stats.isFile() && !stats.isDirectory()
              } catch (ex) {
                return false
              }
            })

            return foundInDir ? path.join(foundInDir, file) : null
          }

          /**
           * Reads the contents of the given file.
           *
           * @param {string} aPath Path to the file to read.
           * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the
           *     file contents.
           */
          function read(aPath) {
            return checkedCall((callback) => fs.readFile(aPath, callback))
          }

          /**
           * Writes to a file.
           *
           * @param {string} aPath Path to the file to write to.
           * @param {(string|!Buffer)} data The data to write.
           * @return {!Promise} A promise that will resolve when the operation has
           *     completed.
           */
          function write(aPath, data) {
            return checkedCall((callback) => fs.writeFile(aPath, data, callback))
          }

          /**
           * Creates a directory.
           *
           * @param {string} aPath The directory path.
           * @return {!Promise<string>} A promise that will resolve with the path of the
           *     created directory.
           */
          function mkdir(aPath) {
            return checkedCall((callback) => {
              fs.mkdir(aPath, undefined, (err) => {
                if (err && err.code !== 'EEXIST') {
                  callback(err)
                } else {
                  callback(null, aPath)
                }
              })
            })
          }

          /**
           * Recursively creates a directory and any ancestors that do not yet exist.
           *
           * @param {string} dir The directory path to create.
           * @return {!Promise<string>} A promise that will resolve with the path of the
           *     created directory.
           */
          function mkdirp(dir) {
            return checkedCall((callback) => {
              fs.mkdir(dir, undefined, (err) => {
                if (!err) {
                  callback(null, dir)
                  return
                }

                switch (err.code) {
                  case 'EEXIST':
                    callback(null, dir)
                    return
                  case 'ENOENT':
                    return mkdirp(path.dirname(dir))
                      .then(() => mkdirp(dir))
                      .then(
                        () => callback(null, dir),
                        (err) => callback(err)
                      )
                  default:
                    callback(err)
                    return
                }
              })
            })
          }

          /**
           * Recursively walks a directory, returning a promise that will resolve with
           * a list of all files/directories seen.
           *
           * @param {string} rootPath the directory to walk.
           * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will
           *     resolve with a list of entries seen. For each entry, the recorded path
           *     will be relative to `rootPath`.
           */
          function walkDir(rootPath) {
            const seen = []
            return (function walk(dir) {
              return checkedCall((callback) => fs.readdir(dir, callback)).then((files) =>
                Promise.all(
                  files.map((file) => {
                    file = path.join(dir, file)
                    return checkedCall((cb) => fs.stat(file, cb)).then((stats) => {
                      seen.push({
                        path: path.relative(rootPath, file),
                        dir: stats.isDirectory()
                      })
                      return stats.isDirectory() && walk(file)
                    })
                  })
                )
              )
            })(rootPath).then(() => seen)
          }

          // PUBLIC API
          module.exports = {
            walkDir,
            rmDir,
            mkdirp,
            mkdir,
            write,
            read,
            findInPath,
            tmpFile,
            tmpDir,
            unlink,
            copy,
            copyDir,
            exists,
            stat
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/io/zip.js':
        /*!***************************************************!*\
  !*** ./node_modules/selenium-webdriver/io/zip.js ***!
  \***************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const jszip = __webpack_require__(/*! jszip */ './node_modules/jszip/lib/index.js')
          const path = __webpack_require__(/*! path */ 'path')

          const io = __webpack_require__(
            /*! ./index */ './node_modules/selenium-webdriver/io/index.js'
          )
          const { InvalidArgumentError } = __webpack_require__(
            /*! ../lib/error */ './node_modules/selenium-webdriver/lib/error.js'
          )

          /**
           * Manages a zip archive.
           */
          class Zip {
            constructor() {
              /** @private @const */
              this.z_ = new jszip()

              /** @private @const {!Set<!Promise<?>>} */
              this.pendingAdds_ = new Set()
            }

            /**
             * Adds a file to this zip.
             *
             * @param {string} filePath path to the file to add.
             * @param {string=} zipPath path to the file in the zip archive, defaults
             *     to the basename of `filePath`.
             * @return {!Promise<?>} a promise that will resolve when added.
             */
            addFile(filePath, zipPath = path.basename(filePath)) {
              let add = io
                .read(filePath)
                .then((buffer) =>
                  this.z_.file(/** @type {string} */ (zipPath.replace(/\\/g, '/')), buffer)
                )
              this.pendingAdds_.add(add)
              return add.then(
                () => this.pendingAdds_.delete(add),
                (e) => {
                  this.pendingAdds_.delete(add)
                  throw e
                }
              )
            }

            /**
             * Recursively adds a directory and all of its contents to this archive.
             *
             * @param {string} dirPath path to the directory to add.
             * @param {string=} zipPath path to the folder in the archive to add the
             *     directory contents to. Defaults to the root folder.
             * @return {!Promise<?>} returns a promise that will resolve when
             * the operation is complete.
             */
            addDir(dirPath, zipPath = '') {
              return io.walkDir(dirPath).then((entries) => {
                let archive = this.z_
                if (zipPath) {
                  archive = archive.folder(zipPath)
                }

                let files = []
                entries.forEach((spec) => {
                  if (spec.dir) {
                    archive.folder(spec.path)
                  } else {
                    files.push(
                      this.addFile(path.join(dirPath, spec.path), path.join(zipPath, spec.path))
                    )
                  }
                })

                return Promise.all(files)
              })
            }

            /**
             * @param {string} path File path to test for within the archive.
             * @return {boolean} Whether this zip archive contains an entry with the given
             *     path.
             */
            has(path) {
              return this.z_.file(path) !== null
            }

            /**
             * Returns the contents of the file in this zip archive with the given `path`.
             * The returned promise will be rejected with an {@link InvalidArgumentError}
             * if either `path` does not exist within the archive, or if `path` refers
             * to a directory.
             *
             * @param {string} path the path to the file whose contents to return.
             * @return {!Promise<!Buffer>} a promise that will be resolved with the file's
             *     contents as a buffer.
             */
            getFile(path) {
              let file = this.z_.file(path)
              if (!file) {
                return Promise.reject(
                  new InvalidArgumentError(`No such file in zip archive: ${path}`)
                )
              }

              if (file.dir) {
                return Promise.reject(
                  new InvalidArgumentError(`The requested file is a directory: ${path}`)
                )
              }

              return Promise.resolve(file.async('nodebuffer'))
            }

            /**
             * Returns the compressed data for this archive in a buffer. _This method will
             * not wait for any outstanding {@link #addFile add}
             * {@link #addDir operations} before encoding the archive._
             *
             * @param {string} compression The desired compression.
             *     Must be `STORE` (the default) or `DEFLATE`.
             * @return {!Promise<!Buffer>} a promise that will resolve with this archive
             *     as a buffer.
             */
            toBuffer(compression = 'STORE') {
              if (compression !== 'STORE' && compression !== 'DEFLATE') {
                return Promise.reject(
                  new InvalidArgumentError(
                    `compression must be one of {STORE, DEFLATE}, got ${compression}`
                  )
                )
              }
              return Promise.resolve(this.z_.generateAsync({ compression, type: 'nodebuffer' }))
            }
          }

          /**
           * Asynchronously opens a zip archive.
           *
           * @param {string} path to the zip archive to load.
           * @return {!Promise<!Zip>} a promise that will resolve with the opened
           *     archive.
           */
          function load(path) {
            return io.read(path).then((data) => {
              let zip = new Zip()
              return zip.z_.loadAsync(data).then(() => zip)
            })
          }

          /**
           * Asynchronously unzips an archive file.
           *
           * @param {string} src path to the source file to unzip.
           * @param {string} dst path to the destination directory.
           * @return {!Promise<string>} a promise that will resolve with `dst` once the
           *     archive has been unzipped.
           */
          function unzip(src, dst) {
            return load(src).then((zip) => {
              const promisedDirs = new Map()
              const promises = []

              zip.z_.forEach((relPath, file) => {
                let p
                if (file.dir) {
                  p = createDir(relPath)
                } else {
                  let dirname = path.dirname(relPath)
                  if (dirname === '.') {
                    p = writeFile(relPath, file)
                  } else {
                    p = createDir(dirname).then(() => writeFile(relPath, file))
                  }
                }
                promises.push(p)
              })

              return Promise.all(promises).then(() => dst)

              function createDir(dir) {
                let p = promisedDirs.get(dir)
                if (!p) {
                  p = io.mkdirp(path.join(dst, dir))
                  promisedDirs.set(dir, p)
                }
                return p
              }

              function writeFile(relPath, file) {
                return file
                  .async('nodebuffer')
                  .then((buffer) => io.write(path.join(dst, relPath), buffer))
              }
            })
          }

          // PUBLIC API
          module.exports = { Zip, load, unzip }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/atoms/find-elements.js':
        /*!********************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/atoms/find-elements.js ***!
  \********************************************************************/
        /***/ (module) => {
          // GENERATED CODE - DO NOT EDIT
          module.exports = function () {
            return function () {
              var aa = this || self
              function ba(a) {
                return 'string' == typeof a
              }
              function ca(a, b) {
                a = a.split('.')
                var c = aa
                a[0] in c || 'undefined' == typeof c.execScript || c.execScript('var ' + a[0])
                for (var d; a.length && (d = a.shift()); )
                  a.length || void 0 === b
                    ? c[d] && c[d] !== Object.prototype[d]
                      ? (c = c[d])
                      : (c = c[d] = {})
                    : (c[d] = b)
              }
              function da(a) {
                var b = typeof a
                if ('object' == b)
                  if (a) {
                    if (a instanceof Array) return 'array'
                    if (a instanceof Object) return b
                    var c = Object.prototype.toString.call(a)
                    if ('[object Window]' == c) return 'object'
                    if (
                      '[object Array]' == c ||
                      ('number' == typeof a.length &&
                        'undefined' != typeof a.splice &&
                        'undefined' != typeof a.propertyIsEnumerable &&
                        !a.propertyIsEnumerable('splice'))
                    )
                      return 'array'
                    if (
                      '[object Function]' == c ||
                      ('undefined' != typeof a.call &&
                        'undefined' != typeof a.propertyIsEnumerable &&
                        !a.propertyIsEnumerable('call'))
                    )
                      return 'function'
                  } else return 'null'
                else if ('function' == b && 'undefined' == typeof a.call) return 'object'
                return b
              }
              function ea(a) {
                return 'function' == da(a)
              }
              function ha(a) {
                var b = typeof a
                return ('object' == b && null != a) || 'function' == b
              }
              function ia(a, b, c) {
                return a.call.apply(a.bind, arguments)
              }
              function ja(a, b, c) {
                if (!a) throw Error()
                if (2 < arguments.length) {
                  var d = Array.prototype.slice.call(arguments, 2)
                  return function () {
                    var e = Array.prototype.slice.call(arguments)
                    Array.prototype.unshift.apply(e, d)
                    return a.apply(b, e)
                  }
                }
                return function () {
                  return a.apply(b, arguments)
                }
              }
              function ka(a, b, c) {
                Function.prototype.bind &&
                -1 != Function.prototype.bind.toString().indexOf('native code')
                  ? (ka = ia)
                  : (ka = ja)
                return ka.apply(null, arguments)
              }
              function la(a, b) {
                var c = Array.prototype.slice.call(arguments, 1)
                return function () {
                  var d = c.slice()
                  d.push.apply(d, arguments)
                  return a.apply(this, d)
                }
              }
              function k(a, b) {
                function c() {}
                c.prototype = b.prototype
                a.prototype = new c()
                a.prototype.constructor = a
              } /*

 The MIT License

 Copyright (c) 2007 Cybozu Labs, Inc.
 Copyright (c) 2012 Google Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 IN THE SOFTWARE.
*/
              function ma(a, b, c) {
                this.a = a
                this.b = b || 1
                this.f = c || 1
              }
              var na
              var oa = Array.prototype.indexOf
                  ? function (a, b) {
                      return Array.prototype.indexOf.call(a, b, void 0)
                    }
                  : function (a, b) {
                      if ('string' === typeof a)
                        return 'string' !== typeof b || 1 != b.length ? -1 : a.indexOf(b, 0)
                      for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c
                      return -1
                    },
                l = Array.prototype.forEach
                  ? function (a, b, c) {
                      Array.prototype.forEach.call(a, b, c)
                    }
                  : function (a, b, c) {
                      for (
                        var d = a.length, e = 'string' === typeof a ? a.split('') : a, f = 0;
                        f < d;
                        f++
                      )
                        f in e && b.call(c, e[f], f, a)
                    },
                pa = Array.prototype.filter
                  ? function (a, b) {
                      return Array.prototype.filter.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length,
                          d = [],
                          e = 0,
                          f = 'string' === typeof a ? a.split('') : a,
                          g = 0;
                        g < c;
                        g++
                      )
                        if (g in f) {
                          var h = f[g]
                          b.call(void 0, h, g, a) && (d[e++] = h)
                        }
                      return d
                    },
                qa = Array.prototype.map
                  ? function (a, b) {
                      return Array.prototype.map.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length,
                          d = Array(c),
                          e = 'string' === typeof a ? a.split('') : a,
                          f = 0;
                        f < c;
                        f++
                      )
                        f in e && (d[f] = b.call(void 0, e[f], f, a))
                      return d
                    },
                ra = Array.prototype.reduce
                  ? function (a, b, c) {
                      return Array.prototype.reduce.call(a, b, c)
                    }
                  : function (a, b, c) {
                      var d = c
                      l(a, function (e, f) {
                        d = b.call(void 0, d, e, f, a)
                      })
                      return d
                    },
                sa = Array.prototype.some
                  ? function (a, b) {
                      return Array.prototype.some.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                        e < c;
                        e++
                      )
                        if (e in d && b.call(void 0, d[e], e, a)) return !0
                      return !1
                    },
                ta = Array.prototype.every
                  ? function (a, b, c) {
                      return Array.prototype.every.call(a, b, c)
                    }
                  : function (a, b, c) {
                      for (
                        var d = a.length, e = 'string' === typeof a ? a.split('') : a, f = 0;
                        f < d;
                        f++
                      )
                        if (f in e && !b.call(c, e[f], f, a)) return !1
                      return !0
                    }
              function ua(a, b) {
                a: {
                  for (
                    var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                    e < c;
                    e++
                  )
                    if (e in d && b.call(void 0, d[e], e, a)) {
                      b = e
                      break a
                    }
                  b = -1
                }
                return 0 > b ? null : 'string' === typeof a ? a.charAt(b) : a[b]
              }
              function va(a) {
                return Array.prototype.concat.apply([], arguments)
              }
              function wa(a, b, c) {
                return 2 >= arguments.length
                  ? Array.prototype.slice.call(a, b)
                  : Array.prototype.slice.call(a, b, c)
              }
              function xa(a, b) {
                a.sort(b || ya)
              }
              function ya(a, b) {
                return a > b ? 1 : a < b ? -1 : 0
              }
              function za(a) {
                var b = a.length - 1
                return 0 <= b && a.indexOf(' ', b) == b
              }
              var Aa = String.prototype.trim
                ? function (a) {
                    return a.trim()
                  }
                : function (a) {
                    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]
                  }
              function Ba(a, b) {
                var c = 0
                a = Aa(String(a)).split('.')
                b = Aa(String(b)).split('.')
                for (var d = Math.max(a.length, b.length), e = 0; 0 == c && e < d; e++) {
                  var f = a[e] || '',
                    g = b[e] || ''
                  do {
                    f = /(\d*)(\D*)(.*)/.exec(f) || ['', '', '', '']
                    g = /(\d*)(\D*)(.*)/.exec(g) || ['', '', '', '']
                    if (0 == f[0].length && 0 == g[0].length) break
                    c =
                      Ca(
                        0 == f[1].length ? 0 : parseInt(f[1], 10),
                        0 == g[1].length ? 0 : parseInt(g[1], 10)
                      ) ||
                      Ca(0 == f[2].length, 0 == g[2].length) ||
                      Ca(f[2], g[2])
                    f = f[3]
                    g = g[3]
                  } while (0 == c)
                }
                return c
              }
              function Ca(a, b) {
                return a < b ? -1 : a > b ? 1 : 0
              }
              var q
              a: {
                var Da = aa.navigator
                if (Da) {
                  var Ea = Da.userAgent
                  if (Ea) {
                    q = Ea
                    break a
                  }
                }
                q = ''
              }
              function r(a) {
                return -1 != q.indexOf(a)
              }
              function Fa() {
                return r('Firefox') || r('FxiOS')
              }
              function Ga() {
                return (r('Chrome') || r('CriOS')) && !r('Edge')
              }
              function Ha(a) {
                return String(a).replace(/\-([a-z])/g, function (b, c) {
                  return c.toUpperCase()
                })
              }
              function Ia() {
                return r('iPhone') && !r('iPod') && !r('iPad')
              }
              function Ja(a, b) {
                var c = Ka
                return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : (c[a] = b(a))
              }
              var La = r('Opera'),
                t = r('Trident') || r('MSIE'),
                Ma = r('Edge'),
                Na =
                  r('Gecko') &&
                  !(-1 != q.toLowerCase().indexOf('webkit') && !r('Edge')) &&
                  !(r('Trident') || r('MSIE')) &&
                  !r('Edge'),
                Oa = -1 != q.toLowerCase().indexOf('webkit') && !r('Edge')
              function Pa() {
                var a = aa.document
                return a ? a.documentMode : void 0
              }
              var Qa
              a: {
                var Ra = '',
                  Sa = (function () {
                    var a = q
                    if (Na) return /rv:([^\);]+)(\)|;)/.exec(a)
                    if (Ma) return /Edge\/([\d\.]+)/.exec(a)
                    if (t) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
                    if (Oa) return /WebKit\/(\S+)/.exec(a)
                    if (La) return /(?:Version)[ \/]?(\S+)/.exec(a)
                  })()
                Sa && (Ra = Sa ? Sa[1] : '')
                if (t) {
                  var Ta = Pa()
                  if (null != Ta && Ta > parseFloat(Ra)) {
                    Qa = String(Ta)
                    break a
                  }
                }
                Qa = Ra
              }
              var Ka = {}
              function Ua(a) {
                return Ja(a, function () {
                  return 0 <= Ba(Qa, a)
                })
              }
              var w
              w = aa.document && t ? Pa() : void 0
              var x = t && !(9 <= Number(w)),
                Va = t && !(8 <= Number(w))
              function Wa(a, b, c, d) {
                this.a = a
                this.nodeName = c
                this.nodeValue = d
                this.nodeType = 2
                this.parentNode = this.ownerElement = b
              }
              function Xa(a, b) {
                var c = Va && 'href' == b.nodeName ? a.getAttribute(b.nodeName, 2) : b.nodeValue
                return new Wa(b, a, b.nodeName, c)
              }
              function Ya(a) {
                this.b = a
                this.a = 0
              }
              function Za(a) {
                a = a.match($a)
                for (var b = 0; b < a.length; b++) ab.test(a[b]) && a.splice(b, 1)
                return new Ya(a)
              }
              var $a =
                  /\$?(?:(?![0-9-\.])(?:\*|[\w-\.]+):)?(?![0-9-\.])(?:\*|[\w-\.]+)|\/\/|\.\.|::|\d+(?:\.\d*)?|\.\d+|"[^"]*"|'[^']*'|[!<>]=|\s+|./g,
                ab = /^\s/
              function y(a, b) {
                return a.b[a.a + (b || 0)]
              }
              function z(a) {
                return a.b[a.a++]
              }
              function bb(a) {
                return a.b.length <= a.a
              }
              function cb(a, b) {
                this.x = void 0 !== a ? a : 0
                this.y = void 0 !== b ? b : 0
              }
              cb.prototype.ceil = function () {
                this.x = Math.ceil(this.x)
                this.y = Math.ceil(this.y)
                return this
              }
              cb.prototype.floor = function () {
                this.x = Math.floor(this.x)
                this.y = Math.floor(this.y)
                return this
              }
              cb.prototype.round = function () {
                this.x = Math.round(this.x)
                this.y = Math.round(this.y)
                return this
              }
              function db(a, b) {
                this.width = a
                this.height = b
              }
              db.prototype.aspectRatio = function () {
                return this.width / this.height
              }
              db.prototype.ceil = function () {
                this.width = Math.ceil(this.width)
                this.height = Math.ceil(this.height)
                return this
              }
              db.prototype.floor = function () {
                this.width = Math.floor(this.width)
                this.height = Math.floor(this.height)
                return this
              }
              db.prototype.round = function () {
                this.width = Math.round(this.width)
                this.height = Math.round(this.height)
                return this
              }
              function eb(a) {
                return a ? new fb(A(a)) : na || (na = new fb())
              }
              function gb(a) {
                for (; a && 1 != a.nodeType; ) a = a.previousSibling
                return a
              }
              function hb(a, b) {
                if (!a || !b) return !1
                if (a.contains && 1 == b.nodeType) return a == b || a.contains(b)
                if ('undefined' != typeof a.compareDocumentPosition)
                  return a == b || !!(a.compareDocumentPosition(b) & 16)
                for (; b && a != b; ) b = b.parentNode
                return b == a
              }
              function ib(a, b) {
                if (a == b) return 0
                if (a.compareDocumentPosition) return a.compareDocumentPosition(b) & 2 ? 1 : -1
                if (t && !(9 <= Number(w))) {
                  if (9 == a.nodeType) return -1
                  if (9 == b.nodeType) return 1
                }
                if ('sourceIndex' in a || (a.parentNode && 'sourceIndex' in a.parentNode)) {
                  var c = 1 == a.nodeType,
                    d = 1 == b.nodeType
                  if (c && d) return a.sourceIndex - b.sourceIndex
                  var e = a.parentNode,
                    f = b.parentNode
                  return e == f
                    ? jb(a, b)
                    : !c && hb(e, b)
                    ? -1 * kb(a, b)
                    : !d && hb(f, a)
                    ? kb(b, a)
                    : (c ? a.sourceIndex : e.sourceIndex) - (d ? b.sourceIndex : f.sourceIndex)
                }
                d = A(a)
                c = d.createRange()
                c.selectNode(a)
                c.collapse(!0)
                a = d.createRange()
                a.selectNode(b)
                a.collapse(!0)
                return c.compareBoundaryPoints(aa.Range.START_TO_END, a)
              }
              function kb(a, b) {
                var c = a.parentNode
                if (c == b) return -1
                for (; b.parentNode != c; ) b = b.parentNode
                return jb(b, a)
              }
              function jb(a, b) {
                for (; (b = b.previousSibling); ) if (b == a) return -1
                return 1
              }
              function A(a) {
                return 9 == a.nodeType ? a : a.ownerDocument || a.document
              }
              function lb(a, b) {
                a && (a = a.parentNode)
                for (var c = 0; a; ) {
                  if (b(a)) return a
                  a = a.parentNode
                  c++
                }
                return null
              }
              function fb(a) {
                this.a = a || aa.document || document
              }
              fb.prototype.getElementsByTagName = function (a, b) {
                return (b || this.a).getElementsByTagName(String(a))
              }
              function mb(a, b, c, d) {
                a = d || a.a
                var e = b && '*' != b ? String(b).toUpperCase() : ''
                if (a.querySelectorAll && a.querySelector && (e || c))
                  c = a.querySelectorAll(e + (c ? '.' + c : ''))
                else if (c && a.getElementsByClassName)
                  if (((b = a.getElementsByClassName(c)), e)) {
                    a = {}
                    for (var f = (d = 0), g; (g = b[f]); f++) e == g.nodeName && (a[d++] = g)
                    a.length = d
                    c = a
                  } else c = b
                else if (((b = a.getElementsByTagName(e || '*')), c)) {
                  a = {}
                  for (f = d = 0; (g = b[f]); f++) {
                    e = g.className
                    var h
                    if ((h = 'function' == typeof e.split)) h = 0 <= oa(e.split(/\s+/), c)
                    h && (a[d++] = g)
                  }
                  a.length = d
                  c = a
                } else c = b
                return c
              }
              function B(a) {
                var b = null,
                  c = a.nodeType
                1 == c &&
                  ((b = a.textContent),
                  (b = void 0 == b || null == b ? a.innerText : b),
                  (b = void 0 == b || null == b ? '' : b))
                if ('string' != typeof b)
                  if (x && 'title' == a.nodeName.toLowerCase() && 1 == c) b = a.text
                  else if (9 == c || 1 == c) {
                    a = 9 == c ? a.documentElement : a.firstChild
                    c = 0
                    var d = []
                    for (b = ''; a; ) {
                      do
                        1 != a.nodeType && (b += a.nodeValue),
                          x && 'title' == a.nodeName.toLowerCase() && (b += a.text),
                          (d[c++] = a)
                      while ((a = a.firstChild))
                      for (; c && !(a = d[--c].nextSibling); );
                    }
                  } else b = a.nodeValue
                return b
              }
              function nb(a, b, c) {
                if (null === b) return !0
                try {
                  if (!a.getAttribute) return !1
                } catch (d) {
                  return !1
                }
                Va && 'class' == b && (b = 'className')
                return null == c ? !!a.getAttribute(b) : a.getAttribute(b, 2) == c
              }
              function ob(a, b, c, d, e) {
                return (x ? pb : qb).call(
                  null,
                  a,
                  b,
                  ba(c) ? c : null,
                  ba(d) ? d : null,
                  e || new C()
                )
              }
              function pb(a, b, c, d, e) {
                if (a instanceof rb || 8 == a.b || (c && null === a.b)) {
                  var f = b.all
                  if (!f) return e
                  a = sb(a)
                  if ('*' != a && ((f = b.getElementsByTagName(a)), !f)) return e
                  if (c) {
                    for (var g = [], h = 0; (b = f[h++]); ) nb(b, c, d) && g.push(b)
                    f = g
                  }
                  for (h = 0; (b = f[h++]); ) ('*' == a && '!' == b.tagName) || e.add(b)
                  return e
                }
                tb(a, b, c, d, e)
                return e
              }
              function qb(a, b, c, d, e) {
                b.getElementsByName && d && 'name' == c && !t
                  ? ((b = b.getElementsByName(d)),
                    l(b, function (f) {
                      a.a(f) && e.add(f)
                    }))
                  : b.getElementsByClassName && d && 'class' == c
                  ? ((b = b.getElementsByClassName(d)),
                    l(b, function (f) {
                      f.className == d && a.a(f) && e.add(f)
                    }))
                  : a instanceof D
                  ? tb(a, b, c, d, e)
                  : b.getElementsByTagName &&
                    ((b = b.getElementsByTagName(a.f())),
                    l(b, function (f) {
                      nb(f, c, d) && e.add(f)
                    }))
                return e
              }
              function ub(a, b, c, d, e) {
                var f
                if ((a instanceof rb || 8 == a.b || (c && null === a.b)) && (f = b.childNodes)) {
                  var g = sb(a)
                  if (
                    '*' != g &&
                    ((f = pa(f, function (h) {
                      return h.tagName && h.tagName.toLowerCase() == g
                    })),
                    !f)
                  )
                    return e
                  c &&
                    (f = pa(f, function (h) {
                      return nb(h, c, d)
                    }))
                  l(f, function (h) {
                    ;('*' == g && ('!' == h.tagName || ('*' == g && 1 != h.nodeType))) || e.add(h)
                  })
                  return e
                }
                return vb(a, b, c, d, e)
              }
              function vb(a, b, c, d, e) {
                for (b = b.firstChild; b; b = b.nextSibling) nb(b, c, d) && a.a(b) && e.add(b)
                return e
              }
              function tb(a, b, c, d, e) {
                for (b = b.firstChild; b; b = b.nextSibling)
                  nb(b, c, d) && a.a(b) && e.add(b), tb(a, b, c, d, e)
              }
              function sb(a) {
                if (a instanceof D) {
                  if (8 == a.b) return '!'
                  if (null === a.b) return '*'
                }
                return a.f()
              }
              function C() {
                this.b = this.a = null
                this.m = 0
              }
              function wb(a) {
                this.f = a
                this.a = this.b = null
              }
              function xb(a, b) {
                if (!a.a) return b
                if (!b.a) return a
                var c = a.a
                b = b.a
                for (var d = null, e, f = 0; c && b; ) {
                  e = c.f
                  var g = b.f
                  e == g || (e instanceof Wa && g instanceof Wa && e.a == g.a)
                    ? ((e = c), (c = c.a), (b = b.a))
                    : 0 < ib(c.f, b.f)
                    ? ((e = b), (b = b.a))
                    : ((e = c), (c = c.a))
                  ;(e.b = d) ? (d.a = e) : (a.a = e)
                  d = e
                  f++
                }
                for (e = c || b; e; ) (e.b = d), (d = d.a = e), f++, (e = e.a)
                a.b = d
                a.m = f
                return a
              }
              function yb(a, b) {
                b = new wb(b)
                b.a = a.a
                a.b ? (a.a.b = b) : (a.a = a.b = b)
                a.a = b
                a.m++
              }
              C.prototype.add = function (a) {
                a = new wb(a)
                a.b = this.b
                this.a ? (this.b.a = a) : (this.a = this.b = a)
                this.b = a
                this.m++
              }
              function zb(a) {
                return (a = a.a) ? a.f : null
              }
              function Bb(a) {
                return (a = zb(a)) ? B(a) : ''
              }
              function Cb(a, b) {
                return new Db(a, !!b)
              }
              function Db(a, b) {
                this.f = a
                this.b = (this.A = b) ? a.b : a.a
                this.a = null
              }
              function E(a) {
                var b = a.b
                if (null == b) return null
                var c = (a.a = b)
                a.b = a.A ? b.b : b.a
                return c.f
              }
              function F(a) {
                this.i = a
                this.b = this.g = !1
                this.f = null
              }
              function H(a) {
                return '\n  ' + a.toString().split('\n').join('\n  ')
              }
              function Eb(a, b) {
                a.g = b
              }
              function Fb(a, b) {
                a.b = b
              }
              function I(a, b) {
                a = a.a(b)
                return a instanceof C ? +Bb(a) : +a
              }
              function J(a, b) {
                a = a.a(b)
                return a instanceof C ? Bb(a) : '' + a
              }
              function Gb(a, b) {
                a = a.a(b)
                return a instanceof C ? !!a.m : !!a
              }
              function Hb(a, b, c) {
                F.call(this, a.i)
                this.c = a
                this.h = b
                this.v = c
                this.g = b.g || c.g
                this.b = b.b || c.b
                this.c == Ib &&
                  (c.b || c.g || 4 == c.i || 0 == c.i || !b.f
                    ? b.b ||
                      b.g ||
                      4 == b.i ||
                      0 == b.i ||
                      !c.f ||
                      (this.f = { name: c.f.name, B: b })
                    : (this.f = { name: b.f.name, B: c }))
              }
              k(Hb, F)
              function Jb(a, b, c, d, e) {
                b = b.a(d)
                c = c.a(d)
                var f
                if (b instanceof C && c instanceof C) {
                  b = Cb(b)
                  for (d = E(b); d; d = E(b))
                    for (e = Cb(c), f = E(e); f; f = E(e)) if (a(B(d), B(f))) return !0
                  return !1
                }
                if (b instanceof C || c instanceof C) {
                  b instanceof C ? ((e = b), (d = c)) : ((e = c), (d = b))
                  f = Cb(e)
                  for (var g = typeof d, h = E(f); h; h = E(f)) {
                    switch (g) {
                      case 'number':
                        h = +B(h)
                        break
                      case 'boolean':
                        h = !!B(h)
                        break
                      case 'string':
                        h = B(h)
                        break
                      default:
                        throw Error('Illegal primitive type for comparison.')
                    }
                    if ((e == b && a(h, d)) || (e == c && a(d, h))) return !0
                  }
                  return !1
                }
                return e
                  ? 'boolean' == typeof b || 'boolean' == typeof c
                    ? a(!!b, !!c)
                    : 'number' == typeof b || 'number' == typeof c
                    ? a(+b, +c)
                    : a(b, c)
                  : a(+b, +c)
              }
              Hb.prototype.a = function (a) {
                return this.c.s(this.h, this.v, a)
              }
              Hb.prototype.toString = function () {
                var a = 'Binary Expression: ' + this.c
                a += H(this.h)
                return (a += H(this.v))
              }
              function Kb(a, b, c, d) {
                this.$ = a
                this.M = b
                this.i = c
                this.s = d
              }
              Kb.prototype.toString = function () {
                return this.$
              }
              var Lb = {}
              function K(a, b, c, d) {
                if (Lb.hasOwnProperty(a)) throw Error('Binary operator already created: ' + a)
                a = new Kb(a, b, c, d)
                return (Lb[a.toString()] = a)
              }
              K('div', 6, 1, function (a, b, c) {
                return I(a, c) / I(b, c)
              })
              K('mod', 6, 1, function (a, b, c) {
                return I(a, c) % I(b, c)
              })
              K('*', 6, 1, function (a, b, c) {
                return I(a, c) * I(b, c)
              })
              K('+', 5, 1, function (a, b, c) {
                return I(a, c) + I(b, c)
              })
              K('-', 5, 1, function (a, b, c) {
                return I(a, c) - I(b, c)
              })
              K('<', 4, 2, function (a, b, c) {
                return Jb(
                  function (d, e) {
                    return d < e
                  },
                  a,
                  b,
                  c
                )
              })
              K('>', 4, 2, function (a, b, c) {
                return Jb(
                  function (d, e) {
                    return d > e
                  },
                  a,
                  b,
                  c
                )
              })
              K('<=', 4, 2, function (a, b, c) {
                return Jb(
                  function (d, e) {
                    return d <= e
                  },
                  a,
                  b,
                  c
                )
              })
              K('>=', 4, 2, function (a, b, c) {
                return Jb(
                  function (d, e) {
                    return d >= e
                  },
                  a,
                  b,
                  c
                )
              })
              var Ib = K('=', 3, 2, function (a, b, c) {
                return Jb(
                  function (d, e) {
                    return d == e
                  },
                  a,
                  b,
                  c,
                  !0
                )
              })
              K('!=', 3, 2, function (a, b, c) {
                return Jb(
                  function (d, e) {
                    return d != e
                  },
                  a,
                  b,
                  c,
                  !0
                )
              })
              K('and', 2, 2, function (a, b, c) {
                return Gb(a, c) && Gb(b, c)
              })
              K('or', 1, 2, function (a, b, c) {
                return Gb(a, c) || Gb(b, c)
              })
              function Mb(a, b) {
                if (b.a.length && 4 != a.i)
                  throw Error(
                    'Primary expression must evaluate to nodeset if filter has predicate(s).'
                  )
                F.call(this, a.i)
                this.c = a
                this.h = b
                this.g = a.g
                this.b = a.b
              }
              k(Mb, F)
              Mb.prototype.a = function (a) {
                a = this.c.a(a)
                return Nb(this.h, a)
              }
              Mb.prototype.toString = function () {
                var a = 'Filter:' + H(this.c)
                return (a += H(this.h))
              }
              function Ob(a, b) {
                if (b.length < a.L)
                  throw Error(
                    'Function ' +
                      a.l +
                      ' expects at least' +
                      a.L +
                      ' arguments, ' +
                      b.length +
                      ' given'
                  )
                if (null !== a.H && b.length > a.H)
                  throw Error(
                    'Function ' +
                      a.l +
                      ' expects at most ' +
                      a.H +
                      ' arguments, ' +
                      b.length +
                      ' given'
                  )
                a.Z &&
                  l(b, function (c, d) {
                    if (4 != c.i)
                      throw Error(
                        'Argument ' + d + ' to function ' + a.l + ' is not of type Nodeset: ' + c
                      )
                  })
                F.call(this, a.i)
                this.D = a
                this.c = b
                Eb(
                  this,
                  a.g ||
                    sa(b, function (c) {
                      return c.g
                    })
                )
                Fb(
                  this,
                  (a.Y && !b.length) ||
                    (a.X && !!b.length) ||
                    sa(b, function (c) {
                      return c.b
                    })
                )
              }
              k(Ob, F)
              Ob.prototype.a = function (a) {
                return this.D.s.apply(null, va(a, this.c))
              }
              Ob.prototype.toString = function () {
                var a = 'Function: ' + this.D
                if (this.c.length) {
                  var b = ra(
                    this.c,
                    function (c, d) {
                      return c + H(d)
                    },
                    'Arguments:'
                  )
                  a += H(b)
                }
                return a
              }
              function Pb(a, b, c, d, e, f, g, h) {
                this.l = a
                this.i = b
                this.g = c
                this.Y = d
                this.X = !1
                this.s = e
                this.L = f
                this.H = void 0 !== g ? g : f
                this.Z = !!h
              }
              Pb.prototype.toString = function () {
                return this.l
              }
              var Qb = {}
              function L(a, b, c, d, e, f, g, h) {
                if (Qb.hasOwnProperty(a)) throw Error('Function already created: ' + a + '.')
                Qb[a] = new Pb(a, b, c, d, e, f, g, h)
              }
              L(
                'boolean',
                2,
                !1,
                !1,
                function (a, b) {
                  return Gb(b, a)
                },
                1
              )
              L(
                'ceiling',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.ceil(I(b, a))
                },
                1
              )
              L(
                'concat',
                3,
                !1,
                !1,
                function (a, b) {
                  return ra(
                    wa(arguments, 1),
                    function (c, d) {
                      return c + J(d, a)
                    },
                    ''
                  )
                },
                2,
                null
              )
              L(
                'contains',
                2,
                !1,
                !1,
                function (a, b, c) {
                  b = J(b, a)
                  a = J(c, a)
                  return (a = -1 != b.indexOf(a))
                },
                2
              )
              L(
                'count',
                1,
                !1,
                !1,
                function (a, b) {
                  return b.a(a).m
                },
                1,
                1,
                !0
              )
              L(
                'false',
                2,
                !1,
                !1,
                function () {
                  return !1
                },
                0
              )
              L(
                'floor',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.floor(I(b, a))
                },
                1
              )
              L(
                'id',
                4,
                !1,
                !1,
                function (a, b) {
                  function c(h) {
                    if (x) {
                      var n = e.all[h]
                      if (n) {
                        if (n.nodeType && h == n.id) return n
                        if (n.length)
                          return ua(n, function (u) {
                            return h == u.id
                          })
                      }
                      return null
                    }
                    return e.getElementById(h)
                  }
                  var d = a.a,
                    e = 9 == d.nodeType ? d : d.ownerDocument
                  a = J(b, a).split(/\s+/)
                  var f = []
                  l(a, function (h) {
                    h = c(h)
                    !h || 0 <= oa(f, h) || f.push(h)
                  })
                  f.sort(ib)
                  var g = new C()
                  l(f, function (h) {
                    g.add(h)
                  })
                  return g
                },
                1
              )
              L(
                'lang',
                2,
                !1,
                !1,
                function () {
                  return !1
                },
                1
              )
              L(
                'last',
                1,
                !0,
                !1,
                function (a) {
                  if (1 != arguments.length) throw Error('Function last expects ()')
                  return a.f
                },
                0
              )
              L(
                'local-name',
                3,
                !1,
                !0,
                function (a, b) {
                  return (a = b ? zb(b.a(a)) : a.a) ? a.localName || a.nodeName.toLowerCase() : ''
                },
                0,
                1,
                !0
              )
              L(
                'name',
                3,
                !1,
                !0,
                function (a, b) {
                  return (a = b ? zb(b.a(a)) : a.a) ? a.nodeName.toLowerCase() : ''
                },
                0,
                1,
                !0
              )
              L(
                'namespace-uri',
                3,
                !0,
                !1,
                function () {
                  return ''
                },
                0,
                1,
                !0
              )
              L(
                'normalize-space',
                3,
                !1,
                !0,
                function (a, b) {
                  return (b ? J(b, a) : B(a.a)).replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '')
                },
                0,
                1
              )
              L(
                'not',
                2,
                !1,
                !1,
                function (a, b) {
                  return !Gb(b, a)
                },
                1
              )
              L(
                'number',
                1,
                !1,
                !0,
                function (a, b) {
                  return b ? I(b, a) : +B(a.a)
                },
                0,
                1
              )
              L(
                'position',
                1,
                !0,
                !1,
                function (a) {
                  return a.b
                },
                0
              )
              L(
                'round',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.round(I(b, a))
                },
                1
              )
              L(
                'starts-with',
                2,
                !1,
                !1,
                function (a, b, c) {
                  b = J(b, a)
                  a = J(c, a)
                  return 0 == b.lastIndexOf(a, 0)
                },
                2
              )
              L(
                'string',
                3,
                !1,
                !0,
                function (a, b) {
                  return b ? J(b, a) : B(a.a)
                },
                0,
                1
              )
              L(
                'string-length',
                1,
                !1,
                !0,
                function (a, b) {
                  return (b ? J(b, a) : B(a.a)).length
                },
                0,
                1
              )
              L(
                'substring',
                3,
                !1,
                !1,
                function (a, b, c, d) {
                  c = I(c, a)
                  if (isNaN(c) || Infinity == c || -Infinity == c) return ''
                  d = d ? I(d, a) : Infinity
                  if (isNaN(d) || -Infinity === d) return ''
                  c = Math.round(c) - 1
                  var e = Math.max(c, 0)
                  a = J(b, a)
                  return Infinity == d ? a.substring(e) : a.substring(e, c + Math.round(d))
                },
                2,
                3
              )
              L(
                'substring-after',
                3,
                !1,
                !1,
                function (a, b, c) {
                  b = J(b, a)
                  a = J(c, a)
                  c = b.indexOf(a)
                  return -1 == c ? '' : b.substring(c + a.length)
                },
                2
              )
              L(
                'substring-before',
                3,
                !1,
                !1,
                function (a, b, c) {
                  b = J(b, a)
                  a = J(c, a)
                  a = b.indexOf(a)
                  return -1 == a ? '' : b.substring(0, a)
                },
                2
              )
              L(
                'sum',
                1,
                !1,
                !1,
                function (a, b) {
                  a = Cb(b.a(a))
                  b = 0
                  for (var c = E(a); c; c = E(a)) b += +B(c)
                  return b
                },
                1,
                1,
                !0
              )
              L(
                'translate',
                3,
                !1,
                !1,
                function (a, b, c, d) {
                  b = J(b, a)
                  c = J(c, a)
                  var e = J(d, a)
                  a = {}
                  for (d = 0; d < c.length; d++) {
                    var f = c.charAt(d)
                    f in a || (a[f] = e.charAt(d))
                  }
                  c = ''
                  for (d = 0; d < b.length; d++) (f = b.charAt(d)), (c += f in a ? a[f] : f)
                  return c
                },
                3
              )
              L(
                'true',
                2,
                !1,
                !1,
                function () {
                  return !0
                },
                0
              )
              function D(a, b) {
                this.h = a
                this.c = void 0 !== b ? b : null
                this.b = null
                switch (a) {
                  case 'comment':
                    this.b = 8
                    break
                  case 'text':
                    this.b = 3
                    break
                  case 'processing-instruction':
                    this.b = 7
                    break
                  case 'node':
                    break
                  default:
                    throw Error('Unexpected argument')
                }
              }
              function Rb(a) {
                return 'comment' == a || 'text' == a || 'processing-instruction' == a || 'node' == a
              }
              D.prototype.a = function (a) {
                return null === this.b || this.b == a.nodeType
              }
              D.prototype.f = function () {
                return this.h
              }
              D.prototype.toString = function () {
                var a = 'Kind Test: ' + this.h
                null === this.c || (a += H(this.c))
                return a
              }
              function Sb(a) {
                F.call(this, 3)
                this.c = a.substring(1, a.length - 1)
              }
              k(Sb, F)
              Sb.prototype.a = function () {
                return this.c
              }
              Sb.prototype.toString = function () {
                return 'Literal: ' + this.c
              }
              function rb(a, b) {
                this.l = a.toLowerCase()
                a = '*' == this.l ? '*' : 'http://www.w3.org/1999/xhtml'
                this.c = b ? b.toLowerCase() : a
              }
              rb.prototype.a = function (a) {
                var b = a.nodeType
                if (1 != b && 2 != b) return !1
                b = void 0 !== a.localName ? a.localName : a.nodeName
                return '*' != this.l && this.l != b.toLowerCase()
                  ? !1
                  : '*' == this.c
                  ? !0
                  : this.c ==
                    (a.namespaceURI ? a.namespaceURI.toLowerCase() : 'http://www.w3.org/1999/xhtml')
              }
              rb.prototype.f = function () {
                return this.l
              }
              rb.prototype.toString = function () {
                return (
                  'Name Test: ' +
                  ('http://www.w3.org/1999/xhtml' == this.c ? '' : this.c + ':') +
                  this.l
                )
              }
              function Tb(a) {
                F.call(this, 1)
                this.c = a
              }
              k(Tb, F)
              Tb.prototype.a = function () {
                return this.c
              }
              Tb.prototype.toString = function () {
                return 'Number: ' + this.c
              }
              function Ub(a, b) {
                F.call(this, a.i)
                this.h = a
                this.c = b
                this.g = a.g
                this.b = a.b
                1 == this.c.length &&
                  ((a = this.c[0]),
                  a.G ||
                    a.c != Vb ||
                    ((a = a.v), '*' != a.f() && (this.f = { name: a.f(), B: null })))
              }
              k(Ub, F)
              function Wb() {
                F.call(this, 4)
              }
              k(Wb, F)
              Wb.prototype.a = function (a) {
                var b = new C()
                a = a.a
                9 == a.nodeType ? b.add(a) : b.add(a.ownerDocument)
                return b
              }
              Wb.prototype.toString = function () {
                return 'Root Helper Expression'
              }
              function Xb() {
                F.call(this, 4)
              }
              k(Xb, F)
              Xb.prototype.a = function (a) {
                var b = new C()
                b.add(a.a)
                return b
              }
              Xb.prototype.toString = function () {
                return 'Context Helper Expression'
              }
              function Yb(a) {
                return '/' == a || '//' == a
              }
              Ub.prototype.a = function (a) {
                var b = this.h.a(a)
                if (!(b instanceof C)) throw Error('Filter expression must evaluate to nodeset.')
                a = this.c
                for (var c = 0, d = a.length; c < d && b.m; c++) {
                  var e = a[c],
                    f = Cb(b, e.c.A)
                  if (e.g || e.c != Zb)
                    if (e.g || e.c != $b) {
                      var g = E(f)
                      for (b = e.a(new ma(g)); null != (g = E(f)); )
                        (g = e.a(new ma(g))), (b = xb(b, g))
                    } else (g = E(f)), (b = e.a(new ma(g)))
                  else {
                    for (
                      g = E(f);
                      (b = E(f)) &&
                      (!g.contains || g.contains(b)) &&
                      b.compareDocumentPosition(g) & 8;
                      g = b
                    );
                    b = e.a(new ma(g))
                  }
                }
                return b
              }
              Ub.prototype.toString = function () {
                var a = 'Path Expression:' + H(this.h)
                if (this.c.length) {
                  var b = ra(
                    this.c,
                    function (c, d) {
                      return c + H(d)
                    },
                    'Steps:'
                  )
                  a += H(b)
                }
                return a
              }
              function ac(a, b) {
                this.a = a
                this.A = !!b
              }
              function Nb(a, b, c) {
                for (c = c || 0; c < a.a.length; c++)
                  for (var d = a.a[c], e = Cb(b), f = b.m, g, h = 0; (g = E(e)); h++) {
                    var n = a.A ? f - h : h + 1
                    g = d.a(new ma(g, n, f))
                    if ('number' == typeof g) n = n == g
                    else if ('string' == typeof g || 'boolean' == typeof g) n = !!g
                    else if (g instanceof C) n = 0 < g.m
                    else throw Error('Predicate.evaluate returned an unexpected type.')
                    if (!n) {
                      n = e
                      g = n.f
                      var u = n.a
                      if (!u) throw Error('Next must be called at least once before remove.')
                      var p = u.b
                      u = u.a
                      p ? (p.a = u) : (g.a = u)
                      u ? (u.b = p) : (g.b = p)
                      g.m--
                      n.a = null
                    }
                  }
                return b
              }
              ac.prototype.toString = function () {
                return ra(
                  this.a,
                  function (a, b) {
                    return a + H(b)
                  },
                  'Predicates:'
                )
              }
              function bc(a, b, c, d) {
                F.call(this, 4)
                this.c = a
                this.v = b
                this.h = c || new ac([])
                this.G = !!d
                b = this.h
                b = 0 < b.a.length ? b.a[0].f : null
                a.ca &&
                  b &&
                  ((a = b.name), (a = x ? a.toLowerCase() : a), (this.f = { name: a, B: b.B }))
                a: {
                  a = this.h
                  for (b = 0; b < a.a.length; b++)
                    if (((c = a.a[b]), c.g || 1 == c.i || 0 == c.i)) {
                      a = !0
                      break a
                    }
                  a = !1
                }
                this.g = a
              }
              k(bc, F)
              bc.prototype.a = function (a) {
                var b = a.a,
                  c = this.f,
                  d = null,
                  e = null,
                  f = 0
                c && ((d = c.name), (e = c.B ? J(c.B, a) : null), (f = 1))
                if (this.G)
                  if (this.g || this.c != cc)
                    if (((b = Cb(new bc(dc, new D('node')).a(a))), (c = E(b))))
                      for (a = this.s(c, d, e, f); null != (c = E(b)); )
                        a = xb(a, this.s(c, d, e, f))
                    else a = new C()
                  else (a = ob(this.v, b, d, e)), (a = Nb(this.h, a, f))
                else a = this.s(a.a, d, e, f)
                return a
              }
              bc.prototype.s = function (a, b, c, d) {
                a = this.c.D(this.v, a, b, c)
                return (a = Nb(this.h, a, d))
              }
              bc.prototype.toString = function () {
                var a = 'Step:' + H('Operator: ' + (this.G ? '//' : '/'))
                this.c.l && (a += H('Axis: ' + this.c))
                a += H(this.v)
                if (this.h.a.length) {
                  var b = ra(
                    this.h.a,
                    function (c, d) {
                      return c + H(d)
                    },
                    'Predicates:'
                  )
                  a += H(b)
                }
                return a
              }
              function ec(a, b, c, d) {
                this.l = a
                this.D = b
                this.A = c
                this.ca = d
              }
              ec.prototype.toString = function () {
                return this.l
              }
              var fc = {}
              function M(a, b, c, d) {
                if (fc.hasOwnProperty(a)) throw Error('Axis already created: ' + a)
                b = new ec(a, b, c, !!d)
                return (fc[a] = b)
              }
              M(
                'ancestor',
                function (a, b) {
                  for (var c = new C(); (b = b.parentNode); ) a.a(b) && yb(c, b)
                  return c
                },
                !0
              )
              M(
                'ancestor-or-self',
                function (a, b) {
                  var c = new C()
                  do a.a(b) && yb(c, b)
                  while ((b = b.parentNode))
                  return c
                },
                !0
              )
              var Vb = M(
                  'attribute',
                  function (a, b) {
                    var c = new C(),
                      d = a.f()
                    if ('style' == d && x && b.style)
                      return c.add(new Wa(b.style, b, 'style', b.style.cssText)), c
                    var e = b.attributes
                    if (e)
                      if ((a instanceof D && null === a.b) || '*' == d)
                        for (a = 0; (d = e[a]); a++) x ? d.nodeValue && c.add(Xa(b, d)) : c.add(d)
                      else
                        (d = e.getNamedItem(d)) && (x ? d.nodeValue && c.add(Xa(b, d)) : c.add(d))
                    return c
                  },
                  !1
                ),
                cc = M(
                  'child',
                  function (a, b, c, d, e) {
                    return (x ? ub : vb).call(
                      null,
                      a,
                      b,
                      ba(c) ? c : null,
                      ba(d) ? d : null,
                      e || new C()
                    )
                  },
                  !1,
                  !0
                )
              M('descendant', ob, !1, !0)
              var dc = M(
                  'descendant-or-self',
                  function (a, b, c, d) {
                    var e = new C()
                    nb(b, c, d) && a.a(b) && e.add(b)
                    return ob(a, b, c, d, e)
                  },
                  !1,
                  !0
                ),
                Zb = M(
                  'following',
                  function (a, b, c, d) {
                    var e = new C()
                    do
                      for (var f = b; (f = f.nextSibling); )
                        nb(f, c, d) && a.a(f) && e.add(f), (e = ob(a, f, c, d, e))
                    while ((b = b.parentNode))
                    return e
                  },
                  !1,
                  !0
                )
              M(
                'following-sibling',
                function (a, b) {
                  for (var c = new C(); (b = b.nextSibling); ) a.a(b) && c.add(b)
                  return c
                },
                !1
              )
              M(
                'namespace',
                function () {
                  return new C()
                },
                !1
              )
              var gc = M(
                  'parent',
                  function (a, b) {
                    var c = new C()
                    if (9 == b.nodeType) return c
                    if (2 == b.nodeType) return c.add(b.ownerElement), c
                    b = b.parentNode
                    a.a(b) && c.add(b)
                    return c
                  },
                  !1
                ),
                $b = M(
                  'preceding',
                  function (a, b, c, d) {
                    var e = new C(),
                      f = []
                    do f.unshift(b)
                    while ((b = b.parentNode))
                    for (var g = 1, h = f.length; g < h; g++) {
                      var n = []
                      for (b = f[g]; (b = b.previousSibling); ) n.unshift(b)
                      for (var u = 0, p = n.length; u < p; u++)
                        (b = n[u]), nb(b, c, d) && a.a(b) && e.add(b), (e = ob(a, b, c, d, e))
                    }
                    return e
                  },
                  !0,
                  !0
                )
              M(
                'preceding-sibling',
                function (a, b) {
                  for (var c = new C(); (b = b.previousSibling); ) a.a(b) && yb(c, b)
                  return c
                },
                !0
              )
              var hc = M(
                'self',
                function (a, b) {
                  var c = new C()
                  a.a(b) && c.add(b)
                  return c
                },
                !1
              )
              function ic(a) {
                F.call(this, 1)
                this.c = a
                this.g = a.g
                this.b = a.b
              }
              k(ic, F)
              ic.prototype.a = function (a) {
                return -I(this.c, a)
              }
              ic.prototype.toString = function () {
                return 'Unary Expression: -' + H(this.c)
              }
              function jc(a) {
                F.call(this, 4)
                this.c = a
                Eb(
                  this,
                  sa(this.c, function (b) {
                    return b.g
                  })
                )
                Fb(
                  this,
                  sa(this.c, function (b) {
                    return b.b
                  })
                )
              }
              k(jc, F)
              jc.prototype.a = function (a) {
                var b = new C()
                l(this.c, function (c) {
                  c = c.a(a)
                  if (!(c instanceof C)) throw Error('Path expression must evaluate to NodeSet.')
                  b = xb(b, c)
                })
                return b
              }
              jc.prototype.toString = function () {
                return ra(
                  this.c,
                  function (a, b) {
                    return a + H(b)
                  },
                  'Union Expression:'
                )
              }
              function kc(a, b) {
                this.a = a
                this.b = b
              }
              function lc(a) {
                for (var b, c = []; ; ) {
                  N(a, 'Missing right hand side of binary expression.')
                  b = mc(a)
                  var d = z(a.a)
                  if (!d) break
                  var e = (d = Lb[d] || null) && d.M
                  if (!e) {
                    a.a.a--
                    break
                  }
                  for (; c.length && e <= c[c.length - 1].M; ) b = new Hb(c.pop(), c.pop(), b)
                  c.push(b, d)
                }
                for (; c.length; ) b = new Hb(c.pop(), c.pop(), b)
                return b
              }
              function N(a, b) {
                if (bb(a.a)) throw Error(b)
              }
              function nc(a, b) {
                a = z(a.a)
                if (a != b) throw Error('Bad token, expected: ' + b + ' got: ' + a)
              }
              function oc(a) {
                a = z(a.a)
                if (')' != a) throw Error('Bad token: ' + a)
              }
              function rc(a) {
                a = z(a.a)
                if (2 > a.length) throw Error('Unclosed literal string')
                return new Sb(a)
              }
              function sc(a) {
                var b = []
                if (Yb(y(a.a))) {
                  var c = z(a.a)
                  var d = y(a.a)
                  if (
                    '/' == c &&
                    (bb(a.a) ||
                      ('.' != d && '..' != d && '@' != d && '*' != d && !/(?![0-9])[\w]/.test(d)))
                  )
                    return new Wb()
                  d = new Wb()
                  N(a, 'Missing next location step.')
                  c = tc(a, c)
                  b.push(c)
                } else {
                  a: {
                    c = y(a.a)
                    d = c.charAt(0)
                    switch (d) {
                      case '$':
                        throw Error('Variable reference not allowed in HTML XPath')
                      case '(':
                        z(a.a)
                        c = lc(a)
                        N(a, 'unclosed "("')
                        nc(a, ')')
                        break
                      case '"':
                      case "'":
                        c = rc(a)
                        break
                      default:
                        if (isNaN(+c))
                          if (!Rb(c) && /(?![0-9])[\w]/.test(d) && '(' == y(a.a, 1)) {
                            c = z(a.a)
                            c = Qb[c] || null
                            z(a.a)
                            for (d = []; ')' != y(a.a); ) {
                              N(a, 'Missing function argument list.')
                              d.push(lc(a))
                              if (',' != y(a.a)) break
                              z(a.a)
                            }
                            N(a, 'Unclosed function argument list.')
                            oc(a)
                            c = new Ob(c, d)
                          } else {
                            c = null
                            break a
                          }
                        else c = new Tb(+z(a.a))
                    }
                    '[' == y(a.a) && ((d = new ac(uc(a))), (c = new Mb(c, d)))
                  }
                  if (c)
                    if (Yb(y(a.a))) d = c
                    else return c
                  else (c = tc(a, '/')), (d = new Xb()), b.push(c)
                }
                for (; Yb(y(a.a)); )
                  (c = z(a.a)), N(a, 'Missing next location step.'), (c = tc(a, c)), b.push(c)
                return new Ub(d, b)
              }
              function tc(a, b) {
                if ('/' != b && '//' != b) throw Error('Step op should be "/" or "//"')
                if ('.' == y(a.a)) {
                  var c = new bc(hc, new D('node'))
                  z(a.a)
                  return c
                }
                if ('..' == y(a.a)) return (c = new bc(gc, new D('node'))), z(a.a), c
                if ('@' == y(a.a)) {
                  var d = Vb
                  z(a.a)
                  N(a, 'Missing attribute name')
                } else if ('::' == y(a.a, 1)) {
                  if (!/(?![0-9])[\w]/.test(y(a.a).charAt(0))) throw Error('Bad token: ' + z(a.a))
                  var e = z(a.a)
                  d = fc[e] || null
                  if (!d) throw Error('No axis with name: ' + e)
                  z(a.a)
                  N(a, 'Missing node name')
                } else d = cc
                e = y(a.a)
                if (/(?![0-9])[\w\*]/.test(e.charAt(0)))
                  if ('(' == y(a.a, 1)) {
                    if (!Rb(e)) throw Error('Invalid node type: ' + e)
                    e = z(a.a)
                    if (!Rb(e)) throw Error('Invalid type name: ' + e)
                    nc(a, '(')
                    N(a, 'Bad nodetype')
                    var f = y(a.a).charAt(0),
                      g = null
                    if ('"' == f || "'" == f) g = rc(a)
                    N(a, 'Bad nodetype')
                    oc(a)
                    e = new D(e, g)
                  } else if (((e = z(a.a)), (f = e.indexOf(':')), -1 == f)) e = new rb(e)
                  else {
                    g = e.substring(0, f)
                    if ('*' == g) var h = '*'
                    else if (((h = a.b(g)), !h)) throw Error('Namespace prefix not declared: ' + g)
                    e = e.substr(f + 1)
                    e = new rb(e, h)
                  }
                else throw Error('Bad token: ' + z(a.a))
                a = new ac(uc(a), d.A)
                return c || new bc(d, e, a, '//' == b)
              }
              function uc(a) {
                for (var b = []; '[' == y(a.a); ) {
                  z(a.a)
                  N(a, 'Missing predicate expression.')
                  var c = lc(a)
                  b.push(c)
                  N(a, 'Unclosed predicate expression.')
                  nc(a, ']')
                }
                return b
              }
              function mc(a) {
                if ('-' == y(a.a)) return z(a.a), new ic(mc(a))
                var b = sc(a)
                if ('|' != y(a.a)) a = b
                else {
                  for (b = [b]; '|' == z(a.a); )
                    N(a, 'Missing next union location path.'), b.push(sc(a))
                  a.a.a--
                  a = new jc(b)
                }
                return a
              }
              function vc(a) {
                switch (a.nodeType) {
                  case 1:
                    return la(wc, a)
                  case 9:
                    return vc(a.documentElement)
                  case 11:
                  case 10:
                  case 6:
                  case 12:
                    return xc
                  default:
                    return a.parentNode ? vc(a.parentNode) : xc
                }
              }
              function xc() {
                return null
              }
              function wc(a, b) {
                if (a.prefix == b) return a.namespaceURI || 'http://www.w3.org/1999/xhtml'
                var c = a.getAttributeNode('xmlns:' + b)
                return c && c.specified
                  ? c.value || null
                  : a.parentNode && 9 != a.parentNode.nodeType
                  ? wc(a.parentNode, b)
                  : null
              }
              function yc(a, b) {
                if (!a.length) throw Error('Empty XPath expression.')
                a = Za(a)
                if (bb(a)) throw Error('Invalid XPath expression.')
                b
                  ? ea(b) || (b = ka(b.lookupNamespaceURI, b))
                  : (b = function () {
                      return null
                    })
                var c = lc(new kc(a, b))
                if (!bb(a)) throw Error('Bad token: ' + z(a))
                this.evaluate = function (d, e) {
                  d = c.a(new ma(d))
                  return new O(d, e)
                }
              }
              function O(a, b) {
                if (0 == b)
                  if (a instanceof C) b = 4
                  else if ('string' == typeof a) b = 2
                  else if ('number' == typeof a) b = 1
                  else if ('boolean' == typeof a) b = 3
                  else throw Error('Unexpected evaluation result.')
                if (2 != b && 1 != b && 3 != b && !(a instanceof C))
                  throw Error('value could not be converted to the specified type')
                this.resultType = b
                switch (b) {
                  case 2:
                    this.stringValue = a instanceof C ? Bb(a) : '' + a
                    break
                  case 1:
                    this.numberValue = a instanceof C ? +Bb(a) : +a
                    break
                  case 3:
                    this.booleanValue = a instanceof C ? 0 < a.m : !!a
                    break
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    var c = Cb(a)
                    var d = []
                    for (var e = E(c); e; e = E(c)) d.push(e instanceof Wa ? e.a : e)
                    this.snapshotLength = a.m
                    this.invalidIteratorState = !1
                    break
                  case 8:
                  case 9:
                    a = zb(a)
                    this.singleNodeValue = a instanceof Wa ? a.a : a
                    break
                  default:
                    throw Error('Unknown XPathResult type.')
                }
                var f = 0
                this.iterateNext = function () {
                  if (4 != b && 5 != b) throw Error('iterateNext called with wrong result type')
                  return f >= d.length ? null : d[f++]
                }
                this.snapshotItem = function (g) {
                  if (6 != b && 7 != b) throw Error('snapshotItem called with wrong result type')
                  return g >= d.length || 0 > g ? null : d[g]
                }
              }
              O.ANY_TYPE = 0
              O.NUMBER_TYPE = 1
              O.STRING_TYPE = 2
              O.BOOLEAN_TYPE = 3
              O.UNORDERED_NODE_ITERATOR_TYPE = 4
              O.ORDERED_NODE_ITERATOR_TYPE = 5
              O.UNORDERED_NODE_SNAPSHOT_TYPE = 6
              O.ORDERED_NODE_SNAPSHOT_TYPE = 7
              O.ANY_UNORDERED_NODE_TYPE = 8
              O.FIRST_ORDERED_NODE_TYPE = 9
              function zc(a) {
                this.lookupNamespaceURI = vc(a)
              }
              function Ac(a, b) {
                a = a || aa
                var c = (a.Document && a.Document.prototype) || a.document
                if (!c.evaluate || b)
                  (a.XPathResult = O),
                    (c.evaluate = function (d, e, f, g) {
                      return new yc(d, f).evaluate(e, g)
                    }),
                    (c.createExpression = function (d, e) {
                      return new yc(d, e)
                    }),
                    (c.createNSResolver = function (d) {
                      return new zc(d)
                    })
              }
              ca('wgxpath.install', Ac)
              ca('wgxpath.install', Ac)
              var Bc = window
              function P(a, b) {
                this.code = a
                this.a = Q[a] || Cc
                this.message = b || ''
                a = this.a.replace(/((?:^|\s+)[a-z])/g, function (c) {
                  return c.toUpperCase().replace(/^[\s\xa0]+/g, '')
                })
                b = a.length - 5
                if (0 > b || a.indexOf('Error', b) != b) a += 'Error'
                this.name = a
                a = Error(this.message)
                a.name = this.name
                this.stack = a.stack || ''
              }
              k(P, Error)
              var Cc = 'unknown error',
                Q = { 15: 'element not selectable', 11: 'element not visible' }
              Q[31] = Cc
              Q[30] = Cc
              Q[24] = 'invalid cookie domain'
              Q[29] = 'invalid element coordinates'
              Q[12] = 'invalid element state'
              Q[32] = 'invalid selector'
              Q[51] = 'invalid selector'
              Q[52] = 'invalid selector'
              Q[17] = 'javascript error'
              Q[405] = 'unsupported operation'
              Q[34] = 'move target out of bounds'
              Q[27] = 'no such alert'
              Q[7] = 'no such element'
              Q[8] = 'no such frame'
              Q[23] = 'no such window'
              Q[28] = 'script timeout'
              Q[33] = 'session not created'
              Q[10] = 'stale element reference'
              Q[21] = 'timeout'
              Q[25] = 'unable to set cookie'
              Q[26] = 'unexpected alert open'
              Q[13] = Cc
              Q[9] = 'unknown command'
              var Dc = {
                C: function (a) {
                  return !(!a.querySelectorAll || !a.querySelector)
                },
                o: function (a, b) {
                  if (!a) throw new P(32, 'No class name specified')
                  a = Aa(a)
                  if (-1 !== a.indexOf(' ')) throw new P(32, 'Compound class names not permitted')
                  if (Dc.C(b))
                    try {
                      return b.querySelector('.' + a.replace(/\./g, '\\.')) || null
                    } catch (c) {
                      throw new P(32, 'An invalid or illegal class name was specified')
                    }
                  a = mb(eb(b), '*', a, b)
                  return a.length ? a[0] : null
                },
                j: function (a, b) {
                  if (!a) throw new P(32, 'No class name specified')
                  a = Aa(a)
                  if (-1 !== a.indexOf(' ')) throw new P(32, 'Compound class names not permitted')
                  if (Dc.C(b))
                    try {
                      return b.querySelectorAll('.' + a.replace(/\./g, '\\.'))
                    } catch (c) {
                      throw new P(32, 'An invalid or illegal class name was specified')
                    }
                  return mb(eb(b), '*', a, b)
                }
              }
              var Ec = Fa(),
                Fc = Ia() || r('iPod'),
                Gc = r('iPad'),
                Hc = r('Android') && !(Ga() || Fa() || r('Opera') || r('Silk')),
                Ic = Ga(),
                Jc =
                  r('Safari') &&
                  !(
                    Ga() ||
                    r('Coast') ||
                    r('Opera') ||
                    r('Edge') ||
                    r('Edg/') ||
                    r('OPR') ||
                    Fa() ||
                    r('Silk') ||
                    r('Android')
                  ) &&
                  !(Ia() || r('iPad') || r('iPod'))
              function Kc(a) {
                return (a = a.exec(q)) ? a[1] : ''
              }
              ;(function () {
                if (Ec) return Kc(/Firefox\/([0-9.]+)/)
                if (t || Ma || La) return Qa
                if (Ic)
                  return Ia() || r('iPad') || r('iPod')
                    ? Kc(/CriOS\/([0-9.]+)/)
                    : Kc(/Chrome\/([0-9.]+)/)
                if (Jc && !(Ia() || r('iPad') || r('iPod'))) return Kc(/Version\/([0-9.]+)/)
                if (Fc || Gc) {
                  var a = /Version\/(\S+).*Mobile\/(\S+)/.exec(q)
                  if (a) return a[1] + '.' + a[2]
                } else if (Hc) return (a = Kc(/Android\s+([0-9.]+)/)) ? a : Kc(/Version\/([0-9.]+)/)
                return ''
              })()
              var Lc = t && !(8 <= Number(w)),
                Mc = t && !(9 <= Number(w))
              var Nc = {
                o: function (a, b) {
                  if (
                    !ea(b.querySelector) &&
                    t &&
                    (t ? 0 <= Ba(w, 8) : Ua(8)) &&
                    !ha(b.querySelector)
                  )
                    throw Error('CSS selection is not supported')
                  if (!a) throw new P(32, 'No selector specified')
                  a = Aa(a)
                  try {
                    var c = b.querySelector(a)
                  } catch (d) {
                    throw new P(32, 'An invalid or illegal selector was specified')
                  }
                  return c && 1 == c.nodeType ? c : null
                },
                j: function (a, b) {
                  if (
                    !ea(b.querySelectorAll) &&
                    t &&
                    (t ? 0 <= Ba(w, 8) : Ua(8)) &&
                    !ha(b.querySelector)
                  )
                    throw Error('CSS selection is not supported')
                  if (!a) throw new P(32, 'No selector specified')
                  a = Aa(a)
                  try {
                    return b.querySelectorAll(a)
                  } catch (c) {
                    throw new P(32, 'An invalid or illegal selector was specified')
                  }
                }
              }
              var Oc = {
                aliceblue: '#f0f8ff',
                antiquewhite: '#faebd7',
                aqua: '#00ffff',
                aquamarine: '#7fffd4',
                azure: '#f0ffff',
                beige: '#f5f5dc',
                bisque: '#ffe4c4',
                black: '#000000',
                blanchedalmond: '#ffebcd',
                blue: '#0000ff',
                blueviolet: '#8a2be2',
                brown: '#a52a2a',
                burlywood: '#deb887',
                cadetblue: '#5f9ea0',
                chartreuse: '#7fff00',
                chocolate: '#d2691e',
                coral: '#ff7f50',
                cornflowerblue: '#6495ed',
                cornsilk: '#fff8dc',
                crimson: '#dc143c',
                cyan: '#00ffff',
                darkblue: '#00008b',
                darkcyan: '#008b8b',
                darkgoldenrod: '#b8860b',
                darkgray: '#a9a9a9',
                darkgreen: '#006400',
                darkgrey: '#a9a9a9',
                darkkhaki: '#bdb76b',
                darkmagenta: '#8b008b',
                darkolivegreen: '#556b2f',
                darkorange: '#ff8c00',
                darkorchid: '#9932cc',
                darkred: '#8b0000',
                darksalmon: '#e9967a',
                darkseagreen: '#8fbc8f',
                darkslateblue: '#483d8b',
                darkslategray: '#2f4f4f',
                darkslategrey: '#2f4f4f',
                darkturquoise: '#00ced1',
                darkviolet: '#9400d3',
                deeppink: '#ff1493',
                deepskyblue: '#00bfff',
                dimgray: '#696969',
                dimgrey: '#696969',
                dodgerblue: '#1e90ff',
                firebrick: '#b22222',
                floralwhite: '#fffaf0',
                forestgreen: '#228b22',
                fuchsia: '#ff00ff',
                gainsboro: '#dcdcdc',
                ghostwhite: '#f8f8ff',
                gold: '#ffd700',
                goldenrod: '#daa520',
                gray: '#808080',
                green: '#008000',
                greenyellow: '#adff2f',
                grey: '#808080',
                honeydew: '#f0fff0',
                hotpink: '#ff69b4',
                indianred: '#cd5c5c',
                indigo: '#4b0082',
                ivory: '#fffff0',
                khaki: '#f0e68c',
                lavender: '#e6e6fa',
                lavenderblush: '#fff0f5',
                lawngreen: '#7cfc00',
                lemonchiffon: '#fffacd',
                lightblue: '#add8e6',
                lightcoral: '#f08080',
                lightcyan: '#e0ffff',
                lightgoldenrodyellow: '#fafad2',
                lightgray: '#d3d3d3',
                lightgreen: '#90ee90',
                lightgrey: '#d3d3d3',
                lightpink: '#ffb6c1',
                lightsalmon: '#ffa07a',
                lightseagreen: '#20b2aa',
                lightskyblue: '#87cefa',
                lightslategray: '#778899',
                lightslategrey: '#778899',
                lightsteelblue: '#b0c4de',
                lightyellow: '#ffffe0',
                lime: '#00ff00',
                limegreen: '#32cd32',
                linen: '#faf0e6',
                magenta: '#ff00ff',
                maroon: '#800000',
                mediumaquamarine: '#66cdaa',
                mediumblue: '#0000cd',
                mediumorchid: '#ba55d3',
                mediumpurple: '#9370db',
                mediumseagreen: '#3cb371',
                mediumslateblue: '#7b68ee',
                mediumspringgreen: '#00fa9a',
                mediumturquoise: '#48d1cc',
                mediumvioletred: '#c71585',
                midnightblue: '#191970',
                mintcream: '#f5fffa',
                mistyrose: '#ffe4e1',
                moccasin: '#ffe4b5',
                navajowhite: '#ffdead',
                navy: '#000080',
                oldlace: '#fdf5e6',
                olive: '#808000',
                olivedrab: '#6b8e23',
                orange: '#ffa500',
                orangered: '#ff4500',
                orchid: '#da70d6',
                palegoldenrod: '#eee8aa',
                palegreen: '#98fb98',
                paleturquoise: '#afeeee',
                palevioletred: '#db7093',
                papayawhip: '#ffefd5',
                peachpuff: '#ffdab9',
                peru: '#cd853f',
                pink: '#ffc0cb',
                plum: '#dda0dd',
                powderblue: '#b0e0e6',
                purple: '#800080',
                red: '#ff0000',
                rosybrown: '#bc8f8f',
                royalblue: '#4169e1',
                saddlebrown: '#8b4513',
                salmon: '#fa8072',
                sandybrown: '#f4a460',
                seagreen: '#2e8b57',
                seashell: '#fff5ee',
                sienna: '#a0522d',
                silver: '#c0c0c0',
                skyblue: '#87ceeb',
                slateblue: '#6a5acd',
                slategray: '#708090',
                slategrey: '#708090',
                snow: '#fffafa',
                springgreen: '#00ff7f',
                steelblue: '#4682b4',
                tan: '#d2b48c',
                teal: '#008080',
                thistle: '#d8bfd8',
                tomato: '#ff6347',
                turquoise: '#40e0d0',
                violet: '#ee82ee',
                wheat: '#f5deb3',
                white: '#ffffff',
                whitesmoke: '#f5f5f5',
                yellow: '#ffff00',
                yellowgreen: '#9acd32'
              }
              var Pc =
                  'backgroundColor borderTopColor borderRightColor borderBottomColor borderLeftColor color outlineColor'.split(
                    ' '
                  ),
                Qc = /#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])/,
                Rc = /^#(?:[0-9a-f]{3}){1,2}$/i,
                Sc = /^(?:rgba)?\((\d{1,3}),\s?(\d{1,3}),\s?(\d{1,3}),\s?(0|1|0\.\d*)\)$/i,
                Tc = /^(?:rgb)?\((0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2})\)$/i
              function Uc(a, b) {
                b = b.toLowerCase()
                return 'style' == b
                  ? Vc(a.style.cssText)
                  : Lc && 'value' == b && S(a, 'INPUT')
                  ? a.value
                  : Mc && !0 === a[b]
                  ? String(a.getAttribute(b))
                  : (a = a.getAttributeNode(b)) && a.specified
                  ? a.value
                  : null
              }
              var Wc =
                /[;]+(?=(?:(?:[^"]*"){2})*[^"]*$)(?=(?:(?:[^']*'){2})*[^']*$)(?=(?:[^()]*\([^()]*\))*[^()]*$)/
              function Vc(a) {
                var b = []
                l(a.split(Wc), function (c) {
                  var d = c.indexOf(':')
                  0 < d &&
                    ((c = [c.slice(0, d), c.slice(d + 1)]),
                    2 == c.length && b.push(c[0].toLowerCase(), ':', c[1], ';'))
                })
                b = b.join('')
                return (b = ';' == b.charAt(b.length - 1) ? b : b + ';')
              }
              function S(a, b) {
                b && 'string' !== typeof b && (b = b.toString())
                return !!a && 1 == a.nodeType && (!b || a.tagName.toUpperCase() == b)
              }
              var T = {}
              T.I = (function () {
                var a = { da: 'http://www.w3.org/2000/svg' }
                return function (b) {
                  return a[b] || null
                }
              })()
              T.s = function (a, b, c) {
                var d = A(a)
                if (!d.documentElement) return null
                ;(t || Hc) && Ac(d ? d.parentWindow || d.defaultView : window)
                try {
                  var e = d.createNSResolver ? d.createNSResolver(d.documentElement) : T.I
                  if (t && !Ua(7)) return d.evaluate.call(d, b, a, e, c, null)
                  if (!t || 9 <= Number(w)) {
                    for (var f = {}, g = d.getElementsByTagName('*'), h = 0; h < g.length; ++h) {
                      var n = g[h],
                        u = n.namespaceURI
                      if (u && !f[u]) {
                        var p = n.lookupPrefix(u)
                        if (!p) {
                          var G = u.match('.*/(\\w+)/?$')
                          p = G ? G[1] : 'xhtml'
                        }
                        f[u] = p
                      }
                    }
                    var R = {},
                      fa
                    for (fa in f) R[f[fa]] = fa
                    e = function (m) {
                      return R[m] || null
                    }
                  }
                  try {
                    return d.evaluate(b, a, e, c, null)
                  } catch (m) {
                    if ('TypeError' === m.name)
                      return (
                        (e = d.createNSResolver ? d.createNSResolver(d.documentElement) : T.I),
                        d.evaluate(b, a, e, c, null)
                      )
                    throw m
                  }
                } catch (m) {
                  if (!Na || 'NS_ERROR_ILLEGAL_VALUE' != m.name)
                    throw new P(
                      32,
                      'Unable to locate an element with the xpath expression ' +
                        b +
                        ' because of the following error:\n' +
                        m
                    )
                }
              }
              T.J = function (a, b) {
                if (!a || 1 != a.nodeType)
                  throw new P(
                    32,
                    'The result of the xpath expression "' +
                      b +
                      '" is: ' +
                      a +
                      '. It should be an element.'
                  )
              }
              T.o = function (a, b) {
                var c = (function () {
                  var d = T.s(b, a, 9)
                  return d
                    ? d.singleNodeValue || null
                    : b.selectSingleNode
                    ? ((d = A(b)),
                      d.setProperty && d.setProperty('SelectionLanguage', 'XPath'),
                      b.selectSingleNode(a))
                    : null
                })()
                null === c || T.J(c, a)
                return c
              }
              T.j = function (a, b) {
                var c = (function () {
                  var d = T.s(b, a, 7)
                  if (d) {
                    for (var e = d.snapshotLength, f = [], g = 0; g < e; ++g)
                      f.push(d.snapshotItem(g))
                    return f
                  }
                  return b.selectNodes
                    ? ((d = A(b)),
                      d.setProperty && d.setProperty('SelectionLanguage', 'XPath'),
                      b.selectNodes(a))
                    : []
                })()
                l(c, function (d) {
                  T.J(d, a)
                })
                return c
              }
              function Xc(a, b, c, d) {
                this.c = a
                this.a = b
                this.b = c
                this.f = d
              }
              Xc.prototype.ceil = function () {
                this.c = Math.ceil(this.c)
                this.a = Math.ceil(this.a)
                this.b = Math.ceil(this.b)
                this.f = Math.ceil(this.f)
                return this
              }
              Xc.prototype.floor = function () {
                this.c = Math.floor(this.c)
                this.a = Math.floor(this.a)
                this.b = Math.floor(this.b)
                this.f = Math.floor(this.f)
                return this
              }
              Xc.prototype.round = function () {
                this.c = Math.round(this.c)
                this.a = Math.round(this.a)
                this.b = Math.round(this.b)
                this.f = Math.round(this.f)
                return this
              }
              function U(a, b, c, d) {
                this.a = a
                this.b = b
                this.width = c
                this.height = d
              }
              U.prototype.ceil = function () {
                this.a = Math.ceil(this.a)
                this.b = Math.ceil(this.b)
                this.width = Math.ceil(this.width)
                this.height = Math.ceil(this.height)
                return this
              }
              U.prototype.floor = function () {
                this.a = Math.floor(this.a)
                this.b = Math.floor(this.b)
                this.width = Math.floor(this.width)
                this.height = Math.floor(this.height)
                return this
              }
              U.prototype.round = function () {
                this.a = Math.round(this.a)
                this.b = Math.round(this.b)
                this.width = Math.round(this.width)
                this.height = Math.round(this.height)
                return this
              }
              var Yc = 'function' === typeof ShadowRoot
              function Zc(a) {
                for (
                  a = a.parentNode;
                  a && 1 != a.nodeType && 9 != a.nodeType && 11 != a.nodeType;

                )
                  a = a.parentNode
                return S(a) ? a : null
              }
              function V(a, b) {
                b = Ha(b)
                if ('float' == b || 'cssFloat' == b || 'styleFloat' == b)
                  b = Mc ? 'styleFloat' : 'cssFloat'
                a: {
                  var c = b
                  var d = A(a)
                  if (
                    d.defaultView &&
                    d.defaultView.getComputedStyle &&
                    (d = d.defaultView.getComputedStyle(a, null))
                  ) {
                    c = d[c] || d.getPropertyValue(c) || ''
                    break a
                  }
                  c = ''
                }
                a = c || $c(a, b)
                if (null === a) a = null
                else if (0 <= oa(Pc, b)) {
                  b: {
                    var e = a.match(Sc)
                    if (
                      e &&
                      ((b = Number(e[1])),
                      (c = Number(e[2])),
                      (d = Number(e[3])),
                      (e = Number(e[4])),
                      0 <= b &&
                        255 >= b &&
                        0 <= c &&
                        255 >= c &&
                        0 <= d &&
                        255 >= d &&
                        0 <= e &&
                        1 >= e)
                    ) {
                      b = [b, c, d, e]
                      break b
                    }
                    b = null
                  }
                  if (!b)
                    b: {
                      if ((d = a.match(Tc)))
                        if (
                          ((b = Number(d[1])),
                          (c = Number(d[2])),
                          (d = Number(d[3])),
                          0 <= b && 255 >= b && 0 <= c && 255 >= c && 0 <= d && 255 >= d)
                        ) {
                          b = [b, c, d, 1]
                          break b
                        }
                      b = null
                    }
                  if (!b)
                    b: {
                      b = a.toLowerCase()
                      c = Oc[b.toLowerCase()]
                      if (
                        !c &&
                        ((c = '#' == b.charAt(0) ? b : '#' + b),
                        4 == c.length && (c = c.replace(Qc, '#$1$1$2$2$3$3')),
                        !Rc.test(c))
                      ) {
                        b = null
                        break b
                      }
                      b = [
                        parseInt(c.substr(1, 2), 16),
                        parseInt(c.substr(3, 2), 16),
                        parseInt(c.substr(5, 2), 16),
                        1
                      ]
                    }
                  a = b ? 'rgba(' + b.join(', ') + ')' : a
                }
                return a
              }
              function $c(a, b) {
                var c = a.currentStyle || a.style,
                  d = c[b]
                void 0 === d && ea(c.getPropertyValue) && (d = c.getPropertyValue(b))
                return 'inherit' != d ? (void 0 !== d ? d : null) : (a = Zc(a)) ? $c(a, b) : null
              }
              function ad(a, b, c) {
                function d(g) {
                  var h = W(g)
                  return 0 < h.height && 0 < h.width
                    ? !0
                    : S(g, 'PATH') && (0 < h.height || 0 < h.width)
                    ? ((g = V(g, 'stroke-width')), !!g && 0 < parseInt(g, 10))
                    : 'hidden' != V(g, 'overflow') &&
                      sa(g.childNodes, function (n) {
                        return 3 == n.nodeType || (S(n) && d(n))
                      })
                }
                function e(g) {
                  return (
                    bd(g) == X &&
                    ta(g.childNodes, function (h) {
                      return !S(h) || e(h) || !d(h)
                    })
                  )
                }
                if (!S(a)) throw Error('Argument to isShown must be of type Element')
                if (S(a, 'BODY')) return !0
                if (S(a, 'OPTION') || S(a, 'OPTGROUP'))
                  return (
                    (a = lb(a, function (g) {
                      return S(g, 'SELECT')
                    })),
                    !!a && ad(a, !0, c)
                  )
                var f = cd(a)
                if (f)
                  return !!f.image && 0 < f.rect.width && 0 < f.rect.height && ad(f.image, b, c)
                if ((S(a, 'INPUT') && 'hidden' == a.type.toLowerCase()) || S(a, 'NOSCRIPT'))
                  return !1
                f = V(a, 'visibility')
                return 'collapse' != f && 'hidden' != f && c(a) && (b || 0 != dd(a)) && d(a)
                  ? !e(a)
                  : !1
              }
              function ed(a) {
                function b(c) {
                  if (S(c) && 'none' == V(c, 'display')) return !1
                  var d
                  if ((d = c.parentNode) && d.shadowRoot && void 0 !== c.assignedSlot)
                    d = c.assignedSlot ? c.assignedSlot.parentNode : null
                  else if (c.getDestinationInsertionPoints) {
                    var e = c.getDestinationInsertionPoints()
                    0 < e.length && (d = e[e.length - 1])
                  }
                  if (Yc && d instanceof ShadowRoot) {
                    if (d.host.shadowRoot !== d) return !1
                    d = d.host
                  }
                  return !d || (9 != d.nodeType && 11 != d.nodeType)
                    ? d && S(d, 'DETAILS') && !d.open && !S(c, 'SUMMARY')
                      ? !1
                      : !!d && b(d)
                    : !0
                }
                return ad(a, !1, b)
              }
              var X = 'hidden'
              function bd(a) {
                function b(m) {
                  function v(Ab) {
                    if (Ab == g) return !0
                    var pc = V(Ab, 'display')
                    return 0 == pc.lastIndexOf('inline', 0) ||
                      'contents' == pc ||
                      ('absolute' == qc && 'static' == V(Ab, 'position'))
                      ? !1
                      : !0
                  }
                  var qc = V(m, 'position')
                  if ('fixed' == qc) return (u = !0), m == g ? null : g
                  for (m = Zc(m); m && !v(m); ) m = Zc(m)
                  return m
                }
                function c(m) {
                  var v = m
                  if ('visible' == n)
                    if (m == g && h) v = h
                    else if (m == h) return { x: 'visible', y: 'visible' }
                  v = { x: V(v, 'overflow-x'), y: V(v, 'overflow-y') }
                  m == g &&
                    ((v.x = 'visible' == v.x ? 'auto' : v.x),
                    (v.y = 'visible' == v.y ? 'auto' : v.y))
                  return v
                }
                function d(m) {
                  if (m == g) {
                    var v = new fb(f).a
                    m = v.scrollingElement
                      ? v.scrollingElement
                      : Oa || 'CSS1Compat' != v.compatMode
                      ? v.body || v.documentElement
                      : v.documentElement
                    v = v.parentWindow || v.defaultView
                    m =
                      t && Ua('10') && v.pageYOffset != m.scrollTop
                        ? new cb(m.scrollLeft, m.scrollTop)
                        : new cb(v.pageXOffset || m.scrollLeft, v.pageYOffset || m.scrollTop)
                  } else m = new cb(m.scrollLeft, m.scrollTop)
                  return m
                }
                var e = fd(a),
                  f = A(a),
                  g = f.documentElement,
                  h = f.body,
                  n = V(g, 'overflow'),
                  u
                for (a = b(a); a; a = b(a)) {
                  var p = c(a)
                  if ('visible' != p.x || 'visible' != p.y) {
                    var G = W(a)
                    if (0 == G.width || 0 == G.height) return X
                    var R = e.a < G.a,
                      fa = e.b < G.b
                    if ((R && 'hidden' == p.x) || (fa && 'hidden' == p.y)) return X
                    if ((R && 'visible' != p.x) || (fa && 'visible' != p.y)) {
                      R = d(a)
                      fa = e.b < G.b - R.y
                      if ((e.a < G.a - R.x && 'visible' != p.x) || (fa && 'visible' != p.x))
                        return X
                      e = bd(a)
                      return e == X ? X : 'scroll'
                    }
                    R = e.f >= G.a + G.width
                    G = e.c >= G.b + G.height
                    if ((R && 'hidden' == p.x) || (G && 'hidden' == p.y)) return X
                    if ((R && 'visible' != p.x) || (G && 'visible' != p.y)) {
                      if (
                        u &&
                        ((p = d(a)), e.f >= g.scrollWidth - p.x || e.a >= g.scrollHeight - p.y)
                      )
                        return X
                      e = bd(a)
                      return e == X ? X : 'scroll'
                    }
                  }
                }
                return 'none'
              }
              function W(a) {
                var b = cd(a)
                if (b) return b.rect
                if (S(a, 'HTML'))
                  return (
                    (a = A(a)),
                    (a = ((a ? a.parentWindow || a.defaultView : window) || window).document),
                    (a = 'CSS1Compat' == a.compatMode ? a.documentElement : a.body),
                    (a = new db(a.clientWidth, a.clientHeight)),
                    new U(0, 0, a.width, a.height)
                  )
                try {
                  var c = a.getBoundingClientRect()
                } catch (d) {
                  return new U(0, 0, 0, 0)
                }
                b = new U(c.left, c.top, c.right - c.left, c.bottom - c.top)
                t &&
                  a.ownerDocument.body &&
                  ((a = A(a)),
                  (b.a -= a.documentElement.clientLeft + a.body.clientLeft),
                  (b.b -= a.documentElement.clientTop + a.body.clientTop))
                return b
              }
              function cd(a) {
                var b = S(a, 'MAP')
                if (!b && !S(a, 'AREA')) return null
                var c = b ? a : S(a.parentNode, 'MAP') ? a.parentNode : null,
                  d = null,
                  e = null
                c &&
                  c.name &&
                  (d = T.o('/descendant::*[@usemap = "#' + c.name + '"]', A(c))) &&
                  ((e = W(d)),
                  b ||
                    'default' == a.shape.toLowerCase() ||
                    ((a = gd(a)),
                    (b = Math.min(Math.max(a.a, 0), e.width)),
                    (c = Math.min(Math.max(a.b, 0), e.height)),
                    (e = new U(
                      b + e.a,
                      c + e.b,
                      Math.min(a.width, e.width - b),
                      Math.min(a.height, e.height - c)
                    ))))
                return { image: d, rect: e || new U(0, 0, 0, 0) }
              }
              function gd(a) {
                var b = a.shape.toLowerCase()
                a = a.coords.split(',')
                if ('rect' == b && 4 == a.length) {
                  b = a[0]
                  var c = a[1]
                  return new U(b, c, a[2] - b, a[3] - c)
                }
                if ('circle' == b && 3 == a.length)
                  return (b = a[2]), new U(a[0] - b, a[1] - b, 2 * b, 2 * b)
                if ('poly' == b && 2 < a.length) {
                  b = a[0]
                  c = a[1]
                  for (var d = b, e = c, f = 2; f + 1 < a.length; f += 2)
                    (b = Math.min(b, a[f])),
                      (d = Math.max(d, a[f])),
                      (c = Math.min(c, a[f + 1])),
                      (e = Math.max(e, a[f + 1]))
                  return new U(b, c, d - b, e - c)
                }
                return new U(0, 0, 0, 0)
              }
              function fd(a) {
                a = W(a)
                return new Xc(a.b, a.a + a.width, a.b + a.height, a.a)
              }
              function hd(a) {
                return a.replace(/^[^\S\xa0]+|[^\S\xa0]+$/g, '')
              }
              function id(a) {
                var b = []
                Yc ? jd(a, b) : kd(a, b)
                a = qa(b, hd)
                return hd(a.join('\n')).replace(/\xa0/g, ' ')
              }
              function ld(a, b, c) {
                if (S(a, 'BR')) b.push('')
                else {
                  var d = S(a, 'TD'),
                    e = V(a, 'display'),
                    f = !d && !(0 <= oa(md, e)),
                    g =
                      void 0 !== a.previousElementSibling
                        ? a.previousElementSibling
                        : gb(a.previousSibling)
                  g = g ? V(g, 'display') : ''
                  var h = V(a, 'float') || V(a, 'cssFloat') || V(a, 'styleFloat')
                  !f ||
                    ('run-in' == g && 'none' == h) ||
                    /^[\s\xa0]*$/.test(b[b.length - 1] || '') ||
                    b.push('')
                  var n = ed(a),
                    u = null,
                    p = null
                  n && ((u = V(a, 'white-space')), (p = V(a, 'text-transform')))
                  l(a.childNodes, function (G) {
                    c(G, b, n, u, p)
                  })
                  a = b[b.length - 1] || ''
                  ;(!d && 'table-cell' != e) || !a || za(a) || (b[b.length - 1] += ' ')
                  f && 'run-in' != e && !/^[\s\xa0]*$/.test(a) && b.push('')
                }
              }
              function kd(a, b) {
                ld(a, b, function (c, d, e, f, g) {
                  3 == c.nodeType && e ? nd(c, d, f, g) : S(c) && kd(c, d)
                })
              }
              var md =
                'inline inline-block inline-table none table-cell table-column table-column-group'.split(
                  ' '
                )
              function nd(a, b, c, d) {
                a = a.nodeValue.replace(/[\u200b\u200e\u200f]/g, '')
                a = a.replace(/(\r\n|\r|\n)/g, '\n')
                if ('normal' == c || 'nowrap' == c) a = a.replace(/\n/g, ' ')
                a =
                  'pre' == c || 'pre-wrap' == c
                    ? a.replace(/[ \f\t\v\u2028\u2029]/g, '\u00a0')
                    : a.replace(/[ \f\t\v\u2028\u2029]+/g, ' ')
                'capitalize' == d
                  ? (a = a.replace(
                      t ? /(^|\s|\b)(\S)/g : /(^|[^\d\p{L}\p{S}])([\p{Ll}|\p{S}])/gu,
                      function (e, f, g) {
                        return f + g.toUpperCase()
                      }
                    ))
                  : 'uppercase' == d
                  ? (a = a.toUpperCase())
                  : 'lowercase' == d && (a = a.toLowerCase())
                c = b.pop() || ''
                za(c) && 0 == a.lastIndexOf(' ', 0) && (a = a.substr(1))
                b.push(c + a)
              }
              function dd(a) {
                if (Mc) {
                  if ('relative' == V(a, 'position')) return 1
                  a = V(a, 'filter')
                  return (a =
                    a.match(/^alpha\(opacity=(\d*)\)/) ||
                    a.match(/^progid:DXImageTransform.Microsoft.Alpha\(Opacity=(\d*)\)/))
                    ? Number(a[1]) / 100
                    : 1
                }
                return od(a)
              }
              function od(a) {
                var b = 1,
                  c = V(a, 'opacity')
                c && (b = Number(c))
                ;(a = Zc(a)) && (b *= od(a))
                return b
              }
              function pd(a, b, c, d, e) {
                if (3 == a.nodeType && c) nd(a, b, d, e)
                else if (S(a))
                  if (S(a, 'CONTENT') || S(a, 'SLOT')) {
                    for (var f = a; f.parentNode; ) f = f.parentNode
                    f instanceof ShadowRoot
                      ? ((a = S(a, 'CONTENT') ? a.getDistributedNodes() : a.assignedNodes()),
                        l(a, function (g) {
                          pd(g, b, c, d, e)
                        }))
                      : jd(a, b)
                  } else if (S(a, 'SHADOW')) {
                    for (f = a; f.parentNode; ) f = f.parentNode
                    if (f instanceof ShadowRoot && (a = f))
                      for (a = a.olderShadowRoot; a; )
                        l(a.childNodes, function (g) {
                          pd(g, b, c, d, e)
                        }),
                          (a = a.olderShadowRoot)
                  } else jd(a, b)
              }
              function jd(a, b) {
                a.shadowRoot &&
                  l(a.shadowRoot.childNodes, function (c) {
                    pd(c, b, !0, null, null)
                  })
                ld(a, b, function (c, d, e, f, g) {
                  var h = null
                  1 == c.nodeType ? (h = c) : 3 == c.nodeType && (h = c)
                  ;(null != h &&
                    (null != h.assignedSlot ||
                      (h.getDestinationInsertionPoints &&
                        0 < h.getDestinationInsertionPoints().length))) ||
                    pd(c, d, e, f, g)
                })
              }
              var qd = {
                C: function (a, b) {
                  return !(!a.querySelectorAll || !a.querySelector) && !/^\d.*/.test(b)
                },
                o: function (a, b) {
                  var c = eb(b),
                    d = 'string' === typeof a ? c.a.getElementById(a) : a
                  return d
                    ? Uc(d, 'id') == a && b != d && hb(b, d)
                      ? d
                      : ua(mb(c, '*'), function (e) {
                          return Uc(e, 'id') == a && b != e && hb(b, e)
                        })
                    : null
                },
                j: function (a, b) {
                  if (!a) return []
                  if (qd.C(b, a))
                    try {
                      return b.querySelectorAll('#' + qd.T(a))
                    } catch (c) {
                      return []
                    }
                  b = mb(eb(b), '*', null, b)
                  return pa(b, function (c) {
                    return Uc(c, 'id') == a
                  })
                },
                T: function (a) {
                  return a.replace(/([\s'"\\#.:;,!?+<>=~*^$|%&@`{}\-\/\[\]\(\)])/g, '\\$1')
                }
              }
              var Y = {},
                rd = {}
              Y.N = function (a, b, c) {
                try {
                  var d = Nc.j('a', b)
                } catch (e) {
                  d = mb(eb(b), 'A', null, b)
                }
                return ua(d, function (e) {
                  e = id(e)
                  e = e.replace(/^[\s]+|[\s]+$/g, '')
                  return (c && -1 != e.indexOf(a)) || e == a
                })
              }
              Y.K = function (a, b, c) {
                try {
                  var d = Nc.j('a', b)
                } catch (e) {
                  d = mb(eb(b), 'A', null, b)
                }
                return pa(d, function (e) {
                  e = id(e)
                  e = e.replace(/^[\s]+|[\s]+$/g, '')
                  return (c && -1 != e.indexOf(a)) || e == a
                })
              }
              Y.o = function (a, b) {
                return Y.N(a, b, !1)
              }
              Y.j = function (a, b) {
                return Y.K(a, b, !1)
              }
              rd.o = function (a, b) {
                return Y.N(a, b, !0)
              }
              rd.j = function (a, b) {
                return Y.K(a, b, !0)
              }
              var Z = {
                F: function (a, b) {
                  return function (c) {
                    var d = Z.u(a)
                    d = W(d)
                    c = W(c)
                    return b.call(null, d, c)
                  }
                },
                R: function (a) {
                  return Z.F(a, function (b, c) {
                    return c.b + c.height < b.b
                  })
                },
                S: function (a) {
                  return Z.F(a, function (b, c) {
                    return b.b + b.height < c.b
                  })
                },
                V: function (a) {
                  return Z.F(a, function (b, c) {
                    return c.a + c.width < b.a
                  })
                },
                aa: function (a) {
                  return Z.F(a, function (b, c) {
                    return b.a + b.width < c.a
                  })
                },
                W: function (a, b) {
                  var c
                  b ? (c = b) : 'number' == typeof a.distance && (c = a.distance)
                  c || (c = 50)
                  return function (d) {
                    var e = Z.u(a)
                    if (e === d) return !1
                    e = W(e)
                    d = W(d)
                    e = new U(e.a - c, e.b - c, e.width + 2 * c, e.height + 2 * c)
                    return (
                      e.a <= d.a + d.width &&
                      d.a <= e.a + e.width &&
                      e.b <= d.b + d.height &&
                      d.b <= e.b + e.height
                    )
                  }
                },
                u: function (a) {
                  if (ha(a) && 1 == a.nodeType) return a
                  if (ea(a)) return Z.u(a.call(null))
                  if (ha(a)) {
                    var b
                    a: {
                      if ((b = sd(a))) {
                        var c = td[b]
                        if (c && ea(c.o)) {
                          b = c.o(a[b], Bc.document)
                          break a
                        }
                      }
                      throw new P(61, 'Unsupported locator strategy: ' + b)
                    }
                    if (!b) throw new P(7, 'No element has been found by ' + JSON.stringify(a))
                    return b
                  }
                  throw new P(61, 'Selector is of wrong type: ' + JSON.stringify(a))
                }
              }
              Z.P = { left: Z.V, right: Z.aa, above: Z.R, below: Z.S, near: Z.W }
              Z.O = { left: Z.u, right: Z.u, above: Z.u, below: Z.u, near: Z.u }
              Z.U = function (a, b) {
                var c = []
                l(
                  a,
                  function (e) {
                    e &&
                      ta(
                        b,
                        function (f) {
                          var g = f.kind,
                            h = Z.P[g]
                          if (!h) throw new P(61, 'Cannot find filter suitable for ' + g)
                          return h.apply(null, f.args)(e)
                        },
                        null
                      ) &&
                      c.push(e)
                  },
                  null
                )
                a = b[b.length - 1]
                var d = Z.O[a ? a.kind : 'unknown']
                return d ? ((a = d.apply(null, a.args)) ? Z.ba(a, c) : c) : c
              }
              Z.ba = function (a, b) {
                function c(f) {
                  f = W(f)
                  return Math.sqrt(
                    Math.pow(d - (f.a + Math.max(1, f.width) / 2), 2) +
                      Math.pow(e - (f.b + Math.max(1, f.height) / 2), 2)
                  )
                }
                a = W(a)
                var d = a.a + Math.max(1, a.width) / 2,
                  e = a.b + Math.max(1, a.height) / 2
                xa(b, function (f, g) {
                  return c(f) - c(g)
                })
                return b
              }
              Z.o = function (a, b) {
                a = Z.j(a, b)
                return 0 == a.length ? null : a[0]
              }
              Z.j = function (a, b) {
                if (!a.hasOwnProperty('root') || !a.hasOwnProperty('filters'))
                  throw new P(
                    61,
                    'Locator not suitable for relative locators: ' + JSON.stringify(a)
                  )
                var c = a.filters,
                  d = da(c)
                if ('array' != d && ('object' != d || 'number' != typeof c.length))
                  throw new P(61, 'Targets should be an array: ' + JSON.stringify(a))
                var e
                S(a.root) ? (e = [a.root]) : (e = ud(a.root, b))
                return 0 == e.length ? [] : Z.U(e, a.filters)
              }
              var vd = {
                o: function (a, b) {
                  if ('' === a) throw new P(32, 'Unable to locate an element with the tagName ""')
                  return b.getElementsByTagName(a)[0] || null
                },
                j: function (a, b) {
                  if ('' === a) throw new P(32, 'Unable to locate an element with the tagName ""')
                  return b.getElementsByTagName(a)
                }
              }
              var td = {
                className: Dc,
                'class name': Dc,
                css: Nc,
                'css selector': Nc,
                relative: Z,
                id: qd,
                linkText: Y,
                'link text': Y,
                name: {
                  o: function (a, b) {
                    b = mb(eb(b), '*', null, b)
                    return ua(b, function (c) {
                      return Uc(c, 'name') == a
                    })
                  },
                  j: function (a, b) {
                    b = mb(eb(b), '*', null, b)
                    return pa(b, function (c) {
                      return Uc(c, 'name') == a
                    })
                  }
                },
                partialLinkText: rd,
                'partial link text': rd,
                tagName: vd,
                'tag name': vd,
                xpath: T
              }
              function sd(a) {
                for (var b in a) if (a.hasOwnProperty(b)) return b
                return null
              }
              function ud(a, b) {
                var c = sd(a)
                if (c) {
                  var d = td[c]
                  if (d && ea(d.j)) return d.j(a[c], b || Bc.document)
                }
                throw new P(61, 'Unsupported locator strategy: ' + c)
              }
              ca('_', ud)
              return this._.apply(null, arguments)
            }.apply(
              {
                navigator: typeof window != 'undefined' ? window.navigator : null,
                document: typeof window != 'undefined' ? window.document : null
              },
              arguments
            )
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/atoms/get-attribute.js':
        /*!********************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/atoms/get-attribute.js ***!
  \********************************************************************/
        /***/ (module) => {
          // GENERATED CODE - DO NOT EDIT
          module.exports = function () {
            return function () {
              var h = this || self
              function aa(a) {
                return 'string' == typeof a
              }
              function ba(a, b) {
                a = a.split('.')
                var c = h
                a[0] in c || 'undefined' == typeof c.execScript || c.execScript('var ' + a[0])
                for (var d; a.length && (d = a.shift()); )
                  a.length || void 0 === b
                    ? c[d] && c[d] !== Object.prototype[d]
                      ? (c = c[d])
                      : (c = c[d] = {})
                    : (c[d] = b)
              }
              function ca(a) {
                var b = typeof a
                if ('object' == b)
                  if (a) {
                    if (a instanceof Array) return 'array'
                    if (a instanceof Object) return b
                    var c = Object.prototype.toString.call(a)
                    if ('[object Window]' == c) return 'object'
                    if (
                      '[object Array]' == c ||
                      ('number' == typeof a.length &&
                        'undefined' != typeof a.splice &&
                        'undefined' != typeof a.propertyIsEnumerable &&
                        !a.propertyIsEnumerable('splice'))
                    )
                      return 'array'
                    if (
                      '[object Function]' == c ||
                      ('undefined' != typeof a.call &&
                        'undefined' != typeof a.propertyIsEnumerable &&
                        !a.propertyIsEnumerable('call'))
                    )
                      return 'function'
                  } else return 'null'
                else if ('function' == b && 'undefined' == typeof a.call) return 'object'
                return b
              }
              function da(a) {
                var b = typeof a
                return ('object' == b && null != a) || 'function' == b
              }
              function ea(a, b, c) {
                return a.call.apply(a.bind, arguments)
              }
              function fa(a, b, c) {
                if (!a) throw Error()
                if (2 < arguments.length) {
                  var d = Array.prototype.slice.call(arguments, 2)
                  return function () {
                    var e = Array.prototype.slice.call(arguments)
                    Array.prototype.unshift.apply(e, d)
                    return a.apply(b, e)
                  }
                }
                return function () {
                  return a.apply(b, arguments)
                }
              }
              function ha(a, b, c) {
                Function.prototype.bind &&
                -1 != Function.prototype.bind.toString().indexOf('native code')
                  ? (ha = ea)
                  : (ha = fa)
                return ha.apply(null, arguments)
              }
              function ia(a, b) {
                var c = Array.prototype.slice.call(arguments, 1)
                return function () {
                  var d = c.slice()
                  d.push.apply(d, arguments)
                  return a.apply(this, d)
                }
              }
              function m(a, b) {
                function c() {}
                c.prototype = b.prototype
                a.H = b.prototype
                a.prototype = new c()
                a.prototype.constructor = a
              }
              function ja(a, b, c) {
                var d = arguments.callee.caller
                if ('undefined' !== typeof d.H) {
                  for (var e = Array(arguments.length - 1), f = 1; f < arguments.length; f++)
                    e[f - 1] = arguments[f]
                  d.H.constructor.apply(a, e)
                } else {
                  if ('string' != typeof b && 'symbol' != typeof b)
                    throw Error('method names provided to goog.base must be a string or a symbol')
                  e = Array(arguments.length - 2)
                  for (f = 2; f < arguments.length; f++) e[f - 2] = arguments[f]
                  f = !1
                  for (var g = a.constructor.prototype; g; g = Object.getPrototypeOf(g))
                    if (g[b] === d) f = !0
                    else if (f) {
                      g[b].apply(a, e)
                      return
                    }
                  if (a[b] === d) a.constructor.prototype[b].apply(a, e)
                  else
                    throw Error(
                      'goog.base called from a method of one name to a method of a different name'
                    )
                }
              } /*

 The MIT License

 Copyright (c) 2007 Cybozu Labs, Inc.
 Copyright (c) 2012 Google Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 IN THE SOFTWARE.
*/
              function ka(a, b, c) {
                this.a = a
                this.b = b || 1
                this.f = c || 1
              }
              var la
              var ma = Array.prototype.indexOf
                  ? function (a, b) {
                      return Array.prototype.indexOf.call(a, b, void 0)
                    }
                  : function (a, b) {
                      if ('string' === typeof a)
                        return 'string' !== typeof b || 1 != b.length ? -1 : a.indexOf(b, 0)
                      for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c
                      return -1
                    },
                n = Array.prototype.forEach
                  ? function (a, b) {
                      Array.prototype.forEach.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                        e < c;
                        e++
                      )
                        e in d && b.call(void 0, d[e], e, a)
                    },
                na = Array.prototype.filter
                  ? function (a, b) {
                      return Array.prototype.filter.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length,
                          d = [],
                          e = 0,
                          f = 'string' === typeof a ? a.split('') : a,
                          g = 0;
                        g < c;
                        g++
                      )
                        if (g in f) {
                          var k = f[g]
                          b.call(void 0, k, g, a) && (d[e++] = k)
                        }
                      return d
                    },
                oa = Array.prototype.map
                  ? function (a, b) {
                      return Array.prototype.map.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length,
                          d = Array(c),
                          e = 'string' === typeof a ? a.split('') : a,
                          f = 0;
                        f < c;
                        f++
                      )
                        f in e && (d[f] = b.call(void 0, e[f], f, a))
                      return d
                    },
                pa = Array.prototype.reduce
                  ? function (a, b, c) {
                      return Array.prototype.reduce.call(a, b, c)
                    }
                  : function (a, b, c) {
                      var d = c
                      n(a, function (e, f) {
                        d = b.call(void 0, d, e, f, a)
                      })
                      return d
                    },
                qa = Array.prototype.some
                  ? function (a, b) {
                      return Array.prototype.some.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                        e < c;
                        e++
                      )
                        if (e in d && b.call(void 0, d[e], e, a)) return !0
                      return !1
                    }
              function ra(a, b) {
                a: {
                  for (
                    var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                    e < c;
                    e++
                  )
                    if (e in d && b.call(void 0, d[e], e, a)) {
                      b = e
                      break a
                    }
                  b = -1
                }
                return 0 > b ? null : 'string' === typeof a ? a.charAt(b) : a[b]
              }
              function sa(a) {
                return Array.prototype.concat.apply([], arguments)
              }
              function ta(a, b, c) {
                return 2 >= arguments.length
                  ? Array.prototype.slice.call(a, b)
                  : Array.prototype.slice.call(a, b, c)
              }
              var ua = String.prototype.trim
                ? function (a) {
                    return a.trim()
                  }
                : function (a) {
                    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]
                  }
              function va(a, b) {
                var c = 0
                a = ua(String(a)).split('.')
                b = ua(String(b)).split('.')
                for (var d = Math.max(a.length, b.length), e = 0; 0 == c && e < d; e++) {
                  var f = a[e] || '',
                    g = b[e] || ''
                  do {
                    f = /(\d*)(\D*)(.*)/.exec(f) || ['', '', '', '']
                    g = /(\d*)(\D*)(.*)/.exec(g) || ['', '', '', '']
                    if (0 == f[0].length && 0 == g[0].length) break
                    c =
                      wa(
                        0 == f[1].length ? 0 : parseInt(f[1], 10),
                        0 == g[1].length ? 0 : parseInt(g[1], 10)
                      ) ||
                      wa(0 == f[2].length, 0 == g[2].length) ||
                      wa(f[2], g[2])
                    f = f[3]
                    g = g[3]
                  } while (0 == c)
                }
                return c
              }
              function wa(a, b) {
                return a < b ? -1 : a > b ? 1 : 0
              }
              var p
              a: {
                var xa = h.navigator
                if (xa) {
                  var ya = xa.userAgent
                  if (ya) {
                    p = ya
                    break a
                  }
                }
                p = ''
              }
              function q(a) {
                return -1 != p.indexOf(a)
              }
              function za() {
                return q('Firefox') || q('FxiOS')
              }
              function Aa() {
                return (q('Chrome') || q('CriOS')) && !q('Edge')
              }
              function Ba() {
                return q('iPhone') && !q('iPod') && !q('iPad')
              }
              function Ca(a, b) {
                var c = Da
                return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : (c[a] = b(a))
              }
              var Ea = q('Opera'),
                r = q('Trident') || q('MSIE'),
                Fa = q('Edge'),
                t =
                  q('Gecko') &&
                  !(-1 != p.toLowerCase().indexOf('webkit') && !q('Edge')) &&
                  !(q('Trident') || q('MSIE')) &&
                  !q('Edge'),
                Ga = -1 != p.toLowerCase().indexOf('webkit') && !q('Edge'),
                Ha = q('Macintosh'),
                Ia = q('Windows')
              function Ja() {
                var a = h.document
                return a ? a.documentMode : void 0
              }
              var Ka
              a: {
                var La = '',
                  Ma = (function () {
                    var a = p
                    if (t) return /rv:([^\);]+)(\)|;)/.exec(a)
                    if (Fa) return /Edge\/([\d\.]+)/.exec(a)
                    if (r) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
                    if (Ga) return /WebKit\/(\S+)/.exec(a)
                    if (Ea) return /(?:Version)[ \/]?(\S+)/.exec(a)
                  })()
                Ma && (La = Ma ? Ma[1] : '')
                if (r) {
                  var Na = Ja()
                  if (null != Na && Na > parseFloat(La)) {
                    Ka = String(Na)
                    break a
                  }
                }
                Ka = La
              }
              var Da = {}
              function Oa(a) {
                return Ca(a, function () {
                  return 0 <= va(Ka, a)
                })
              }
              var w
              w = h.document && r ? Ja() : void 0
              var x = r && !(9 <= Number(w)),
                Pa = r && !(8 <= Number(w))
              function Qa(a, b, c, d) {
                this.a = a
                this.nodeName = c
                this.nodeValue = d
                this.nodeType = 2
                this.parentNode = this.ownerElement = b
              }
              function Sa(a, b) {
                var c = Pa && 'href' == b.nodeName ? a.getAttribute(b.nodeName, 2) : b.nodeValue
                return new Qa(b, a, b.nodeName, c)
              }
              function Ta(a) {
                this.b = a
                this.a = 0
              }
              function Ua(a) {
                a = a.match(Va)
                for (var b = 0; b < a.length; b++) Wa.test(a[b]) && a.splice(b, 1)
                return new Ta(a)
              }
              var Va =
                  /\$?(?:(?![0-9-\.])(?:\*|[\w-\.]+):)?(?![0-9-\.])(?:\*|[\w-\.]+)|\/\/|\.\.|::|\d+(?:\.\d*)?|\.\d+|"[^"]*"|'[^']*'|[!<>]=|\s+|./g,
                Wa = /^\s/
              function y(a, b) {
                return a.b[a.a + (b || 0)]
              }
              function z(a) {
                return a.b[a.a++]
              }
              function Xa(a) {
                return a.b.length <= a.a
              }
              function Ya(a) {
                return a.scrollingElement
                  ? a.scrollingElement
                  : Ga || 'CSS1Compat' != a.compatMode
                  ? a.body || a.documentElement
                  : a.documentElement
              }
              function Za(a, b) {
                if (!a || !b) return !1
                if (a.contains && 1 == b.nodeType) return a == b || a.contains(b)
                if ('undefined' != typeof a.compareDocumentPosition)
                  return a == b || !!(a.compareDocumentPosition(b) & 16)
                for (; b && a != b; ) b = b.parentNode
                return b == a
              }
              function $a(a, b) {
                if (a == b) return 0
                if (a.compareDocumentPosition) return a.compareDocumentPosition(b) & 2 ? 1 : -1
                if (r && !(9 <= Number(w))) {
                  if (9 == a.nodeType) return -1
                  if (9 == b.nodeType) return 1
                }
                if ('sourceIndex' in a || (a.parentNode && 'sourceIndex' in a.parentNode)) {
                  var c = 1 == a.nodeType,
                    d = 1 == b.nodeType
                  if (c && d) return a.sourceIndex - b.sourceIndex
                  var e = a.parentNode,
                    f = b.parentNode
                  return e == f
                    ? ab(a, b)
                    : !c && Za(e, b)
                    ? -1 * bb(a, b)
                    : !d && Za(f, a)
                    ? bb(b, a)
                    : (c ? a.sourceIndex : e.sourceIndex) - (d ? b.sourceIndex : f.sourceIndex)
                }
                d = A(a)
                c = d.createRange()
                c.selectNode(a)
                c.collapse(!0)
                a = d.createRange()
                a.selectNode(b)
                a.collapse(!0)
                return c.compareBoundaryPoints(h.Range.START_TO_END, a)
              }
              function bb(a, b) {
                var c = a.parentNode
                if (c == b) return -1
                for (; b.parentNode != c; ) b = b.parentNode
                return ab(b, a)
              }
              function ab(a, b) {
                for (; (b = b.previousSibling); ) if (b == a) return -1
                return 1
              }
              function A(a) {
                return 9 == a.nodeType ? a : a.ownerDocument || a.document
              }
              var cb = { SCRIPT: 1, STYLE: 1, HEAD: 1, IFRAME: 1, OBJECT: 1 },
                db = { IMG: ' ', BR: '\n' }
              function eb(a, b, c) {
                if (!(a.nodeName in cb))
                  if (3 == a.nodeType)
                    c
                      ? b.push(String(a.nodeValue).replace(/(\r\n|\r|\n)/g, ''))
                      : b.push(a.nodeValue)
                  else if (a.nodeName in db) b.push(db[a.nodeName])
                  else for (a = a.firstChild; a; ) eb(a, b, c), (a = a.nextSibling)
              }
              function fb(a) {
                this.a = a || h.document || document
              }
              fb.prototype.getElementsByTagName = function (a, b) {
                return (b || this.a).getElementsByTagName(String(a))
              }
              function B(a) {
                var b = null,
                  c = a.nodeType
                1 == c &&
                  ((b = a.textContent),
                  (b = void 0 == b || null == b ? a.innerText : b),
                  (b = void 0 == b || null == b ? '' : b))
                if ('string' != typeof b)
                  if (x && 'title' == a.nodeName.toLowerCase() && 1 == c) b = a.text
                  else if (9 == c || 1 == c) {
                    a = 9 == c ? a.documentElement : a.firstChild
                    c = 0
                    var d = []
                    for (b = ''; a; ) {
                      do
                        1 != a.nodeType && (b += a.nodeValue),
                          x && 'title' == a.nodeName.toLowerCase() && (b += a.text),
                          (d[c++] = a)
                      while ((a = a.firstChild))
                      for (; c && !(a = d[--c].nextSibling); );
                    }
                  } else b = a.nodeValue
                return b
              }
              function C(a, b, c) {
                if (null === b) return !0
                try {
                  if (!a.getAttribute) return !1
                } catch (d) {
                  return !1
                }
                Pa && 'class' == b && (b = 'className')
                return null == c ? !!a.getAttribute(b) : a.getAttribute(b, 2) == c
              }
              function gb(a, b, c, d, e) {
                return (x ? hb : ib).call(
                  null,
                  a,
                  b,
                  aa(c) ? c : null,
                  aa(d) ? d : null,
                  e || new D()
                )
              }
              function hb(a, b, c, d, e) {
                if (a instanceof jb || 8 == a.b || (c && null === a.b)) {
                  var f = b.all
                  if (!f) return e
                  a = kb(a)
                  if ('*' != a && ((f = b.getElementsByTagName(a)), !f)) return e
                  if (c) {
                    for (var g = [], k = 0; (b = f[k++]); ) C(b, c, d) && g.push(b)
                    f = g
                  }
                  for (k = 0; (b = f[k++]); ) ('*' == a && '!' == b.tagName) || e.add(b)
                  return e
                }
                lb(a, b, c, d, e)
                return e
              }
              function ib(a, b, c, d, e) {
                b.getElementsByName && d && 'name' == c && !r
                  ? ((b = b.getElementsByName(d)),
                    n(b, function (f) {
                      a.a(f) && e.add(f)
                    }))
                  : b.getElementsByClassName && d && 'class' == c
                  ? ((b = b.getElementsByClassName(d)),
                    n(b, function (f) {
                      f.className == d && a.a(f) && e.add(f)
                    }))
                  : a instanceof E
                  ? lb(a, b, c, d, e)
                  : b.getElementsByTagName &&
                    ((b = b.getElementsByTagName(a.f())),
                    n(b, function (f) {
                      C(f, c, d) && e.add(f)
                    }))
                return e
              }
              function mb(a, b, c, d, e) {
                var f
                if ((a instanceof jb || 8 == a.b || (c && null === a.b)) && (f = b.childNodes)) {
                  var g = kb(a)
                  if (
                    '*' != g &&
                    ((f = na(f, function (k) {
                      return k.tagName && k.tagName.toLowerCase() == g
                    })),
                    !f)
                  )
                    return e
                  c &&
                    (f = na(f, function (k) {
                      return C(k, c, d)
                    }))
                  n(f, function (k) {
                    ;('*' == g && ('!' == k.tagName || ('*' == g && 1 != k.nodeType))) || e.add(k)
                  })
                  return e
                }
                return nb(a, b, c, d, e)
              }
              function nb(a, b, c, d, e) {
                for (b = b.firstChild; b; b = b.nextSibling) C(b, c, d) && a.a(b) && e.add(b)
                return e
              }
              function lb(a, b, c, d, e) {
                for (b = b.firstChild; b; b = b.nextSibling)
                  C(b, c, d) && a.a(b) && e.add(b), lb(a, b, c, d, e)
              }
              function kb(a) {
                if (a instanceof E) {
                  if (8 == a.b) return '!'
                  if (null === a.b) return '*'
                }
                return a.f()
              }
              function D() {
                this.b = this.a = null
                this.o = 0
              }
              function ob(a) {
                this.f = a
                this.a = this.b = null
              }
              function pb(a, b) {
                if (!a.a) return b
                if (!b.a) return a
                var c = a.a
                b = b.a
                for (var d = null, e, f = 0; c && b; ) {
                  e = c.f
                  var g = b.f
                  e == g || (e instanceof Qa && g instanceof Qa && e.a == g.a)
                    ? ((e = c), (c = c.a), (b = b.a))
                    : 0 < $a(c.f, b.f)
                    ? ((e = b), (b = b.a))
                    : ((e = c), (c = c.a))
                  ;(e.b = d) ? (d.a = e) : (a.a = e)
                  d = e
                  f++
                }
                for (e = c || b; e; ) (e.b = d), (d = d.a = e), f++, (e = e.a)
                a.b = d
                a.o = f
                return a
              }
              function qb(a, b) {
                b = new ob(b)
                b.a = a.a
                a.b ? (a.a.b = b) : (a.a = a.b = b)
                a.a = b
                a.o++
              }
              D.prototype.add = function (a) {
                a = new ob(a)
                a.b = this.b
                this.a ? (this.b.a = a) : (this.a = this.b = a)
                this.b = a
                this.o++
              }
              function rb(a) {
                return (a = a.a) ? a.f : null
              }
              function sb(a) {
                return (a = rb(a)) ? B(a) : ''
              }
              function F(a, b) {
                return new tb(a, !!b)
              }
              function tb(a, b) {
                this.f = a
                this.b = (this.v = b) ? a.b : a.a
                this.a = null
              }
              function G(a) {
                var b = a.b
                if (null == b) return null
                var c = (a.a = b)
                a.b = a.v ? b.b : b.a
                return c.f
              }
              function H(a) {
                this.l = a
                this.b = this.i = !1
                this.f = null
              }
              function I(a) {
                return '\n  ' + a.toString().split('\n').join('\n  ')
              }
              function ub(a, b) {
                a.i = b
              }
              function vb(a, b) {
                a.b = b
              }
              function J(a, b) {
                a = a.a(b)
                return a instanceof D ? +sb(a) : +a
              }
              function L(a, b) {
                a = a.a(b)
                return a instanceof D ? sb(a) : '' + a
              }
              function wb(a, b) {
                a = a.a(b)
                return a instanceof D ? !!a.o : !!a
              }
              function xb(a, b, c) {
                H.call(this, a.l)
                this.c = a
                this.j = b
                this.u = c
                this.i = b.i || c.i
                this.b = b.b || c.b
                this.c == yb &&
                  (c.b || c.i || 4 == c.l || 0 == c.l || !b.f
                    ? b.b ||
                      b.i ||
                      4 == b.l ||
                      0 == b.l ||
                      !c.f ||
                      (this.f = { name: c.f.name, A: b })
                    : (this.f = { name: b.f.name, A: c }))
              }
              m(xb, H)
              function zb(a, b, c, d, e) {
                b = b.a(d)
                c = c.a(d)
                var f
                if (b instanceof D && c instanceof D) {
                  b = F(b)
                  for (d = G(b); d; d = G(b))
                    for (e = F(c), f = G(e); f; f = G(e)) if (a(B(d), B(f))) return !0
                  return !1
                }
                if (b instanceof D || c instanceof D) {
                  b instanceof D ? ((e = b), (d = c)) : ((e = c), (d = b))
                  f = F(e)
                  for (var g = typeof d, k = G(f); k; k = G(f)) {
                    switch (g) {
                      case 'number':
                        k = +B(k)
                        break
                      case 'boolean':
                        k = !!B(k)
                        break
                      case 'string':
                        k = B(k)
                        break
                      default:
                        throw Error('Illegal primitive type for comparison.')
                    }
                    if ((e == b && a(k, d)) || (e == c && a(d, k))) return !0
                  }
                  return !1
                }
                return e
                  ? 'boolean' == typeof b || 'boolean' == typeof c
                    ? a(!!b, !!c)
                    : 'number' == typeof b || 'number' == typeof c
                    ? a(+b, +c)
                    : a(b, c)
                  : a(+b, +c)
              }
              xb.prototype.a = function (a) {
                return this.c.s(this.j, this.u, a)
              }
              xb.prototype.toString = function () {
                var a = 'Binary Expression: ' + this.c
                a += I(this.j)
                return (a += I(this.u))
              }
              function Ab(a, b, c, d) {
                this.L = a
                this.G = b
                this.l = c
                this.s = d
              }
              Ab.prototype.toString = function () {
                return this.L
              }
              var Bb = {}
              function M(a, b, c, d) {
                if (Bb.hasOwnProperty(a)) throw Error('Binary operator already created: ' + a)
                a = new Ab(a, b, c, d)
                return (Bb[a.toString()] = a)
              }
              M('div', 6, 1, function (a, b, c) {
                return J(a, c) / J(b, c)
              })
              M('mod', 6, 1, function (a, b, c) {
                return J(a, c) % J(b, c)
              })
              M('*', 6, 1, function (a, b, c) {
                return J(a, c) * J(b, c)
              })
              M('+', 5, 1, function (a, b, c) {
                return J(a, c) + J(b, c)
              })
              M('-', 5, 1, function (a, b, c) {
                return J(a, c) - J(b, c)
              })
              M('<', 4, 2, function (a, b, c) {
                return zb(
                  function (d, e) {
                    return d < e
                  },
                  a,
                  b,
                  c
                )
              })
              M('>', 4, 2, function (a, b, c) {
                return zb(
                  function (d, e) {
                    return d > e
                  },
                  a,
                  b,
                  c
                )
              })
              M('<=', 4, 2, function (a, b, c) {
                return zb(
                  function (d, e) {
                    return d <= e
                  },
                  a,
                  b,
                  c
                )
              })
              M('>=', 4, 2, function (a, b, c) {
                return zb(
                  function (d, e) {
                    return d >= e
                  },
                  a,
                  b,
                  c
                )
              })
              var yb = M('=', 3, 2, function (a, b, c) {
                return zb(
                  function (d, e) {
                    return d == e
                  },
                  a,
                  b,
                  c,
                  !0
                )
              })
              M('!=', 3, 2, function (a, b, c) {
                return zb(
                  function (d, e) {
                    return d != e
                  },
                  a,
                  b,
                  c,
                  !0
                )
              })
              M('and', 2, 2, function (a, b, c) {
                return wb(a, c) && wb(b, c)
              })
              M('or', 1, 2, function (a, b, c) {
                return wb(a, c) || wb(b, c)
              })
              function Cb(a, b) {
                if (b.a.length && 4 != a.l)
                  throw Error(
                    'Primary expression must evaluate to nodeset if filter has predicate(s).'
                  )
                H.call(this, a.l)
                this.c = a
                this.j = b
                this.i = a.i
                this.b = a.b
              }
              m(Cb, H)
              Cb.prototype.a = function (a) {
                a = this.c.a(a)
                return Db(this.j, a)
              }
              Cb.prototype.toString = function () {
                var a = 'Filter:' + I(this.c)
                return (a += I(this.j))
              }
              function Eb(a, b) {
                if (b.length < a.F)
                  throw Error(
                    'Function ' +
                      a.m +
                      ' expects at least' +
                      a.F +
                      ' arguments, ' +
                      b.length +
                      ' given'
                  )
                if (null !== a.D && b.length > a.D)
                  throw Error(
                    'Function ' +
                      a.m +
                      ' expects at most ' +
                      a.D +
                      ' arguments, ' +
                      b.length +
                      ' given'
                  )
                a.K &&
                  n(b, function (c, d) {
                    if (4 != c.l)
                      throw Error(
                        'Argument ' + d + ' to function ' + a.m + ' is not of type Nodeset: ' + c
                      )
                  })
                H.call(this, a.l)
                this.B = a
                this.c = b
                ub(
                  this,
                  a.i ||
                    qa(b, function (c) {
                      return c.i
                    })
                )
                vb(
                  this,
                  (a.J && !b.length) ||
                    (a.I && !!b.length) ||
                    qa(b, function (c) {
                      return c.b
                    })
                )
              }
              m(Eb, H)
              Eb.prototype.a = function (a) {
                return this.B.s.apply(null, sa(a, this.c))
              }
              Eb.prototype.toString = function () {
                var a = 'Function: ' + this.B
                if (this.c.length) {
                  var b = pa(
                    this.c,
                    function (c, d) {
                      return c + I(d)
                    },
                    'Arguments:'
                  )
                  a += I(b)
                }
                return a
              }
              function Fb(a, b, c, d, e, f, g, k) {
                this.m = a
                this.l = b
                this.i = c
                this.J = d
                this.I = !1
                this.s = e
                this.F = f
                this.D = void 0 !== g ? g : f
                this.K = !!k
              }
              Fb.prototype.toString = function () {
                return this.m
              }
              var Gb = {}
              function N(a, b, c, d, e, f, g, k) {
                if (Gb.hasOwnProperty(a)) throw Error('Function already created: ' + a + '.')
                Gb[a] = new Fb(a, b, c, d, e, f, g, k)
              }
              N(
                'boolean',
                2,
                !1,
                !1,
                function (a, b) {
                  return wb(b, a)
                },
                1
              )
              N(
                'ceiling',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.ceil(J(b, a))
                },
                1
              )
              N(
                'concat',
                3,
                !1,
                !1,
                function (a, b) {
                  return pa(
                    ta(arguments, 1),
                    function (c, d) {
                      return c + L(d, a)
                    },
                    ''
                  )
                },
                2,
                null
              )
              N(
                'contains',
                2,
                !1,
                !1,
                function (a, b, c) {
                  b = L(b, a)
                  a = L(c, a)
                  return -1 != b.indexOf(a)
                },
                2
              )
              N(
                'count',
                1,
                !1,
                !1,
                function (a, b) {
                  return b.a(a).o
                },
                1,
                1,
                !0
              )
              N(
                'false',
                2,
                !1,
                !1,
                function () {
                  return !1
                },
                0
              )
              N(
                'floor',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.floor(J(b, a))
                },
                1
              )
              N(
                'id',
                4,
                !1,
                !1,
                function (a, b) {
                  function c(k) {
                    if (x) {
                      var l = e.all[k]
                      if (l) {
                        if (l.nodeType && k == l.id) return l
                        if (l.length)
                          return ra(l, function (u) {
                            return k == u.id
                          })
                      }
                      return null
                    }
                    return e.getElementById(k)
                  }
                  var d = a.a,
                    e = 9 == d.nodeType ? d : d.ownerDocument
                  a = L(b, a).split(/\s+/)
                  var f = []
                  n(a, function (k) {
                    k = c(k)
                    !k || 0 <= ma(f, k) || f.push(k)
                  })
                  f.sort($a)
                  var g = new D()
                  n(f, function (k) {
                    g.add(k)
                  })
                  return g
                },
                1
              )
              N(
                'lang',
                2,
                !1,
                !1,
                function () {
                  return !1
                },
                1
              )
              N(
                'last',
                1,
                !0,
                !1,
                function (a) {
                  if (1 != arguments.length) throw Error('Function last expects ()')
                  return a.f
                },
                0
              )
              N(
                'local-name',
                3,
                !1,
                !0,
                function (a, b) {
                  return (a = b ? rb(b.a(a)) : a.a) ? a.localName || a.nodeName.toLowerCase() : ''
                },
                0,
                1,
                !0
              )
              N(
                'name',
                3,
                !1,
                !0,
                function (a, b) {
                  return (a = b ? rb(b.a(a)) : a.a) ? a.nodeName.toLowerCase() : ''
                },
                0,
                1,
                !0
              )
              N(
                'namespace-uri',
                3,
                !0,
                !1,
                function () {
                  return ''
                },
                0,
                1,
                !0
              )
              N(
                'normalize-space',
                3,
                !1,
                !0,
                function (a, b) {
                  return (b ? L(b, a) : B(a.a)).replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '')
                },
                0,
                1
              )
              N(
                'not',
                2,
                !1,
                !1,
                function (a, b) {
                  return !wb(b, a)
                },
                1
              )
              N(
                'number',
                1,
                !1,
                !0,
                function (a, b) {
                  return b ? J(b, a) : +B(a.a)
                },
                0,
                1
              )
              N(
                'position',
                1,
                !0,
                !1,
                function (a) {
                  return a.b
                },
                0
              )
              N(
                'round',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.round(J(b, a))
                },
                1
              )
              N(
                'starts-with',
                2,
                !1,
                !1,
                function (a, b, c) {
                  b = L(b, a)
                  a = L(c, a)
                  return 0 == b.lastIndexOf(a, 0)
                },
                2
              )
              N(
                'string',
                3,
                !1,
                !0,
                function (a, b) {
                  return b ? L(b, a) : B(a.a)
                },
                0,
                1
              )
              N(
                'string-length',
                1,
                !1,
                !0,
                function (a, b) {
                  return (b ? L(b, a) : B(a.a)).length
                },
                0,
                1
              )
              N(
                'substring',
                3,
                !1,
                !1,
                function (a, b, c, d) {
                  c = J(c, a)
                  if (isNaN(c) || Infinity == c || -Infinity == c) return ''
                  d = d ? J(d, a) : Infinity
                  if (isNaN(d) || -Infinity === d) return ''
                  c = Math.round(c) - 1
                  var e = Math.max(c, 0)
                  a = L(b, a)
                  return Infinity == d ? a.substring(e) : a.substring(e, c + Math.round(d))
                },
                2,
                3
              )
              N(
                'substring-after',
                3,
                !1,
                !1,
                function (a, b, c) {
                  b = L(b, a)
                  a = L(c, a)
                  c = b.indexOf(a)
                  return -1 == c ? '' : b.substring(c + a.length)
                },
                2
              )
              N(
                'substring-before',
                3,
                !1,
                !1,
                function (a, b, c) {
                  b = L(b, a)
                  a = L(c, a)
                  a = b.indexOf(a)
                  return -1 == a ? '' : b.substring(0, a)
                },
                2
              )
              N(
                'sum',
                1,
                !1,
                !1,
                function (a, b) {
                  a = F(b.a(a))
                  b = 0
                  for (var c = G(a); c; c = G(a)) b += +B(c)
                  return b
                },
                1,
                1,
                !0
              )
              N(
                'translate',
                3,
                !1,
                !1,
                function (a, b, c, d) {
                  b = L(b, a)
                  c = L(c, a)
                  var e = L(d, a)
                  a = {}
                  for (d = 0; d < c.length; d++) {
                    var f = c.charAt(d)
                    f in a || (a[f] = e.charAt(d))
                  }
                  c = ''
                  for (d = 0; d < b.length; d++) (f = b.charAt(d)), (c += f in a ? a[f] : f)
                  return c
                },
                3
              )
              N(
                'true',
                2,
                !1,
                !1,
                function () {
                  return !0
                },
                0
              )
              function E(a, b) {
                this.j = a
                this.c = void 0 !== b ? b : null
                this.b = null
                switch (a) {
                  case 'comment':
                    this.b = 8
                    break
                  case 'text':
                    this.b = 3
                    break
                  case 'processing-instruction':
                    this.b = 7
                    break
                  case 'node':
                    break
                  default:
                    throw Error('Unexpected argument')
                }
              }
              function Hb(a) {
                return 'comment' == a || 'text' == a || 'processing-instruction' == a || 'node' == a
              }
              E.prototype.a = function (a) {
                return null === this.b || this.b == a.nodeType
              }
              E.prototype.f = function () {
                return this.j
              }
              E.prototype.toString = function () {
                var a = 'Kind Test: ' + this.j
                null === this.c || (a += I(this.c))
                return a
              }
              function Ib(a) {
                H.call(this, 3)
                this.c = a.substring(1, a.length - 1)
              }
              m(Ib, H)
              Ib.prototype.a = function () {
                return this.c
              }
              Ib.prototype.toString = function () {
                return 'Literal: ' + this.c
              }
              function jb(a, b) {
                this.m = a.toLowerCase()
                a = '*' == this.m ? '*' : 'http://www.w3.org/1999/xhtml'
                this.c = b ? b.toLowerCase() : a
              }
              jb.prototype.a = function (a) {
                var b = a.nodeType
                if (1 != b && 2 != b) return !1
                b = void 0 !== a.localName ? a.localName : a.nodeName
                return '*' != this.m && this.m != b.toLowerCase()
                  ? !1
                  : '*' == this.c
                  ? !0
                  : this.c ==
                    (a.namespaceURI ? a.namespaceURI.toLowerCase() : 'http://www.w3.org/1999/xhtml')
              }
              jb.prototype.f = function () {
                return this.m
              }
              jb.prototype.toString = function () {
                return (
                  'Name Test: ' +
                  ('http://www.w3.org/1999/xhtml' == this.c ? '' : this.c + ':') +
                  this.m
                )
              }
              function Jb(a) {
                H.call(this, 1)
                this.c = a
              }
              m(Jb, H)
              Jb.prototype.a = function () {
                return this.c
              }
              Jb.prototype.toString = function () {
                return 'Number: ' + this.c
              }
              function Kb(a, b) {
                H.call(this, a.l)
                this.j = a
                this.c = b
                this.i = a.i
                this.b = a.b
                1 == this.c.length &&
                  ((a = this.c[0]),
                  a.C ||
                    a.c != Lb ||
                    ((a = a.u), '*' != a.f() && (this.f = { name: a.f(), A: null })))
              }
              m(Kb, H)
              function Mb() {
                H.call(this, 4)
              }
              m(Mb, H)
              Mb.prototype.a = function (a) {
                var b = new D()
                a = a.a
                9 == a.nodeType ? b.add(a) : b.add(a.ownerDocument)
                return b
              }
              Mb.prototype.toString = function () {
                return 'Root Helper Expression'
              }
              function Nb() {
                H.call(this, 4)
              }
              m(Nb, H)
              Nb.prototype.a = function (a) {
                var b = new D()
                b.add(a.a)
                return b
              }
              Nb.prototype.toString = function () {
                return 'Context Helper Expression'
              }
              function Ob(a) {
                return '/' == a || '//' == a
              }
              Kb.prototype.a = function (a) {
                var b = this.j.a(a)
                if (!(b instanceof D)) throw Error('Filter expression must evaluate to nodeset.')
                a = this.c
                for (var c = 0, d = a.length; c < d && b.o; c++) {
                  var e = a[c],
                    f = F(b, e.c.v)
                  if (e.i || e.c != Pb)
                    if (e.i || e.c != Qb) {
                      var g = G(f)
                      for (b = e.a(new ka(g)); null != (g = G(f)); )
                        (g = e.a(new ka(g))), (b = pb(b, g))
                    } else (g = G(f)), (b = e.a(new ka(g)))
                  else {
                    for (
                      g = G(f);
                      (b = G(f)) &&
                      (!g.contains || g.contains(b)) &&
                      b.compareDocumentPosition(g) & 8;
                      g = b
                    );
                    b = e.a(new ka(g))
                  }
                }
                return b
              }
              Kb.prototype.toString = function () {
                var a = 'Path Expression:' + I(this.j)
                if (this.c.length) {
                  var b = pa(
                    this.c,
                    function (c, d) {
                      return c + I(d)
                    },
                    'Steps:'
                  )
                  a += I(b)
                }
                return a
              }
              function Rb(a, b) {
                this.a = a
                this.v = !!b
              }
              function Db(a, b, c) {
                for (c = c || 0; c < a.a.length; c++)
                  for (var d = a.a[c], e = F(b), f = b.o, g, k = 0; (g = G(e)); k++) {
                    var l = a.v ? f - k : k + 1
                    g = d.a(new ka(g, l, f))
                    if ('number' == typeof g) l = l == g
                    else if ('string' == typeof g || 'boolean' == typeof g) l = !!g
                    else if (g instanceof D) l = 0 < g.o
                    else throw Error('Predicate.evaluate returned an unexpected type.')
                    if (!l) {
                      l = e
                      g = l.f
                      var u = l.a
                      if (!u) throw Error('Next must be called at least once before remove.')
                      var K = u.b
                      u = u.a
                      K ? (K.a = u) : (g.a = u)
                      u ? (u.b = K) : (g.b = K)
                      g.o--
                      l.a = null
                    }
                  }
                return b
              }
              Rb.prototype.toString = function () {
                return pa(
                  this.a,
                  function (a, b) {
                    return a + I(b)
                  },
                  'Predicates:'
                )
              }
              function O(a, b, c, d) {
                H.call(this, 4)
                this.c = a
                this.u = b
                this.j = c || new Rb([])
                this.C = !!d
                b = this.j
                b = 0 < b.a.length ? b.a[0].f : null
                a.M &&
                  b &&
                  ((a = b.name), (a = x ? a.toLowerCase() : a), (this.f = { name: a, A: b.A }))
                a: {
                  a = this.j
                  for (b = 0; b < a.a.length; b++)
                    if (((c = a.a[b]), c.i || 1 == c.l || 0 == c.l)) {
                      a = !0
                      break a
                    }
                  a = !1
                }
                this.i = a
              }
              m(O, H)
              O.prototype.a = function (a) {
                var b = a.a,
                  c = this.f,
                  d = null,
                  e = null,
                  f = 0
                c && ((d = c.name), (e = c.A ? L(c.A, a) : null), (f = 1))
                if (this.C)
                  if (this.i || this.c != Sb)
                    if (((b = F(new O(Tb, new E('node')).a(a))), (c = G(b))))
                      for (a = this.s(c, d, e, f); null != (c = G(b)); )
                        a = pb(a, this.s(c, d, e, f))
                    else a = new D()
                  else (a = gb(this.u, b, d, e)), (a = Db(this.j, a, f))
                else a = this.s(a.a, d, e, f)
                return a
              }
              O.prototype.s = function (a, b, c, d) {
                a = this.c.B(this.u, a, b, c)
                return (a = Db(this.j, a, d))
              }
              O.prototype.toString = function () {
                var a = 'Step:' + I('Operator: ' + (this.C ? '//' : '/'))
                this.c.m && (a += I('Axis: ' + this.c))
                a += I(this.u)
                if (this.j.a.length) {
                  var b = pa(
                    this.j.a,
                    function (c, d) {
                      return c + I(d)
                    },
                    'Predicates:'
                  )
                  a += I(b)
                }
                return a
              }
              function Ub(a, b, c, d) {
                this.m = a
                this.B = b
                this.v = c
                this.M = d
              }
              Ub.prototype.toString = function () {
                return this.m
              }
              var Vb = {}
              function P(a, b, c, d) {
                if (Vb.hasOwnProperty(a)) throw Error('Axis already created: ' + a)
                b = new Ub(a, b, c, !!d)
                return (Vb[a] = b)
              }
              P(
                'ancestor',
                function (a, b) {
                  for (var c = new D(); (b = b.parentNode); ) a.a(b) && qb(c, b)
                  return c
                },
                !0
              )
              P(
                'ancestor-or-self',
                function (a, b) {
                  var c = new D()
                  do a.a(b) && qb(c, b)
                  while ((b = b.parentNode))
                  return c
                },
                !0
              )
              var Lb = P(
                  'attribute',
                  function (a, b) {
                    var c = new D(),
                      d = a.f()
                    if ('style' == d && x && b.style)
                      return c.add(new Qa(b.style, b, 'style', b.style.cssText)), c
                    var e = b.attributes
                    if (e)
                      if ((a instanceof E && null === a.b) || '*' == d)
                        for (a = 0; (d = e[a]); a++) x ? d.nodeValue && c.add(Sa(b, d)) : c.add(d)
                      else
                        (d = e.getNamedItem(d)) && (x ? d.nodeValue && c.add(Sa(b, d)) : c.add(d))
                    return c
                  },
                  !1
                ),
                Sb = P(
                  'child',
                  function (a, b, c, d, e) {
                    return (x ? mb : nb).call(
                      null,
                      a,
                      b,
                      aa(c) ? c : null,
                      aa(d) ? d : null,
                      e || new D()
                    )
                  },
                  !1,
                  !0
                )
              P('descendant', gb, !1, !0)
              var Tb = P(
                  'descendant-or-self',
                  function (a, b, c, d) {
                    var e = new D()
                    C(b, c, d) && a.a(b) && e.add(b)
                    return gb(a, b, c, d, e)
                  },
                  !1,
                  !0
                ),
                Pb = P(
                  'following',
                  function (a, b, c, d) {
                    var e = new D()
                    do
                      for (var f = b; (f = f.nextSibling); )
                        C(f, c, d) && a.a(f) && e.add(f), (e = gb(a, f, c, d, e))
                    while ((b = b.parentNode))
                    return e
                  },
                  !1,
                  !0
                )
              P(
                'following-sibling',
                function (a, b) {
                  for (var c = new D(); (b = b.nextSibling); ) a.a(b) && c.add(b)
                  return c
                },
                !1
              )
              P(
                'namespace',
                function () {
                  return new D()
                },
                !1
              )
              var Wb = P(
                  'parent',
                  function (a, b) {
                    var c = new D()
                    if (9 == b.nodeType) return c
                    if (2 == b.nodeType) return c.add(b.ownerElement), c
                    b = b.parentNode
                    a.a(b) && c.add(b)
                    return c
                  },
                  !1
                ),
                Qb = P(
                  'preceding',
                  function (a, b, c, d) {
                    var e = new D(),
                      f = []
                    do f.unshift(b)
                    while ((b = b.parentNode))
                    for (var g = 1, k = f.length; g < k; g++) {
                      var l = []
                      for (b = f[g]; (b = b.previousSibling); ) l.unshift(b)
                      for (var u = 0, K = l.length; u < K; u++)
                        (b = l[u]), C(b, c, d) && a.a(b) && e.add(b), (e = gb(a, b, c, d, e))
                    }
                    return e
                  },
                  !0,
                  !0
                )
              P(
                'preceding-sibling',
                function (a, b) {
                  for (var c = new D(); (b = b.previousSibling); ) a.a(b) && qb(c, b)
                  return c
                },
                !0
              )
              var Xb = P(
                'self',
                function (a, b) {
                  var c = new D()
                  a.a(b) && c.add(b)
                  return c
                },
                !1
              )
              function Yb(a) {
                H.call(this, 1)
                this.c = a
                this.i = a.i
                this.b = a.b
              }
              m(Yb, H)
              Yb.prototype.a = function (a) {
                return -J(this.c, a)
              }
              Yb.prototype.toString = function () {
                return 'Unary Expression: -' + I(this.c)
              }
              function Zb(a) {
                H.call(this, 4)
                this.c = a
                ub(
                  this,
                  qa(this.c, function (b) {
                    return b.i
                  })
                )
                vb(
                  this,
                  qa(this.c, function (b) {
                    return b.b
                  })
                )
              }
              m(Zb, H)
              Zb.prototype.a = function (a) {
                var b = new D()
                n(this.c, function (c) {
                  c = c.a(a)
                  if (!(c instanceof D)) throw Error('Path expression must evaluate to NodeSet.')
                  b = pb(b, c)
                })
                return b
              }
              Zb.prototype.toString = function () {
                return pa(
                  this.c,
                  function (a, b) {
                    return a + I(b)
                  },
                  'Union Expression:'
                )
              }
              function $b(a, b) {
                this.a = a
                this.b = b
              }
              function ac(a) {
                for (var b, c = []; ; ) {
                  Q(a, 'Missing right hand side of binary expression.')
                  b = bc(a)
                  var d = z(a.a)
                  if (!d) break
                  var e = (d = Bb[d] || null) && d.G
                  if (!e) {
                    a.a.a--
                    break
                  }
                  for (; c.length && e <= c[c.length - 1].G; ) b = new xb(c.pop(), c.pop(), b)
                  c.push(b, d)
                }
                for (; c.length; ) b = new xb(c.pop(), c.pop(), b)
                return b
              }
              function Q(a, b) {
                if (Xa(a.a)) throw Error(b)
              }
              function cc(a, b) {
                a = z(a.a)
                if (a != b) throw Error('Bad token, expected: ' + b + ' got: ' + a)
              }
              function dc(a) {
                a = z(a.a)
                if (')' != a) throw Error('Bad token: ' + a)
              }
              function ec(a) {
                a = z(a.a)
                if (2 > a.length) throw Error('Unclosed literal string')
                return new Ib(a)
              }
              function fc(a) {
                var b = []
                if (Ob(y(a.a))) {
                  var c = z(a.a)
                  var d = y(a.a)
                  if (
                    '/' == c &&
                    (Xa(a.a) ||
                      ('.' != d && '..' != d && '@' != d && '*' != d && !/(?![0-9])[\w]/.test(d)))
                  )
                    return new Mb()
                  d = new Mb()
                  Q(a, 'Missing next location step.')
                  c = gc(a, c)
                  b.push(c)
                } else {
                  a: {
                    c = y(a.a)
                    d = c.charAt(0)
                    switch (d) {
                      case '$':
                        throw Error('Variable reference not allowed in HTML XPath')
                      case '(':
                        z(a.a)
                        c = ac(a)
                        Q(a, 'unclosed "("')
                        cc(a, ')')
                        break
                      case '"':
                      case "'":
                        c = ec(a)
                        break
                      default:
                        if (isNaN(+c))
                          if (!Hb(c) && /(?![0-9])[\w]/.test(d) && '(' == y(a.a, 1)) {
                            c = z(a.a)
                            c = Gb[c] || null
                            z(a.a)
                            for (d = []; ')' != y(a.a); ) {
                              Q(a, 'Missing function argument list.')
                              d.push(ac(a))
                              if (',' != y(a.a)) break
                              z(a.a)
                            }
                            Q(a, 'Unclosed function argument list.')
                            dc(a)
                            c = new Eb(c, d)
                          } else {
                            c = null
                            break a
                          }
                        else c = new Jb(+z(a.a))
                    }
                    '[' == y(a.a) && ((d = new Rb(hc(a))), (c = new Cb(c, d)))
                  }
                  if (c)
                    if (Ob(y(a.a))) d = c
                    else return c
                  else (c = gc(a, '/')), (d = new Nb()), b.push(c)
                }
                for (; Ob(y(a.a)); )
                  (c = z(a.a)), Q(a, 'Missing next location step.'), (c = gc(a, c)), b.push(c)
                return new Kb(d, b)
              }
              function gc(a, b) {
                if ('/' != b && '//' != b) throw Error('Step op should be "/" or "//"')
                if ('.' == y(a.a)) {
                  var c = new O(Xb, new E('node'))
                  z(a.a)
                  return c
                }
                if ('..' == y(a.a)) return (c = new O(Wb, new E('node'))), z(a.a), c
                if ('@' == y(a.a)) {
                  var d = Lb
                  z(a.a)
                  Q(a, 'Missing attribute name')
                } else if ('::' == y(a.a, 1)) {
                  if (!/(?![0-9])[\w]/.test(y(a.a).charAt(0))) throw Error('Bad token: ' + z(a.a))
                  var e = z(a.a)
                  d = Vb[e] || null
                  if (!d) throw Error('No axis with name: ' + e)
                  z(a.a)
                  Q(a, 'Missing node name')
                } else d = Sb
                e = y(a.a)
                if (/(?![0-9])[\w\*]/.test(e.charAt(0)))
                  if ('(' == y(a.a, 1)) {
                    if (!Hb(e)) throw Error('Invalid node type: ' + e)
                    e = z(a.a)
                    if (!Hb(e)) throw Error('Invalid type name: ' + e)
                    cc(a, '(')
                    Q(a, 'Bad nodetype')
                    var f = y(a.a).charAt(0),
                      g = null
                    if ('"' == f || "'" == f) g = ec(a)
                    Q(a, 'Bad nodetype')
                    dc(a)
                    e = new E(e, g)
                  } else if (((e = z(a.a)), (f = e.indexOf(':')), -1 == f)) e = new jb(e)
                  else {
                    g = e.substring(0, f)
                    if ('*' == g) var k = '*'
                    else if (((k = a.b(g)), !k)) throw Error('Namespace prefix not declared: ' + g)
                    e = e.substr(f + 1)
                    e = new jb(e, k)
                  }
                else throw Error('Bad token: ' + z(a.a))
                a = new Rb(hc(a), d.v)
                return c || new O(d, e, a, '//' == b)
              }
              function hc(a) {
                for (var b = []; '[' == y(a.a); ) {
                  z(a.a)
                  Q(a, 'Missing predicate expression.')
                  var c = ac(a)
                  b.push(c)
                  Q(a, 'Unclosed predicate expression.')
                  cc(a, ']')
                }
                return b
              }
              function bc(a) {
                if ('-' == y(a.a)) return z(a.a), new Yb(bc(a))
                var b = fc(a)
                if ('|' != y(a.a)) a = b
                else {
                  for (b = [b]; '|' == z(a.a); )
                    Q(a, 'Missing next union location path.'), b.push(fc(a))
                  a.a.a--
                  a = new Zb(b)
                }
                return a
              }
              function ic(a) {
                switch (a.nodeType) {
                  case 1:
                    return ia(jc, a)
                  case 9:
                    return ic(a.documentElement)
                  case 11:
                  case 10:
                  case 6:
                  case 12:
                    return kc
                  default:
                    return a.parentNode ? ic(a.parentNode) : kc
                }
              }
              function kc() {
                return null
              }
              function jc(a, b) {
                if (a.prefix == b) return a.namespaceURI || 'http://www.w3.org/1999/xhtml'
                var c = a.getAttributeNode('xmlns:' + b)
                return c && c.specified
                  ? c.value || null
                  : a.parentNode && 9 != a.parentNode.nodeType
                  ? jc(a.parentNode, b)
                  : null
              }
              function lc(a, b) {
                if (!a.length) throw Error('Empty XPath expression.')
                a = Ua(a)
                if (Xa(a)) throw Error('Invalid XPath expression.')
                b
                  ? 'function' == ca(b) || (b = ha(b.lookupNamespaceURI, b))
                  : (b = function () {
                      return null
                    })
                var c = ac(new $b(a, b))
                if (!Xa(a)) throw Error('Bad token: ' + z(a))
                this.evaluate = function (d, e) {
                  d = c.a(new ka(d))
                  return new T(d, e)
                }
              }
              function T(a, b) {
                if (0 == b)
                  if (a instanceof D) b = 4
                  else if ('string' == typeof a) b = 2
                  else if ('number' == typeof a) b = 1
                  else if ('boolean' == typeof a) b = 3
                  else throw Error('Unexpected evaluation result.')
                if (2 != b && 1 != b && 3 != b && !(a instanceof D))
                  throw Error('value could not be converted to the specified type')
                this.resultType = b
                switch (b) {
                  case 2:
                    this.stringValue = a instanceof D ? sb(a) : '' + a
                    break
                  case 1:
                    this.numberValue = a instanceof D ? +sb(a) : +a
                    break
                  case 3:
                    this.booleanValue = a instanceof D ? 0 < a.o : !!a
                    break
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    var c = F(a)
                    var d = []
                    for (var e = G(c); e; e = G(c)) d.push(e instanceof Qa ? e.a : e)
                    this.snapshotLength = a.o
                    this.invalidIteratorState = !1
                    break
                  case 8:
                  case 9:
                    a = rb(a)
                    this.singleNodeValue = a instanceof Qa ? a.a : a
                    break
                  default:
                    throw Error('Unknown XPathResult type.')
                }
                var f = 0
                this.iterateNext = function () {
                  if (4 != b && 5 != b) throw Error('iterateNext called with wrong result type')
                  return f >= d.length ? null : d[f++]
                }
                this.snapshotItem = function (g) {
                  if (6 != b && 7 != b) throw Error('snapshotItem called with wrong result type')
                  return g >= d.length || 0 > g ? null : d[g]
                }
              }
              T.ANY_TYPE = 0
              T.NUMBER_TYPE = 1
              T.STRING_TYPE = 2
              T.BOOLEAN_TYPE = 3
              T.UNORDERED_NODE_ITERATOR_TYPE = 4
              T.ORDERED_NODE_ITERATOR_TYPE = 5
              T.UNORDERED_NODE_SNAPSHOT_TYPE = 6
              T.ORDERED_NODE_SNAPSHOT_TYPE = 7
              T.ANY_UNORDERED_NODE_TYPE = 8
              T.FIRST_ORDERED_NODE_TYPE = 9
              function mc(a) {
                this.lookupNamespaceURI = ic(a)
              }
              function nc(a, b) {
                a = a || h
                var c = (a.Document && a.Document.prototype) || a.document
                if (!c.evaluate || b)
                  (a.XPathResult = T),
                    (c.evaluate = function (d, e, f, g) {
                      return new lc(d, f).evaluate(e, g)
                    }),
                    (c.createExpression = function (d, e) {
                      return new lc(d, e)
                    }),
                    (c.createNSResolver = function (d) {
                      return new mc(d)
                    })
              }
              ba('wgxpath.install', nc)
              ba('wgxpath.install', nc)
              var oc = window
              function U(a, b) {
                this.code = a
                this.a = V[a] || pc
                this.message = b || ''
                a = this.a.replace(/((?:^|\s+)[a-z])/g, function (c) {
                  return c.toUpperCase().replace(/^[\s\xa0]+/g, '')
                })
                b = a.length - 5
                if (0 > b || a.indexOf('Error', b) != b) a += 'Error'
                this.name = a
                a = Error(this.message)
                a.name = this.name
                this.stack = a.stack || ''
              }
              m(U, Error)
              var pc = 'unknown error',
                V = { 15: 'element not selectable', 11: 'element not visible' }
              V[31] = pc
              V[30] = pc
              V[24] = 'invalid cookie domain'
              V[29] = 'invalid element coordinates'
              V[12] = 'invalid element state'
              V[32] = 'invalid selector'
              V[51] = 'invalid selector'
              V[52] = 'invalid selector'
              V[17] = 'javascript error'
              V[405] = 'unsupported operation'
              V[34] = 'move target out of bounds'
              V[27] = 'no such alert'
              V[7] = 'no such element'
              V[8] = 'no such frame'
              V[23] = 'no such window'
              V[28] = 'script timeout'
              V[33] = 'session not created'
              V[10] = 'stale element reference'
              V[21] = 'timeout'
              V[25] = 'unable to set cookie'
              V[26] = 'unexpected alert open'
              V[13] = pc
              V[9] = 'unknown command'
              var qc = za(),
                rc = Ba() || q('iPod'),
                sc = q('iPad'),
                tc = q('Android') && !(Aa() || za() || q('Opera') || q('Silk')),
                uc = Aa(),
                vc =
                  q('Safari') &&
                  !(
                    Aa() ||
                    q('Coast') ||
                    q('Opera') ||
                    q('Edge') ||
                    q('Edg/') ||
                    q('OPR') ||
                    za() ||
                    q('Silk') ||
                    q('Android')
                  ) &&
                  !(Ba() || q('iPad') || q('iPod'))
              function wc(a) {
                return (a = a.exec(p)) ? a[1] : ''
              }
              var xc = (function () {
                if (qc) return wc(/Firefox\/([0-9.]+)/)
                if (r || Fa || Ea) return Ka
                if (uc)
                  return Ba() || q('iPad') || q('iPod')
                    ? wc(/CriOS\/([0-9.]+)/)
                    : wc(/Chrome\/([0-9.]+)/)
                if (vc && !(Ba() || q('iPad') || q('iPod'))) return wc(/Version\/([0-9.]+)/)
                if (rc || sc) {
                  var a = /Version\/(\S+).*Mobile\/(\S+)/.exec(p)
                  if (a) return a[1] + '.' + a[2]
                } else if (tc) return (a = wc(/Android\s+([0-9.]+)/)) ? a : wc(/Version\/([0-9.]+)/)
                return ''
              })()
              var yc = sc || rc,
                zc
              if (tc) {
                var Ac = /Android\s+([0-9\.]+)/.exec(p)
                zc = Ac ? Ac[1] : '0'
              } else zc = '0'
              var Bc = zc,
                Cc = r && !(8 <= Number(w)),
                Dc = r && !(9 <= Number(w))
              function Ec(a, b) {
                b = b.toLowerCase()
                return 'style' == b
                  ? Fc(a.style.cssText)
                  : Cc && 'value' == b && Gc(a, 'INPUT')
                  ? a.value
                  : Dc && !0 === a[b]
                  ? String(a.getAttribute(b))
                  : (a = a.getAttributeNode(b)) && a.specified
                  ? a.value
                  : null
              }
              var Hc =
                /[;]+(?=(?:(?:[^"]*"){2})*[^"]*$)(?=(?:(?:[^']*'){2})*[^']*$)(?=(?:[^()]*\([^()]*\))*[^()]*$)/
              function Fc(a) {
                var b = []
                n(a.split(Hc), function (c) {
                  var d = c.indexOf(':')
                  0 < d &&
                    ((c = [c.slice(0, d), c.slice(d + 1)]),
                    2 == c.length && b.push(c[0].toLowerCase(), ':', c[1], ';'))
                })
                b = b.join('')
                return (b = ';' == b.charAt(b.length - 1) ? b : b + ';')
              }
              function Ic(a, b) {
                Cc && 'value' == b && Gc(a, 'OPTION') && null === Ec(a, 'value')
                  ? ((b = []), eb(a, b, !1), (a = b.join('')))
                  : (a = a[b])
                return a
              }
              function Gc(a, b) {
                b && 'string' !== typeof b && (b = b.toString())
                return !!a && 1 == a.nodeType && (!b || a.tagName.toUpperCase() == b)
              }
              function Jc(a) {
                return Gc(a, 'OPTION')
                  ? !0
                  : Gc(a, 'INPUT')
                  ? ((a = a.type.toLowerCase()), 'checkbox' == a || 'radio' == a)
                  : !1
              }
              function Kc(a) {
                a = a ? A(a) : document
                return !r ||
                  9 <= Number(w) ||
                  'CSS1Compat' == (a ? new fb(A(a)) : la || (la = new fb())).a.compatMode
                  ? a.documentElement
                  : a.body
              }
              var Lc = !(r && !(r ? 0 <= va(w, 10) : Oa(10))),
                Mc = tc ? !(tc ? 0 <= va(Bc, 4) : 0 <= va(xc, 4)) : !yc,
                Nc = r && oc.navigator.msPointerEnabled
              function Oc(a, b, c) {
                this.a = a
                this.b = b
                this.f = c
              }
              Oc.prototype.create = function (a) {
                a = A(a).createEvent('HTMLEvents')
                a.initEvent(this.a, this.b, this.f)
                return a
              }
              Oc.prototype.toString = function () {
                return this.a
              }
              function W(a, b, c) {
                ja(this, a, b, c)
              }
              m(W, Oc)
              W.prototype.create = function (a, b) {
                if (!t && this == Pc)
                  throw new U(9, 'Browser does not support a mouse pixel scroll event.')
                var c = A(a),
                  d = c ? c.parentWindow || c.defaultView : window
                var e = c.createEvent('MouseEvents')
                var f = 1
                this == Qc && (t || (e.wheelDelta = b.wheelDelta), t && (f = b.wheelDelta / -40))
                t && this == Pc && (f = b.wheelDelta)
                e.initMouseEvent(
                  this.a,
                  this.b,
                  this.f,
                  d,
                  f,
                  b.clientX,
                  b.clientY,
                  b.clientX,
                  b.clientY,
                  b.ctrlKey,
                  b.altKey,
                  b.shiftKey,
                  b.metaKey,
                  b.button,
                  b.relatedTarget
                )
                if (r && 0 === e.pageX && 0 === e.pageY && Object.defineProperty) {
                  a = Ya((a ? new fb(A(a)) : la || (la = new fb())).a)
                  c = Kc(c)
                  var g = b.clientX + a.scrollLeft - c.clientLeft,
                    k = b.clientY + a.scrollTop - c.clientTop
                  Object.defineProperty(e, 'pageX', {
                    get: function () {
                      return g
                    }
                  })
                  Object.defineProperty(e, 'pageY', {
                    get: function () {
                      return k
                    }
                  })
                }
                return e
              }
              function Rc(a, b, c) {
                ja(this, a, b, c)
              }
              m(Rc, Oc)
              Rc.prototype.create = function (a, b) {
                var c = A(a)
                if (t && !(r ? 0 <= va(w, 93) : Oa(93))) {
                  a = c ? c.parentWindow || c.defaultView : window
                  var d = b.charCode ? 0 : b.keyCode
                  c = c.createEvent('KeyboardEvent')
                  c.initKeyEvent(
                    this.a,
                    this.b,
                    this.f,
                    a,
                    b.ctrlKey,
                    b.altKey,
                    b.shiftKey,
                    b.metaKey,
                    d,
                    b.charCode
                  )
                  this.a == Sc && b.preventDefault && c.preventDefault()
                } else if (
                  ((c = c.createEvent('Events')),
                  c.initEvent(this.a, this.b, this.f),
                  (c.altKey = b.altKey),
                  (c.ctrlKey = b.ctrlKey),
                  (c.metaKey = b.metaKey),
                  (c.shiftKey = b.shiftKey),
                  (c.keyCode = b.charCode || b.keyCode),
                  Ga || Fa)
                )
                  c.charCode = this == Sc ? c.keyCode : 0
                return c
              }
              function Tc(a, b, c) {
                ja(this, a, b, c)
              }
              m(Tc, Oc)
              Tc.prototype.create = function (a, b) {
                function c(R) {
                  R = oa(R, function (v) {
                    return g.createTouch(k, a, v.identifier, v.pageX, v.pageY, v.screenX, v.screenY)
                  })
                  return g.createTouchList.apply(g, R)
                }
                function d(R) {
                  var v = oa(R, function (S) {
                    return {
                      identifier: S.identifier,
                      screenX: S.screenX,
                      screenY: S.screenY,
                      clientX: S.clientX,
                      clientY: S.clientY,
                      pageX: S.pageX,
                      pageY: S.pageY,
                      target: a
                    }
                  })
                  v.item = function (S) {
                    return v[S]
                  }
                  return v
                }
                function e(R) {
                  return oa(R, function (v) {
                    return new Touch({
                      identifier: v.identifier,
                      screenX: v.screenX,
                      screenY: v.screenY,
                      clientX: v.clientX,
                      clientY: v.clientY,
                      pageX: v.pageX,
                      pageY: v.pageY,
                      target: a
                    })
                  })
                }
                function f(R, v) {
                  switch (R) {
                    case 1:
                      return d(v)
                    case 2:
                      return c(v)
                    case 3:
                      return e(v)
                  }
                  return null
                }
                if (!Lc) throw new U(9, 'Browser does not support firing touch events.')
                var g = A(a),
                  k = g ? g.parentWindow || g.defaultView : window
                if (Mc) var l = 1
                else if (TouchEvent.prototype.initTouchEvent) l = 2
                else if (TouchEvent && 0 < TouchEvent.length) l = 3
                else throw new U(9, 'Not able to create touch events in this browser')
                var u = f(l, b.changedTouches),
                  K = b.touches == b.changedTouches ? u : f(l, b.touches),
                  Ra = b.targetTouches == b.changedTouches ? u : f(l, b.targetTouches)
                if (1 == l)
                  (l = g.createEvent('MouseEvents')),
                    l.initMouseEvent(
                      this.a,
                      this.b,
                      this.f,
                      k,
                      1,
                      0,
                      0,
                      b.clientX,
                      b.clientY,
                      b.ctrlKey,
                      b.altKey,
                      b.shiftKey,
                      b.metaKey,
                      0,
                      b.relatedTarget
                    ),
                    (l.touches = K),
                    (l.targetTouches = Ra),
                    (l.changedTouches = u),
                    (l.scale = b.scale),
                    (l.rotation = b.rotation)
                else if (2 == l)
                  (l = g.createEvent('TouchEvent')),
                    0 == l.initTouchEvent.length
                      ? l.initTouchEvent(
                          K,
                          Ra,
                          u,
                          this.a,
                          k,
                          0,
                          0,
                          b.clientX,
                          b.clientY,
                          b.ctrlKey,
                          b.altKey,
                          b.shiftKey,
                          b.metaKey
                        )
                      : l.initTouchEvent(
                          this.a,
                          this.b,
                          this.f,
                          k,
                          1,
                          0,
                          0,
                          b.clientX,
                          b.clientY,
                          b.ctrlKey,
                          b.altKey,
                          b.shiftKey,
                          b.metaKey,
                          K,
                          Ra,
                          u,
                          b.scale,
                          b.rotation
                        ),
                    (l.relatedTarget = b.relatedTarget)
                else if (3 == l)
                  l = new TouchEvent(this.a, {
                    touches: K,
                    targetTouches: Ra,
                    changedTouches: u,
                    bubbles: this.b,
                    cancelable: this.f,
                    ctrlKey: b.ctrlKey,
                    shiftKey: b.shiftKey,
                    altKey: b.altKey,
                    metaKey: b.metaKey
                  })
                else throw new U(9, 'Illegal TouchEventStrategy_ value (this is a bug)')
                return l
              }
              function X(a, b, c) {
                ja(this, a, b, c)
              }
              m(X, Oc)
              X.prototype.create = function (a, b) {
                if (!Nc) throw new U(9, 'Browser does not support MSGesture events.')
                var c = A(a)
                a = c ? c.parentWindow || c.defaultView : window
                c = c.createEvent('MSGestureEvent')
                c.initGestureEvent(
                  this.a,
                  this.b,
                  this.f,
                  a,
                  1,
                  0,
                  0,
                  b.clientX,
                  b.clientY,
                  0,
                  0,
                  b.translationX,
                  b.translationY,
                  b.scale,
                  b.expansion,
                  b.rotation,
                  b.velocityX,
                  b.velocityY,
                  b.velocityExpansion,
                  b.velocityAngular,
                  new Date().getTime(),
                  b.relatedTarget
                )
                return c
              }
              function Y(a, b, c) {
                ja(this, a, b, c)
              }
              m(Y, Oc)
              Y.prototype.create = function (a, b) {
                if (!Nc) throw new U(9, 'Browser does not support MSPointer events.')
                var c = A(a)
                a = c ? c.parentWindow || c.defaultView : window
                c = c.createEvent('MSPointerEvent')
                c.initPointerEvent(
                  this.a,
                  this.b,
                  this.f,
                  a,
                  0,
                  0,
                  0,
                  b.clientX,
                  b.clientY,
                  b.ctrlKey,
                  b.altKey,
                  b.shiftKey,
                  b.metaKey,
                  b.button,
                  b.relatedTarget,
                  0,
                  0,
                  b.width,
                  b.height,
                  b.pressure,
                  b.rotation,
                  b.tiltX,
                  b.tiltY,
                  b.pointerId,
                  b.pointerType,
                  0,
                  b.isPrimary
                )
                return c
              }
              new W('click', !0, !0)
              new W('contextmenu', !0, !0)
              new W('dblclick', !0, !0)
              new W('mousedown', !0, !0)
              new W('mousemove', !0, !1)
              new W('mouseout', !0, !0)
              new W('mouseover', !0, !0)
              new W('mouseup', !0, !0)
              var Qc = new W(t ? 'DOMMouseScroll' : 'mousewheel', !0, !0),
                Pc = new W('MozMousePixelScroll', !0, !0)
              new Rc('keydown', !0, !0)
              var Sc = new Rc('keypress', !0, !0)
              new Rc('keyup', !0, !0)
              new Tc('touchend', !0, !0)
              new Tc('touchmove', !0, !0)
              new Tc('touchstart', !0, !0)
              new X('MSGestureChange', !0, !0)
              new X('MSGestureEnd', !0, !0)
              new X('MSGestureHold', !0, !0)
              new X('MSGestureStart', !0, !0)
              new X('MSGestureTap', !0, !0)
              new X('MSInertiaStart', !0, !0)
              new Y('MSGotPointerCapture', !0, !1)
              new Y('MSLostPointerCapture', !0, !1)
              new Y('MSPointerCancel', !0, !0)
              new Y('MSPointerDown', !0, !0)
              new Y('MSPointerMove', !0, !0)
              new Y('MSPointerOver', !0, !0)
              new Y('MSPointerOut', !0, !0)
              new Y('MSPointerUp', !0, !0)
              function Uc(a, b) {
                this.b = {}
                this.a = []
                this.f = 0
                var c = arguments.length
                if (1 < c) {
                  if (c % 2) throw Error('Uneven number of arguments')
                  for (var d = 0; d < c; d += 2) this.set(arguments[d], arguments[d + 1])
                } else if (a)
                  if (a instanceof Uc)
                    for (c = Vc(a), d = 0; d < c.length; d++) this.set(c[d], a.get(c[d]))
                  else for (d in a) this.set(d, a[d])
              }
              function Vc(a) {
                if (a.f != a.a.length) {
                  for (var b = 0, c = 0; b < a.a.length; ) {
                    var d = a.a[b]
                    Object.prototype.hasOwnProperty.call(a.b, d) && (a.a[c++] = d)
                    b++
                  }
                  a.a.length = c
                }
                if (a.f != a.a.length) {
                  var e = {}
                  for (c = b = 0; b < a.a.length; )
                    (d = a.a[b]),
                      Object.prototype.hasOwnProperty.call(e, d) || ((a.a[c++] = d), (e[d] = 1)),
                      b++
                  a.a.length = c
                }
                return a.a.concat()
              }
              Uc.prototype.get = function (a, b) {
                return Object.prototype.hasOwnProperty.call(this.b, a) ? this.b[a] : b
              }
              Uc.prototype.set = function (a, b) {
                Object.prototype.hasOwnProperty.call(this.b, a) || (this.f++, this.a.push(a))
                this.b[a] = b
              }
              var Wc = {}
              function Z(a, b, c) {
                da(a) && (a = t ? a.g : a.h)
                a = new Xc(a)
                !b ||
                  (b in Wc && !c) ||
                  ((Wc[b] = { key: a, shift: !1 }), c && (Wc[c] = { key: a, shift: !0 }))
                return a
              }
              function Xc(a) {
                this.code = a
              }
              Z(8)
              Z(9)
              Z(13)
              var Yc = Z(16),
                Zc = Z(17),
                $c = Z(18)
              Z(19)
              Z(20)
              Z(27)
              Z(32, ' ')
              Z(33)
              Z(34)
              Z(35)
              Z(36)
              Z(37)
              Z(38)
              Z(39)
              Z(40)
              Z(44)
              Z(45)
              Z(46)
              Z(48, '0', ')')
              Z(49, '1', '!')
              Z(50, '2', '@')
              Z(51, '3', '#')
              Z(52, '4', '$')
              Z(53, '5', '%')
              Z(54, '6', '^')
              Z(55, '7', '&')
              Z(56, '8', '*')
              Z(57, '9', '(')
              Z(65, 'a', 'A')
              Z(66, 'b', 'B')
              Z(67, 'c', 'C')
              Z(68, 'd', 'D')
              Z(69, 'e', 'E')
              Z(70, 'f', 'F')
              Z(71, 'g', 'G')
              Z(72, 'h', 'H')
              Z(73, 'i', 'I')
              Z(74, 'j', 'J')
              Z(75, 'k', 'K')
              Z(76, 'l', 'L')
              Z(77, 'm', 'M')
              Z(78, 'n', 'N')
              Z(79, 'o', 'O')
              Z(80, 'p', 'P')
              Z(81, 'q', 'Q')
              Z(82, 'r', 'R')
              Z(83, 's', 'S')
              Z(84, 't', 'T')
              Z(85, 'u', 'U')
              Z(86, 'v', 'V')
              Z(87, 'w', 'W')
              Z(88, 'x', 'X')
              Z(89, 'y', 'Y')
              Z(90, 'z', 'Z')
              var ad = Z(Ia ? { g: 91, h: 91 } : Ha ? { g: 224, h: 91 } : { g: 0, h: 91 })
              Z(Ia ? { g: 92, h: 92 } : Ha ? { g: 224, h: 93 } : { g: 0, h: 92 })
              Z(Ia ? { g: 93, h: 93 } : Ha ? { g: 0, h: 0 } : { g: 93, h: null })
              Z({ g: 96, h: 96 }, '0')
              Z({ g: 97, h: 97 }, '1')
              Z({ g: 98, h: 98 }, '2')
              Z({ g: 99, h: 99 }, '3')
              Z({ g: 100, h: 100 }, '4')
              Z({ g: 101, h: 101 }, '5')
              Z({ g: 102, h: 102 }, '6')
              Z({ g: 103, h: 103 }, '7')
              Z({ g: 104, h: 104 }, '8')
              Z({ g: 105, h: 105 }, '9')
              Z({ g: 106, h: 106 }, '*')
              Z({ g: 107, h: 107 }, '+')
              Z({ g: 109, h: 109 }, '-')
              Z({ g: 110, h: 110 }, '.')
              Z({ g: 111, h: 111 }, '/')
              Z(144)
              Z(112)
              Z(113)
              Z(114)
              Z(115)
              Z(116)
              Z(117)
              Z(118)
              Z(119)
              Z(120)
              Z(121)
              Z(122)
              Z(123)
              Z({ g: 107, h: 187 }, '=', '+')
              Z(108, ',')
              Z({ g: 109, h: 189 }, '-', '_')
              Z(188, ',', '<')
              Z(190, '.', '>')
              Z(191, '/', '?')
              Z(192, '`', '~')
              Z(219, '[', '{')
              Z(220, '\\', '|')
              Z(221, ']', '}')
              Z({ g: 59, h: 186 }, ';', ':')
              Z(222, "'", '"')
              var bd = new Uc()
              bd.set(1, Yc)
              bd.set(2, Zc)
              bd.set(4, $c)
              bd.set(8, ad)
              ;(function (a) {
                var b = new Uc()
                n(Vc(a), function (c) {
                  b.set(a.get(c).code, c)
                })
                return b
              })(bd)
              var cd = { class: 'className', readonly: 'readOnly' },
                dd =
                  'allowfullscreen allowpaymentrequest allowusermedia async autofocus autoplay checked compact complete controls declare default defaultchecked defaultselected defer disabled ended formnovalidate hidden indeterminate iscontenteditable ismap itemscope loop multiple muted nohref nomodule noresize noshade novalidate nowrap open paused playsinline pubdate readonly required reversed scoped seamless seeking selected truespeed typemustmatch willvalidate'.split(
                    ' '
                  )
              ba('_', function (a, b) {
                var c = null,
                  d = b.toLowerCase()
                if ('style' == d) return (c = a.style) && !aa(c) && (c = c.cssText), c
                if (('selected' == d || 'checked' == d) && Jc(a)) {
                  if (!Jc(a)) throw new U(15, 'Element is not selectable')
                  b = 'selected'
                  c = a.type && a.type.toLowerCase()
                  if ('checkbox' == c || 'radio' == c) b = 'checked'
                  return Ic(a, b) ? 'true' : null
                }
                var e = Gc(a, 'A')
                if ((Gc(a, 'IMG') && 'src' == d) || (e && 'href' == d))
                  return (c = Ec(a, d)) && (c = Ic(a, d)), c
                if ('spellcheck' == d) {
                  c = Ec(a, d)
                  if (null !== c) {
                    if ('false' == c.toLowerCase()) return 'false'
                    if ('true' == c.toLowerCase()) return 'true'
                  }
                  return Ic(a, d) + ''
                }
                e = cd[b] || b
                if (0 <= ma(dd, d)) return (c = null !== Ec(a, b) || Ic(a, e)) ? 'true' : null
                try {
                  var f = Ic(a, e)
                } catch (g) {}
                null == f || da(f) ? (c = Ec(a, b)) : (c = f)
                return null != c ? c.toString() : null
              })
              return this._.apply(null, arguments)
            }.apply(
              {
                navigator: typeof window != 'undefined' ? window.navigator : null,
                document: typeof window != 'undefined' ? window.document : null
              },
              arguments
            )
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/atoms/is-displayed.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/atoms/is-displayed.js ***!
  \*******************************************************************/
        /***/ (module) => {
          // GENERATED CODE - DO NOT EDIT
          module.exports = function () {
            return function () {
              var k = this || self
              function aa(a) {
                return 'string' == typeof a
              }
              function ba(a, b) {
                a = a.split('.')
                var c = k
                a[0] in c || 'undefined' == typeof c.execScript || c.execScript('var ' + a[0])
                for (var d; a.length && (d = a.shift()); )
                  a.length || void 0 === b
                    ? c[d] && c[d] !== Object.prototype[d]
                      ? (c = c[d])
                      : (c = c[d] = {})
                    : (c[d] = b)
              }
              function ca(a) {
                var b = typeof a
                if ('object' == b)
                  if (a) {
                    if (a instanceof Array) return 'array'
                    if (a instanceof Object) return b
                    var c = Object.prototype.toString.call(a)
                    if ('[object Window]' == c) return 'object'
                    if (
                      '[object Array]' == c ||
                      ('number' == typeof a.length &&
                        'undefined' != typeof a.splice &&
                        'undefined' != typeof a.propertyIsEnumerable &&
                        !a.propertyIsEnumerable('splice'))
                    )
                      return 'array'
                    if (
                      '[object Function]' == c ||
                      ('undefined' != typeof a.call &&
                        'undefined' != typeof a.propertyIsEnumerable &&
                        !a.propertyIsEnumerable('call'))
                    )
                      return 'function'
                  } else return 'null'
                else if ('function' == b && 'undefined' == typeof a.call) return 'object'
                return b
              }
              function da(a, b, c) {
                return a.call.apply(a.bind, arguments)
              }
              function ea(a, b, c) {
                if (!a) throw Error()
                if (2 < arguments.length) {
                  var d = Array.prototype.slice.call(arguments, 2)
                  return function () {
                    var e = Array.prototype.slice.call(arguments)
                    Array.prototype.unshift.apply(e, d)
                    return a.apply(b, e)
                  }
                }
                return function () {
                  return a.apply(b, arguments)
                }
              }
              function fa(a, b, c) {
                Function.prototype.bind &&
                -1 != Function.prototype.bind.toString().indexOf('native code')
                  ? (fa = da)
                  : (fa = ea)
                return fa.apply(null, arguments)
              }
              function ha(a, b) {
                var c = Array.prototype.slice.call(arguments, 1)
                return function () {
                  var d = c.slice()
                  d.push.apply(d, arguments)
                  return a.apply(this, d)
                }
              }
              function l(a, b) {
                function c() {}
                c.prototype = b.prototype
                a.prototype = new c()
                a.prototype.constructor = a
              } /*

 The MIT License

 Copyright (c) 2007 Cybozu Labs, Inc.
 Copyright (c) 2012 Google Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 IN THE SOFTWARE.
*/
              function ia(a, b, c) {
                this.a = a
                this.b = b || 1
                this.f = c || 1
              }
              var ja = Array.prototype.indexOf
                  ? function (a, b) {
                      return Array.prototype.indexOf.call(a, b, void 0)
                    }
                  : function (a, b) {
                      if ('string' === typeof a)
                        return 'string' !== typeof b || 1 != b.length ? -1 : a.indexOf(b, 0)
                      for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c
                      return -1
                    },
                n = Array.prototype.forEach
                  ? function (a, b) {
                      Array.prototype.forEach.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                        e < c;
                        e++
                      )
                        e in d && b.call(void 0, d[e], e, a)
                    },
                ka = Array.prototype.filter
                  ? function (a, b) {
                      return Array.prototype.filter.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length,
                          d = [],
                          e = 0,
                          f = 'string' === typeof a ? a.split('') : a,
                          g = 0;
                        g < c;
                        g++
                      )
                        if (g in f) {
                          var h = f[g]
                          b.call(void 0, h, g, a) && (d[e++] = h)
                        }
                      return d
                    },
                la = Array.prototype.reduce
                  ? function (a, b, c) {
                      return Array.prototype.reduce.call(a, b, c)
                    }
                  : function (a, b, c) {
                      var d = c
                      n(a, function (e, f) {
                        d = b.call(void 0, d, e, f, a)
                      })
                      return d
                    },
                ma = Array.prototype.some
                  ? function (a, b) {
                      return Array.prototype.some.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                        e < c;
                        e++
                      )
                        if (e in d && b.call(void 0, d[e], e, a)) return !0
                      return !1
                    },
                na = Array.prototype.every
                  ? function (a, b) {
                      return Array.prototype.every.call(a, b, void 0)
                    }
                  : function (a, b) {
                      for (
                        var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                        e < c;
                        e++
                      )
                        if (e in d && !b.call(void 0, d[e], e, a)) return !1
                      return !0
                    }
              function oa(a, b) {
                a: {
                  for (
                    var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0;
                    e < c;
                    e++
                  )
                    if (e in d && b.call(void 0, d[e], e, a)) {
                      b = e
                      break a
                    }
                  b = -1
                }
                return 0 > b ? null : 'string' === typeof a ? a.charAt(b) : a[b]
              }
              function pa(a) {
                return Array.prototype.concat.apply([], arguments)
              }
              function qa(a, b, c) {
                return 2 >= arguments.length
                  ? Array.prototype.slice.call(a, b)
                  : Array.prototype.slice.call(a, b, c)
              }
              var ra = String.prototype.trim
                ? function (a) {
                    return a.trim()
                  }
                : function (a) {
                    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]
                  }
              function sa(a, b) {
                return a < b ? -1 : a > b ? 1 : 0
              }
              var t
              a: {
                var ta = k.navigator
                if (ta) {
                  var ua = ta.userAgent
                  if (ua) {
                    t = ua
                    break a
                  }
                }
                t = ''
              }
              function u(a) {
                return -1 != t.indexOf(a)
              }
              function va() {
                return u('Firefox') || u('FxiOS')
              }
              function wa() {
                return (u('Chrome') || u('CriOS')) && !u('Edge')
              }
              function xa(a) {
                return String(a).replace(/\-([a-z])/g, function (b, c) {
                  return c.toUpperCase()
                })
              }
              function ya() {
                return u('iPhone') && !u('iPod') && !u('iPad')
              }
              function za(a, b) {
                var c = Aa
                return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : (c[a] = b(a))
              }
              var Ba = u('Opera'),
                v = u('Trident') || u('MSIE'),
                Ca = u('Edge'),
                Da =
                  u('Gecko') &&
                  !(-1 != t.toLowerCase().indexOf('webkit') && !u('Edge')) &&
                  !(u('Trident') || u('MSIE')) &&
                  !u('Edge'),
                Ea = -1 != t.toLowerCase().indexOf('webkit') && !u('Edge')
              function Fa() {
                var a = k.document
                return a ? a.documentMode : void 0
              }
              var Ga
              a: {
                var Ha = '',
                  Ia = (function () {
                    var a = t
                    if (Da) return /rv:([^\);]+)(\)|;)/.exec(a)
                    if (Ca) return /Edge\/([\d\.]+)/.exec(a)
                    if (v) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
                    if (Ea) return /WebKit\/(\S+)/.exec(a)
                    if (Ba) return /(?:Version)[ \/]?(\S+)/.exec(a)
                  })()
                Ia && (Ha = Ia ? Ia[1] : '')
                if (v) {
                  var Ja = Fa()
                  if (null != Ja && Ja > parseFloat(Ha)) {
                    Ga = String(Ja)
                    break a
                  }
                }
                Ga = Ha
              }
              var Aa = {}
              function Ka(a) {
                return za(a, function () {
                  for (
                    var b = 0,
                      c = ra(String(Ga)).split('.'),
                      d = ra(String(a)).split('.'),
                      e = Math.max(c.length, d.length),
                      f = 0;
                    0 == b && f < e;
                    f++
                  ) {
                    var g = c[f] || '',
                      h = d[f] || ''
                    do {
                      g = /(\d*)(\D*)(.*)/.exec(g) || ['', '', '', '']
                      h = /(\d*)(\D*)(.*)/.exec(h) || ['', '', '', '']
                      if (0 == g[0].length && 0 == h[0].length) break
                      b =
                        sa(
                          0 == g[1].length ? 0 : parseInt(g[1], 10),
                          0 == h[1].length ? 0 : parseInt(h[1], 10)
                        ) ||
                        sa(0 == g[2].length, 0 == h[2].length) ||
                        sa(g[2], h[2])
                      g = g[3]
                      h = h[3]
                    } while (0 == b)
                  }
                  return 0 <= b
                })
              }
              var La
              La = k.document && v ? Fa() : void 0
              var x = v && !(9 <= Number(La)),
                Ma = v && !(8 <= Number(La))
              function Na(a, b, c, d) {
                this.a = a
                this.nodeName = c
                this.nodeValue = d
                this.nodeType = 2
                this.parentNode = this.ownerElement = b
              }
              function Oa(a, b) {
                var c = Ma && 'href' == b.nodeName ? a.getAttribute(b.nodeName, 2) : b.nodeValue
                return new Na(b, a, b.nodeName, c)
              }
              function Pa(a) {
                this.b = a
                this.a = 0
              }
              function Qa(a) {
                a = a.match(Ra)
                for (var b = 0; b < a.length; b++) Sa.test(a[b]) && a.splice(b, 1)
                return new Pa(a)
              }
              var Ra =
                  /\$?(?:(?![0-9-\.])(?:\*|[\w-\.]+):)?(?![0-9-\.])(?:\*|[\w-\.]+)|\/\/|\.\.|::|\d+(?:\.\d*)?|\.\d+|"[^"]*"|'[^']*'|[!<>]=|\s+|./g,
                Sa = /^\s/
              function y(a, b) {
                return a.b[a.a + (b || 0)]
              }
              function z(a) {
                return a.b[a.a++]
              }
              function Ta(a) {
                return a.b.length <= a.a
              }
              function Ua(a, b) {
                this.x = void 0 !== a ? a : 0
                this.y = void 0 !== b ? b : 0
              }
              Ua.prototype.ceil = function () {
                this.x = Math.ceil(this.x)
                this.y = Math.ceil(this.y)
                return this
              }
              Ua.prototype.floor = function () {
                this.x = Math.floor(this.x)
                this.y = Math.floor(this.y)
                return this
              }
              Ua.prototype.round = function () {
                this.x = Math.round(this.x)
                this.y = Math.round(this.y)
                return this
              }
              function Va(a, b) {
                this.width = a
                this.height = b
              }
              Va.prototype.aspectRatio = function () {
                return this.width / this.height
              }
              Va.prototype.ceil = function () {
                this.width = Math.ceil(this.width)
                this.height = Math.ceil(this.height)
                return this
              }
              Va.prototype.floor = function () {
                this.width = Math.floor(this.width)
                this.height = Math.floor(this.height)
                return this
              }
              Va.prototype.round = function () {
                this.width = Math.round(this.width)
                this.height = Math.round(this.height)
                return this
              }
              function Wa(a, b) {
                if (!a || !b) return !1
                if (a.contains && 1 == b.nodeType) return a == b || a.contains(b)
                if ('undefined' != typeof a.compareDocumentPosition)
                  return a == b || !!(a.compareDocumentPosition(b) & 16)
                for (; b && a != b; ) b = b.parentNode
                return b == a
              }
              function Xa(a, b) {
                if (a == b) return 0
                if (a.compareDocumentPosition) return a.compareDocumentPosition(b) & 2 ? 1 : -1
                if (v && !(9 <= Number(La))) {
                  if (9 == a.nodeType) return -1
                  if (9 == b.nodeType) return 1
                }
                if ('sourceIndex' in a || (a.parentNode && 'sourceIndex' in a.parentNode)) {
                  var c = 1 == a.nodeType,
                    d = 1 == b.nodeType
                  if (c && d) return a.sourceIndex - b.sourceIndex
                  var e = a.parentNode,
                    f = b.parentNode
                  return e == f
                    ? Ya(a, b)
                    : !c && Wa(e, b)
                    ? -1 * Za(a, b)
                    : !d && Wa(f, a)
                    ? Za(b, a)
                    : (c ? a.sourceIndex : e.sourceIndex) - (d ? b.sourceIndex : f.sourceIndex)
                }
                d = A(a)
                c = d.createRange()
                c.selectNode(a)
                c.collapse(!0)
                a = d.createRange()
                a.selectNode(b)
                a.collapse(!0)
                return c.compareBoundaryPoints(k.Range.START_TO_END, a)
              }
              function Za(a, b) {
                var c = a.parentNode
                if (c == b) return -1
                for (; b.parentNode != c; ) b = b.parentNode
                return Ya(b, a)
              }
              function Ya(a, b) {
                for (; (b = b.previousSibling); ) if (b == a) return -1
                return 1
              }
              function A(a) {
                return 9 == a.nodeType ? a : a.ownerDocument || a.document
              }
              function $a(a, b) {
                a && (a = a.parentNode)
                for (var c = 0; a; ) {
                  if (b(a)) return a
                  a = a.parentNode
                  c++
                }
                return null
              }
              function ab(a) {
                this.a = a || k.document || document
              }
              ab.prototype.getElementsByTagName = function (a, b) {
                return (b || this.a).getElementsByTagName(String(a))
              }
              function B(a) {
                var b = null,
                  c = a.nodeType
                1 == c &&
                  ((b = a.textContent),
                  (b = void 0 == b || null == b ? a.innerText : b),
                  (b = void 0 == b || null == b ? '' : b))
                if ('string' != typeof b)
                  if (x && 'title' == a.nodeName.toLowerCase() && 1 == c) b = a.text
                  else if (9 == c || 1 == c) {
                    a = 9 == c ? a.documentElement : a.firstChild
                    c = 0
                    var d = []
                    for (b = ''; a; ) {
                      do
                        1 != a.nodeType && (b += a.nodeValue),
                          x && 'title' == a.nodeName.toLowerCase() && (b += a.text),
                          (d[c++] = a)
                      while ((a = a.firstChild))
                      for (; c && !(a = d[--c].nextSibling); );
                    }
                  } else b = a.nodeValue
                return b
              }
              function C(a, b, c) {
                if (null === b) return !0
                try {
                  if (!a.getAttribute) return !1
                } catch (d) {
                  return !1
                }
                Ma && 'class' == b && (b = 'className')
                return null == c ? !!a.getAttribute(b) : a.getAttribute(b, 2) == c
              }
              function bb(a, b, c, d, e) {
                return (x ? cb : db).call(
                  null,
                  a,
                  b,
                  aa(c) ? c : null,
                  aa(d) ? d : null,
                  e || new E()
                )
              }
              function cb(a, b, c, d, e) {
                if (a instanceof F || 8 == a.b || (c && null === a.b)) {
                  var f = b.all
                  if (!f) return e
                  a = eb(a)
                  if ('*' != a && ((f = b.getElementsByTagName(a)), !f)) return e
                  if (c) {
                    for (var g = [], h = 0; (b = f[h++]); ) C(b, c, d) && g.push(b)
                    f = g
                  }
                  for (h = 0; (b = f[h++]); ) ('*' == a && '!' == b.tagName) || e.add(b)
                  return e
                }
                gb(a, b, c, d, e)
                return e
              }
              function db(a, b, c, d, e) {
                b.getElementsByName && d && 'name' == c && !v
                  ? ((b = b.getElementsByName(d)),
                    n(b, function (f) {
                      a.a(f) && e.add(f)
                    }))
                  : b.getElementsByClassName && d && 'class' == c
                  ? ((b = b.getElementsByClassName(d)),
                    n(b, function (f) {
                      f.className == d && a.a(f) && e.add(f)
                    }))
                  : a instanceof G
                  ? gb(a, b, c, d, e)
                  : b.getElementsByTagName &&
                    ((b = b.getElementsByTagName(a.f())),
                    n(b, function (f) {
                      C(f, c, d) && e.add(f)
                    }))
                return e
              }
              function hb(a, b, c, d, e) {
                var f
                if ((a instanceof F || 8 == a.b || (c && null === a.b)) && (f = b.childNodes)) {
                  var g = eb(a)
                  if (
                    '*' != g &&
                    ((f = ka(f, function (h) {
                      return h.tagName && h.tagName.toLowerCase() == g
                    })),
                    !f)
                  )
                    return e
                  c &&
                    (f = ka(f, function (h) {
                      return C(h, c, d)
                    }))
                  n(f, function (h) {
                    ;('*' == g && ('!' == h.tagName || ('*' == g && 1 != h.nodeType))) || e.add(h)
                  })
                  return e
                }
                return ib(a, b, c, d, e)
              }
              function ib(a, b, c, d, e) {
                for (b = b.firstChild; b; b = b.nextSibling) C(b, c, d) && a.a(b) && e.add(b)
                return e
              }
              function gb(a, b, c, d, e) {
                for (b = b.firstChild; b; b = b.nextSibling)
                  C(b, c, d) && a.a(b) && e.add(b), gb(a, b, c, d, e)
              }
              function eb(a) {
                if (a instanceof G) {
                  if (8 == a.b) return '!'
                  if (null === a.b) return '*'
                }
                return a.f()
              }
              function E() {
                this.b = this.a = null
                this.l = 0
              }
              function jb(a) {
                this.f = a
                this.a = this.b = null
              }
              function kb(a, b) {
                if (!a.a) return b
                if (!b.a) return a
                var c = a.a
                b = b.a
                for (var d = null, e, f = 0; c && b; ) {
                  e = c.f
                  var g = b.f
                  e == g || (e instanceof Na && g instanceof Na && e.a == g.a)
                    ? ((e = c), (c = c.a), (b = b.a))
                    : 0 < Xa(c.f, b.f)
                    ? ((e = b), (b = b.a))
                    : ((e = c), (c = c.a))
                  ;(e.b = d) ? (d.a = e) : (a.a = e)
                  d = e
                  f++
                }
                for (e = c || b; e; ) (e.b = d), (d = d.a = e), f++, (e = e.a)
                a.b = d
                a.l = f
                return a
              }
              function lb(a, b) {
                b = new jb(b)
                b.a = a.a
                a.b ? (a.a.b = b) : (a.a = a.b = b)
                a.a = b
                a.l++
              }
              E.prototype.add = function (a) {
                a = new jb(a)
                a.b = this.b
                this.a ? (this.b.a = a) : (this.a = this.b = a)
                this.b = a
                this.l++
              }
              function mb(a) {
                return (a = a.a) ? a.f : null
              }
              function nb(a) {
                return (a = mb(a)) ? B(a) : ''
              }
              function H(a, b) {
                return new ob(a, !!b)
              }
              function ob(a, b) {
                this.f = a
                this.b = (this.s = b) ? a.b : a.a
                this.a = null
              }
              function I(a) {
                var b = a.b
                if (null == b) return null
                var c = (a.a = b)
                a.b = a.s ? b.b : b.a
                return c.f
              }
              function J(a) {
                this.i = a
                this.b = this.g = !1
                this.f = null
              }
              function K(a) {
                return '\n  ' + a.toString().split('\n').join('\n  ')
              }
              function pb(a, b) {
                a.g = b
              }
              function qb(a, b) {
                a.b = b
              }
              function N(a, b) {
                a = a.a(b)
                return a instanceof E ? +nb(a) : +a
              }
              function O(a, b) {
                a = a.a(b)
                return a instanceof E ? nb(a) : '' + a
              }
              function rb(a, b) {
                a = a.a(b)
                return a instanceof E ? !!a.l : !!a
              }
              function sb(a, b, c) {
                J.call(this, a.i)
                this.c = a
                this.h = b
                this.o = c
                this.g = b.g || c.g
                this.b = b.b || c.b
                this.c == tb &&
                  (c.b || c.g || 4 == c.i || 0 == c.i || !b.f
                    ? b.b ||
                      b.g ||
                      4 == b.i ||
                      0 == b.i ||
                      !c.f ||
                      (this.f = { name: c.f.name, u: b })
                    : (this.f = { name: b.f.name, u: c }))
              }
              l(sb, J)
              function ub(a, b, c, d, e) {
                b = b.a(d)
                c = c.a(d)
                var f
                if (b instanceof E && c instanceof E) {
                  b = H(b)
                  for (d = I(b); d; d = I(b))
                    for (e = H(c), f = I(e); f; f = I(e)) if (a(B(d), B(f))) return !0
                  return !1
                }
                if (b instanceof E || c instanceof E) {
                  b instanceof E ? ((e = b), (d = c)) : ((e = c), (d = b))
                  f = H(e)
                  for (var g = typeof d, h = I(f); h; h = I(f)) {
                    switch (g) {
                      case 'number':
                        h = +B(h)
                        break
                      case 'boolean':
                        h = !!B(h)
                        break
                      case 'string':
                        h = B(h)
                        break
                      default:
                        throw Error('Illegal primitive type for comparison.')
                    }
                    if ((e == b && a(h, d)) || (e == c && a(d, h))) return !0
                  }
                  return !1
                }
                return e
                  ? 'boolean' == typeof b || 'boolean' == typeof c
                    ? a(!!b, !!c)
                    : 'number' == typeof b || 'number' == typeof c
                    ? a(+b, +c)
                    : a(b, c)
                  : a(+b, +c)
              }
              sb.prototype.a = function (a) {
                return this.c.m(this.h, this.o, a)
              }
              sb.prototype.toString = function () {
                var a = 'Binary Expression: ' + this.c
                a += K(this.h)
                return (a += K(this.o))
              }
              function vb(a, b, c, d) {
                this.I = a
                this.D = b
                this.i = c
                this.m = d
              }
              vb.prototype.toString = function () {
                return this.I
              }
              var wb = {}
              function P(a, b, c, d) {
                if (wb.hasOwnProperty(a)) throw Error('Binary operator already created: ' + a)
                a = new vb(a, b, c, d)
                return (wb[a.toString()] = a)
              }
              P('div', 6, 1, function (a, b, c) {
                return N(a, c) / N(b, c)
              })
              P('mod', 6, 1, function (a, b, c) {
                return N(a, c) % N(b, c)
              })
              P('*', 6, 1, function (a, b, c) {
                return N(a, c) * N(b, c)
              })
              P('+', 5, 1, function (a, b, c) {
                return N(a, c) + N(b, c)
              })
              P('-', 5, 1, function (a, b, c) {
                return N(a, c) - N(b, c)
              })
              P('<', 4, 2, function (a, b, c) {
                return ub(
                  function (d, e) {
                    return d < e
                  },
                  a,
                  b,
                  c
                )
              })
              P('>', 4, 2, function (a, b, c) {
                return ub(
                  function (d, e) {
                    return d > e
                  },
                  a,
                  b,
                  c
                )
              })
              P('<=', 4, 2, function (a, b, c) {
                return ub(
                  function (d, e) {
                    return d <= e
                  },
                  a,
                  b,
                  c
                )
              })
              P('>=', 4, 2, function (a, b, c) {
                return ub(
                  function (d, e) {
                    return d >= e
                  },
                  a,
                  b,
                  c
                )
              })
              var tb = P('=', 3, 2, function (a, b, c) {
                return ub(
                  function (d, e) {
                    return d == e
                  },
                  a,
                  b,
                  c,
                  !0
                )
              })
              P('!=', 3, 2, function (a, b, c) {
                return ub(
                  function (d, e) {
                    return d != e
                  },
                  a,
                  b,
                  c,
                  !0
                )
              })
              P('and', 2, 2, function (a, b, c) {
                return rb(a, c) && rb(b, c)
              })
              P('or', 1, 2, function (a, b, c) {
                return rb(a, c) || rb(b, c)
              })
              function xb(a, b) {
                if (b.a.length && 4 != a.i)
                  throw Error(
                    'Primary expression must evaluate to nodeset if filter has predicate(s).'
                  )
                J.call(this, a.i)
                this.c = a
                this.h = b
                this.g = a.g
                this.b = a.b
              }
              l(xb, J)
              xb.prototype.a = function (a) {
                a = this.c.a(a)
                return yb(this.h, a)
              }
              xb.prototype.toString = function () {
                var a = 'Filter:' + K(this.c)
                return (a += K(this.h))
              }
              function zb(a, b) {
                if (b.length < a.C)
                  throw Error(
                    'Function ' +
                      a.j +
                      ' expects at least' +
                      a.C +
                      ' arguments, ' +
                      b.length +
                      ' given'
                  )
                if (null !== a.B && b.length > a.B)
                  throw Error(
                    'Function ' +
                      a.j +
                      ' expects at most ' +
                      a.B +
                      ' arguments, ' +
                      b.length +
                      ' given'
                  )
                a.H &&
                  n(b, function (c, d) {
                    if (4 != c.i)
                      throw Error(
                        'Argument ' + d + ' to function ' + a.j + ' is not of type Nodeset: ' + c
                      )
                  })
                J.call(this, a.i)
                this.v = a
                this.c = b
                pb(
                  this,
                  a.g ||
                    ma(b, function (c) {
                      return c.g
                    })
                )
                qb(
                  this,
                  (a.G && !b.length) ||
                    (a.F && !!b.length) ||
                    ma(b, function (c) {
                      return c.b
                    })
                )
              }
              l(zb, J)
              zb.prototype.a = function (a) {
                return this.v.m.apply(null, pa(a, this.c))
              }
              zb.prototype.toString = function () {
                var a = 'Function: ' + this.v
                if (this.c.length) {
                  var b = la(
                    this.c,
                    function (c, d) {
                      return c + K(d)
                    },
                    'Arguments:'
                  )
                  a += K(b)
                }
                return a
              }
              function Ab(a, b, c, d, e, f, g, h) {
                this.j = a
                this.i = b
                this.g = c
                this.G = d
                this.F = !1
                this.m = e
                this.C = f
                this.B = void 0 !== g ? g : f
                this.H = !!h
              }
              Ab.prototype.toString = function () {
                return this.j
              }
              var Bb = {}
              function Q(a, b, c, d, e, f, g, h) {
                if (Bb.hasOwnProperty(a)) throw Error('Function already created: ' + a + '.')
                Bb[a] = new Ab(a, b, c, d, e, f, g, h)
              }
              Q(
                'boolean',
                2,
                !1,
                !1,
                function (a, b) {
                  return rb(b, a)
                },
                1
              )
              Q(
                'ceiling',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.ceil(N(b, a))
                },
                1
              )
              Q(
                'concat',
                3,
                !1,
                !1,
                function (a, b) {
                  return la(
                    qa(arguments, 1),
                    function (c, d) {
                      return c + O(d, a)
                    },
                    ''
                  )
                },
                2,
                null
              )
              Q(
                'contains',
                2,
                !1,
                !1,
                function (a, b, c) {
                  b = O(b, a)
                  a = O(c, a)
                  return -1 != b.indexOf(a)
                },
                2
              )
              Q(
                'count',
                1,
                !1,
                !1,
                function (a, b) {
                  return b.a(a).l
                },
                1,
                1,
                !0
              )
              Q(
                'false',
                2,
                !1,
                !1,
                function () {
                  return !1
                },
                0
              )
              Q(
                'floor',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.floor(N(b, a))
                },
                1
              )
              Q(
                'id',
                4,
                !1,
                !1,
                function (a, b) {
                  function c(h) {
                    if (x) {
                      var m = e.all[h]
                      if (m) {
                        if (m.nodeType && h == m.id) return m
                        if (m.length)
                          return oa(m, function (w) {
                            return h == w.id
                          })
                      }
                      return null
                    }
                    return e.getElementById(h)
                  }
                  var d = a.a,
                    e = 9 == d.nodeType ? d : d.ownerDocument
                  a = O(b, a).split(/\s+/)
                  var f = []
                  n(a, function (h) {
                    h = c(h)
                    !h || 0 <= ja(f, h) || f.push(h)
                  })
                  f.sort(Xa)
                  var g = new E()
                  n(f, function (h) {
                    g.add(h)
                  })
                  return g
                },
                1
              )
              Q(
                'lang',
                2,
                !1,
                !1,
                function () {
                  return !1
                },
                1
              )
              Q(
                'last',
                1,
                !0,
                !1,
                function (a) {
                  if (1 != arguments.length) throw Error('Function last expects ()')
                  return a.f
                },
                0
              )
              Q(
                'local-name',
                3,
                !1,
                !0,
                function (a, b) {
                  return (a = b ? mb(b.a(a)) : a.a) ? a.localName || a.nodeName.toLowerCase() : ''
                },
                0,
                1,
                !0
              )
              Q(
                'name',
                3,
                !1,
                !0,
                function (a, b) {
                  return (a = b ? mb(b.a(a)) : a.a) ? a.nodeName.toLowerCase() : ''
                },
                0,
                1,
                !0
              )
              Q(
                'namespace-uri',
                3,
                !0,
                !1,
                function () {
                  return ''
                },
                0,
                1,
                !0
              )
              Q(
                'normalize-space',
                3,
                !1,
                !0,
                function (a, b) {
                  return (b ? O(b, a) : B(a.a)).replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '')
                },
                0,
                1
              )
              Q(
                'not',
                2,
                !1,
                !1,
                function (a, b) {
                  return !rb(b, a)
                },
                1
              )
              Q(
                'number',
                1,
                !1,
                !0,
                function (a, b) {
                  return b ? N(b, a) : +B(a.a)
                },
                0,
                1
              )
              Q(
                'position',
                1,
                !0,
                !1,
                function (a) {
                  return a.b
                },
                0
              )
              Q(
                'round',
                1,
                !1,
                !1,
                function (a, b) {
                  return Math.round(N(b, a))
                },
                1
              )
              Q(
                'starts-with',
                2,
                !1,
                !1,
                function (a, b, c) {
                  b = O(b, a)
                  a = O(c, a)
                  return 0 == b.lastIndexOf(a, 0)
                },
                2
              )
              Q(
                'string',
                3,
                !1,
                !0,
                function (a, b) {
                  return b ? O(b, a) : B(a.a)
                },
                0,
                1
              )
              Q(
                'string-length',
                1,
                !1,
                !0,
                function (a, b) {
                  return (b ? O(b, a) : B(a.a)).length
                },
                0,
                1
              )
              Q(
                'substring',
                3,
                !1,
                !1,
                function (a, b, c, d) {
                  c = N(c, a)
                  if (isNaN(c) || Infinity == c || -Infinity == c) return ''
                  d = d ? N(d, a) : Infinity
                  if (isNaN(d) || -Infinity === d) return ''
                  c = Math.round(c) - 1
                  var e = Math.max(c, 0)
                  a = O(b, a)
                  return Infinity == d ? a.substring(e) : a.substring(e, c + Math.round(d))
                },
                2,
                3
              )
              Q(
                'substring-after',
                3,
                !1,
                !1,
                function (a, b, c) {
                  b = O(b, a)
                  a = O(c, a)
                  c = b.indexOf(a)
                  return -1 == c ? '' : b.substring(c + a.length)
                },
                2
              )
              Q(
                'substring-before',
                3,
                !1,
                !1,
                function (a, b, c) {
                  b = O(b, a)
                  a = O(c, a)
                  a = b.indexOf(a)
                  return -1 == a ? '' : b.substring(0, a)
                },
                2
              )
              Q(
                'sum',
                1,
                !1,
                !1,
                function (a, b) {
                  a = H(b.a(a))
                  b = 0
                  for (var c = I(a); c; c = I(a)) b += +B(c)
                  return b
                },
                1,
                1,
                !0
              )
              Q(
                'translate',
                3,
                !1,
                !1,
                function (a, b, c, d) {
                  b = O(b, a)
                  c = O(c, a)
                  var e = O(d, a)
                  a = {}
                  for (d = 0; d < c.length; d++) {
                    var f = c.charAt(d)
                    f in a || (a[f] = e.charAt(d))
                  }
                  c = ''
                  for (d = 0; d < b.length; d++) (f = b.charAt(d)), (c += f in a ? a[f] : f)
                  return c
                },
                3
              )
              Q(
                'true',
                2,
                !1,
                !1,
                function () {
                  return !0
                },
                0
              )
              function G(a, b) {
                this.h = a
                this.c = void 0 !== b ? b : null
                this.b = null
                switch (a) {
                  case 'comment':
                    this.b = 8
                    break
                  case 'text':
                    this.b = 3
                    break
                  case 'processing-instruction':
                    this.b = 7
                    break
                  case 'node':
                    break
                  default:
                    throw Error('Unexpected argument')
                }
              }
              function Cb(a) {
                return 'comment' == a || 'text' == a || 'processing-instruction' == a || 'node' == a
              }
              G.prototype.a = function (a) {
                return null === this.b || this.b == a.nodeType
              }
              G.prototype.f = function () {
                return this.h
              }
              G.prototype.toString = function () {
                var a = 'Kind Test: ' + this.h
                null === this.c || (a += K(this.c))
                return a
              }
              function Db(a) {
                J.call(this, 3)
                this.c = a.substring(1, a.length - 1)
              }
              l(Db, J)
              Db.prototype.a = function () {
                return this.c
              }
              Db.prototype.toString = function () {
                return 'Literal: ' + this.c
              }
              function F(a, b) {
                this.j = a.toLowerCase()
                a = '*' == this.j ? '*' : 'http://www.w3.org/1999/xhtml'
                this.c = b ? b.toLowerCase() : a
              }
              F.prototype.a = function (a) {
                var b = a.nodeType
                if (1 != b && 2 != b) return !1
                b = void 0 !== a.localName ? a.localName : a.nodeName
                return '*' != this.j && this.j != b.toLowerCase()
                  ? !1
                  : '*' == this.c
                  ? !0
                  : this.c ==
                    (a.namespaceURI ? a.namespaceURI.toLowerCase() : 'http://www.w3.org/1999/xhtml')
              }
              F.prototype.f = function () {
                return this.j
              }
              F.prototype.toString = function () {
                return (
                  'Name Test: ' +
                  ('http://www.w3.org/1999/xhtml' == this.c ? '' : this.c + ':') +
                  this.j
                )
              }
              function Eb(a) {
                J.call(this, 1)
                this.c = a
              }
              l(Eb, J)
              Eb.prototype.a = function () {
                return this.c
              }
              Eb.prototype.toString = function () {
                return 'Number: ' + this.c
              }
              function Fb(a, b) {
                J.call(this, a.i)
                this.h = a
                this.c = b
                this.g = a.g
                this.b = a.b
                1 == this.c.length &&
                  ((a = this.c[0]),
                  a.A ||
                    a.c != Gb ||
                    ((a = a.o), '*' != a.f() && (this.f = { name: a.f(), u: null })))
              }
              l(Fb, J)
              function Hb() {
                J.call(this, 4)
              }
              l(Hb, J)
              Hb.prototype.a = function (a) {
                var b = new E()
                a = a.a
                9 == a.nodeType ? b.add(a) : b.add(a.ownerDocument)
                return b
              }
              Hb.prototype.toString = function () {
                return 'Root Helper Expression'
              }
              function Ib() {
                J.call(this, 4)
              }
              l(Ib, J)
              Ib.prototype.a = function (a) {
                var b = new E()
                b.add(a.a)
                return b
              }
              Ib.prototype.toString = function () {
                return 'Context Helper Expression'
              }
              function Jb(a) {
                return '/' == a || '//' == a
              }
              Fb.prototype.a = function (a) {
                var b = this.h.a(a)
                if (!(b instanceof E)) throw Error('Filter expression must evaluate to nodeset.')
                a = this.c
                for (var c = 0, d = a.length; c < d && b.l; c++) {
                  var e = a[c],
                    f = H(b, e.c.s)
                  if (e.g || e.c != Kb)
                    if (e.g || e.c != Lb) {
                      var g = I(f)
                      for (b = e.a(new ia(g)); null != (g = I(f)); )
                        (g = e.a(new ia(g))), (b = kb(b, g))
                    } else (g = I(f)), (b = e.a(new ia(g)))
                  else {
                    for (
                      g = I(f);
                      (b = I(f)) &&
                      (!g.contains || g.contains(b)) &&
                      b.compareDocumentPosition(g) & 8;
                      g = b
                    );
                    b = e.a(new ia(g))
                  }
                }
                return b
              }
              Fb.prototype.toString = function () {
                var a = 'Path Expression:' + K(this.h)
                if (this.c.length) {
                  var b = la(
                    this.c,
                    function (c, d) {
                      return c + K(d)
                    },
                    'Steps:'
                  )
                  a += K(b)
                }
                return a
              }
              function Mb(a, b) {
                this.a = a
                this.s = !!b
              }
              function yb(a, b, c) {
                for (c = c || 0; c < a.a.length; c++)
                  for (var d = a.a[c], e = H(b), f = b.l, g, h = 0; (g = I(e)); h++) {
                    var m = a.s ? f - h : h + 1
                    g = d.a(new ia(g, m, f))
                    if ('number' == typeof g) m = m == g
                    else if ('string' == typeof g || 'boolean' == typeof g) m = !!g
                    else if (g instanceof E) m = 0 < g.l
                    else throw Error('Predicate.evaluate returned an unexpected type.')
                    if (!m) {
                      m = e
                      g = m.f
                      var w = m.a
                      if (!w) throw Error('Next must be called at least once before remove.')
                      var r = w.b
                      w = w.a
                      r ? (r.a = w) : (g.a = w)
                      w ? (w.b = r) : (g.b = r)
                      g.l--
                      m.a = null
                    }
                  }
                return b
              }
              Mb.prototype.toString = function () {
                return la(
                  this.a,
                  function (a, b) {
                    return a + K(b)
                  },
                  'Predicates:'
                )
              }
              function R(a, b, c, d) {
                J.call(this, 4)
                this.c = a
                this.o = b
                this.h = c || new Mb([])
                this.A = !!d
                b = this.h
                b = 0 < b.a.length ? b.a[0].f : null
                a.J &&
                  b &&
                  ((a = b.name), (a = x ? a.toLowerCase() : a), (this.f = { name: a, u: b.u }))
                a: {
                  a = this.h
                  for (b = 0; b < a.a.length; b++)
                    if (((c = a.a[b]), c.g || 1 == c.i || 0 == c.i)) {
                      a = !0
                      break a
                    }
                  a = !1
                }
                this.g = a
              }
              l(R, J)
              R.prototype.a = function (a) {
                var b = a.a,
                  c = this.f,
                  d = null,
                  e = null,
                  f = 0
                c && ((d = c.name), (e = c.u ? O(c.u, a) : null), (f = 1))
                if (this.A)
                  if (this.g || this.c != Nb)
                    if (((b = H(new R(Ob, new G('node')).a(a))), (c = I(b))))
                      for (a = this.m(c, d, e, f); null != (c = I(b)); )
                        a = kb(a, this.m(c, d, e, f))
                    else a = new E()
                  else (a = bb(this.o, b, d, e)), (a = yb(this.h, a, f))
                else a = this.m(a.a, d, e, f)
                return a
              }
              R.prototype.m = function (a, b, c, d) {
                a = this.c.v(this.o, a, b, c)
                return (a = yb(this.h, a, d))
              }
              R.prototype.toString = function () {
                var a = 'Step:' + K('Operator: ' + (this.A ? '//' : '/'))
                this.c.j && (a += K('Axis: ' + this.c))
                a += K(this.o)
                if (this.h.a.length) {
                  var b = la(
                    this.h.a,
                    function (c, d) {
                      return c + K(d)
                    },
                    'Predicates:'
                  )
                  a += K(b)
                }
                return a
              }
              function Pb(a, b, c, d) {
                this.j = a
                this.v = b
                this.s = c
                this.J = d
              }
              Pb.prototype.toString = function () {
                return this.j
              }
              var Qb = {}
              function S(a, b, c, d) {
                if (Qb.hasOwnProperty(a)) throw Error('Axis already created: ' + a)
                b = new Pb(a, b, c, !!d)
                return (Qb[a] = b)
              }
              S(
                'ancestor',
                function (a, b) {
                  for (var c = new E(); (b = b.parentNode); ) a.a(b) && lb(c, b)
                  return c
                },
                !0
              )
              S(
                'ancestor-or-self',
                function (a, b) {
                  var c = new E()
                  do a.a(b) && lb(c, b)
                  while ((b = b.parentNode))
                  return c
                },
                !0
              )
              var Gb = S(
                  'attribute',
                  function (a, b) {
                    var c = new E(),
                      d = a.f()
                    if ('style' == d && x && b.style)
                      return c.add(new Na(b.style, b, 'style', b.style.cssText)), c
                    var e = b.attributes
                    if (e)
                      if ((a instanceof G && null === a.b) || '*' == d)
                        for (a = 0; (d = e[a]); a++) x ? d.nodeValue && c.add(Oa(b, d)) : c.add(d)
                      else
                        (d = e.getNamedItem(d)) && (x ? d.nodeValue && c.add(Oa(b, d)) : c.add(d))
                    return c
                  },
                  !1
                ),
                Nb = S(
                  'child',
                  function (a, b, c, d, e) {
                    return (x ? hb : ib).call(
                      null,
                      a,
                      b,
                      aa(c) ? c : null,
                      aa(d) ? d : null,
                      e || new E()
                    )
                  },
                  !1,
                  !0
                )
              S('descendant', bb, !1, !0)
              var Ob = S(
                  'descendant-or-self',
                  function (a, b, c, d) {
                    var e = new E()
                    C(b, c, d) && a.a(b) && e.add(b)
                    return bb(a, b, c, d, e)
                  },
                  !1,
                  !0
                ),
                Kb = S(
                  'following',
                  function (a, b, c, d) {
                    var e = new E()
                    do
                      for (var f = b; (f = f.nextSibling); )
                        C(f, c, d) && a.a(f) && e.add(f), (e = bb(a, f, c, d, e))
                    while ((b = b.parentNode))
                    return e
                  },
                  !1,
                  !0
                )
              S(
                'following-sibling',
                function (a, b) {
                  for (var c = new E(); (b = b.nextSibling); ) a.a(b) && c.add(b)
                  return c
                },
                !1
              )
              S(
                'namespace',
                function () {
                  return new E()
                },
                !1
              )
              var Rb = S(
                  'parent',
                  function (a, b) {
                    var c = new E()
                    if (9 == b.nodeType) return c
                    if (2 == b.nodeType) return c.add(b.ownerElement), c
                    b = b.parentNode
                    a.a(b) && c.add(b)
                    return c
                  },
                  !1
                ),
                Lb = S(
                  'preceding',
                  function (a, b, c, d) {
                    var e = new E(),
                      f = []
                    do f.unshift(b)
                    while ((b = b.parentNode))
                    for (var g = 1, h = f.length; g < h; g++) {
                      var m = []
                      for (b = f[g]; (b = b.previousSibling); ) m.unshift(b)
                      for (var w = 0, r = m.length; w < r; w++)
                        (b = m[w]), C(b, c, d) && a.a(b) && e.add(b), (e = bb(a, b, c, d, e))
                    }
                    return e
                  },
                  !0,
                  !0
                )
              S(
                'preceding-sibling',
                function (a, b) {
                  for (var c = new E(); (b = b.previousSibling); ) a.a(b) && lb(c, b)
                  return c
                },
                !0
              )
              var Sb = S(
                'self',
                function (a, b) {
                  var c = new E()
                  a.a(b) && c.add(b)
                  return c
                },
                !1
              )
              function Tb(a) {
                J.call(this, 1)
                this.c = a
                this.g = a.g
                this.b = a.b
              }
              l(Tb, J)
              Tb.prototype.a = function (a) {
                return -N(this.c, a)
              }
              Tb.prototype.toString = function () {
                return 'Unary Expression: -' + K(this.c)
              }
              function Ub(a) {
                J.call(this, 4)
                this.c = a
                pb(
                  this,
                  ma(this.c, function (b) {
                    return b.g
                  })
                )
                qb(
                  this,
                  ma(this.c, function (b) {
                    return b.b
                  })
                )
              }
              l(Ub, J)
              Ub.prototype.a = function (a) {
                var b = new E()
                n(this.c, function (c) {
                  c = c.a(a)
                  if (!(c instanceof E)) throw Error('Path expression must evaluate to NodeSet.')
                  b = kb(b, c)
                })
                return b
              }
              Ub.prototype.toString = function () {
                return la(
                  this.c,
                  function (a, b) {
                    return a + K(b)
                  },
                  'Union Expression:'
                )
              }
              function Vb(a, b) {
                this.a = a
                this.b = b
              }
              function Yb(a) {
                for (var b, c = []; ; ) {
                  T(a, 'Missing right hand side of binary expression.')
                  b = Zb(a)
                  var d = z(a.a)
                  if (!d) break
                  var e = (d = wb[d] || null) && d.D
                  if (!e) {
                    a.a.a--
                    break
                  }
                  for (; c.length && e <= c[c.length - 1].D; ) b = new sb(c.pop(), c.pop(), b)
                  c.push(b, d)
                }
                for (; c.length; ) b = new sb(c.pop(), c.pop(), b)
                return b
              }
              function T(a, b) {
                if (Ta(a.a)) throw Error(b)
              }
              function $b(a, b) {
                a = z(a.a)
                if (a != b) throw Error('Bad token, expected: ' + b + ' got: ' + a)
              }
              function ac(a) {
                a = z(a.a)
                if (')' != a) throw Error('Bad token: ' + a)
              }
              function bc(a) {
                a = z(a.a)
                if (2 > a.length) throw Error('Unclosed literal string')
                return new Db(a)
              }
              function cc(a) {
                var b = []
                if (Jb(y(a.a))) {
                  var c = z(a.a)
                  var d = y(a.a)
                  if (
                    '/' == c &&
                    (Ta(a.a) ||
                      ('.' != d && '..' != d && '@' != d && '*' != d && !/(?![0-9])[\w]/.test(d)))
                  )
                    return new Hb()
                  d = new Hb()
                  T(a, 'Missing next location step.')
                  c = dc(a, c)
                  b.push(c)
                } else {
                  a: {
                    c = y(a.a)
                    d = c.charAt(0)
                    switch (d) {
                      case '$':
                        throw Error('Variable reference not allowed in HTML XPath')
                      case '(':
                        z(a.a)
                        c = Yb(a)
                        T(a, 'unclosed "("')
                        $b(a, ')')
                        break
                      case '"':
                      case "'":
                        c = bc(a)
                        break
                      default:
                        if (isNaN(+c))
                          if (!Cb(c) && /(?![0-9])[\w]/.test(d) && '(' == y(a.a, 1)) {
                            c = z(a.a)
                            c = Bb[c] || null
                            z(a.a)
                            for (d = []; ')' != y(a.a); ) {
                              T(a, 'Missing function argument list.')
                              d.push(Yb(a))
                              if (',' != y(a.a)) break
                              z(a.a)
                            }
                            T(a, 'Unclosed function argument list.')
                            ac(a)
                            c = new zb(c, d)
                          } else {
                            c = null
                            break a
                          }
                        else c = new Eb(+z(a.a))
                    }
                    '[' == y(a.a) && ((d = new Mb(ec(a))), (c = new xb(c, d)))
                  }
                  if (c)
                    if (Jb(y(a.a))) d = c
                    else return c
                  else (c = dc(a, '/')), (d = new Ib()), b.push(c)
                }
                for (; Jb(y(a.a)); )
                  (c = z(a.a)), T(a, 'Missing next location step.'), (c = dc(a, c)), b.push(c)
                return new Fb(d, b)
              }
              function dc(a, b) {
                if ('/' != b && '//' != b) throw Error('Step op should be "/" or "//"')
                if ('.' == y(a.a)) {
                  var c = new R(Sb, new G('node'))
                  z(a.a)
                  return c
                }
                if ('..' == y(a.a)) return (c = new R(Rb, new G('node'))), z(a.a), c
                if ('@' == y(a.a)) {
                  var d = Gb
                  z(a.a)
                  T(a, 'Missing attribute name')
                } else if ('::' == y(a.a, 1)) {
                  if (!/(?![0-9])[\w]/.test(y(a.a).charAt(0))) throw Error('Bad token: ' + z(a.a))
                  var e = z(a.a)
                  d = Qb[e] || null
                  if (!d) throw Error('No axis with name: ' + e)
                  z(a.a)
                  T(a, 'Missing node name')
                } else d = Nb
                e = y(a.a)
                if (/(?![0-9])[\w\*]/.test(e.charAt(0)))
                  if ('(' == y(a.a, 1)) {
                    if (!Cb(e)) throw Error('Invalid node type: ' + e)
                    e = z(a.a)
                    if (!Cb(e)) throw Error('Invalid type name: ' + e)
                    $b(a, '(')
                    T(a, 'Bad nodetype')
                    var f = y(a.a).charAt(0),
                      g = null
                    if ('"' == f || "'" == f) g = bc(a)
                    T(a, 'Bad nodetype')
                    ac(a)
                    e = new G(e, g)
                  } else if (((e = z(a.a)), (f = e.indexOf(':')), -1 == f)) e = new F(e)
                  else {
                    g = e.substring(0, f)
                    if ('*' == g) var h = '*'
                    else if (((h = a.b(g)), !h)) throw Error('Namespace prefix not declared: ' + g)
                    e = e.substr(f + 1)
                    e = new F(e, h)
                  }
                else throw Error('Bad token: ' + z(a.a))
                a = new Mb(ec(a), d.s)
                return c || new R(d, e, a, '//' == b)
              }
              function ec(a) {
                for (var b = []; '[' == y(a.a); ) {
                  z(a.a)
                  T(a, 'Missing predicate expression.')
                  var c = Yb(a)
                  b.push(c)
                  T(a, 'Unclosed predicate expression.')
                  $b(a, ']')
                }
                return b
              }
              function Zb(a) {
                if ('-' == y(a.a)) return z(a.a), new Tb(Zb(a))
                var b = cc(a)
                if ('|' != y(a.a)) a = b
                else {
                  for (b = [b]; '|' == z(a.a); )
                    T(a, 'Missing next union location path.'), b.push(cc(a))
                  a.a.a--
                  a = new Ub(b)
                }
                return a
              }
              function fc(a) {
                switch (a.nodeType) {
                  case 1:
                    return ha(gc, a)
                  case 9:
                    return fc(a.documentElement)
                  case 11:
                  case 10:
                  case 6:
                  case 12:
                    return hc
                  default:
                    return a.parentNode ? fc(a.parentNode) : hc
                }
              }
              function hc() {
                return null
              }
              function gc(a, b) {
                if (a.prefix == b) return a.namespaceURI || 'http://www.w3.org/1999/xhtml'
                var c = a.getAttributeNode('xmlns:' + b)
                return c && c.specified
                  ? c.value || null
                  : a.parentNode && 9 != a.parentNode.nodeType
                  ? gc(a.parentNode, b)
                  : null
              }
              function ic(a, b) {
                if (!a.length) throw Error('Empty XPath expression.')
                a = Qa(a)
                if (Ta(a)) throw Error('Invalid XPath expression.')
                b
                  ? 'function' == ca(b) || (b = fa(b.lookupNamespaceURI, b))
                  : (b = function () {
                      return null
                    })
                var c = Yb(new Vb(a, b))
                if (!Ta(a)) throw Error('Bad token: ' + z(a))
                this.evaluate = function (d, e) {
                  d = c.a(new ia(d))
                  return new U(d, e)
                }
              }
              function U(a, b) {
                if (0 == b)
                  if (a instanceof E) b = 4
                  else if ('string' == typeof a) b = 2
                  else if ('number' == typeof a) b = 1
                  else if ('boolean' == typeof a) b = 3
                  else throw Error('Unexpected evaluation result.')
                if (2 != b && 1 != b && 3 != b && !(a instanceof E))
                  throw Error('value could not be converted to the specified type')
                this.resultType = b
                switch (b) {
                  case 2:
                    this.stringValue = a instanceof E ? nb(a) : '' + a
                    break
                  case 1:
                    this.numberValue = a instanceof E ? +nb(a) : +a
                    break
                  case 3:
                    this.booleanValue = a instanceof E ? 0 < a.l : !!a
                    break
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    var c = H(a)
                    var d = []
                    for (var e = I(c); e; e = I(c)) d.push(e instanceof Na ? e.a : e)
                    this.snapshotLength = a.l
                    this.invalidIteratorState = !1
                    break
                  case 8:
                  case 9:
                    a = mb(a)
                    this.singleNodeValue = a instanceof Na ? a.a : a
                    break
                  default:
                    throw Error('Unknown XPathResult type.')
                }
                var f = 0
                this.iterateNext = function () {
                  if (4 != b && 5 != b) throw Error('iterateNext called with wrong result type')
                  return f >= d.length ? null : d[f++]
                }
                this.snapshotItem = function (g) {
                  if (6 != b && 7 != b) throw Error('snapshotItem called with wrong result type')
                  return g >= d.length || 0 > g ? null : d[g]
                }
              }
              U.ANY_TYPE = 0
              U.NUMBER_TYPE = 1
              U.STRING_TYPE = 2
              U.BOOLEAN_TYPE = 3
              U.UNORDERED_NODE_ITERATOR_TYPE = 4
              U.ORDERED_NODE_ITERATOR_TYPE = 5
              U.UNORDERED_NODE_SNAPSHOT_TYPE = 6
              U.ORDERED_NODE_SNAPSHOT_TYPE = 7
              U.ANY_UNORDERED_NODE_TYPE = 8
              U.FIRST_ORDERED_NODE_TYPE = 9
              function jc(a) {
                this.lookupNamespaceURI = fc(a)
              }
              function kc(a, b) {
                a = a || k
                var c = (a.Document && a.Document.prototype) || a.document
                if (!c.evaluate || b)
                  (a.XPathResult = U),
                    (c.evaluate = function (d, e, f, g) {
                      return new ic(d, f).evaluate(e, g)
                    }),
                    (c.createExpression = function (d, e) {
                      return new ic(d, e)
                    }),
                    (c.createNSResolver = function (d) {
                      return new jc(d)
                    })
              }
              ba('wgxpath.install', kc)
              ba('wgxpath.install', kc)
              var lc = {
                aliceblue: '#f0f8ff',
                antiquewhite: '#faebd7',
                aqua: '#00ffff',
                aquamarine: '#7fffd4',
                azure: '#f0ffff',
                beige: '#f5f5dc',
                bisque: '#ffe4c4',
                black: '#000000',
                blanchedalmond: '#ffebcd',
                blue: '#0000ff',
                blueviolet: '#8a2be2',
                brown: '#a52a2a',
                burlywood: '#deb887',
                cadetblue: '#5f9ea0',
                chartreuse: '#7fff00',
                chocolate: '#d2691e',
                coral: '#ff7f50',
                cornflowerblue: '#6495ed',
                cornsilk: '#fff8dc',
                crimson: '#dc143c',
                cyan: '#00ffff',
                darkblue: '#00008b',
                darkcyan: '#008b8b',
                darkgoldenrod: '#b8860b',
                darkgray: '#a9a9a9',
                darkgreen: '#006400',
                darkgrey: '#a9a9a9',
                darkkhaki: '#bdb76b',
                darkmagenta: '#8b008b',
                darkolivegreen: '#556b2f',
                darkorange: '#ff8c00',
                darkorchid: '#9932cc',
                darkred: '#8b0000',
                darksalmon: '#e9967a',
                darkseagreen: '#8fbc8f',
                darkslateblue: '#483d8b',
                darkslategray: '#2f4f4f',
                darkslategrey: '#2f4f4f',
                darkturquoise: '#00ced1',
                darkviolet: '#9400d3',
                deeppink: '#ff1493',
                deepskyblue: '#00bfff',
                dimgray: '#696969',
                dimgrey: '#696969',
                dodgerblue: '#1e90ff',
                firebrick: '#b22222',
                floralwhite: '#fffaf0',
                forestgreen: '#228b22',
                fuchsia: '#ff00ff',
                gainsboro: '#dcdcdc',
                ghostwhite: '#f8f8ff',
                gold: '#ffd700',
                goldenrod: '#daa520',
                gray: '#808080',
                green: '#008000',
                greenyellow: '#adff2f',
                grey: '#808080',
                honeydew: '#f0fff0',
                hotpink: '#ff69b4',
                indianred: '#cd5c5c',
                indigo: '#4b0082',
                ivory: '#fffff0',
                khaki: '#f0e68c',
                lavender: '#e6e6fa',
                lavenderblush: '#fff0f5',
                lawngreen: '#7cfc00',
                lemonchiffon: '#fffacd',
                lightblue: '#add8e6',
                lightcoral: '#f08080',
                lightcyan: '#e0ffff',
                lightgoldenrodyellow: '#fafad2',
                lightgray: '#d3d3d3',
                lightgreen: '#90ee90',
                lightgrey: '#d3d3d3',
                lightpink: '#ffb6c1',
                lightsalmon: '#ffa07a',
                lightseagreen: '#20b2aa',
                lightskyblue: '#87cefa',
                lightslategray: '#778899',
                lightslategrey: '#778899',
                lightsteelblue: '#b0c4de',
                lightyellow: '#ffffe0',
                lime: '#00ff00',
                limegreen: '#32cd32',
                linen: '#faf0e6',
                magenta: '#ff00ff',
                maroon: '#800000',
                mediumaquamarine: '#66cdaa',
                mediumblue: '#0000cd',
                mediumorchid: '#ba55d3',
                mediumpurple: '#9370db',
                mediumseagreen: '#3cb371',
                mediumslateblue: '#7b68ee',
                mediumspringgreen: '#00fa9a',
                mediumturquoise: '#48d1cc',
                mediumvioletred: '#c71585',
                midnightblue: '#191970',
                mintcream: '#f5fffa',
                mistyrose: '#ffe4e1',
                moccasin: '#ffe4b5',
                navajowhite: '#ffdead',
                navy: '#000080',
                oldlace: '#fdf5e6',
                olive: '#808000',
                olivedrab: '#6b8e23',
                orange: '#ffa500',
                orangered: '#ff4500',
                orchid: '#da70d6',
                palegoldenrod: '#eee8aa',
                palegreen: '#98fb98',
                paleturquoise: '#afeeee',
                palevioletred: '#db7093',
                papayawhip: '#ffefd5',
                peachpuff: '#ffdab9',
                peru: '#cd853f',
                pink: '#ffc0cb',
                plum: '#dda0dd',
                powderblue: '#b0e0e6',
                purple: '#800080',
                red: '#ff0000',
                rosybrown: '#bc8f8f',
                royalblue: '#4169e1',
                saddlebrown: '#8b4513',
                salmon: '#fa8072',
                sandybrown: '#f4a460',
                seagreen: '#2e8b57',
                seashell: '#fff5ee',
                sienna: '#a0522d',
                silver: '#c0c0c0',
                skyblue: '#87ceeb',
                slateblue: '#6a5acd',
                slategray: '#708090',
                slategrey: '#708090',
                snow: '#fffafa',
                springgreen: '#00ff7f',
                steelblue: '#4682b4',
                tan: '#d2b48c',
                teal: '#008080',
                thistle: '#d8bfd8',
                tomato: '#ff6347',
                turquoise: '#40e0d0',
                violet: '#ee82ee',
                wheat: '#f5deb3',
                white: '#ffffff',
                whitesmoke: '#f5f5f5',
                yellow: '#ffff00',
                yellowgreen: '#9acd32'
              }
              var mc =
                  'backgroundColor borderTopColor borderRightColor borderBottomColor borderLeftColor color outlineColor'.split(
                    ' '
                  ),
                nc = /#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])/,
                oc = /^#(?:[0-9a-f]{3}){1,2}$/i,
                pc = /^(?:rgba)?\((\d{1,3}),\s?(\d{1,3}),\s?(\d{1,3}),\s?(0|1|0\.\d*)\)$/i,
                qc = /^(?:rgb)?\((0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2})\)$/i
              function rc(a, b) {
                this.code = a
                this.a = V[a] || sc
                this.message = b || ''
                a = this.a.replace(/((?:^|\s+)[a-z])/g, function (c) {
                  return c.toUpperCase().replace(/^[\s\xa0]+/g, '')
                })
                b = a.length - 5
                if (0 > b || a.indexOf('Error', b) != b) a += 'Error'
                this.name = a
                a = Error(this.message)
                a.name = this.name
                this.stack = a.stack || ''
              }
              l(rc, Error)
              var sc = 'unknown error',
                V = { 15: 'element not selectable', 11: 'element not visible' }
              V[31] = sc
              V[30] = sc
              V[24] = 'invalid cookie domain'
              V[29] = 'invalid element coordinates'
              V[12] = 'invalid element state'
              V[32] = 'invalid selector'
              V[51] = 'invalid selector'
              V[52] = 'invalid selector'
              V[17] = 'javascript error'
              V[405] = 'unsupported operation'
              V[34] = 'move target out of bounds'
              V[27] = 'no such alert'
              V[7] = 'no such element'
              V[8] = 'no such frame'
              V[23] = 'no such window'
              V[28] = 'script timeout'
              V[33] = 'session not created'
              V[10] = 'stale element reference'
              V[21] = 'timeout'
              V[25] = 'unable to set cookie'
              V[26] = 'unexpected alert open'
              V[13] = sc
              V[9] = 'unknown command'
              var tc = va(),
                uc = ya() || u('iPod'),
                vc = u('iPad'),
                wc = u('Android') && !(wa() || va() || u('Opera') || u('Silk')),
                xc = wa(),
                yc =
                  u('Safari') &&
                  !(
                    wa() ||
                    u('Coast') ||
                    u('Opera') ||
                    u('Edge') ||
                    u('Edg/') ||
                    u('OPR') ||
                    va() ||
                    u('Silk') ||
                    u('Android')
                  ) &&
                  !(ya() || u('iPad') || u('iPod'))
              function zc(a) {
                return (a = a.exec(t)) ? a[1] : ''
              }
              ;(function () {
                if (tc) return zc(/Firefox\/([0-9.]+)/)
                if (v || Ca || Ba) return Ga
                if (xc)
                  return ya() || u('iPad') || u('iPod')
                    ? zc(/CriOS\/([0-9.]+)/)
                    : zc(/Chrome\/([0-9.]+)/)
                if (yc && !(ya() || u('iPad') || u('iPod'))) return zc(/Version\/([0-9.]+)/)
                if (uc || vc) {
                  var a = /Version\/(\S+).*Mobile\/(\S+)/.exec(t)
                  if (a) return a[1] + '.' + a[2]
                } else if (wc) return (a = zc(/Android\s+([0-9.]+)/)) ? a : zc(/Version\/([0-9.]+)/)
                return ''
              })()
              var Ac = v && !(9 <= Number(La))
              function W(a, b) {
                b && 'string' !== typeof b && (b = b.toString())
                return !!a && 1 == a.nodeType && (!b || a.tagName.toUpperCase() == b)
              }
              var Bc = (function () {
                var a = { K: 'http://www.w3.org/2000/svg' }
                return function (b) {
                  return a[b] || null
                }
              })()
              function Cc(a, b) {
                var c = A(a)
                if (!c.documentElement) return null
                ;(v || wc) && kc(c ? c.parentWindow || c.defaultView : window)
                try {
                  var d = c.createNSResolver ? c.createNSResolver(c.documentElement) : Bc
                  if (v && !Ka(7)) return c.evaluate.call(c, b, a, d, 9, null)
                  if (!v || 9 <= Number(La)) {
                    for (var e = {}, f = c.getElementsByTagName('*'), g = 0; g < f.length; ++g) {
                      var h = f[g],
                        m = h.namespaceURI
                      if (m && !e[m]) {
                        var w = h.lookupPrefix(m)
                        if (!w) {
                          var r = m.match('.*/(\\w+)/?$')
                          w = r ? r[1] : 'xhtml'
                        }
                        e[m] = w
                      }
                    }
                    var D = {},
                      L
                    for (L in e) D[e[L]] = L
                    d = function (M) {
                      return D[M] || null
                    }
                  }
                  try {
                    return c.evaluate(b, a, d, 9, null)
                  } catch (M) {
                    if ('TypeError' === M.name)
                      return (
                        (d = c.createNSResolver ? c.createNSResolver(c.documentElement) : Bc),
                        c.evaluate(b, a, d, 9, null)
                      )
                    throw M
                  }
                } catch (M) {
                  if (!Da || 'NS_ERROR_ILLEGAL_VALUE' != M.name)
                    throw new rc(
                      32,
                      'Unable to locate an element with the xpath expression ' +
                        b +
                        ' because of the following error:\n' +
                        M
                    )
                }
              }
              function Dc(a, b) {
                var c = (function () {
                  var d = Cc(b, a)
                  return d
                    ? d.singleNodeValue || null
                    : b.selectSingleNode
                    ? ((d = A(b)),
                      d.setProperty && d.setProperty('SelectionLanguage', 'XPath'),
                      b.selectSingleNode(a))
                    : null
                })()
                if (null !== c && (!c || 1 != c.nodeType))
                  throw new rc(
                    32,
                    'The result of the xpath expression "' +
                      a +
                      '" is: ' +
                      c +
                      '. It should be an element.'
                  )
                return c
              }
              function Ec(a, b, c, d) {
                this.c = a
                this.a = b
                this.b = c
                this.f = d
              }
              Ec.prototype.ceil = function () {
                this.c = Math.ceil(this.c)
                this.a = Math.ceil(this.a)
                this.b = Math.ceil(this.b)
                this.f = Math.ceil(this.f)
                return this
              }
              Ec.prototype.floor = function () {
                this.c = Math.floor(this.c)
                this.a = Math.floor(this.a)
                this.b = Math.floor(this.b)
                this.f = Math.floor(this.f)
                return this
              }
              Ec.prototype.round = function () {
                this.c = Math.round(this.c)
                this.a = Math.round(this.a)
                this.b = Math.round(this.b)
                this.f = Math.round(this.f)
                return this
              }
              function X(a, b, c, d) {
                this.a = a
                this.b = b
                this.width = c
                this.height = d
              }
              X.prototype.ceil = function () {
                this.a = Math.ceil(this.a)
                this.b = Math.ceil(this.b)
                this.width = Math.ceil(this.width)
                this.height = Math.ceil(this.height)
                return this
              }
              X.prototype.floor = function () {
                this.a = Math.floor(this.a)
                this.b = Math.floor(this.b)
                this.width = Math.floor(this.width)
                this.height = Math.floor(this.height)
                return this
              }
              X.prototype.round = function () {
                this.a = Math.round(this.a)
                this.b = Math.round(this.b)
                this.width = Math.round(this.width)
                this.height = Math.round(this.height)
                return this
              }
              var Fc = 'function' === typeof ShadowRoot
              function Gc(a) {
                for (
                  a = a.parentNode;
                  a && 1 != a.nodeType && 9 != a.nodeType && 11 != a.nodeType;

                )
                  a = a.parentNode
                return W(a) ? a : null
              }
              function Y(a, b) {
                b = xa(b)
                if ('float' == b || 'cssFloat' == b || 'styleFloat' == b)
                  b = Ac ? 'styleFloat' : 'cssFloat'
                a: {
                  var c = b
                  var d = A(a)
                  if (
                    d.defaultView &&
                    d.defaultView.getComputedStyle &&
                    (d = d.defaultView.getComputedStyle(a, null))
                  ) {
                    c = d[c] || d.getPropertyValue(c) || ''
                    break a
                  }
                  c = ''
                }
                a = c || Hc(a, b)
                if (null === a) a = null
                else if (0 <= ja(mc, b)) {
                  b: {
                    var e = a.match(pc)
                    if (
                      e &&
                      ((b = Number(e[1])),
                      (c = Number(e[2])),
                      (d = Number(e[3])),
                      (e = Number(e[4])),
                      0 <= b &&
                        255 >= b &&
                        0 <= c &&
                        255 >= c &&
                        0 <= d &&
                        255 >= d &&
                        0 <= e &&
                        1 >= e)
                    ) {
                      b = [b, c, d, e]
                      break b
                    }
                    b = null
                  }
                  if (!b)
                    b: {
                      if ((d = a.match(qc)))
                        if (
                          ((b = Number(d[1])),
                          (c = Number(d[2])),
                          (d = Number(d[3])),
                          0 <= b && 255 >= b && 0 <= c && 255 >= c && 0 <= d && 255 >= d)
                        ) {
                          b = [b, c, d, 1]
                          break b
                        }
                      b = null
                    }
                  if (!b)
                    b: {
                      b = a.toLowerCase()
                      c = lc[b.toLowerCase()]
                      if (
                        !c &&
                        ((c = '#' == b.charAt(0) ? b : '#' + b),
                        4 == c.length && (c = c.replace(nc, '#$1$1$2$2$3$3')),
                        !oc.test(c))
                      ) {
                        b = null
                        break b
                      }
                      b = [
                        parseInt(c.substr(1, 2), 16),
                        parseInt(c.substr(3, 2), 16),
                        parseInt(c.substr(5, 2), 16),
                        1
                      ]
                    }
                  a = b ? 'rgba(' + b.join(', ') + ')' : a
                }
                return a
              }
              function Hc(a, b) {
                var c = a.currentStyle || a.style,
                  d = c[b]
                void 0 === d && 'function' == ca(c.getPropertyValue) && (d = c.getPropertyValue(b))
                return 'inherit' != d ? (void 0 !== d ? d : null) : (a = Gc(a)) ? Hc(a, b) : null
              }
              function Ic(a, b, c) {
                function d(g) {
                  var h = Jc(g)
                  return 0 < h.height && 0 < h.width
                    ? !0
                    : W(g, 'PATH') && (0 < h.height || 0 < h.width)
                    ? ((g = Y(g, 'stroke-width')), !!g && 0 < parseInt(g, 10))
                    : 'hidden' != Y(g, 'overflow') &&
                      ma(g.childNodes, function (m) {
                        return 3 == m.nodeType || (W(m) && d(m))
                      })
                }
                function e(g) {
                  return (
                    Kc(g) == Z &&
                    na(g.childNodes, function (h) {
                      return !W(h) || e(h) || !d(h)
                    })
                  )
                }
                if (!W(a)) throw Error('Argument to isShown must be of type Element')
                if (W(a, 'BODY')) return !0
                if (W(a, 'OPTION') || W(a, 'OPTGROUP'))
                  return (
                    (a = $a(a, function (g) {
                      return W(g, 'SELECT')
                    })),
                    !!a && Ic(a, !0, c)
                  )
                var f = Lc(a)
                if (f)
                  return !!f.image && 0 < f.rect.width && 0 < f.rect.height && Ic(f.image, b, c)
                if ((W(a, 'INPUT') && 'hidden' == a.type.toLowerCase()) || W(a, 'NOSCRIPT'))
                  return !1
                f = Y(a, 'visibility')
                return 'collapse' != f && 'hidden' != f && c(a) && (b || 0 != Mc(a)) && d(a)
                  ? !e(a)
                  : !1
              }
              var Z = 'hidden'
              function Kc(a) {
                function b(p) {
                  function q(fb) {
                    if (fb == g) return !0
                    var Wb = Y(fb, 'display')
                    return 0 == Wb.lastIndexOf('inline', 0) ||
                      'contents' == Wb ||
                      ('absolute' == Xb && 'static' == Y(fb, 'position'))
                      ? !1
                      : !0
                  }
                  var Xb = Y(p, 'position')
                  if ('fixed' == Xb) return (w = !0), p == g ? null : g
                  for (p = Gc(p); p && !q(p); ) p = Gc(p)
                  return p
                }
                function c(p) {
                  var q = p
                  if ('visible' == m)
                    if (p == g && h) q = h
                    else if (p == h) return { x: 'visible', y: 'visible' }
                  q = { x: Y(q, 'overflow-x'), y: Y(q, 'overflow-y') }
                  p == g &&
                    ((q.x = 'visible' == q.x ? 'auto' : q.x),
                    (q.y = 'visible' == q.y ? 'auto' : q.y))
                  return q
                }
                function d(p) {
                  if (p == g) {
                    var q = new ab(f).a
                    p = q.scrollingElement
                      ? q.scrollingElement
                      : Ea || 'CSS1Compat' != q.compatMode
                      ? q.body || q.documentElement
                      : q.documentElement
                    q = q.parentWindow || q.defaultView
                    p =
                      v && Ka('10') && q.pageYOffset != p.scrollTop
                        ? new Ua(p.scrollLeft, p.scrollTop)
                        : new Ua(q.pageXOffset || p.scrollLeft, q.pageYOffset || p.scrollTop)
                  } else p = new Ua(p.scrollLeft, p.scrollTop)
                  return p
                }
                var e = Nc(a),
                  f = A(a),
                  g = f.documentElement,
                  h = f.body,
                  m = Y(g, 'overflow'),
                  w
                for (a = b(a); a; a = b(a)) {
                  var r = c(a)
                  if ('visible' != r.x || 'visible' != r.y) {
                    var D = Jc(a)
                    if (0 == D.width || 0 == D.height) return Z
                    var L = e.a < D.a,
                      M = e.b < D.b
                    if ((L && 'hidden' == r.x) || (M && 'hidden' == r.y)) return Z
                    if ((L && 'visible' != r.x) || (M && 'visible' != r.y)) {
                      L = d(a)
                      M = e.b < D.b - L.y
                      if ((e.a < D.a - L.x && 'visible' != r.x) || (M && 'visible' != r.x)) return Z
                      e = Kc(a)
                      return e == Z ? Z : 'scroll'
                    }
                    L = e.f >= D.a + D.width
                    D = e.c >= D.b + D.height
                    if ((L && 'hidden' == r.x) || (D && 'hidden' == r.y)) return Z
                    if ((L && 'visible' != r.x) || (D && 'visible' != r.y)) {
                      if (
                        w &&
                        ((r = d(a)), e.f >= g.scrollWidth - r.x || e.a >= g.scrollHeight - r.y)
                      )
                        return Z
                      e = Kc(a)
                      return e == Z ? Z : 'scroll'
                    }
                  }
                }
                return 'none'
              }
              function Jc(a) {
                var b = Lc(a)
                if (b) return b.rect
                if (W(a, 'HTML'))
                  return (
                    (a = A(a)),
                    (a = ((a ? a.parentWindow || a.defaultView : window) || window).document),
                    (a = 'CSS1Compat' == a.compatMode ? a.documentElement : a.body),
                    (a = new Va(a.clientWidth, a.clientHeight)),
                    new X(0, 0, a.width, a.height)
                  )
                try {
                  var c = a.getBoundingClientRect()
                } catch (d) {
                  return new X(0, 0, 0, 0)
                }
                b = new X(c.left, c.top, c.right - c.left, c.bottom - c.top)
                v &&
                  a.ownerDocument.body &&
                  ((a = A(a)),
                  (b.a -= a.documentElement.clientLeft + a.body.clientLeft),
                  (b.b -= a.documentElement.clientTop + a.body.clientTop))
                return b
              }
              function Lc(a) {
                var b = W(a, 'MAP')
                if (!b && !W(a, 'AREA')) return null
                var c = b ? a : W(a.parentNode, 'MAP') ? a.parentNode : null,
                  d = null,
                  e = null
                c &&
                  c.name &&
                  (d = Dc('/descendant::*[@usemap = "#' + c.name + '"]', A(c))) &&
                  ((e = Jc(d)),
                  b ||
                    'default' == a.shape.toLowerCase() ||
                    ((a = Oc(a)),
                    (b = Math.min(Math.max(a.a, 0), e.width)),
                    (c = Math.min(Math.max(a.b, 0), e.height)),
                    (e = new X(
                      b + e.a,
                      c + e.b,
                      Math.min(a.width, e.width - b),
                      Math.min(a.height, e.height - c)
                    ))))
                return { image: d, rect: e || new X(0, 0, 0, 0) }
              }
              function Oc(a) {
                var b = a.shape.toLowerCase()
                a = a.coords.split(',')
                if ('rect' == b && 4 == a.length) {
                  b = a[0]
                  var c = a[1]
                  return new X(b, c, a[2] - b, a[3] - c)
                }
                if ('circle' == b && 3 == a.length)
                  return (b = a[2]), new X(a[0] - b, a[1] - b, 2 * b, 2 * b)
                if ('poly' == b && 2 < a.length) {
                  b = a[0]
                  c = a[1]
                  for (var d = b, e = c, f = 2; f + 1 < a.length; f += 2)
                    (b = Math.min(b, a[f])),
                      (d = Math.max(d, a[f])),
                      (c = Math.min(c, a[f + 1])),
                      (e = Math.max(e, a[f + 1]))
                  return new X(b, c, d - b, e - c)
                }
                return new X(0, 0, 0, 0)
              }
              function Nc(a) {
                a = Jc(a)
                return new Ec(a.b, a.a + a.width, a.b + a.height, a.a)
              }
              function Mc(a) {
                if (Ac) {
                  if ('relative' == Y(a, 'position')) return 1
                  a = Y(a, 'filter')
                  return (a =
                    a.match(/^alpha\(opacity=(\d*)\)/) ||
                    a.match(/^progid:DXImageTransform.Microsoft.Alpha\(Opacity=(\d*)\)/))
                    ? Number(a[1]) / 100
                    : 1
                }
                return Pc(a)
              }
              function Pc(a) {
                var b = 1,
                  c = Y(a, 'opacity')
                c && (b = Number(c))
                ;(a = Gc(a)) && (b *= Pc(a))
                return b
              }
              ba('_', function (a, b) {
                function c(d) {
                  if (W(d) && 'none' == Y(d, 'display')) return !1
                  var e
                  if ((e = d.parentNode) && e.shadowRoot && void 0 !== d.assignedSlot)
                    e = d.assignedSlot ? d.assignedSlot.parentNode : null
                  else if (d.getDestinationInsertionPoints) {
                    var f = d.getDestinationInsertionPoints()
                    0 < f.length && (e = f[f.length - 1])
                  }
                  if (Fc && e instanceof ShadowRoot) {
                    if (e.host.shadowRoot !== e) return !1
                    e = e.host
                  }
                  return !e || (9 != e.nodeType && 11 != e.nodeType)
                    ? e && W(e, 'DETAILS') && !e.open && !W(d, 'SUMMARY')
                      ? !1
                      : !!e && c(e)
                    : !0
                }
                return Ic(a, !!b, c)
              })
              return this._.apply(null, arguments)
            }.apply(
              {
                navigator: typeof window != 'undefined' ? window.navigator : null,
                document: typeof window != 'undefined' ? window.document : null
              },
              arguments
            )
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/atoms/mutation-listener.js':
        /*!************************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/atoms/mutation-listener.js ***!
  \************************************************************************/
        /***/ () => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          ;(function () {
            const observer = new MutationObserver((mutations) => {
              for (const mutation of mutations) {
                switch (mutation.type) {
                  case 'attributes':
                    // Don't report our own attribute has changed.
                    if (mutation.attributeName === 'data-__webdriver_id') {
                      break
                    }
                    const curr = mutation.target.getAttribute(mutation.attributeName)
                    var id = mutation.target.dataset.__webdriver_id
                    if (!id) {
                      id = Math.random().toString(36).substring(2) + Date.now().toString(36)
                      mutation.target.dataset.__webdriver_id = id
                    }
                    const json = JSON.stringify({
                      target: id,
                      name: mutation.attributeName,
                      value: curr,
                      oldValue: mutation.oldValue
                    })
                    __webdriver_attribute(json)
                    break
                  default:
                    break
                }
              }
            })

            observer.observe(document, {
              attributes: true,
              attributeOldValue: true,
              characterData: true,
              characterDataOldValue: true,
              childList: true,
              subtree: true
            })
          })()

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/atoms sync recursive ^\\.\\/.*$':
        /*!******************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/atoms/ sync ^\.\/.*$ ***!
  \******************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          var map = {
            './find-elements': './node_modules/selenium-webdriver/lib/atoms/find-elements.js',
            './find-elements.js': './node_modules/selenium-webdriver/lib/atoms/find-elements.js',
            './get-attribute': './node_modules/selenium-webdriver/lib/atoms/get-attribute.js',
            './get-attribute.js': './node_modules/selenium-webdriver/lib/atoms/get-attribute.js',
            './is-displayed': './node_modules/selenium-webdriver/lib/atoms/is-displayed.js',
            './is-displayed.js': './node_modules/selenium-webdriver/lib/atoms/is-displayed.js',
            './mutation-listener':
              './node_modules/selenium-webdriver/lib/atoms/mutation-listener.js',
            './mutation-listener.js':
              './node_modules/selenium-webdriver/lib/atoms/mutation-listener.js'
          }

          function webpackContext(req) {
            var id = webpackContextResolve(req)
            return __webpack_require__(id)
          }
          function webpackContextResolve(req) {
            if (!__webpack_require__.o(map, req)) {
              var e = new Error("Cannot find module '" + req + "'")
              e.code = 'MODULE_NOT_FOUND'
              throw e
            }
            return map[req]
          }
          webpackContext.keys = function webpackContextKeys() {
            return Object.keys(map)
          }
          webpackContext.resolve = webpackContextResolve
          module.exports = webpackContext
          webpackContext.id =
            './node_modules/selenium-webdriver/lib/atoms sync recursive ^\\.\\/.*$'

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/by.js':
        /*!***************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/by.js ***!
  \***************************************************/
        /***/ (module) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Factory methods for the supported locator strategies.
           */

          /**
           * Short-hand expressions for the primary element locator strategies.
           * For example the following two statements are equivalent:
           *
           *     var e1 = driver.findElement(By.id('foo'));
           *     var e2 = driver.findElement({id: 'foo'});
           *
           * Care should be taken when using JavaScript minifiers (such as the
           * Closure compiler), as locator hashes will always be parsed using
           * the un-obfuscated properties listed.
           *
           * @typedef {(
           *     {className: string}|
           *     {css: string}|
           *     {id: string}|
           *     {js: string}|
           *     {linkText: string}|
           *     {name: string}|
           *     {partialLinkText: string}|
           *     {tagName: string}|
           *     {xpath: string})} ByHash
           */

          /**
           * Error thrown if an invalid character is encountered while escaping a CSS
           * identifier.
           * @see https://drafts.csswg.org/cssom/#serialize-an-identifier
           */
          class InvalidCharacterError extends Error {
            constructor() {
              super()
              this.name = this.constructor.name
            }
          }

          /**
           * Escapes a CSS string.
           * @param {string} css the string to escape.
           * @return {string} the escaped string.
           * @throws {TypeError} if the input value is not a string.
           * @throws {InvalidCharacterError} if the string contains an invalid character.
           * @see https://drafts.csswg.org/cssom/#serialize-an-identifier
           */
          function escapeCss(css) {
            if (typeof css !== 'string') {
              throw new TypeError('input must be a string')
            }
            let ret = ''
            const n = css.length
            for (let i = 0; i < n; i++) {
              const c = css.charCodeAt(i)
              if (c == 0x0) {
                throw new InvalidCharacterError()
              }

              if (
                (c >= 0x0001 && c <= 0x001f) ||
                c == 0x007f ||
                (i == 0 && c >= 0x0030 && c <= 0x0039) ||
                (i == 1 && c >= 0x0030 && c <= 0x0039 && css.charCodeAt(0) == 0x002d)
              ) {
                ret += '\\' + c.toString(16) + ' '
                continue
              }

              if (i == 0 && c == 0x002d && n == 1) {
                ret += '\\' + css.charAt(i)
                continue
              }

              if (
                c >= 0x0080 ||
                c == 0x002d || // -
                c == 0x005f || // _
                (c >= 0x0030 && c <= 0x0039) || // [0-9]
                (c >= 0x0041 && c <= 0x005a) || // [A-Z]
                (c >= 0x0061 && c <= 0x007a)
              ) {
                // [a-z]
                ret += css.charAt(i)
                continue
              }

              ret += '\\' + css.charAt(i)
            }
            return ret
          }

          /**
           * Describes a mechanism for locating an element on the page.
           * @final
           */
          class By {
            /**
             * @param {string} using the name of the location strategy to use.
             * @param {string} value the value to search for.
             */
            constructor(using, value) {
              /** @type {string} */
              this.using = using

              /** @type {string} */
              this.value = value
            }

            /**
             * Locates elements that have a specific class name.
             *
             * @param {string} name The class name to search for.
             * @return {!By} The new locator.
             * @see http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes
             * @see http://www.w3.org/TR/CSS2/selector.html#class-html
             */
            static className(name) {
              let names = name
                .split(/\s+/g)
                .filter((s) => s.length > 0)
                .map((s) => escapeCss(s))
              return By.css('.' + names.join('.'))
            }

            /**
             * Locates elements using a CSS selector.
             *
             * @param {string} selector The CSS selector to use.
             * @return {!By} The new locator.
             * @see http://www.w3.org/TR/CSS2/selector.html
             */
            static css(selector) {
              return new By('css selector', selector)
            }

            /**
             * Locates elements by the ID attribute. This locator uses the CSS selector
             * `*[id="$ID"]`, _not_ `document.getElementById`.
             *
             * @param {string} id The ID to search for.
             * @return {!By} The new locator.
             */
            static id(id) {
              return By.css('*[id="' + escapeCss(id) + '"]')
            }

            /**
             * Locates link elements whose
             * {@linkplain webdriver.WebElement#getText visible text} matches the given
             * string.
             *
             * @param {string} text The link text to search for.
             * @return {!By} The new locator.
             */
            static linkText(text) {
              return new By('link text', text)
            }

            /**
             * Locates elements by evaluating a `script` that defines the body of
             * a {@linkplain webdriver.WebDriver#executeScript JavaScript function}.
             * The return value of this function must be an element or an array-like
             * list of elements. When this locator returns a list of elements, but only
             * one is expected, the first element in this list will be used as the
             * single element value.
             *
             * @param {!(string|Function)} script The script to execute.
             * @param {...*} var_args The arguments to pass to the script.
             * @return {function(!./webdriver.WebDriver): !Promise}
             *     A new JavaScript-based locator function.
             */
            static js(script, ...var_args) {
              return function (driver) {
                return driver.executeScript.call(driver, script, ...var_args)
              }
            }

            /**
             * Locates elements whose `name` attribute has the given value.
             *
             * @param {string} name The name attribute to search for.
             * @return {!By} The new locator.
             */
            static name(name) {
              return By.css('*[name="' + escapeCss(name) + '"]')
            }

            /**
             * Locates link elements whose
             * {@linkplain webdriver.WebElement#getText visible text} contains the given
             * substring.
             *
             * @param {string} text The substring to check for in a link's visible text.
             * @return {!By} The new locator.
             */
            static partialLinkText(text) {
              return new By('partial link text', text)
            }

            /**
             * Locates elements with a given tag name.
             *
             * @param {string} name The tag name to search for.
             * @return {!By} The new locator.
             */
            static tagName(name) {
              return new By('tag name', name)
            }

            /**
             * Locates elements matching a XPath selector. Care should be taken when
             * using an XPath selector with a {@link webdriver.WebElement} as WebDriver
             * will respect the context in the specified in the selector. For example,
             * given the selector `//div`, WebDriver will search from the document root
             * regardless of whether the locator was used with a WebElement.
             *
             * @param {string} xpath The XPath selector to use.
             * @return {!By} The new locator.
             * @see http://www.w3.org/TR/xpath/
             */
            static xpath(xpath) {
              return new By('xpath', xpath)
            }

            /** @override */
            toString() {
              // The static By.name() overrides this.constructor.name.  Shame...
              return `By(${this.using}, ${this.value})`
            }

            toObject() {
              const tmp = {}
              tmp[this.using] = this.value
              return tmp
            }
          }

          /**
           * Start Searching for relative objects using the value returned from
           * `By.tagName()`.
           *
           * Note: this method will likely be removed in the future please use
           * `locateWith`.
           * @param {By} The value returned from calling By.tagName()
           * @returns
           */
          function withTagName(tagName) {
            return new RelativeBy({ 'css selector': tagName })
          }

          /**
           * Start searching for relative objects using search criteria with By.
           * @param {string} A By map that shows how to find the initial element
           * @returns {RelativeBy}
           */
          function locateWith(by) {
            return new RelativeBy(getLocator(by))
          }

          function getLocator(locatorOrElement) {
            let toFind
            if (locatorOrElement instanceof By) {
              toFind = locatorOrElement.toObject()
            } else {
              toFind = locatorOrElement
            }
            return toFind
          }

          /**
           * Describes a mechanism for locating an element relative to others
           * on the page.
           * @final
           */
          class RelativeBy {
            /**
             * @param {By} findDetails
             * @param {Array<Object>} filters
             */
            constructor(findDetails, filters = null) {
              this.root = findDetails
              this.filters = filters || []
            }

            /**
             * Look for elements above the root element passed in
             * @param {string|WebElement} locatorOrElement
             * @return {!RelativeBy} Return this object
             */
            above(locatorOrElement) {
              this.filters.push({
                kind: 'above',
                args: [getLocator(locatorOrElement)]
              })
              return this
            }

            /**
             * Look for elements below the root element passed in
             * @param {string|WebElement} locatorOrElement
             * @return {!RelativeBy} Return this object
             */
            below(locatorOrElement) {
              this.filters.push({
                kind: 'below',
                args: [getLocator(locatorOrElement)]
              })
              return this
            }

            /**
             * Look for elements left the root element passed in
             * @param {string|WebElement} locatorOrElement
             * @return {!RelativeBy} Return this object
             */
            toLeftOf(locatorOrElement) {
              this.filters.push({
                kind: 'left',
                args: [getLocator(locatorOrElement)]
              })
              return this
            }

            /**
             * Look for elements right the root element passed in
             * @param {string|WebElement} locatorOrElement
             * @return {!RelativeBy} Return this object
             */
            toRightOf(locatorOrElement) {
              this.filters.push({
                kind: 'right',
                args: [getLocator(locatorOrElement)]
              })
              return this
            }

            /**
             * Look for elements near the root element passed in
             * @param {string|WebElement} locatorOrElement
             * @return {!RelativeBy} Return this object
             */
            near(locatorOrElement) {
              this.filters.push({
                kind: 'near',
                args: [getLocator(locatorOrElement)]
              })
              return this
            }

            /**
             * Returns a marshalled version of the {@link RelativeBy}
             * @return {!Object} Object representation of a {@link WebElement}
             *     that will be used in {@link #findElements}.
             */
            marshall() {
              return {
                relative: {
                  root: this.root,
                  filters: this.filters
                }
              }
            }

            /** @override */
            toString() {
              // The static By.name() overrides this.constructor.name.  Shame...
              return `RelativeBy(${JSON.stringify(this.marshall())})`
            }
          }

          /**
           * Checks if a value is a valid locator.
           * @param {!(By|Function|ByHash)} locator The value to check.
           * @return {!(By|Function)} The valid locator.
           * @throws {TypeError} If the given value does not define a valid locator
           *     strategy.
           */
          function check(locator) {
            if (locator instanceof By || typeof locator === 'function') {
              return locator
            }

            if (
              locator &&
              typeof locator === 'object' &&
              typeof locator.using === 'string' &&
              typeof locator.value === 'string'
            ) {
              return new By(locator.using, locator.value)
            }

            for (let key in locator) {
              if (
                Object.prototype.hasOwnProperty.call(locator, key) &&
                Object.prototype.hasOwnProperty.call(By, key)
              ) {
                return By[key](locator[key])
              }
            }
            throw new TypeError('Invalid locator')
          }

          // PUBLIC API

          module.exports = {
            By,
            RelativeBy,
            withTagName,
            locateWith,
            escapeCss,
            checkedLocator: check
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/capabilities.js':
        /*!*************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/capabilities.js ***!
  \*************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines types related to describing the capabilities of a
           * WebDriver session.
           */

          const Symbols = __webpack_require__(
            /*! ./symbols */ './node_modules/selenium-webdriver/lib/symbols.js'
          )

          /**
           * Recognized browser names.
           * @enum {string}
           */
          const Browser = {
            CHROME: 'chrome',
            EDGE: 'MicrosoftEdge',
            FIREFOX: 'firefox',
            INTERNET_EXPLORER: 'internet explorer',
            SAFARI: 'safari'
          }

          /**
           * Strategies for waiting for [document readiness] after a navigation
           * event.
           *
           * [document readiness]: https://html.spec.whatwg.org/#current-document-readiness
           *
           * @enum {string}
           */
          const PageLoadStrategy = {
            /**
             * Indicates WebDriver should not wait on the document readiness state after a
             * navigation event.
             */
            NONE: 'none',

            /**
             * Indicates WebDriver should wait for the document readiness state to
             * become "interactive" after navigation.
             */
            EAGER: 'eager',

            /**
             * Indicates WebDriver should wait for the document readiness state to
             * be "complete" after navigation. This is the default page loading strategy.
             */
            NORMAL: 'normal'
          }

          /**
           * Common platform names. These platforms are not explicitly defined by the
           * WebDriver spec, however, their use is encouraged for interoperability.
           *
           * @enum {string}
           * @see <https://w3c.github.io/webdriver/webdriver-spec.html>
           */
          const Platform = {
            LINUX: 'linux',
            MAC: 'mac',
            WINDOWS: 'windows'
          }

          /**
           * Record object defining the timeouts that apply to certain WebDriver actions.
           *
           * @record
           */
          function Timeouts() {}

          /**
           * Defines when, in milliseconds, to interrupt a script that is being
           * {@linkplain ./webdriver.IWebDriver#executeScript evaluated}.
           * @type {number}
           */
          Timeouts.prototype.script

          /**
           * The timeout, in milliseconds, to apply to navigation events along with the
           * {@link PageLoadStrategy}.
           * @type {number}
           */
          Timeouts.prototype.pageLoad

          /**
           * The maximum amount of time, in milliseconds, to spend attempting to
           * {@linkplain ./webdriver.IWebDriver#findElement locate} an element on the
           * current page.
           * @type {number}
           */
          Timeouts.prototype.implicit

          /**
           * The possible default actions a WebDriver session can take to respond to
           * unhandled user prompts (`window.alert()`, `window.confirm()`, and
           * `window.prompt()`).
           *
           * @enum {string}
           */
          const UserPromptHandler = {
            /** All prompts should be silently accepted. */
            ACCEPT: 'accept',
            /** All prompts should be silently dismissed. */
            DISMISS: 'dismiss',
            /**
             * All prompts should be automatically accepted, but an error should be
             * returned to the next (or currently executing) WebDriver command.
             */
            ACCEPT_AND_NOTIFY: 'accept and notify',
            /**
             * All prompts should be automatically dismissed, but an error should be
             * returned to the next (or currently executing) WebDriver command.
             */
            DISMISS_AND_NOTIFY: 'dismiss and notify',
            /** All prompts should be left unhandled. */
            IGNORE: 'ignore'
          }

          /**
           * The standard WebDriver capability keys.
           *
           * @enum {string}
           * @see <https://w3c.github.io/webdriver/webdriver-spec.html#capabilities>
           */
          const Capability = {
            /**
             * Indicates whether a WebDriver session implicitly trusts otherwise untrusted
             * and self-signed TLS certificates during navigation.
             */
            ACCEPT_INSECURE_TLS_CERTS: 'acceptInsecureCerts',

            /**
             * The browser name. Common browser names are defined in the
             * {@link ./capabilities.Browser Browser} enum.
             */
            BROWSER_NAME: 'browserName',

            /** Identifies the browser version. */
            BROWSER_VERSION: 'browserVersion',

            /**
             * Key for the logging driver logging preferences.
             * The browser name. Common browser names are defined in the
             * {@link ./capabilities.Browser Browser} enum.
             */
            LOGGING_PREFS: 'goog:loggingPrefs',

            /**
             * Defines the session's
             * {@linkplain ./capabilities.PageLoadStrategy page loading strategy}.
             */
            PAGE_LOAD_STRATEGY: 'pageLoadStrategy',

            /**
             * Identifies the operating system of the endpoint node. Common values
             * recognized by the most WebDriver server implementations are predefined in
             * the {@link ./capabilities.Platform Platform} enum.
             */
            PLATFORM_NAME: 'platformName',

            /**
             * Describes the proxy configuration to use for a new WebDriver session.
             */
            PROXY: 'proxy',

            /**
             * Indicates whether the remote end supports all of the window resizing and
             * positioning commands:
             *
             * -  {@linkplain ./webdriver.Window#getRect Window.getRect()}
             * -  {@linkplain ./webdriver.Window#setRect Window.setRect()}
             * -  {@linkplain ./webdriver.Window#maximize Window.maximize()}
             * -  {@linkplain ./webdriver.Window#minimize Window.minimize()}
             * -  {@linkplain ./webdriver.Window#fullscreen Window.fullscreen()}
             */
            SET_WINDOW_RECT: 'setWindowRect',

            /**
             * Describes the {@linkplain ./capabilities.Timeouts timeouts} imposed on
             * certain session operations.
             */
            TIMEOUTS: 'timeouts',

            /**
             * Defines how a WebDriver session should
             * {@linkplain ./capabilities.UserPromptHandler respond} to unhandled user
             * prompts.
             */
            UNHANDLED_PROMPT_BEHAVIOR: 'unhandledPromptBehavior',

            /**
             * Defines the current session’s strict file interactability.
             * Used to upload a file when strict file interactability is on
             */
            STRICT_FILE_INTERACTABILITY: 'strictFileInteractability'
          }

          /**
           * Converts a generic hash object to a map.
           * @param {!Object<string, ?>} hash The hash object.
           * @return {!Map<string, ?>} The converted map.
           */
          function toMap(hash) {
            let m = new Map()
            for (let key in hash) {
              if (Object.prototype.hasOwnProperty.call(hash, key)) {
                m.set(key, hash[key])
              }
            }
            return m
          }

          /**
           * Describes a set of capabilities for a WebDriver session.
           */
          class Capabilities {
            /**
             * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of
             *     capabilities to initialize this instance from.
             */
            constructor(other = undefined) {
              if (other instanceof Capabilities) {
                other = other.map_
              } else if (other && !(other instanceof Map)) {
                other = toMap(other)
              }
              /** @private @const {!Map<string, ?>} */
              this.map_ = new Map(other)
            }

            /**
             * @return {!Capabilities} A basic set of capabilities for Chrome.
             */
            static chrome() {
              return new Capabilities().setBrowserName(Browser.CHROME)
            }

            /**
             * @return {!Capabilities} A basic set of capabilities for Microsoft Edge.
             */
            static edge() {
              return new Capabilities().setBrowserName(Browser.EDGE)
            }

            /**
             * @return {!Capabilities} A basic set of capabilities for Firefox.
             */
            static firefox() {
              return new Capabilities()
                .setBrowserName(Browser.FIREFOX)
                .set('moz:debuggerAddress', true)
            }

            /**
             * @return {!Capabilities} A basic set of capabilities for Internet Explorer.
             */
            static ie() {
              return new Capabilities().setBrowserName(Browser.INTERNET_EXPLORER)
            }

            /**
             * @return {!Capabilities} A basic set of capabilities for Safari.
             */
            static safari() {
              return new Capabilities().setBrowserName(Browser.SAFARI)
            }

            /**
             * @return {!Object<string, ?>} The JSON representation of this instance.
             *     Note, the returned object may contain nested promised values.
             * @suppress {checkTypes} Suppress [] access on a struct (state inherited from
             *     Map).
             */
            [Symbols.serialize]() {
              return serialize(this)
            }

            /**
             * @param {string} key the parameter key to get.
             * @return {T} the stored parameter value.
             * @template T
             */
            get(key) {
              return this.map_.get(key)
            }

            /**
             * @param {string} key the key to test.
             * @return {boolean} whether this capability set has the specified key.
             */
            has(key) {
              return this.map_.has(key)
            }

            /**
             * @return {!Iterator<string>} an iterator of the keys set.
             */
            keys() {
              return this.map_.keys()
            }

            /** @return {number} The number of capabilities set. */
            get size() {
              return this.map_.size
            }

            /**
             * Merges another set of capabilities into this instance.
             * @param {!(Capabilities|Map<String, ?>|Object<string, ?>)} other The other
             *     set of capabilities to merge.
             * @return {!Capabilities} A self reference.
             */
            merge(other) {
              if (other) {
                let otherMap
                if (other instanceof Capabilities) {
                  otherMap = other.map_
                } else if (other instanceof Map) {
                  otherMap = other
                } else {
                  otherMap = toMap(other)
                }
                otherMap.forEach((value, key) => {
                  this.set(key, value)
                })
                return this
              } else {
                throw new TypeError('no capabilities provided for merge')
              }
            }

            /**
             * Deletes an entry from this set of capabilities.
             *
             * @param {string} key the capability key to delete.
             */
            delete(key) {
              this.map_.delete(key)
            }

            /**
             * @param {string} key The capability key.
             * @param {*} value The capability value.
             * @return {!Capabilities} A self reference.
             * @throws {TypeError} If the `key` is not a string.
             */
            set(key, value) {
              if (typeof key !== 'string') {
                throw new TypeError('Capability keys must be strings: ' + typeof key)
              }
              this.map_.set(key, value)
              return this
            }

            /**
             * Sets whether a WebDriver session should implicitly accept self-signed, or
             * other untrusted TLS certificates on navigation.
             *
             * @param {boolean} accept whether to accept insecure certs.
             * @return {!Capabilities} a self reference.
             */
            setAcceptInsecureCerts(accept) {
              return this.set(Capability.ACCEPT_INSECURE_TLS_CERTS, accept)
            }

            /**
             * @return {boolean} whether the session is configured to accept insecure
             *     TLS certificates.
             */
            getAcceptInsecureCerts() {
              return this.get(Capability.ACCEPT_INSECURE_TLS_CERTS)
            }

            /**
             * Sets the name of the target browser.
             *
             * @param {(Browser|string)} name the browser name.
             * @return {!Capabilities} a self reference.
             */
            setBrowserName(name) {
              return this.set(Capability.BROWSER_NAME, name)
            }

            /**
             * @return {(string|undefined)} the configured browser name, or undefined if
             *     not set.
             */
            getBrowserName() {
              return this.get(Capability.BROWSER_NAME)
            }

            /**
             * Sets the desired version of the target browser.
             *
             * @param {string} version the desired version.
             * @return {!Capabilities} a self reference.
             */
            setBrowserVersion(version) {
              return this.set(Capability.BROWSER_VERSION, version)
            }

            /**
             * @return {(string|undefined)} the configured browser version, or undefined
             *     if not set.
             */
            getBrowserVersion() {
              return this.get(Capability.BROWSER_VERSION)
            }

            /**
             * Sets the desired page loading strategy for a new WebDriver session.
             *
             * @param {PageLoadStrategy} strategy the desired strategy.
             * @return {!Capabilities} a self reference.
             */
            setPageLoadStrategy(strategy) {
              return this.set(Capability.PAGE_LOAD_STRATEGY, strategy)
            }

            /**
             * Returns the configured page load strategy.
             *
             * @return {(string|undefined)} the page load strategy.
             */
            getPageLoadStrategy() {
              return this.get(Capability.PAGE_LOAD_STRATEGY)
            }

            /**
             * Sets the target platform.
             *
             * @param {(Platform|string)} platform the target platform.
             * @return {!Capabilities} a self reference.
             */
            setPlatform(platform) {
              return this.set(Capability.PLATFORM_NAME, platform)
            }

            /**
             * @return {(string|undefined)} the configured platform or undefined if not
             *     set.
             */
            getPlatform() {
              return this.get(Capability.PLATFORM_NAME)
            }

            /**
             * Sets the logging preferences. Preferences may be specified as a
             * {@link ./logging.Preferences} instance, or as a map of log-type to
             * log-level.
             * @param {!(./logging.Preferences|Object<string>)} prefs The logging
             *     preferences.
             * @return {!Capabilities} A self reference.
             */
            setLoggingPrefs(prefs) {
              return this.set(Capability.LOGGING_PREFS, prefs)
            }

            /**
             * Sets the proxy configuration for this instance.
             * @param {proxy.Config} proxy The desired proxy configuration.
             * @return {!Capabilities} A self reference.
             */
            setProxy(proxy) {
              return this.set(Capability.PROXY, proxy)
            }

            /**
             * @return {(proxy.Config|undefined)} the configured proxy settings, or
             *     undefined if not set.
             */
            getProxy() {
              return this.get(Capability.PROXY)
            }

            /**
             * Sets the default action to take with an unexpected alert before returning
             * an error. If unspecified, WebDriver will default to
             * {@link UserPromptHandler.DISMISS_AND_NOTIFY}.
             *
             * @param {?UserPromptHandler} behavior The way WebDriver should respond to
             *     unhandled user prompts.
             * @return {!Capabilities} A self reference.
             */
            setAlertBehavior(behavior) {
              return this.set(Capability.UNHANDLED_PROMPT_BEHAVIOR, behavior)
            }

            /**
             * @return {(UserPromptHandler|undefined)} the behavior pattern for responding
             *     to unhandled user prompts, or undefined if not set.
             */
            getAlertBehavior() {
              return this.get(Capability.UNHANDLED_PROMPT_BEHAVIOR)
            }

            /**
             * Sets the boolean flag configuration for this instance.
             */
            setStrictFileInteractability(strictFileInteractability) {
              return this.set(Capability.STRICT_FILE_INTERACTABILITY, strictFileInteractability)
            }
          }

          /**
           * Serializes a capabilities object. This is defined as a standalone function
           * so it may be type checked (where Capabilities[Symbols.serialize] has type
           * checking disabled since it is defined with [] access on a struct).
           *
           * @param {!Capabilities} caps The capabilities to serialize.
           * @return {!Object<string, ?>} The JSON representation of this instance.
           *     Note, the returned object may contain nested promised values.
           */
          function serialize(caps) {
            let ret = {}
            for (let key of caps.keys()) {
              let cap = caps.get(key)
              if (cap !== undefined && cap !== null) {
                ret[key] = cap
              }
            }
            return ret
          }

          // PUBLIC API

          module.exports = {
            Browser,
            Capabilities,
            Capability,
            PageLoadStrategy,
            Platform,
            Timeouts,
            UserPromptHandler
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/command.js':
        /*!********************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/command.js ***!
  \********************************************************/
        /***/ (module) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Contains several classes for handling commands.
           */

          /**
           * Describes a command to execute.
           * @final
           */
          class Command {
            /** @param {string} name The name of this command. */
            constructor(name) {
              /** @private {string} */
              this.name_ = name

              /** @private {!Object<*>} */
              this.parameters_ = {}
            }

            /** @return {string} This command's name. */
            getName() {
              return this.name_
            }

            /**
             * Sets a parameter to send with this command.
             * @param {string} name The parameter name.
             * @param {*} value The parameter value.
             * @return {!Command} A self reference.
             */
            setParameter(name, value) {
              this.parameters_[name] = value
              return this
            }

            /**
             * Sets the parameters for this command.
             * @param {!Object<*>} parameters The command parameters.
             * @return {!Command} A self reference.
             */
            setParameters(parameters) {
              this.parameters_ = parameters
              return this
            }

            /**
             * Returns a named command parameter.
             * @param {string} key The parameter key to look up.
             * @return {*} The parameter value, or undefined if it has not been set.
             */
            getParameter(key) {
              return this.parameters_[key]
            }

            /**
             * @return {!Object<*>} The parameters to send with this command.
             */
            getParameters() {
              return this.parameters_
            }
          }

          /**
           * Enumeration of predefined names command names that all command processors
           * will support.
           * @enum {string}
           */
          const Name = {
            GET_SERVER_STATUS: 'getStatus',

            NEW_SESSION: 'newSession',
            GET_SESSIONS: 'getSessions',

            CLOSE: 'close',
            QUIT: 'quit',

            GET_CURRENT_URL: 'getCurrentUrl',
            GET: 'get',
            GO_BACK: 'goBack',
            GO_FORWARD: 'goForward',
            REFRESH: 'refresh',

            ADD_COOKIE: 'addCookie',
            GET_COOKIE: 'getCookie',
            GET_ALL_COOKIES: 'getCookies',
            DELETE_COOKIE: 'deleteCookie',
            DELETE_ALL_COOKIES: 'deleteAllCookies',

            GET_ACTIVE_ELEMENT: 'getActiveElement',
            FIND_ELEMENT: 'findElement',
            FIND_ELEMENTS: 'findElements',
            FIND_ELEMENTS_RELATIVE: 'findElementsRelative',
            FIND_CHILD_ELEMENT: 'findChildElement',
            FIND_CHILD_ELEMENTS: 'findChildElements',

            CLEAR_ELEMENT: 'clearElement',
            CLICK_ELEMENT: 'clickElement',
            SEND_KEYS_TO_ELEMENT: 'sendKeysToElement',

            GET_CURRENT_WINDOW_HANDLE: 'getCurrentWindowHandle',
            GET_WINDOW_HANDLES: 'getWindowHandles',
            GET_WINDOW_RECT: 'getWindowRect',
            SET_WINDOW_RECT: 'setWindowRect',
            MAXIMIZE_WINDOW: 'maximizeWindow',
            MINIMIZE_WINDOW: 'minimizeWindow',
            FULLSCREEN_WINDOW: 'fullscreenWindow',

            SWITCH_TO_WINDOW: 'switchToWindow',
            SWITCH_TO_NEW_WINDOW: 'newWindow',
            SWITCH_TO_FRAME: 'switchToFrame',
            SWITCH_TO_FRAME_PARENT: 'switchToFrameParent',
            GET_PAGE_SOURCE: 'getPageSource',
            GET_TITLE: 'getTitle',

            EXECUTE_SCRIPT: 'executeScript',
            EXECUTE_ASYNC_SCRIPT: 'executeAsyncScript',

            GET_ELEMENT_TEXT: 'getElementText',
            GET_COMPUTED_ROLE: 'getAriaRole',
            GET_COMPUTED_LABEL: 'getAccessibleName',
            GET_ELEMENT_TAG_NAME: 'getElementTagName',
            IS_ELEMENT_SELECTED: 'isElementSelected',
            IS_ELEMENT_ENABLED: 'isElementEnabled',
            IS_ELEMENT_DISPLAYED: 'isElementDisplayed',
            GET_ELEMENT_RECT: 'getElementRect',
            GET_ELEMENT_ATTRIBUTE: 'getElementAttribute',
            GET_DOM_ATTRIBUTE: 'getDomAttribute',
            GET_ELEMENT_VALUE_OF_CSS_PROPERTY: 'getElementValueOfCssProperty',
            GET_ELEMENT_PROPERTY: 'getElementProperty',

            SCREENSHOT: 'screenshot',
            TAKE_ELEMENT_SCREENSHOT: 'takeElementScreenshot',

            PRINT_PAGE: 'printPage',

            GET_TIMEOUT: 'getTimeout',
            SET_TIMEOUT: 'setTimeout',

            ACCEPT_ALERT: 'acceptAlert',
            DISMISS_ALERT: 'dismissAlert',
            GET_ALERT_TEXT: 'getAlertText',
            SET_ALERT_TEXT: 'setAlertValue',

            // Shadow DOM Commands
            GET_SHADOW_ROOT: 'getShadowRoot',
            FIND_ELEMENT_FROM_SHADOWROOT: 'findElementFromShadowRoot',
            FIND_ELEMENTS_FROM_SHADOWROOT: 'findElementsFromShadowRoot',

            // Virtual Authenticator Commands
            ADD_VIRTUAL_AUTHENTICATOR: 'addVirtualAuthenticator',
            REMOVE_VIRTUAL_AUTHENTICATOR: 'removeVirtualAuthenticator',
            ADD_CREDENTIAL: 'addCredential',
            GET_CREDENTIALS: 'getCredentials',
            REMOVE_CREDENTIAL: 'removeCredential',
            REMOVE_ALL_CREDENTIALS: 'removeAllCredentials',
            SET_USER_VERIFIED: 'setUserVerified',

            GET_AVAILABLE_LOG_TYPES: 'getAvailableLogTypes',
            GET_LOG: 'getLog',

            // Non-standard commands used by the standalone Selenium server.
            UPLOAD_FILE: 'uploadFile',

            ACTIONS: 'actions',
            CLEAR_ACTIONS: 'clearActions'
          }

          /**
           * Handles the execution of WebDriver {@link Command commands}.
           * @record
           */
          class Executor {
            /**
             * Executes the given {@code command}. If there is an error executing the
             * command, the provided callback will be invoked with the offending error.
             * Otherwise, the callback will be invoked with a null Error and non-null
             * response object.
             *
             * @param {!Command} command The command to execute.
             * @return {!Promise<?>} A promise that will be fulfilled with the command
             *     result.
             */
            execute(command) {} // eslint-disable-line
          }

          // PUBLIC API

          module.exports = {
            Command,
            Name,
            Executor
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/error.js':
        /*!******************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/error.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { isObject } = __webpack_require__(
            /*! ./util */ './node_modules/selenium-webdriver/lib/util.js'
          )

          /**
           * The base WebDriver error type. This error type is only used directly when a
           * more appropriate category is not defined for the offending error.
           */
          class WebDriverError extends Error {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)

              /** @override */
              this.name = this.constructor.name

              /**
               * A stacktrace reported by the remote webdriver endpoint that initially
               * reported this error. This property will be an empty string if the remote
               * end did not provide a stacktrace.
               * @type {string}
               */
              this.remoteStacktrace = ''
            }
          }

          /**
           * Indicates the shadow root is no longer attached to the DOM
           */
          class DetachedShadowRootError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * Indicates a {@linkplain ./webdriver.WebElement#click click command} could not
           * completed because the click target is obscured by other elements on the
           * page.
           */
          class ElementClickInterceptedError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An attempt was made to select an element that cannot be selected.
           */
          class ElementNotSelectableError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * Indicates a command could not be completed because the target element is
           * not pointer or keyboard interactable. This will often occur if an element
           * is present in the DOM, but not rendered (i.e. its CSS style has
           * "display: none").
           */
          class ElementNotInteractableError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * Indicates a navigation event caused the browser to generate a certificate
           * warning. This is usually caused by an expired or invalid TLS certificate.
           */
          class InsecureCertificateError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * The arguments passed to a command are either invalid or malformed.
           */
          class InvalidArgumentError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An illegal attempt was made to set a cookie under a different domain than
           * the current page.
           */
          class InvalidCookieDomainError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * The coordinates provided to an interactions operation are invalid.
           */
          class InvalidCoordinatesError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An element command could not be completed because the element is in an
           * invalid state, e.g. attempting to click an element that is no longer attached
           * to the document.
           */
          class InvalidElementStateError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * Argument was an invalid selector.
           */
          class InvalidSelectorError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * Occurs when a command is directed to a session that does not exist.
           */
          class NoSuchSessionError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An error occurred while executing JavaScript supplied by the user.
           */
          class JavascriptError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * The target for mouse interaction is not in the browser’s viewport and cannot
           * be brought into that viewport.
           */
          class MoveTargetOutOfBoundsError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An attempt was made to operate on a modal dialog when one was not open.
           */
          class NoSuchAlertError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * Indicates a named cookie could not be found in the cookie jar for the
           * currently selected document.
           */
          class NoSuchCookieError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An element could not be located on the page using the given search
           * parameters.
           */
          class NoSuchElementError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A ShadowRoot could not be located on the element
           */
          class NoSuchShadowRootError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A request to switch to a frame could not be satisfied because the frame
           * could not be found.
           */
          class NoSuchFrameError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A request to switch to a window could not be satisfied because the window
           * could not be found.
           */
          class NoSuchWindowError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A script did not complete before its timeout expired.
           */
          class ScriptTimeoutError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A new session could not be created.
           */
          class SessionNotCreatedError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An element command failed because the referenced element is no longer
           * attached to the DOM.
           */
          class StaleElementReferenceError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * An operation did not complete before its timeout expired.
           */
          class TimeoutError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A request to set a cookie’s value could not be satisfied.
           */
          class UnableToSetCookieError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A screen capture operation was not possible.
           */
          class UnableToCaptureScreenError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * A modal dialog was open, blocking this operation.
           */
          class UnexpectedAlertOpenError extends WebDriverError {
            /**
             * @param {string=} opt_error the error message, if any.
             * @param {string=} opt_text the text of the open dialog, if available.
             */
            constructor(opt_error, opt_text) {
              super(opt_error)

              /** @private {(string|undefined)} */
              this.text_ = opt_text
            }

            /**
             * @return {(string|undefined)} The text displayed with the unhandled alert,
             *     if available.
             */
            getAlertText() {
              return this.text_
            }
          }

          /**
           * A command could not be executed because the remote end is not aware of it.
           */
          class UnknownCommandError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * The requested command matched a known URL but did not match an method for
           * that URL.
           */
          class UnknownMethodError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          /**
           * Reports an unsupported operation.
           */
          class UnsupportedOperationError extends WebDriverError {
            /** @param {string=} opt_error the error message, if any. */
            constructor(opt_error) {
              super(opt_error)
            }
          }

          // TODO(jleyba): Define UnknownError as an alias of WebDriverError?

          /**
           * Enum of legacy error codes.
           * TODO: remove this when all code paths have been switched to the new error
           * types.
           * @deprecated
           * @enum {number}
           */
          const ErrorCode = {
            SUCCESS: 0,
            NO_SUCH_SESSION: 6,
            NO_SUCH_ELEMENT: 7,
            NO_SUCH_FRAME: 8,
            UNKNOWN_COMMAND: 9,
            UNSUPPORTED_OPERATION: 9,
            STALE_ELEMENT_REFERENCE: 10,
            ELEMENT_NOT_VISIBLE: 11,
            INVALID_ELEMENT_STATE: 12,
            UNKNOWN_ERROR: 13,
            ELEMENT_NOT_SELECTABLE: 15,
            JAVASCRIPT_ERROR: 17,
            XPATH_LOOKUP_ERROR: 19,
            TIMEOUT: 21,
            NO_SUCH_WINDOW: 23,
            INVALID_COOKIE_DOMAIN: 24,
            UNABLE_TO_SET_COOKIE: 25,
            UNEXPECTED_ALERT_OPEN: 26,
            NO_SUCH_ALERT: 27,
            SCRIPT_TIMEOUT: 28,
            INVALID_ELEMENT_COORDINATES: 29,
            IME_NOT_AVAILABLE: 30,
            IME_ENGINE_ACTIVATION_FAILED: 31,
            INVALID_SELECTOR_ERROR: 32,
            SESSION_NOT_CREATED: 33,
            MOVE_TARGET_OUT_OF_BOUNDS: 34,
            SQL_DATABASE_ERROR: 35,
            INVALID_XPATH_SELECTOR: 51,
            INVALID_XPATH_SELECTOR_RETURN_TYPE: 52,
            ELEMENT_NOT_INTERACTABLE: 60,
            INVALID_ARGUMENT: 61,
            NO_SUCH_COOKIE: 62,
            UNABLE_TO_CAPTURE_SCREEN: 63,
            ELEMENT_CLICK_INTERCEPTED: 64,
            METHOD_NOT_ALLOWED: 405
          }

          const LEGACY_ERROR_CODE_TO_TYPE = new Map([
            [ErrorCode.NO_SUCH_SESSION, NoSuchSessionError],
            [ErrorCode.NO_SUCH_ELEMENT, NoSuchElementError],
            [ErrorCode.NO_SUCH_FRAME, NoSuchFrameError],
            [ErrorCode.UNSUPPORTED_OPERATION, UnsupportedOperationError],
            [ErrorCode.STALE_ELEMENT_REFERENCE, StaleElementReferenceError],
            [ErrorCode.INVALID_ELEMENT_STATE, InvalidElementStateError],
            [ErrorCode.UNKNOWN_ERROR, WebDriverError],
            [ErrorCode.ELEMENT_NOT_SELECTABLE, ElementNotSelectableError],
            [ErrorCode.JAVASCRIPT_ERROR, JavascriptError],
            [ErrorCode.XPATH_LOOKUP_ERROR, InvalidSelectorError],
            [ErrorCode.TIMEOUT, TimeoutError],
            [ErrorCode.NO_SUCH_WINDOW, NoSuchWindowError],
            [ErrorCode.INVALID_COOKIE_DOMAIN, InvalidCookieDomainError],
            [ErrorCode.UNABLE_TO_SET_COOKIE, UnableToSetCookieError],
            [ErrorCode.UNEXPECTED_ALERT_OPEN, UnexpectedAlertOpenError],
            [ErrorCode.NO_SUCH_ALERT, NoSuchAlertError],
            [ErrorCode.SCRIPT_TIMEOUT, ScriptTimeoutError],
            [ErrorCode.INVALID_ELEMENT_COORDINATES, InvalidCoordinatesError],
            [ErrorCode.INVALID_SELECTOR_ERROR, InvalidSelectorError],
            [ErrorCode.SESSION_NOT_CREATED, SessionNotCreatedError],
            [ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS, MoveTargetOutOfBoundsError],
            [ErrorCode.INVALID_XPATH_SELECTOR, InvalidSelectorError],
            [ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPE, InvalidSelectorError],
            [ErrorCode.ELEMENT_NOT_INTERACTABLE, ElementNotInteractableError],
            [ErrorCode.INVALID_ARGUMENT, InvalidArgumentError],
            [ErrorCode.NO_SUCH_COOKIE, NoSuchCookieError],
            [ErrorCode.UNABLE_TO_CAPTURE_SCREEN, UnableToCaptureScreenError],
            [ErrorCode.ELEMENT_CLICK_INTERCEPTED, ElementClickInterceptedError],
            [ErrorCode.METHOD_NOT_ALLOWED, UnsupportedOperationError]
          ])

          const ERROR_CODE_TO_TYPE = new Map([
            ['unknown error', WebDriverError],
            ['detached shadow root', DetachedShadowRootError],
            ['element click intercepted', ElementClickInterceptedError],
            ['element not interactable', ElementNotInteractableError],
            ['element not selectable', ElementNotSelectableError],
            ['insecure certificate', InsecureCertificateError],
            ['invalid argument', InvalidArgumentError],
            ['invalid cookie domain', InvalidCookieDomainError],
            ['invalid coordinates', InvalidCoordinatesError],
            ['invalid element state', InvalidElementStateError],
            ['invalid selector', InvalidSelectorError],
            ['invalid session id', NoSuchSessionError],
            ['javascript error', JavascriptError],
            ['move target out of bounds', MoveTargetOutOfBoundsError],
            ['no such alert', NoSuchAlertError],
            ['no such cookie', NoSuchCookieError],
            ['no such element', NoSuchElementError],
            ['no such frame', NoSuchFrameError],
            ['no such shadow root', NoSuchShadowRootError],
            ['no such window', NoSuchWindowError],
            ['script timeout', ScriptTimeoutError],
            ['session not created', SessionNotCreatedError],
            ['stale element reference', StaleElementReferenceError],
            ['timeout', TimeoutError],
            ['unable to set cookie', UnableToSetCookieError],
            ['unable to capture screen', UnableToCaptureScreenError],
            ['unexpected alert open', UnexpectedAlertOpenError],
            ['unknown command', UnknownCommandError],
            ['unknown method', UnknownMethodError],
            ['unsupported operation', UnsupportedOperationError]
          ])

          const TYPE_TO_ERROR_CODE = new Map()
          ERROR_CODE_TO_TYPE.forEach((value, key) => {
            TYPE_TO_ERROR_CODE.set(value, key)
          })

          /**
           * @param {*} err The error to encode.
           * @return {{error: string, message: string}} the encoded error.
           */
          function encodeError(err) {
            let type = WebDriverError
            if (err instanceof WebDriverError && TYPE_TO_ERROR_CODE.has(err.constructor)) {
              type = err.constructor
            }

            let message = err instanceof Error ? err.message : err + ''

            let code = /** @type {string} */ (TYPE_TO_ERROR_CODE.get(type))
            return { error: code, message: message }
          }

          /**
           * Tests if the given value is a valid error response object according to the
           * W3C WebDriver spec.
           *
           * @param {?} data The value to test.
           * @return {boolean} Whether the given value data object is a valid error
           *     response.
           * @see https://w3c.github.io/webdriver/webdriver-spec.html#protocol
           */
          function isErrorResponse(data) {
            return isObject(data) && typeof data.error === 'string'
          }

          /**
           * Throws an error coded from the W3C protocol. A generic error will be thrown
           * if the provided `data` is not a valid encoded error.
           *
           * @param {{error: string, message: string}} data The error data to decode.
           * @throws {WebDriverError} the decoded error.
           * @see https://w3c.github.io/webdriver/webdriver-spec.html#protocol
           */
          function throwDecodedError(data) {
            if (isErrorResponse(data)) {
              let ctor = ERROR_CODE_TO_TYPE.get(data.error) || WebDriverError
              let err = new ctor(data.message)
              // TODO(jleyba): remove whichever case is excluded from the final W3C spec.
              if (typeof data.stacktrace === 'string') {
                err.remoteStacktrace = data.stacktrace
              } else if (typeof data.stackTrace === 'string') {
                err.remoteStacktrace = data.stackTrace
              }
              throw err
            }
            throw new WebDriverError('Unknown error: ' + JSON.stringify(data))
          }

          /**
           * Checks a legacy response from the Selenium 2.0 wire protocol for an error.
           * @param {*} responseObj the response object to check.
           * @return {*} responseObj the original response if it does not define an error.
           * @throws {WebDriverError} if the response object defines an error.
           */
          function checkLegacyResponse(responseObj) {
            // Handle the legacy Selenium error response format.
            if (
              isObject(responseObj) &&
              typeof responseObj.status === 'number' &&
              responseObj.status !== 0
            ) {
              const { status, value } = responseObj

              let ctor = LEGACY_ERROR_CODE_TO_TYPE.get(status) || WebDriverError

              if (!value || typeof value !== 'object') {
                throw new ctor(value + '')
              } else {
                let message = value['message'] + ''
                if (ctor !== UnexpectedAlertOpenError) {
                  throw new ctor(message)
                }

                let text = ''
                if (value['alert'] && typeof value['alert']['text'] === 'string') {
                  text = value['alert']['text']
                }
                throw new UnexpectedAlertOpenError(message, text)
              }
            }
            return responseObj
          }

          // PUBLIC API

          module.exports = {
            ErrorCode,

            WebDriverError,
            DetachedShadowRootError,
            ElementClickInterceptedError,
            ElementNotInteractableError,
            ElementNotSelectableError,
            InsecureCertificateError,
            InvalidArgumentError,
            InvalidCookieDomainError,
            InvalidCoordinatesError,
            InvalidElementStateError,
            InvalidSelectorError,
            JavascriptError,
            MoveTargetOutOfBoundsError,
            NoSuchAlertError,
            NoSuchCookieError,
            NoSuchElementError,
            NoSuchFrameError,
            NoSuchShadowRootError,
            NoSuchSessionError,
            NoSuchWindowError,
            ScriptTimeoutError,
            SessionNotCreatedError,
            StaleElementReferenceError,
            TimeoutError,
            UnableToSetCookieError,
            UnableToCaptureScreenError,
            UnexpectedAlertOpenError,
            UnknownCommandError,
            UnknownMethodError,
            UnsupportedOperationError,
            checkLegacyResponse,
            encodeError,
            isErrorResponse,
            throwDecodedError
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/http.js':
        /*!*****************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/http.js ***!
  \*****************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines an environment agnostic {@linkplain cmd.Executor
           * command executor} that communicates with a remote end using JSON over HTTP.
           *
           * Clients should implement the {@link Client} interface, which is used by
           * the {@link Executor} to send commands to the remote end.
           */

          const path = __webpack_require__(/*! path */ 'path')
          const cmd = __webpack_require__(
            /*! ./command */ './node_modules/selenium-webdriver/lib/command.js'
          )
          const error = __webpack_require__(
            /*! ./error */ './node_modules/selenium-webdriver/lib/error.js'
          )
          const logging = __webpack_require__(
            /*! ./logging */ './node_modules/selenium-webdriver/lib/logging.js'
          )
          const promise = __webpack_require__(
            /*! ./promise */ './node_modules/selenium-webdriver/lib/promise.js'
          )
          const { Session } = __webpack_require__(
            /*! ./session */ './node_modules/selenium-webdriver/lib/session.js'
          )
          const webElement = __webpack_require__(
            /*! ./webelement */ './node_modules/selenium-webdriver/lib/webelement.js'
          )
          const { isObject } = __webpack_require__(
            /*! ./util */ './node_modules/selenium-webdriver/lib/util.js'
          )

          const getAttribute = requireAtom(
            'get-attribute.js',
            '//javascript/node/selenium-webdriver/lib/atoms:get-attribute.js'
          )
          const isDisplayed = requireAtom(
            'is-displayed.js',
            '//javascript/node/selenium-webdriver/lib/atoms:is-displayed.js'
          )
          const findElements = requireAtom(
            'find-elements.js',
            '//javascript/node/selenium-webdriver/lib/atoms:find-elements.js'
          )

          /**
           * @param {string} module
           * @param {string} bazelTarget
           * @return {!Function}
           */
          function requireAtom(module, bazelTarget) {
            try {
              return __webpack_require__(
                './node_modules/selenium-webdriver/lib/atoms sync recursive ^\\.\\/.*$'
              )('./' + module)
            } catch (ex) {
              try {
                const file = bazelTarget.slice(2).replace(':', '/')
                console.log(`../../../bazel-bin/${file}`)
                return __webpack_require__('./node_modules/selenium-webdriver/lib sync recursive')(
                  path.resolve(`../../../bazel-bin/${file}`)
                )
              } catch (ex2) {
                console.log(ex2)
                throw Error(
                  `Failed to import atoms module ${module}. If running in dev mode, you` +
                    ` need to run \`bazel build ${bazelTarget}\` from the project` +
                    `root: ${ex}`
                )
              }
            }
          }

          /**
           * Converts a headers map to a HTTP header block string.
           * @param {!Map<string, string>} headers The map to convert.
           * @return {string} The headers as a string.
           */
          function headersToString(headers) {
            const ret = []
            headers.forEach(function (value, name) {
              ret.push(`${name.toLowerCase()}: ${value}`)
            })
            return ret.join('\n')
          }

          /**
           * Represents a HTTP request message. This class is a "partial" request and only
           * defines the path on the server to send a request to. It is each client's
           * responsibility to build the full URL for the final request.
           * @final
           */
          class Request {
            /**
             * @param {string} method The HTTP method to use for the request.
             * @param {string} path The path on the server to send the request to.
             * @param {Object=} opt_data This request's non-serialized JSON payload data.
             */
            constructor(method, path, opt_data) {
              this.method = /** string */ method
              this.path = /** string */ path
              this.data = /** Object */ opt_data
              this.headers = /** !Map<string, string> */ new Map([
                ['Accept', 'application/json; charset=utf-8']
              ])
            }

            /** @override */
            toString() {
              let ret = `${this.method} ${this.path} HTTP/1.1\n`
              ret += headersToString(this.headers) + '\n\n'
              if (this.data) {
                ret += JSON.stringify(this.data)
              }
              return ret
            }
          }

          /**
           * Represents a HTTP response message.
           * @final
           */
          class Response {
            /**
             * @param {number} status The response code.
             * @param {!Object<string>} headers The response headers. All header names
             *     will be converted to lowercase strings for consistent lookups.
             * @param {string} body The response body.
             */
            constructor(status, headers, body) {
              this.status = /** number */ status
              this.body = /** string */ body
              this.headers = /** !Map<string, string>*/ new Map()
              for (let header in headers) {
                this.headers.set(header.toLowerCase(), headers[header])
              }
            }

            /** @override */
            toString() {
              let ret = `HTTP/1.1 ${this.status}\n${headersToString(this.headers)}\n\n`
              if (this.body) {
                ret += this.body
              }
              return ret
            }
          }

          /** @enum {!Function} */
          const Atom = {
            GET_ATTRIBUTE: getAttribute,
            IS_DISPLAYED: isDisplayed,
            FIND_ELEMENTS: findElements
          }

          const LOG = logging.getLogger('webdriver.http')

          function post(path) {
            return resource('POST', path)
          }
          function del(path) {
            return resource('DELETE', path)
          }
          function get(path) {
            return resource('GET', path)
          }
          function resource(method, path) {
            return { method: method, path: path }
          }

          /** @typedef {{method: string, path: string}} */
          var CommandSpec // eslint-disable-line

          /** @typedef {function(!cmd.Command): !cmd.Command} */
          var CommandTransformer // eslint-disable-line

          class InternalTypeError extends TypeError {}

          /**
           * @param {!cmd.Command} command The initial command.
           * @param {Atom} atom The name of the atom to execute.
           * @param params
           * @return {!Command} The transformed command to execute.
           */
          function toExecuteAtomCommand(command, atom, name, ...params) {
            if (typeof atom !== 'function') {
              throw new InternalTypeError('atom is not a function: ' + typeof atom)
            }

            return new cmd.Command(cmd.Name.EXECUTE_SCRIPT)
              .setParameter('sessionId', command.getParameter('sessionId'))
              .setParameter('script', `/* ${name} */return (${atom}).apply(null, arguments)`)
              .setParameter(
                'args',
                params.map((param) => command.getParameter(param))
              )
          }

          /** @const {!Map<string, (CommandSpec|CommandTransformer)>} */
          const W3C_COMMAND_MAP = new Map([
            // Session management.
            [cmd.Name.NEW_SESSION, post('/session')],
            [cmd.Name.QUIT, del('/session/:sessionId')],

            // Server status.
            [cmd.Name.GET_SERVER_STATUS, get('/status')],

            // timeouts
            [cmd.Name.GET_TIMEOUT, get('/session/:sessionId/timeouts')],
            [cmd.Name.SET_TIMEOUT, post('/session/:sessionId/timeouts')],

            // Navigation.
            [cmd.Name.GET_CURRENT_URL, get('/session/:sessionId/url')],
            [cmd.Name.GET, post('/session/:sessionId/url')],
            [cmd.Name.GO_BACK, post('/session/:sessionId/back')],
            [cmd.Name.GO_FORWARD, post('/session/:sessionId/forward')],
            [cmd.Name.REFRESH, post('/session/:sessionId/refresh')],

            // Page inspection.
            [cmd.Name.GET_PAGE_SOURCE, get('/session/:sessionId/source')],
            [cmd.Name.GET_TITLE, get('/session/:sessionId/title')],

            // Script execution.
            [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute/sync')],
            [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute/async')],

            // Frame selection.
            [cmd.Name.SWITCH_TO_FRAME, post('/session/:sessionId/frame')],
            [cmd.Name.SWITCH_TO_FRAME_PARENT, post('/session/:sessionId/frame/parent')],

            // Window management.
            [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window')],
            [cmd.Name.CLOSE, del('/session/:sessionId/window')],
            [cmd.Name.SWITCH_TO_WINDOW, post('/session/:sessionId/window')],
            [cmd.Name.SWITCH_TO_NEW_WINDOW, post('/session/:sessionId/window/new')],
            [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window/handles')],
            [cmd.Name.GET_WINDOW_RECT, get('/session/:sessionId/window/rect')],
            [cmd.Name.SET_WINDOW_RECT, post('/session/:sessionId/window/rect')],
            [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/maximize')],
            [cmd.Name.MINIMIZE_WINDOW, post('/session/:sessionId/window/minimize')],
            [cmd.Name.FULLSCREEN_WINDOW, post('/session/:sessionId/window/fullscreen')],

            // Actions.
            [cmd.Name.ACTIONS, post('/session/:sessionId/actions')],
            [cmd.Name.CLEAR_ACTIONS, del('/session/:sessionId/actions')],
            [cmd.Name.PRINT_PAGE, post('/session/:sessionId/print')],

            // Locating elements.
            [cmd.Name.GET_ACTIVE_ELEMENT, get('/session/:sessionId/element/active')],
            [cmd.Name.FIND_ELEMENT, post('/session/:sessionId/element')],
            [cmd.Name.FIND_ELEMENTS, post('/session/:sessionId/elements')],
            [
              cmd.Name.FIND_ELEMENTS_RELATIVE,
              (cmd) => {
                return toExecuteAtomCommand(cmd, Atom.FIND_ELEMENTS, 'findElements', 'args')
              }
            ],
            [cmd.Name.FIND_CHILD_ELEMENT, post('/session/:sessionId/element/:id/element')],
            [cmd.Name.FIND_CHILD_ELEMENTS, post('/session/:sessionId/element/:id/elements')],
            // Element interaction.
            [cmd.Name.GET_ELEMENT_TAG_NAME, get('/session/:sessionId/element/:id/name')],
            [cmd.Name.GET_DOM_ATTRIBUTE, get('/session/:sessionId/element/:id/attribute/:name')],
            [
              cmd.Name.GET_ELEMENT_ATTRIBUTE,
              (cmd) => {
                return toExecuteAtomCommand(cmd, Atom.GET_ATTRIBUTE, 'getAttribute', 'id', 'name')
              }
            ],
            [cmd.Name.GET_ELEMENT_PROPERTY, get('/session/:sessionId/element/:id/property/:name')],
            [
              cmd.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY,
              get('/session/:sessionId/element/:id/css/:propertyName')
            ],
            [cmd.Name.GET_ELEMENT_RECT, get('/session/:sessionId/element/:id/rect')],
            [cmd.Name.CLEAR_ELEMENT, post('/session/:sessionId/element/:id/clear')],
            [cmd.Name.CLICK_ELEMENT, post('/session/:sessionId/element/:id/click')],
            [cmd.Name.SEND_KEYS_TO_ELEMENT, post('/session/:sessionId/element/:id/value')],
            [cmd.Name.GET_ELEMENT_TEXT, get('/session/:sessionId/element/:id/text')],
            [cmd.Name.GET_COMPUTED_ROLE, get('/session/:sessionId/element/:id/computedrole')],
            [cmd.Name.GET_COMPUTED_LABEL, get('/session/:sessionId/element/:id/computedlabel')],
            [cmd.Name.IS_ELEMENT_ENABLED, get('/session/:sessionId/element/:id/enabled')],
            [cmd.Name.IS_ELEMENT_SELECTED, get('/session/:sessionId/element/:id/selected')],

            [
              cmd.Name.IS_ELEMENT_DISPLAYED,
              (cmd) => {
                return toExecuteAtomCommand(cmd, Atom.IS_DISPLAYED, 'isDisplayed', 'id')
              }
            ],

            // Cookie management.
            [cmd.Name.GET_ALL_COOKIES, get('/session/:sessionId/cookie')],
            [cmd.Name.ADD_COOKIE, post('/session/:sessionId/cookie')],
            [cmd.Name.DELETE_ALL_COOKIES, del('/session/:sessionId/cookie')],
            [cmd.Name.GET_COOKIE, get('/session/:sessionId/cookie/:name')],
            [cmd.Name.DELETE_COOKIE, del('/session/:sessionId/cookie/:name')],

            // Alert management.
            [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/alert/accept')],
            [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/alert/dismiss')],
            [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert/text')],
            [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert/text')],

            // Screenshots.
            [cmd.Name.SCREENSHOT, get('/session/:sessionId/screenshot')],
            [cmd.Name.TAKE_ELEMENT_SCREENSHOT, get('/session/:sessionId/element/:id/screenshot')],

            // Shadow Root
            [cmd.Name.GET_SHADOW_ROOT, get('/session/:sessionId/element/:id/shadow')],
            [cmd.Name.FIND_ELEMENT_FROM_SHADOWROOT, post('/session/:sessionId/shadow/:id/element')],
            [
              cmd.Name.FIND_ELEMENTS_FROM_SHADOWROOT,
              post('/session/:sessionId/shadow/:id/elements')
            ],
            // Log extensions.
            [cmd.Name.GET_LOG, post('/session/:sessionId/se/log')],
            [cmd.Name.GET_AVAILABLE_LOG_TYPES, get('/session/:sessionId/se/log/types')],

            // Server Extensions
            [cmd.Name.UPLOAD_FILE, post('/session/:sessionId/se/file')],

            // Virtual Authenticator
            [
              cmd.Name.ADD_VIRTUAL_AUTHENTICATOR,
              post('/session/:sessionId/webauthn/authenticator')
            ],
            [
              cmd.Name.REMOVE_VIRTUAL_AUTHENTICATOR,
              del('/session/:sessionId/webauthn/authenticator/:authenticatorId')
            ],
            [
              cmd.Name.ADD_CREDENTIAL,
              post('/session/:sessionId/webauthn/authenticator/:authenticatorId/credential')
            ],
            [
              cmd.Name.GET_CREDENTIALS,
              get('/session/:sessionId/webauthn/authenticator/:authenticatorId/credentials')
            ],
            [
              cmd.Name.REMOVE_CREDENTIAL,
              del(
                '/session/:sessionId/webauthn/authenticator/:authenticatorId/credentials/:credentialId'
              )
            ],
            [
              cmd.Name.REMOVE_ALL_CREDENTIALS,
              del('/session/:sessionId/webauthn/authenticator/:authenticatorId/credentials')
            ],
            [
              cmd.Name.SET_USER_VERIFIED,
              post('/session/:sessionId/webauthn/authenticator/:authenticatorId/uv')
            ]
          ])

          /**
           * Handles sending HTTP messages to a remote end.
           *
           * @interface
           */
          class Client {
            /**
             * Sends a request to the server. The client will automatically follow any
             * redirects returned by the server, fulfilling the returned promise with the
             * final response.
             *
             * @param {!Request} httpRequest The request to send.
             * @return {!Promise<Response>} A promise that will be fulfilled with the
             *     server's response.
             */
            send(httpRequest) {} // eslint-disable-line
          }

          /**
           * @param {Map<string, CommandSpec>} customCommands
           *     A map of custom command definitions.
           * @param {!cmd.Command} command The command to resolve.
           * @return {!Request} A promise that will resolve with the
           *     command to execute.
           */
          function buildRequest(customCommands, command) {
            LOG.finest(() => `Translating command: ${command.getName()}`)
            let spec = customCommands && customCommands.get(command.getName())
            if (spec) {
              return toHttpRequest(spec)
            }

            spec = W3C_COMMAND_MAP.get(command.getName())
            if (typeof spec === 'function') {
              LOG.finest(() => `Transforming command for W3C: ${command.getName()}`)
              let newCommand = spec(command)
              return buildRequest(customCommands, newCommand)
            } else if (spec) {
              return toHttpRequest(spec)
            }
            throw new error.UnknownCommandError('Unrecognized command: ' + command.getName())

            /**
             * @param {CommandSpec} resource
             * @return {!Request}
             */
            function toHttpRequest(resource) {
              LOG.finest(() => `Building HTTP request: ${JSON.stringify(resource)}`)
              let parameters = command.getParameters()
              let path = buildPath(resource.path, parameters)
              return new Request(resource.method, path, parameters)
            }
          }

          const CLIENTS = /** !WeakMap<!Executor, !(Client|IThenable<!Client>)> */ new WeakMap()

          /**
           * A command executor that communicates with the server using JSON over HTTP.
           *
           * By default, each instance of this class will use the legacy wire protocol
           * from [Selenium project][json]. The executor will automatically switch to the
           * [W3C wire protocol][w3c] if the remote end returns a compliant response to
           * a new session command.
           *
           * [json]: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol
           * [w3c]: https://w3c.github.io/webdriver/webdriver-spec.html
           *
           * @implements {cmd.Executor}
           */
          class Executor {
            /**
             * @param {!(Client|IThenable<!Client>)} client The client to use for sending
             *     requests to the server, or a promise-like object that will resolve
             *     to the client.
             */
            constructor(client) {
              CLIENTS.set(this, client)

              /** @private {Map<string, CommandSpec>} */
              this.customCommands_ = null

              /** @private {!logging.Logger} */
              this.log_ = logging.getLogger('webdriver.http.Executor')
            }

            /**
             * Defines a new command for use with this executor. When a command is sent,
             * the {@code path} will be preprocessed using the command's parameters; any
             * path segments prefixed with ":" will be replaced by the parameter of the
             * same name. For example, given "/person/:name" and the parameters
             * "{name: 'Bob'}", the final command path will be "/person/Bob".
             *
             * @param {string} name The command name.
             * @param {string} method The HTTP method to use when sending this command.
             * @param {string} path The path to send the command to, relative to
             *     the WebDriver server's command root and of the form
             *     "/path/:variable/segment".
             */
            defineCommand(name, method, path) {
              if (!this.customCommands_) {
                this.customCommands_ = new Map()
              }
              this.customCommands_.set(name, { method, path })
            }

            /** @override */
            async execute(command) {
              let request = buildRequest(this.customCommands_, command)
              this.log_.finer(() => `>>> ${request.method} ${request.path}`)

              let client = CLIENTS.get(this)
              if (promise.isPromise(client)) {
                client = await client
                CLIENTS.set(this, client)
              }

              let response = await client.send(request)
              this.log_.finer(() => `>>>\n${request}\n<<<\n${response}`)

              let httpResponse = /** @type {!Response} */ (response)

              let { isW3C, value } = parseHttpResponse(command, httpResponse)

              if (command.getName() === cmd.Name.NEW_SESSION) {
                if (!value || !value.sessionId) {
                  throw new error.WebDriverError(
                    `Unable to parse new session response: ${response.body}`
                  )
                }

                // The remote end is a W3C compliant server if there is no `status`
                // field in the response.
                if (command.getName() === cmd.Name.NEW_SESSION) {
                  this.w3c = this.w3c || isW3C
                }

                // No implementations use the `capabilities` key yet...
                let capabilities = value.capabilities || value.value
                return new Session(
                  /** @type {{sessionId: string}} */ (value).sessionId,
                  capabilities
                )
              }

              return typeof value === 'undefined' ? null : value
            }
          }

          /**
           * @param {string} str .
           * @return {?} .
           */
          function tryParse(str) {
            try {
              return JSON.parse(str)
            } catch (ignored) {
              // Do nothing.
            }
          }

          /**
           * Callback used to parse {@link Response} objects from a
           * {@link HttpClient}.
           *
           * @param {!cmd.Command} command The command the response is for.
           * @param {!Response} httpResponse The HTTP response to parse.
           * @return {{isW3C: boolean, value: ?}} An object describing the parsed
           *     response. This object will have two fields: `isW3C` indicates whether
           *     the response looks like it came from a remote end that conforms with the
           *     W3C WebDriver spec, and `value`, the actual response value.
           * @throws {WebDriverError} If the HTTP response is an error.
           */
          function parseHttpResponse(command, httpResponse) {
            if (httpResponse.status < 200) {
              // This should never happen, but throw the raw response so users report it.
              throw new error.WebDriverError(`Unexpected HTTP response:\n${httpResponse}`)
            }

            let parsed = tryParse(httpResponse.body)

            if (parsed && typeof parsed === 'object') {
              let value = parsed.value
              let isW3C = isObject(value) && typeof parsed.status === 'undefined'

              if (!isW3C) {
                error.checkLegacyResponse(parsed)

                // Adjust legacy new session responses to look like W3C to simplify
                // later processing.
                if (command.getName() === cmd.Name.NEW_SESSION) {
                  value = parsed
                }
              } else if (httpResponse.status > 399) {
                error.throwDecodedError(value)
              }

              return { isW3C, value }
            }

            if (parsed !== undefined) {
              return { isW3C: false, value: parsed }
            }

            let value = httpResponse.body.replace(/\r\n/g, '\n')

            // 404 represents an unknown command; anything else > 399 is a generic unknown
            // error.
            if (httpResponse.status === 404) {
              throw new error.UnsupportedOperationError(command.getName() + ': ' + value)
            } else if (httpResponse.status >= 400) {
              throw new error.WebDriverError(value)
            }

            return { isW3C: false, value: value || null }
          }

          /**
           * Builds a fully qualified path using the given set of command parameters. Each
           * path segment prefixed with ':' will be replaced by the value of the
           * corresponding parameter. All parameters spliced into the path will be
           * removed from the parameter map.
           * @param {string} path The original resource path.
           * @param {!Object<*>} parameters The parameters object to splice into the path.
           * @return {string} The modified path.
           */
          function buildPath(path, parameters) {
            let pathParameters = path.match(/\/:(\w+)\b/g)
            if (pathParameters) {
              for (let i = 0; i < pathParameters.length; ++i) {
                let key = pathParameters[i].substring(2) // Trim the /:
                if (key in parameters) {
                  let value = parameters[key]
                  if (webElement.isId(value)) {
                    // When inserting a WebElement into the URL, only use its ID value,
                    // not the full JSON.
                    value = webElement.extractId(value)
                  }
                  path = path.replace(pathParameters[i], '/' + value)
                  delete parameters[key]
                } else {
                  throw new error.InvalidArgumentError('Missing required parameter: ' + key)
                }
              }
            }
            return path
          }

          // PUBLIC API

          module.exports = {
            Executor,
            Client,
            Request,
            Response,
            // Exported for testing.
            buildPath
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/input.js':
        /*!******************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/input.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines types related to user input with the WebDriver API.
           */
          const { Command, Name } = __webpack_require__(
            /*! ./command */ './node_modules/selenium-webdriver/lib/command.js'
          )
          const { InvalidArgumentError } = __webpack_require__(
            /*! ./error */ './node_modules/selenium-webdriver/lib/error.js'
          )

          /**
           * Enumeration of the buttons used in the advanced interactions API.
           * @enum {number}
           */
          const Button = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            BACK: 3,
            FORWARD: 4
          }

          /**
           * Representations of pressable keys that aren't text.  These are stored in
           * the Unicode PUA (Private Use Area) code points, 0xE000-0xF8FF.  Refer to
           * http://www.google.com.au/search?&q=unicode+pua&btnK=Search
           *
           * @enum {string}
           * @see <https://www.w3.org/TR/webdriver/#keyboard-actions>
           */
          const Key = {
            NULL: '\uE000',
            CANCEL: '\uE001', // ^break
            HELP: '\uE002',
            BACK_SPACE: '\uE003',
            TAB: '\uE004',
            CLEAR: '\uE005',
            RETURN: '\uE006',
            ENTER: '\uE007',
            SHIFT: '\uE008',
            CONTROL: '\uE009',
            ALT: '\uE00A',
            PAUSE: '\uE00B',
            ESCAPE: '\uE00C',
            SPACE: '\uE00D',
            PAGE_UP: '\uE00E',
            PAGE_DOWN: '\uE00F',
            END: '\uE010',
            HOME: '\uE011',
            ARROW_LEFT: '\uE012',
            LEFT: '\uE012',
            ARROW_UP: '\uE013',
            UP: '\uE013',
            ARROW_RIGHT: '\uE014',
            RIGHT: '\uE014',
            ARROW_DOWN: '\uE015',
            DOWN: '\uE015',
            INSERT: '\uE016',
            DELETE: '\uE017',
            SEMICOLON: '\uE018',
            EQUALS: '\uE019',

            NUMPAD0: '\uE01A', // number pad keys
            NUMPAD1: '\uE01B',
            NUMPAD2: '\uE01C',
            NUMPAD3: '\uE01D',
            NUMPAD4: '\uE01E',
            NUMPAD5: '\uE01F',
            NUMPAD6: '\uE020',
            NUMPAD7: '\uE021',
            NUMPAD8: '\uE022',
            NUMPAD9: '\uE023',
            MULTIPLY: '\uE024',
            ADD: '\uE025',
            SEPARATOR: '\uE026',
            SUBTRACT: '\uE027',
            DECIMAL: '\uE028',
            DIVIDE: '\uE029',

            F1: '\uE031', // function keys
            F2: '\uE032',
            F3: '\uE033',
            F4: '\uE034',
            F5: '\uE035',
            F6: '\uE036',
            F7: '\uE037',
            F8: '\uE038',
            F9: '\uE039',
            F10: '\uE03A',
            F11: '\uE03B',
            F12: '\uE03C',

            COMMAND: '\uE03D', // Apple command key
            META: '\uE03D', // alias for Windows key

            /**
             * Japanese modifier key for switching between full- and half-width
             * characters.
             * @see <https://en.wikipedia.org/wiki/Language_input_keys>
             */
            ZENKAKU_HANKAKU: '\uE040'
          }

          /**
           * Simulate pressing many keys at once in a "chord". Takes a sequence of
           * {@linkplain Key keys} or strings, appends each of the values to a string,
           * adds the chord termination key ({@link Key.NULL}) and returns the resulting
           * string.
           *
           * Note: when the low-level webdriver key handlers see Keys.NULL, active
           * modifier keys (CTRL/ALT/SHIFT/etc) release via a keyup event.
           *
           * @param {...string} keys The key sequence to concatenate.
           * @return {string} The null-terminated key sequence.
           */
          Key.chord = function (...keys) {
            return keys.join('') + Key.NULL
          }

          /**
           * Used with {@link ./webelement.WebElement#sendKeys WebElement#sendKeys} on
           * file input elements (`<input type="file">`) to detect when the entered key
           * sequence defines the path to a file.
           *
           * By default, {@linkplain ./webelement.WebElement WebElement's} will enter all
           * key sequences exactly as entered. You may set a
           * {@linkplain ./webdriver.WebDriver#setFileDetector file detector} on the
           * parent WebDriver instance to define custom behavior for handling file
           * elements. Of particular note is the
           * {@link selenium-webdriver/remote.FileDetector}, which should be used when
           * running against a remote
           * [Selenium Server](https://selenium.dev/downloads/).
           */
          class FileDetector {
            /**
             * Handles the file specified by the given path, preparing it for use with
             * the current browser. If the path does not refer to a valid file, it will
             * be returned unchanged, otherwise a path suitable for use with the current
             * browser will be returned.
             *
             * This default implementation is a no-op. Subtypes may override this function
             * for custom tailored file handling.
             *
             * @param {!./webdriver.WebDriver} driver The driver for the current browser.
             * @param {string} path The path to process.
             * @return {!Promise<string>} A promise for the processed file path.
             * @package
             */
            handleFile(_driver, path) {
              // eslint-disable-line
              return Promise.resolve(path)
            }
          }

          /**
           * Generic description of a single action to send to the remote end.
           *
           * @record
           * @package
           */
          class Action {
            constructor() {
              /** @type {!Action.Type} */
              this.type
              /** @type {(number|undefined)} */
              this.duration
              /** @type {(string|undefined)} */
              this.value
              /** @type {(Button|undefined)} */
              this.button
              /** @type {(number|undefined)} */
              this.x
              /** @type {(number|undefined)} */
              this.y
            }
          }

          /**
           * @enum {string}
           * @package
           * @see <https://w3c.github.io/webdriver/webdriver-spec.html#terminology-0>
           */
          Action.Type = {
            KEY_DOWN: 'keyDown',
            KEY_UP: 'keyUp',
            PAUSE: 'pause',
            POINTER_DOWN: 'pointerDown',
            POINTER_UP: 'pointerUp',
            POINTER_MOVE: 'pointerMove',
            POINTER_CANCEL: 'pointerCancel',
            SCROLL: 'scroll'
          }

          /**
           * Represents a user input device.
           *
           * @abstract
           */
          class Device {
            /**
             * @param {Device.Type} type the input type.
             * @param {string} id a unique ID for this device.
             */
            constructor(type, id) {
              /** @private @const */ this.type_ = type
              /** @private @const */ this.id_ = id
            }

            /** @return {!Object} the JSON encoding for this device. */
            toJSON() {
              return { type: this.type_, id: this.id_ }
            }
          }

          /**
           * Device types supported by the WebDriver protocol.
           *
           * @enum {string}
           * @see <https://w3c.github.io/webdriver/webdriver-spec.html#input-source-state>
           */
          Device.Type = {
            KEY: 'key',
            NONE: 'none',
            POINTER: 'pointer',
            WHEEL: 'wheel'
          }

          /**
           * @param {(string|Key|number)} key
           * @return {string}
           * @throws {!(InvalidArgumentError|RangeError)}
           */
          function checkCodePoint(key) {
            if (typeof key === 'number') {
              return String.fromCodePoint(key)
            }

            if (typeof key !== 'string') {
              throw new InvalidArgumentError(`key is not a string: ${key}`)
            }

            key = key.normalize()
            if (Array.from(key).length !== 1) {
              throw new InvalidArgumentError(`key input is not a single code point: ${key}`)
            }
            return key
          }

          /**
           * Keyboard input device.
           *
           * @final
           * @see <https://www.w3.org/TR/webdriver/#dfn-key-input-source>
           */
          class Keyboard extends Device {
            /** @param {string} id the device ID. */
            constructor(id) {
              super(Device.Type.KEY, id)
            }

            /**
             * Generates a key down action.
             *
             * @param {(Key|string|number)} key the key to press. This key may be
             *     specified as a {@link Key} value, a specific unicode code point,
             *     or a string containing a single unicode code point.
             * @return {!Action} a new key down action.
             * @package
             */
            keyDown(key) {
              return { type: Action.Type.KEY_DOWN, value: checkCodePoint(key) }
            }

            /**
             * Generates a key up action.
             *
             * @param {(Key|string|number)} key the key to press. This key may be
             *     specified as a {@link Key} value, a specific unicode code point,
             *     or a string containing a single unicode code point.
             * @return {!Action} a new key up action.
             * @package
             */
            keyUp(key) {
              return { type: Action.Type.KEY_UP, value: checkCodePoint(key) }
            }
          }

          /**
           * Defines the reference point from which to compute offsets for
           * {@linkplain ./input.Pointer#move pointer move} actions.
           *
           * @enum {string}
           */
          const Origin = {
            /** Compute offsets relative to the pointer's current position. */
            POINTER: 'pointer',
            /** Compute offsets relative to the viewport. */
            VIEWPORT: 'viewport'
          }

          /**
           * Pointer input device.
           *
           * @final
           * @see <https://www.w3.org/TR/webdriver/#dfn-pointer-input-source>
           */
          class Pointer extends Device {
            /**
             * @param {string} id the device ID.
             * @param {Pointer.Type} type the pointer type.
             */
            constructor(id, type) {
              super(Device.Type.POINTER, id)
              /** @private @const */ this.pointerType_ = type
            }

            /** @override */
            toJSON() {
              return Object.assign(
                { parameters: { pointerType: this.pointerType_ } },
                super.toJSON()
              )
            }

            /**
             * @return {!Action} An action that cancels this pointer's current input.
             * @package
             */
            cancel() {
              return { type: Action.Type.POINTER_CANCEL }
            }

            /**
             * @param {!Button=} button The button to press.
             * @param width
             * @param height
             * @param pressure
             * @param tangentialPressure
             * @param tiltX
             * @param tiltY
             * @param twist
             * @param altitudeAngle
             * @param azimuthAngle
             * @return {!Action} An action to press the specified button with this device.
             * @package
             */
            press(
              button = Button.LEFT,
              width = 0,
              height = 0,
              pressure = 0,
              tangentialPressure = 0,
              tiltX = 0,
              tiltY = 0,
              twist = 0,
              altitudeAngle = 0,
              azimuthAngle = 0
            ) {
              return {
                type: Action.Type.POINTER_DOWN,
                button,
                width,
                height,
                pressure,
                tangentialPressure,
                tiltX,
                tiltY,
                twist,
                altitudeAngle,
                azimuthAngle
              }
            }

            /**
             * @param {!Button=} button The button to release.
             * @return {!Action} An action to release the specified button with this
             *     device.
             * @package
             */
            release(button = Button.LEFT) {
              return { type: Action.Type.POINTER_UP, button }
            }

            /**
             * Creates an action for moving the pointer `x` and `y` pixels from the
             * specified `origin`. The `origin` may be defined as the pointer's
             * {@linkplain Origin.POINTER current position}, the
             * {@linkplain Origin.VIEWPORT viewport}, or the center of a specific
             * {@linkplain ./webdriver.WebElement WebElement}.
             *
             * @param {{
             *   x: (number|undefined),
             *   y: (number|undefined),
             *   duration: (number|undefined),
             *   origin: (!Origin|!./webdriver.WebElement|undefined),
             * }=} options the move options.
             * @return {!Action} The new action.
             * @package
             */
            move({
              x = 0,
              y = 0,
              duration = 100,
              origin = Origin.VIEWPORT,
              width = 0,
              height = 0,
              pressure = 0,
              tangentialPressure = 0,
              tiltX = 0,
              tiltY = 0,
              twist = 0,
              altitudeAngle = 0,
              azimuthAngle = 0
            }) {
              return {
                type: Action.Type.POINTER_MOVE,
                origin,
                duration,
                x,
                y,
                width,
                height,
                pressure,
                tangentialPressure,
                tiltX,
                tiltY,
                twist,
                altitudeAngle,
                azimuthAngle
              }
            }
          }

          /**
           * The supported types of pointers.
           * @enum {string}
           */
          Pointer.Type = {
            MOUSE: 'mouse',
            PEN: 'pen',
            TOUCH: 'touch'
          }

          class Wheel extends Device {
            /**
             * @param {string} id the device ID..
             */
            constructor(id) {
              super(Device.Type.WHEEL, id)
            }

            /**
             * Scrolls a page via the coordinates given
             * @param {number} x starting x coordinate
             * @param {number} y starting y coordinate
             * @param {number} deltaX Delta X to scroll to target
             * @param {number} deltaY Delta Y to scroll to target
             * @param {WebElement} origin element origin
             * @param {number} duration duration ratio be the ratio of time delta and duration
             * @returns {!Action} An action to scroll with this device.
             */
            scroll(x, y, deltaX, deltaY, origin, duration) {
              return {
                type: Action.Type.SCROLL,
                duration: duration,
                x: x,
                y: y,
                deltaX: deltaX,
                deltaY: deltaY,
                origin: origin
              }
            }
          }

          /**
           * User facing API for generating complex user gestures. This class should not
           * be instantiated directly. Instead, users should create new instances by
           * calling {@link ./webdriver.WebDriver#actions WebDriver.actions()}.
           *
           * ### Action Ticks
           *
           * Action sequences are divided into a series of "ticks". At each tick, the
           * WebDriver remote end will perform a single action for each device included
           * in the action sequence. At tick 0, the driver will perform the first action
           * defined for each device, at tick 1 the second action for each device, and
           * so on until all actions have been executed. If an individual device does
           * not have an action defined at a particular tick, it will automatically
           * pause.
           *
           * By default, action sequences will be synchronized so only one device has a
           * define action in each tick. Consider the following code sample:
           *
           *     const actions = driver.actions();
           *
           *     await actions
           *         .keyDown(SHIFT)
           *         .move({origin: el})
           *         .press()
           *         .release()
           *         .keyUp(SHIFT)
           *         .perform();
           *
           * This sample produces the following sequence of ticks:
           *
           * | Device   | Tick 1         | Tick 2             | Tick 3  | Tick 4    | Tick 5       |
           * | -------- | -------------- | ------------------ | ------- | --------- | ------------ |
           * | Keyboard | keyDown(SHIFT) | pause()            | pause() | pause()   | keyUp(SHIFT) |
           * | Mouse    | pause()        | move({origin: el}) | press() | release() | pause()      |
           *
           * If you'd like the remote end to execute actions with multiple devices
           * simultaneously, you may pass `{async: true}` when creating the actions
           * builder. With synchronization disabled (`{async: true}`), the ticks from our
           * previous example become:
           *
           * | Device   | Tick 1             | Tick 2       | Tick 3    |
           * | -------- | ------------------ | ------------ | --------- |
           * | Keyboard | keyDown(SHIFT)     | keyUp(SHIFT) |           |
           * | Mouse    | move({origin: el}) | press()      | release() |
           *
           * When synchronization is disabled, it is your responsibility to insert
           * {@linkplain #pause() pauses} for each device, as needed:
           *
           *     const actions = driver.actions({async: true});
           *     const kb = actions.keyboard();
           *     const mouse = actions.mouse();
           *
           *     actions.keyDown(SHIFT).pause(kb).pause(kb).key(SHIFT);
           *     actions.pause(mouse).move({origin: el}).press().release();
           *     actions.perform();
           *
           * With pauses insert for individual devices, we're back to:
           *
           * | Device   | Tick 1         | Tick 2             | Tick 3  | Tick 4       |
           * | -------- | -------------- | ------------------ | ------- | ------------ |
           * | Keyboard | keyDown(SHIFT) | pause()            | pause() | keyUp(SHIFT) |
           * | Mouse    | pause()        | move({origin: el}) | press() | release()    |
           *
           * #### Tick Durations
           *
           * The length of each action tick is however long it takes the remote end to
           * execute the actions for every device in that tick. Most actions are
           * "instantaneous", however, {@linkplain #pause pause} and
           * {@linkplain #move pointer move} actions allow you to specify a duration for
           * how long that action should take. The remote end will always wait for all
           * actions within a tick to finish before starting the next tick, so a device
           * may implicitly pause while waiting for other devices to finish.
           *
           * | Device    | Tick 1                | Tick 2  |
           * | --------- | --------------------- | ------- |
           * | Pointer 1 | move({duration: 200}) | press() |
           * | Pointer 2 | move({duration: 300}) | press() |
           *
           * In table above, the move for Pointer 1 should only take 200 ms, but the
           * remote end will wait for the move for Pointer 2 to finish
           * (an additional 100 ms) before proceeding to Tick 2.
           *
           * This implicit waiting also applies to pauses. In the table below, even though
           * the keyboard only defines a pause of 100 ms, the remote end will wait an
           * additional 200 ms for the mouse move to finish before moving to Tick 2.
           *
           * | Device   | Tick 1                | Tick 2         |
           * | -------- | --------------------- | -------------- |
           * | Keyboard | pause(100)            | keyDown(SHIFT) |
           * | Mouse    | move({duration: 300}) |                |
           *
           * [client rect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getClientRects
           * [bounding client rect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
           *
           * @final
           * @see <https://www.w3.org/TR/webdriver/#actions>
           */
          class Actions {
            /**
             * @param {!Executor} executor The object to execute the configured
             *     actions with.
             * @param {{async: (boolean|undefined)}} options Options for this action
             *     sequence (see class description for details).
             */
            constructor(executor, { async = false } = {}) {
              /** @private @const */
              this.executor_ = executor

              /** @private @const */
              this.sync_ = !async

              /** @private @const */
              this.keyboard_ = new Keyboard('default keyboard')

              /** @private @const */
              this.mouse_ = new Pointer('default mouse', Pointer.Type.MOUSE)

              /** @private @const */
              this.wheel_ = new Wheel('default wheel')

              /** @private @const {!Map<!Device, !Array<!Action>>} */
              this.sequences_ = new Map([
                [this.keyboard_, []],
                [this.mouse_, []],
                [this.wheel_, []]
              ])
            }

            /** @return {!Keyboard} the keyboard device handle. */
            keyboard() {
              return this.keyboard_
            }

            /** @return {!Pointer} the mouse pointer device handle. */
            mouse() {
              return this.mouse_
            }

            /** @return {!Wheel} the wheel device handle. */
            wheel() {
              return this.wheel_
            }

            /**
             * @param {!Device} device
             * @return {!Array<!Action>}
             * @private
             */
            sequence_(device) {
              let sequence = this.sequences_.get(device)
              if (!sequence) {
                sequence = []
                this.sequences_.set(device, sequence)
              }
              return sequence
            }

            /**
             * Appends `actions` to the end of the current sequence for the given
             * `device`. If device synchronization is enabled, after inserting the
             * actions, pauses will be inserted for all other devices to ensure all action
             * sequences are the same length.
             *
             * @param {!Device} device the device to update.
             * @param {...!Action} actions the actions to insert.
             * @return {!Actions} a self reference.
             */
            insert(device, ...actions) {
              this.sequence_(device).push(...actions)
              return this.sync_ ? this.synchronize() : this
            }

            /**
             * Ensures the action sequence for every device referenced in this action
             * sequence is the same length. For devices whose sequence is too short,
             * this will insert {@linkplain #pause pauses} so that every device has an
             * explicit action defined at each tick.
             *
             * @param {...!Device} devices The specific devices to synchronize.
             *     If unspecified, the action sequences for every device will be
             *     synchronized.
             * @return {!Actions} a self reference.
             */
            synchronize(...devices) {
              let sequences
              let max = 0
              if (devices.length === 0) {
                for (const s of this.sequences_.values()) {
                  max = Math.max(max, s.length)
                }
                sequences = this.sequences_.values()
              } else {
                sequences = []
                for (const device of devices) {
                  const seq = this.sequence_(device)
                  max = Math.max(max, seq.length)
                  sequences.push(seq)
                }
              }

              const pause = { type: Action.Type.PAUSE, duration: 0 }
              for (const seq of sequences) {
                while (seq.length < max) {
                  seq.push(pause)
                }
              }

              return this
            }

            /**
             * Inserts a pause action for the specified devices, ensuring each device is
             * idle for a tick. The length of the pause (in milliseconds) may be specified
             * as the first parameter to this method (defaults to 0). Otherwise, you may
             * just specify the individual devices that should pause.
             *
             * If no devices are specified, a pause action will be created (using the same
             * duration) for every device.
             *
             * When device synchronization is enabled (the default for new {@link Actions}
             * objects), there is no need to specify devices as pausing one automatically
             * pauses the others for the same duration. In other words, the following are
             * all equivalent:
             *
             *     let a1 = driver.actions();
             *     a1.pause(100).perform();
             *
             *     let a2 = driver.actions();
             *     a2.pause(100, a2.keyboard()).perform();
             *     // Synchronization ensures a2.mouse() is automatically paused too.
             *
             *     let a3 = driver.actions();
             *     a3.pause(100, a3.keyboard(), a3.mouse()).perform();
             *
             * When device synchronization is _disabled_, you can cause individual devices
             * to pause during a tick. For example, to hold the SHIFT key down while
             * moving the mouse:
             *
             *     let actions = driver.actions({async: true});
             *
             *     actions.keyDown(Key.SHIFT);
             *     actions.pause(actions.mouse())  // Pause for shift down
             *         .press(Button.LEFT)
             *         .move({x: 10, y: 10})
             *         .release(Button.LEFT);
             *     actions
             *         .pause(
             *             actions.keyboard(),  // Pause for press left
             *             actions.keyboard(),  // Pause for move
             *             actions.keyboard())  // Pause for release left
             *        .keyUp(Key.SHIFT);
             *     await actions.perform();
             *
             * @param {(number|!Device)=} duration The length of the pause to insert, in
             *     milliseconds. Alternatively, the duration may be omitted (yielding a
             *     default 0 ms pause), and the first device to pause may be specified.
             * @param {...!Device} devices The devices to insert the pause for. If no
             *     devices are specified, the pause will be inserted for _all_ devices.
             * @return {!Actions} a self reference.
             */
            pause(duration, ...devices) {
              if (duration instanceof Device) {
                devices.push(duration)
                duration = 0
              } else if (!duration) {
                duration = 0
              }

              const action = { type: Action.Type.PAUSE, duration }

              // NB: need a properly typed variable for type checking.
              /** @type {!Iterable<!Device>} */
              const iterable = devices.length === 0 ? this.sequences_.keys() : devices
              for (const device of iterable) {
                this.sequence_(device).push(action)
              }
              return this.sync_ ? this.synchronize() : this
            }

            /**
             * Inserts an action to press a single key.
             *
             * @param {(Key|string|number)} key the key to press. This key may be
             *     specified as a {@link Key} value, a specific unicode code point,
             *     or a string containing a single unicode code point.
             * @return {!Actions} a self reference.
             */
            keyDown(key) {
              return this.insert(this.keyboard_, this.keyboard_.keyDown(key))
            }

            /**
             * Inserts an action to release a single key.
             *
             * @param {(Key|string|number)} key the key to release. This key may be
             *     specified as a {@link Key} value, a specific unicode code point,
             *     or a string containing a single unicode code point.
             * @return {!Actions} a self reference.
             */
            keyUp(key) {
              return this.insert(this.keyboard_, this.keyboard_.keyUp(key))
            }

            /**
             * Inserts a sequence of actions to type the provided key sequence.
             * For each key, this will record a pair of {@linkplain #keyDown keyDown}
             * and {@linkplain #keyUp keyUp} actions. An implication of this pairing
             * is that modifier keys (e.g. {@link ./input.Key.SHIFT Key.SHIFT}) will
             * always be immediately released. In other words, `sendKeys(Key.SHIFT, 'a')`
             * is the same as typing `sendKeys('a')`, _not_ `sendKeys('A')`.
             *
             * @param {...(Key|string|number)} keys the keys to type.
             * @return {!Actions} a self reference.
             */
            sendKeys(...keys) {
              const { WebElement } = __webpack_require__(
                /*! ./webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
              )

              const actions = []
              if (keys.length > 1 && keys[0] instanceof WebElement) {
                this.click(keys[0])
                keys.shift()
              }
              for (const key of keys) {
                if (typeof key === 'string') {
                  for (const symbol of key) {
                    actions.push(this.keyboard_.keyDown(symbol), this.keyboard_.keyUp(symbol))
                  }
                } else {
                  actions.push(this.keyboard_.keyDown(key), this.keyboard_.keyUp(key))
                }
              }
              return this.insert(this.keyboard_, ...actions)
            }

            /**
             * Inserts an action to press a mouse button at the mouse's current location.
             *
             * @param {!Button=} button The button to press; defaults to `LEFT`.
             * @return {!Actions} a self reference.
             */
            press(button = Button.LEFT) {
              return this.insert(this.mouse_, this.mouse_.press(button))
            }

            /**
             * Inserts an action to release a mouse button at the mouse's current
             * location.
             *
             * @param {!Button=} button The button to release; defaults to `LEFT`.
             * @return {!Actions} a self reference.
             */
            release(button = Button.LEFT) {
              return this.insert(this.mouse_, this.mouse_.release(button))
            }

            /**
             * scrolls a page via the coordinates given
             * @param {number} x starting x coordinate
             * @param {number} y starting y coordinate
             * @param {number} deltax delta x to scroll to target
             * @param {number} deltay delta y to scroll to target
             * @param {number} duration duration ratio be the ratio of time delta and duration
             * @returns {!Actions} An action to scroll with this device.
             */
            scroll(x, y, targetDeltaX, targetDeltaY, origin, duration) {
              return this.insert(
                this.wheel_,
                this.wheel_.scroll(x, y, targetDeltaX, targetDeltaY, origin, duration)
              )
            }

            /**
             * Inserts an action for moving the mouse `x` and `y` pixels relative to the
             * specified `origin`. The `origin` may be defined as the mouse's
             * {@linkplain ./input.Origin.POINTER current position}, the top-left corner of the
             * {@linkplain ./input.Origin.VIEWPORT viewport}, or the center of a specific
             * {@linkplain ./webdriver.WebElement WebElement}. Default is top left corner of the view-port if origin is not specified
             *
             * You may adjust how long the remote end should take, in milliseconds, to
             * perform the move using the `duration` parameter (defaults to 100 ms).
             * The number of incremental move events generated over this duration is an
             * implementation detail for the remote end.
             *
             * @param {{
             *   x: (number|undefined),
             *   y: (number|undefined),
             *   duration: (number|undefined),
             *   origin: (!Origin|!./webdriver.WebElement|undefined),
             * }=} options The move options. Defaults to moving the mouse to the top-left
             *     corner of the viewport over 100ms.
             * @return {!Actions} a self reference.
             */
            move({ x = 0, y = 0, duration = 100, origin = Origin.VIEWPORT } = {}) {
              return this.insert(this.mouse_, this.mouse_.move({ x, y, duration, origin }))
            }

            /**
             * Short-hand for performing a simple left-click (down/up) with the mouse.
             *
             * @param {./webdriver.WebElement=} element If specified, the mouse will
             *     first be moved to the center of the element before performing the
             *     click.
             * @return {!Actions} a self reference.
             */
            click(element) {
              if (element) {
                this.move({ origin: element })
              }
              return this.press().release()
            }

            /**
             * Short-hand for performing a simple right-click (down/up) with the mouse.
             *
             * @param {./webdriver.WebElement=} element If specified, the mouse will
             *     first be moved to the center of the element before performing the
             *     click.
             * @return {!Actions} a self reference.
             */
            contextClick(element) {
              if (element) {
                this.move({ origin: element })
              }
              return this.press(Button.RIGHT).release(Button.RIGHT)
            }

            /**
             * Short-hand for performing a double left-click with the mouse.
             *
             * @param {./webdriver.WebElement=} element If specified, the mouse will
             *     first be moved to the center of the element before performing the
             *     click.
             * @return {!Actions} a self reference.
             */
            doubleClick(element) {
              return this.click(element).press().release()
            }

            /**
             * Configures a drag-and-drop action consisting of the following steps:
             *
             * 1.  Move to the center of the `from` element (element to be dragged).
             * 2.  Press the left mouse button.
             * 3.  If the `to` target is a {@linkplain ./webdriver.WebElement WebElement},
             *     move the mouse to its center. Otherwise, move the mouse by the
             *     specified offset.
             * 4.  Release the left mouse button.
             *
             * @param {!./webdriver.WebElement} from The element to press the left mouse
             *     button on to start the drag.
             * @param {(!./webdriver.WebElement|{x: number, y: number})} to Either another
             *     element to drag to (will drag to the center of the element), or an
             *     object specifying the offset to drag by, in pixels.
             * @return {!Actions} a self reference.
             */
            dragAndDrop(from, to) {
              // Do not require up top to avoid a cycle that breaks static analysis.
              const { WebElement } = __webpack_require__(
                /*! ./webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
              )
              if (
                !(to instanceof WebElement) &&
                (!to || typeof to.x !== 'number' || typeof to.y !== 'number')
              ) {
                throw new InvalidArgumentError(
                  'Invalid drag target; must specify a WebElement or {x, y} offset'
                )
              }

              this.move({ origin: from }).press()
              if (to instanceof WebElement) {
                this.move({ origin: to })
              } else {
                this.move({ x: to.x, y: to.y, origin: Origin.POINTER })
              }
              return this.release()
            }

            /**
             * Releases all keys, pointers, and clears internal state.
             *
             * @return {!Promise<void>} a promise that will resolve when finished
             *     clearing all action state.
             */
            clear() {
              for (const s of this.sequences_.values()) {
                s.length = 0
              }
              return this.executor_.execute(new Command(Name.CLEAR_ACTIONS))
            }

            /**
             * Performs the configured action sequence.
             *
             * @return {!Promise<void>} a promise that will resolve when all actions have
             *     been completed.
             */
            async perform() {
              const _actions = []
              this.sequences_.forEach((actions, device) => {
                if (!isIdle(actions)) {
                  actions = actions.concat() // Defensive copy.
                  _actions.push(Object.assign({ actions }, device.toJSON()))
                }
              })

              if (_actions.length === 0) {
                return Promise.resolve()
              }

              await this.executor_.execute(
                new Command(Name.ACTIONS).setParameter('actions', _actions)
              )
            }
          }

          /**
           * @param {!Array<!Action>} actions
           * @return {boolean}
           */
          function isIdle(actions) {
            return (
              actions.length === 0 ||
              actions.every((a) => a.type === Action.Type.PAUSE && !a.duration)
            )
          }

          /**
           * Script used to compute the offset from the center of a DOM element's first
           * client rect from the top-left corner of the element's bounding client rect.
           * The element's center point is computed using the algorithm defined here:
           * <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-center-point>.
           *
           * __This is only exported for use in internal unit tests. DO NOT USE.__
           *
           * @package
           */
          const INTERNAL_COMPUTE_OFFSET_SCRIPT = `
function computeOffset(el) {
  var rect = el.getClientRects()[0];
  var left = Math.max(0, Math.min(rect.x, rect.x + rect.width));
  var right =
      Math.min(window.innerWidth, Math.max(rect.x, rect.x + rect.width));
  var top = Math.max(0, Math.min(rect.y, rect.y + rect.height));
  var bot =
      Math.min(window.innerHeight, Math.max(rect.y, rect.y + rect.height));
  var x = Math.floor(0.5 * (left + right));
  var y = Math.floor(0.5 * (top + bot));

  var bbox = el.getBoundingClientRect();
  return [x - bbox.left, y - bbox.top];
}
return computeOffset(arguments[0]);`

          // PUBLIC API

          module.exports = {
            Action, // For documentation only.
            Actions,
            Button,
            Device,
            Key,
            Keyboard,
            FileDetector,
            Origin,
            Pointer,
            INTERNAL_COMPUTE_OFFSET_SCRIPT
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/logging.js':
        /*!********************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/logging.js ***!
  \********************************************************/
        /***/ (module) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines WebDriver's logging system. The logging system is
           * broken into major components: local and remote logging.
           *
           * The local logging API, which is anchored by the {@linkplain Logger} class is
           * similar to Java's logging API. Loggers, retrieved by
           * {@linkplain #getLogger getLogger(name)}, use hierarchical, dot-delimited
           * namespaces (e.g. "" > "webdriver" > "webdriver.logging"). Recorded log
           * messages are represented by the {@linkplain Entry} class. You can capture log
           * records by {@linkplain Logger#addHandler attaching} a handler function to the
           * desired logger. For convenience, you can quickly enable logging to the
           * console by simply calling {@linkplain #installConsoleHandler
           * installConsoleHandler}.
           *
           * The [remote logging API](https://github.com/SeleniumHQ/selenium/wiki/Logging)
           * allows you to retrieve logs from a remote WebDriver server. This API uses the
           * {@link Preferences} class to define desired log levels prior to creating
           * a WebDriver session:
           *
           *     var prefs = new logging.Preferences();
           *     prefs.setLevel(logging.Type.BROWSER, logging.Level.DEBUG);
           *
           *     var caps = Capabilities.chrome();
           *     caps.setLoggingPrefs(prefs);
           *     // ...
           *
           * Remote log entries, also represented by the {@link Entry} class, may be
           * retrieved via {@link webdriver.WebDriver.Logs}:
           *
           *     driver.manage().logs().get(logging.Type.BROWSER)
           *         .then(function(entries) {
           *            entries.forEach(function(entry) {
           *              console.log('[%s] %s', entry.level.name, entry.message);
           *            });
           *         });
           *
           * **NOTE:** Only a few browsers support the remote logging API (notably
           * Firefox and Chrome). Firefox supports basic logging functionality, while
           * Chrome exposes robust
           * [performance logging](https://chromedriver.chromium.org/logging)
           * options. Remote logging is still considered a non-standard feature, and the
           * APIs exposed by this module for it are non-frozen. This module will be
           * updated, possibly breaking backwards-compatibility, once logging is
           * officially defined by the
           * [W3C WebDriver spec](http://www.w3.org/TR/webdriver/).
           */

          /**
           * Defines a message level that may be used to control logging output.
           *
           * @final
           */
          class Level {
            /**
             * @param {string} name the level's name.
             * @param {number} level the level's numeric value.
             */
            constructor(name, level) {
              if (level < 0) {
                throw new TypeError('Level must be >= 0')
              }

              /** @private {string} */
              this.name_ = name

              /** @private {number} */
              this.value_ = level
            }

            /** This logger's name. */
            get name() {
              return this.name_
            }

            /** The numeric log level. */
            get value() {
              return this.value_
            }

            /** @override */
            toString() {
              return this.name
            }
          }

          /**
           * Indicates no log messages should be recorded.
           * @const
           */
          Level.OFF = new Level('OFF', Infinity)

          /**
           * Log messages with a level of `1000` or higher.
           * @const
           */
          Level.SEVERE = new Level('SEVERE', 1000)

          /**
           * Log messages with a level of `900` or higher.
           * @const
           */
          Level.WARNING = new Level('WARNING', 900)

          /**
           * Log messages with a level of `800` or higher.
           * @const
           */
          Level.INFO = new Level('INFO', 800)

          /**
           * Log messages with a level of `700` or higher.
           * @const
           */
          Level.DEBUG = new Level('DEBUG', 700)

          /**
           * Log messages with a level of `500` or higher.
           * @const
           */
          Level.FINE = new Level('FINE', 500)

          /**
           * Log messages with a level of `400` or higher.
           * @const
           */
          Level.FINER = new Level('FINER', 400)

          /**
           * Log messages with a level of `300` or higher.
           * @const
           */
          Level.FINEST = new Level('FINEST', 300)

          /**
           * Indicates all log messages should be recorded.
           * @const
           */
          Level.ALL = new Level('ALL', 0)

          const ALL_LEVELS = /** !Set<Level> */ new Set([
            Level.OFF,
            Level.SEVERE,
            Level.WARNING,
            Level.INFO,
            Level.DEBUG,
            Level.FINE,
            Level.FINER,
            Level.FINEST,
            Level.ALL
          ])

          const LEVELS_BY_NAME = /** !Map<string, !Level> */ new Map([
            [Level.OFF.name, Level.OFF],
            [Level.SEVERE.name, Level.SEVERE],
            [Level.WARNING.name, Level.WARNING],
            [Level.INFO.name, Level.INFO],
            [Level.DEBUG.name, Level.DEBUG],
            [Level.FINE.name, Level.FINE],
            [Level.FINER.name, Level.FINER],
            [Level.FINEST.name, Level.FINEST],
            [Level.ALL.name, Level.ALL]
          ])

          /**
           * Converts a level name or value to a {@link Level} value. If the name/value
           * is not recognized, {@link Level.ALL} will be returned.
           *
           * @param {(number|string)} nameOrValue The log level name, or value, to
           *     convert.
           * @return {!Level} The converted level.
           */
          function getLevel(nameOrValue) {
            if (typeof nameOrValue === 'string') {
              return LEVELS_BY_NAME.get(nameOrValue) || Level.ALL
            }
            if (typeof nameOrValue !== 'number') {
              throw new TypeError('not a string or number')
            }
            for (let level of ALL_LEVELS) {
              if (nameOrValue >= level.value) {
                return level
              }
            }
            return Level.ALL
          }

          /**
           * Describes a single log entry.
           *
           * @final
           */
          class Entry {
            /**
             * @param {(!Level|string|number)} level The entry level.
             * @param {string} message The log message.
             * @param {number=} opt_timestamp The time this entry was generated, in
             *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the
             *     current time will be used.
             * @param {string=} opt_type The log type, if known.
             */
            constructor(level, message, opt_timestamp, opt_type) {
              this.level = level instanceof Level ? level : getLevel(level)
              this.message = message
              this.timestamp = typeof opt_timestamp === 'number' ? opt_timestamp : Date.now()
              this.type = opt_type || ''
            }

            /**
             * @return {{level: string, message: string, timestamp: number,
             *           type: string}} The JSON representation of this entry.
             */
            toJSON() {
              return {
                level: this.level.name,
                message: this.message,
                timestamp: this.timestamp,
                type: this.type
              }
            }
          }

          /**
           * An object used to log debugging messages. Loggers use a hierarchical,
           * dot-separated naming scheme. For instance, "foo" is considered the parent of
           * the "foo.bar" and an ancestor of "foo.bar.baz".
           *
           * Each logger may be assigned a {@linkplain #setLevel log level}, which
           * controls which level of messages will be reported to the
           * {@linkplain #addHandler handlers} attached to this instance. If a log level
           * is not explicitly set on a logger, it will inherit its parent.
           *
           * This class should never be directly instantiated. Instead, users should
           * obtain logger references using the {@linkplain ./logging.getLogger()
           * getLogger()} function.
           *
           * @final
           */
          class Logger {
            /**
             * @param {string} name the name of this logger.
             * @param {Level=} opt_level the initial level for this logger.
             */
            constructor(name, opt_level) {
              /** @private {string} */
              this.name_ = name

              /** @private {Level} */
              this.level_ = opt_level || null

              /** @private {Logger} */
              this.parent_ = null

              /** @private {Set<function(!Entry)>} */
              this.handlers_ = null
            }

            /** @return {string} the name of this logger. */
            getName() {
              return this.name_
            }

            /**
             * @param {Level} level the new level for this logger, or `null` if the logger
             *     should inherit its level from its parent logger.
             */
            setLevel(level) {
              this.level_ = level
            }

            /** @return {Level} the log level for this logger. */
            getLevel() {
              return this.level_
            }

            /**
             * @return {!Level} the effective level for this logger.
             */
            getEffectiveLevel() {
              let logger = this
              let level
              do {
                level = logger.level_
                logger = logger.parent_
              } while (logger && !level)
              return level || Level.OFF
            }

            /**
             * @param {!Level} level the level to check.
             * @return {boolean} whether messages recorded at the given level are loggable
             *     by this instance.
             */
            isLoggable(level) {
              return (
                level.value !== Level.OFF.value && level.value >= this.getEffectiveLevel().value
              )
            }

            /**
             * Adds a handler to this logger. The handler will be invoked for each message
             * logged with this instance, or any of its descendants.
             *
             * @param {function(!Entry)} handler the handler to add.
             */
            addHandler(handler) {
              if (!this.handlers_) {
                this.handlers_ = new Set()
              }
              this.handlers_.add(handler)
            }

            /**
             * Removes a handler from this logger.
             *
             * @param {function(!Entry)} handler the handler to remove.
             * @return {boolean} whether a handler was successfully removed.
             */
            removeHandler(handler) {
              if (!this.handlers_) {
                return false
              }
              return this.handlers_.delete(handler)
            }

            /**
             * Logs a message at the given level. The message may be defined as a string
             * or as a function that will return the message. If a function is provided,
             * it will only be invoked if this logger's
             * {@linkplain #getEffectiveLevel() effective log level} includes the given
             * `level`.
             *
             * @param {!Level} level the level at which to log the message.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            log(level, loggable) {
              if (!this.isLoggable(level)) {
                return
              }
              let message =
                '[' + this.name_ + '] ' + (typeof loggable === 'function' ? loggable() : loggable)
              let entry = new Entry(level, message, Date.now())
              for (let logger = this; logger; logger = logger.parent_) {
                if (logger.handlers_) {
                  for (let handler of logger.handlers_) {
                    handler(entry)
                  }
                }
              }
            }

            /**
             * Logs a message at the {@link Level.SEVERE} log level.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            severe(loggable) {
              this.log(Level.SEVERE, loggable)
            }

            /**
             * Logs a message at the {@link Level.WARNING} log level.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            warning(loggable) {
              this.log(Level.WARNING, loggable)
            }

            /**
             * Logs a message at the {@link Level.INFO} log level.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            info(loggable) {
              this.log(Level.INFO, loggable)
            }

            /**
             * Logs a message at the {@link Level.DEBUG} log level.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            debug(loggable) {
              this.log(Level.DEBUG, loggable)
            }

            /**
             * Logs a message at the {@link Level.FINE} log level.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            fine(loggable) {
              this.log(Level.FINE, loggable)
            }

            /**
             * Logs a message at the {@link Level.FINER} log level.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            finer(loggable) {
              this.log(Level.FINER, loggable)
            }

            /**
             * Logs a message at the {@link Level.FINEST} log level.
             * @param {(string|function(): string)} loggable the message to log, or a
             *     function that will return the message.
             */
            finest(loggable) {
              this.log(Level.FINEST, loggable)
            }
          }

          /**
           * Maintains a collection of loggers.
           *
           * @final
           */
          class LogManager {
            constructor() {
              /** @private {!Map<string, !Logger>} */
              this.loggers_ = new Map()
              this.root_ = new Logger('', Level.OFF)
            }

            /**
             * Retrieves a named logger, creating it in the process. This function will
             * implicitly create the requested logger, and any of its parents, if they
             * do not yet exist.
             *
             * @param {string} name the logger's name.
             * @return {!Logger} the requested logger.
             */
            getLogger(name) {
              if (!name) {
                return this.root_
              }
              let parent = this.root_
              for (let i = name.indexOf('.'); i != -1; i = name.indexOf('.', i + 1)) {
                let parentName = name.substr(0, i)
                parent = this.createLogger_(parentName, parent)
              }
              return this.createLogger_(name, parent)
            }

            /**
             * Creates a new logger.
             *
             * @param {string} name the logger's name.
             * @param {!Logger} parent the logger's parent.
             * @return {!Logger} the new logger.
             * @private
             */
            createLogger_(name, parent) {
              if (this.loggers_.has(name)) {
                return /** @type {!Logger} */ (this.loggers_.get(name))
              }
              let logger = new Logger(name, null)
              logger.parent_ = parent
              this.loggers_.set(name, logger)
              return logger
            }
          }

          const logManager = new LogManager()

          /**
           * Retrieves a named logger, creating it in the process. This function will
           * implicitly create the requested logger, and any of its parents, if they
           * do not yet exist.
           *
           * The log level will be unspecified for newly created loggers. Use
           * {@link Logger#setLevel(level)} to explicitly set a level.
           *
           * @param {string} name the logger's name.
           * @return {!Logger} the requested logger.
           */
          function getLogger(name) {
            return logManager.getLogger(name)
          }

          /**
           * Pads a number to ensure it has a minimum of two digits.
           *
           * @param {number} n the number to be padded.
           * @return {string} the padded number.
           */
          function pad(n) {
            if (n >= 10) {
              return '' + n
            } else {
              return '0' + n
            }
          }

          /**
           * Logs all messages to the Console API.
           * @param {!Entry} entry the entry to log.
           */
          function consoleHandler(entry) {
            if (typeof console === 'undefined' || !console) {
              return
            }

            var timestamp = new Date(entry.timestamp)
            var msg =
              '[' +
              timestamp.getUTCFullYear() +
              '-' +
              pad(timestamp.getUTCMonth() + 1) +
              '-' +
              pad(timestamp.getUTCDate()) +
              'T' +
              pad(timestamp.getUTCHours()) +
              ':' +
              pad(timestamp.getUTCMinutes()) +
              ':' +
              pad(timestamp.getUTCSeconds()) +
              'Z] ' +
              '[' +
              entry.level.name +
              '] ' +
              entry.message

            var level = entry.level.value
            if (level >= Level.SEVERE.value) {
              console.error(msg)
            } else if (level >= Level.WARNING.value) {
              console.warn(msg)
            } else {
              console.log(msg)
            }
          }

          /**
           * Adds the console handler to the given logger. The console handler will log
           * all messages using the JavaScript Console API.
           *
           * @param {Logger=} opt_logger The logger to add the handler to; defaults
           *     to the root logger.
           */
          function addConsoleHandler(opt_logger) {
            let logger = opt_logger || logManager.root_
            logger.addHandler(consoleHandler)
          }

          /**
           * Removes the console log handler from the given logger.
           *
           * @param {Logger=} opt_logger The logger to remove the handler from; defaults
           *     to the root logger.
           * @see exports.addConsoleHandler
           */
          function removeConsoleHandler(opt_logger) {
            let logger = opt_logger || logManager.root_
            logger.removeHandler(consoleHandler)
          }

          /**
           * Installs the console log handler on the root logger.
           */
          function installConsoleHandler() {
            addConsoleHandler(logManager.root_)
          }

          /**
           * Common log types.
           * @enum {string}
           */
          const Type = {
            /** Logs originating from the browser. */
            BROWSER: 'browser',
            /** Logs from a WebDriver client. */
            CLIENT: 'client',
            /** Logs from a WebDriver implementation. */
            DRIVER: 'driver',
            /** Logs related to performance. */
            PERFORMANCE: 'performance',
            /** Logs from the remote server. */
            SERVER: 'server'
          }

          /**
           * Describes the log preferences for a WebDriver session.
           *
           * @final
           */
          class Preferences {
            constructor() {
              /** @private {!Map<string, !Level>} */
              this.prefs_ = new Map()
            }

            /**
             * Sets the desired logging level for a particular log type.
             * @param {(string|Type)} type The log type.
             * @param {(!Level|string|number)} level The desired log level.
             * @throws {TypeError} if `type` is not a `string`.
             */
            setLevel(type, level) {
              if (typeof type !== 'string') {
                throw TypeError('specified log type is not a string: ' + typeof type)
              }
              this.prefs_.set(type, level instanceof Level ? level : getLevel(level))
            }

            /**
             * Converts this instance to its JSON representation.
             * @return {!Object<string, string>} The JSON representation of this set of
             *     preferences.
             */
            toJSON() {
              let json = {}
              for (let key of this.prefs_.keys()) {
                json[key] = this.prefs_.get(key).name
              }
              return json
            }
          }

          // PUBLIC API

          module.exports = {
            Entry: Entry,
            Level: Level,
            LogManager: LogManager,
            Logger: Logger,
            Preferences: Preferences,
            Type: Type,
            addConsoleHandler: addConsoleHandler,
            getLevel: getLevel,
            getLogger: getLogger,
            installConsoleHandler: installConsoleHandler,
            removeConsoleHandler: removeConsoleHandler
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/pinnedScript.js':
        /*!*************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/pinnedScript.js ***!
  \*************************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const crypto = __webpack_require__(/*! crypto */ 'crypto')

          class PinnedScript {
            constructor(script) {
              this.scriptSource_ = script
              this.scriptHandle_ = crypto.randomUUID().replace(/-/gi, '')
            }

            get handle() {
              return this.scriptHandle_
            }

            get source() {
              return this.scriptSource_
            }

            get scriptId() {
              return this.scriptId_
            }

            set scriptId(id) {
              this.scriptId_ = id
            }

            creationScript() {
              return `function __webdriver_${this.scriptHandle_}(arguments) { ${this.scriptSource_} }`
            }

            executionScript() {
              return `return __webdriver_${this.scriptHandle_}(arguments)`
            }

            removalScript() {
              return `__webdriver_${this.scriptHandle_} = undefined`
            }
          }

          // PUBLIC API

          module.exports = {
            PinnedScript
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/promise.js':
        /*!********************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/promise.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines a handful of utility functions to simplify working
           * with promises.
           */

          const { isObject, isPromise } = __webpack_require__(
            /*! ./util */ './node_modules/selenium-webdriver/lib/util.js'
          )

          /**
           * Creates a promise that will be resolved at a set time in the future.
           * @param {number} ms The amount of time, in milliseconds, to wait before
           *     resolving the promise.
           * @return {!Promise<void>} The promise.
           */
          function delayed(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms))
          }

          /**
           * Wraps a function that expects a node-style callback as its final
           * argument. This callback expects two arguments: an error value (which will be
           * null if the call succeeded), and the success value as the second argument.
           * The callback will the resolve or reject the returned promise, based on its
           * arguments.
           * @param {!Function} fn The function to wrap.
           * @param {...?} args The arguments to apply to the function, excluding the
           *     final callback.
           * @return {!Thenable} A promise that will be resolved with the
           *     result of the provided function's callback.
           */
          function checkedNodeCall(fn, ...args) {
            return new Promise(function (fulfill, reject) {
              try {
                fn(...args, function (error, value) {
                  error ? reject(error) : fulfill(value)
                })
              } catch (ex) {
                reject(ex)
              }
            })
          }

          /**
           * Registers a listener to invoke when a promise is resolved, regardless
           * of whether the promise's value was successfully computed. This function
           * is synonymous with the {@code finally} clause in a synchronous API:
           *
           *     // Synchronous API:
           *     try {
           *       doSynchronousWork();
           *     } finally {
           *       cleanUp();
           *     }
           *
           *     // Asynchronous promise API:
           *     doAsynchronousWork().finally(cleanUp);
           *
           * __Note:__ similar to the {@code finally} clause, if the registered
           * callback returns a rejected promise or throws an error, it will silently
           * replace the rejection error (if any) from this promise:
           *
           *     try {
           *       throw Error('one');
           *     } finally {
           *       throw Error('two');  // Hides Error: one
           *     }
           *
           *     let p = Promise.reject(Error('one'));
           *     promise.finally(p, function() {
           *       throw Error('two');  // Hides Error: one
           *     });
           *
           * @param {!IThenable<?>} promise The promise to add the listener to.
           * @param {function(): (R|IThenable<R>)} callback The function to call when
           *     the promise is resolved.
           * @return {!Promise<R>} A promise that will be resolved with the callback
           *     result.
           * @template R
           */
          async function thenFinally(promise, callback) {
            try {
              await Promise.resolve(promise)
              return callback()
            } catch (e) {
              await callback()
              throw e
            }
          }

          /**
           * Calls a function for each element in an array and inserts the result into a
           * new array, which is used as the fulfillment value of the promise returned
           * by this function.
           *
           * If the return value of the mapping function is a promise, this function
           * will wait for it to be fulfilled before inserting it into the new array.
           *
           * If the mapping function throws or returns a rejected promise, the
           * promise returned by this function will be rejected with the same reason.
           * Only the first failure will be reported; all subsequent errors will be
           * silently ignored.
           *
           * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate
           *     over, or a promise that will resolve to said array.
           * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The
           *     function to call for each element in the array. This function should
           *     expect three arguments (the element, the index, and the array itself.
           * @param {SELF=} self The object to be used as the value of 'this' within `fn`.
           * @template TYPE, SELF
           */
          async function map(array, fn, self = undefined) {
            const v = await Promise.resolve(array)
            if (!Array.isArray(v)) {
              throw TypeError('not an array')
            }

            const arr = /** @type {!Array} */ (v)
            const values = []

            for (const [index, item] of arr.entries()) {
              values.push(await Promise.resolve(fn.call(self, item, index, arr)))
            }

            return values
          }

          /**
           * Calls a function for each element in an array, and if the function returns
           * true adds the element to a new array.
           *
           * If the return value of the filter function is a promise, this function
           * will wait for it to be fulfilled before determining whether to insert the
           * element into the new array.
           *
           * If the filter function throws or returns a rejected promise, the promise
           * returned by this function will be rejected with the same reason. Only the
           * first failure will be reported; all subsequent errors will be silently
           * ignored.
           *
           * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate
           *     over, or a promise that will resolve to said array.
           * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (
           *             boolean|IThenable<boolean>)} fn The function
           *     to call for each element in the array.
           * @param {SELF=} self The object to be used as the value of 'this' within `fn`.
           * @template TYPE, SELF
           */
          async function filter(array, fn, self = undefined) {
            const v = await Promise.resolve(array)
            if (!Array.isArray(v)) {
              throw TypeError('not an array')
            }

            const arr = /** @type {!Array} */ (v)
            const values = []

            for (const [index, item] of arr.entries()) {
              const isConditionTrue = await Promise.resolve(fn.call(self, item, index, arr))
              if (isConditionTrue) {
                values.push(item)
              }
            }

            return values
          }

          /**
           * Returns a promise that will be resolved with the input value in a
           * fully-resolved state. If the value is an array, each element will be fully
           * resolved. Likewise, if the value is an object, all keys will be fully
           * resolved. In both cases, all nested arrays and objects will also be
           * fully resolved.  All fields are resolved in place; the returned promise will
           * resolve on {@code value} and not a copy.
           *
           * Warning: This function makes no checks against objects that contain
           * cyclical references:
           *
           *     var value = {};
           *     value['self'] = value;
           *     promise.fullyResolved(value);  // Stack overflow.
           *
           * @param {*} value The value to fully resolve.
           * @return {!Thenable} A promise for a fully resolved version
           *     of the input value.
           */
          async function fullyResolved(value) {
            value = await Promise.resolve(value)
            if (Array.isArray(value)) {
              return fullyResolveKeys(/** @type {!Array} */ (value))
            }

            if (isObject(value)) {
              return fullyResolveKeys(/** @type {!Object} */ (value))
            }

            if (typeof value === 'function') {
              return fullyResolveKeys(/** @type {!Object} */ (value))
            }

            return value
          }

          /**
           * @param {!(Array|Object)} obj the object to resolve.
           * @return {!Thenable} A promise that will be resolved with the
           *     input object once all of its values have been fully resolved.
           */
          async function fullyResolveKeys(obj) {
            const isArray = Array.isArray(obj)
            const numKeys = isArray ? obj.length : Object.keys(obj).length

            if (!numKeys) {
              return obj
            }

            async function forEachProperty(obj, fn) {
              for (let key in obj) {
                await fn(obj[key], key)
              }
            }

            async function forEachElement(arr, fn) {
              for (let i = 0; i < arr.length; i++) {
                await fn(arr[i], i)
              }
            }

            const forEachKey = isArray ? forEachElement : forEachProperty
            await forEachKey(obj, async function (partialValue, key) {
              if (
                !Array.isArray(partialValue) &&
                (!partialValue || typeof partialValue !== 'object')
              ) {
                return
              }
              obj[key] = await fullyResolved(partialValue)
            })
            return obj
          }

          // PUBLIC API

          module.exports = {
            checkedNodeCall,
            delayed,
            filter,
            finally: thenFinally,
            fullyResolved,
            isPromise,
            map
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/select.js':
        /*!*******************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/select.js ***!
  \*******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /*
           * Licensed to the Software Freedom Conservancy (SFC) under one
           * or more contributor license agreements.  See the NOTICE file
           * distributed with this work for additional information
           * regarding copyright ownership.  The SFC licenses this file
           * to you under the Apache License, Version 2.0 (the
           * "License"); you may not use this file except in compliance
           * with the License.  You may obtain a copy of the License at
           *
           *   http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing,
           * software distributed under the License is distributed on an
           * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
           * KIND, either express or implied.  See the License for the
           * specific language governing permissions and limitations
           * under the License.
           */

          const { By, escapeCss } = __webpack_require__(
            /*! ./by */ './node_modules/selenium-webdriver/lib/by.js'
          )
          const error = __webpack_require__(
            /*! ./error */ './node_modules/selenium-webdriver/lib/error.js'
          )

          /**
           * ISelect interface makes a protocol for all kind of select elements (standard html and custom
           * model)
           *
           * @interface
           */
          // eslint-disable-next-line no-unused-vars
          class ISelect {
            /**
             * @return {!Promise<boolean>} Whether this select element supports selecting multiple options at the same time? This
             * is done by checking the value of the "multiple" attribute.
             */
            isMultiple() {} // eslint-disable-line

            /**
             * @return {!Promise<!Array<!WebElement>>} All options belonging to this select tag
             */
            getOptions() {} // eslint-disable-line

            /**
             * @return {!Promise<!Array<!WebElement>>} All selected options belonging to this select tag
             */
            getAllSelectedOptions() {} // eslint-disable-line

            /**
             * @return {!Promise<!WebElement>} The first selected option in this select tag (or the currently selected option in a
             * normal select)
             */
            getFirstSelectedOption() {} // eslint-disable-line

            /**
             * Select all options that display text matching the argument. That is, when given "Bar" this
             * would select an option like:
             *
             * &lt;option value="foo"&gt;Bar&lt;/option&gt;
             *
             * @param {string} text The visible text to match against
             * @return {Promise<void>}
             */
            selectByVisibleText(text) {} // eslint-disable-line

            /**
             * Select all options that have a value matching the argument. That is, when given "foo" this
             * would select an option like:
             *
             * &lt;option value="foo"&gt;Bar&lt;/option&gt;
             *
             * @param {string} value The value to match against
             * @return {Promise<void>}
             */
            selectByValue(value) {} // eslint-disable-line

            /**
             * Select the option at the given index. This is done by examining the "index" attribute of an
             * element, and not merely by counting.
             *
             * @param {Number} index The option at this index will be selected
             * @return {Promise<void>}
             */
            selectByIndex(index) {} // eslint-disable-line

            /**
             * Clear all selected entries. This is only valid when the SELECT supports multiple selections.
             *
             * @return {Promise<void>}
             */
            deselectAll() {} // eslint-disable-line

            /**
             * Deselect all options that display text matching the argument. That is, when given "Bar" this
             * would deselect an option like:
             *
             * &lt;option value="foo"&gt;Bar&lt;/option&gt;
             *
             * @param {string} text The visible text to match against
             * @return {Promise<void>}
             */
            deselectByVisibleText(text) {} // eslint-disable-line

            /**
             * Deselect all options that have a value matching the argument. That is, when given "foo" this
             * would deselect an option like:
             *
             * @param {string} value The value to match against
             * @return {Promise<void>}
             */
            deselectByValue(value) {} // eslint-disable-line

            /**
             * Deselect the option at the given index. This is done by examining the "index" attribute of an
             * element, and not merely by counting.
             *
             * @param {Number} index The option at this index will be deselected
             * @return {Promise<void>}
             */
            deselectByIndex(index) {} // eslint-disable-line
          }

          /**
           * @implements ISelect
           */
          class Select {
            /**
             * Create an Select Element
             * @param {WebElement} element Select WebElement.
             */
            constructor(element) {
              this.element = element

              this.element.getAttribute('tagName').then(function (tagName) {
                if (tagName.toLowerCase() !== 'select') {
                  throw new Error(`Select only works on <select> elements`)
                }
              })
            }

            /**
   *
   * Select option with specified index.
   *
   * <example>
   <select id="selectbox">
    <option value="1">Option 1</option>
    <option value="2">Option 2</option>
    <option value="3">Option 3</option>
   </select>
   const selectBox = await driver.findElement(By.id("selectbox"));
   await selectObject.selectByIndex(1);
   * </example>
   *
   * @param index
   */
            async selectByIndex(index) {
              if (index < 0) {
                throw new Error('Index needs to be 0 or any other positive number')
              }

              let options = await this.element.findElements(By.tagName('option'))

              if (options.length === 0) {
                throw new Error("Select element doesn't contain any option element")
              }

              if (options.length - 1 < index) {
                throw new Error(
                  `Option with index "${index}" not found. Select element only contains ${
                    options.length - 1
                  } option elements`
                )
              }

              for (let option of options) {
                if ((await option.getAttribute('index')) === index.toString()) {
                  await this.setSelected(option)
                }
              }
            }

            /**
   *
   * Select option by specific value.
   *
   * <example>
   <select id="selectbox">
   <option value="1">Option 1</option>
   <option value="2">Option 2</option>
   <option value="3">Option 3</option>
   </select>
   const selectBox = await driver.findElement(By.id("selectbox"));
   await selectObject.selectByVisibleText("Option 2");
   * </example>
   *
   *
   * @param {string} value value of option element to be selected
   */
            async selectByValue(value) {
              let matched = false
              let isMulti = await this.isMultiple()

              let options = await this.element.findElements({
                css: 'option[value =' + escapeCss(value) + ']'
              })

              for (let option of options) {
                await this.setSelected(option)

                if (!isMulti) {
                  return
                }
                matched = true
              }

              if (!matched) {
                throw new Error(`Cannot locate option with value: ${value}`)
              }
            }

            /**
   *
   * Select option with displayed text matching the argument.
   *
   * <example>
   <select id="selectbox">
   <option value="1">Option 1</option>
   <option value="2">Option 2</option>
   <option value="3">Option 3</option>
   </select>
   const selectBox = await driver.findElement(By.id("selectbox"));
   await selectObject.selectByVisibleText("Option 2");
   * </example>
   *
   * @param {String|Number} text       text of option element to get selected
   *
   */
            async selectByVisibleText(text) {
              text = typeof text === 'number' ? text.toString() : text

              const normalized = text
                .trim() // strip leading and trailing white-space characters
                .replace(/\s+/, ' ') // replace sequences of whitespace characters by a single space

              /**
               * find option element using xpath
               */
              const formatted = /"/.test(normalized)
                ? 'concat("' + normalized.split('"').join('", \'"\', "') + '")'
                : `"${normalized}"`
              const dotFormat = `[. = ${formatted}]`
              const spaceFormat = `[normalize-space(text()) = ${formatted}]`

              const selections = [
                `./option${dotFormat}`,
                `./option${spaceFormat}`,
                `./optgroup/option${dotFormat}`,
                `./optgroup/option${spaceFormat}`
              ]

              const optionElement = await this.element.findElement({
                xpath: selections.join('|')
              })
              await this.setSelected(optionElement)
            }

            /**
             * Returns a list of all options belonging to this select tag
             * @returns {!Promise<!Array<!WebElement>>}
             */
            async getOptions() {
              return await this.element.findElements({ tagName: 'option' })
            }

            /**
             * Returns a boolean value if the select tag is multiple
             * @returns {Promise<boolean>}
             */
            async isMultiple() {
              return (await this.element.getAttribute('multiple')) !== null
            }

            /**
             * Returns a list of all selected options belonging to this select tag
             *
             * @returns {Promise<void>}
             */
            async getAllSelectedOptions() {
              const opts = await this.getOptions()
              const results = []
              for (let options of opts) {
                if (await options.isSelected()) {
                  results.push(options)
                }
              }
              return results
            }

            /**
             * Returns first Selected Option
             * @returns {Promise<Element>}
             */
            async getFirstSelectedOption() {
              return (await this.getAllSelectedOptions())[0]
            }

            /**
             * Deselects all selected options
             * @returns {Promise<void>}
             */
            async deselectAll() {
              if (!this.isMultiple()) {
                throw new Error('You may only deselect all options of a multi-select')
              }

              const options = await this.getOptions()

              for (let option of options) {
                if (await option.isSelected()) {
                  await option.click()
                }
              }
            }

            /**
             *
             * @param {string|Number}text text of option to deselect
             * @returns {Promise<void>}
             */
            async deselectByVisibleText(text) {
              if (!(await this.isMultiple())) {
                throw new Error('You may only deselect options of a multi-select')
              }

              /**
               * convert value into string
               */
              text = typeof text === 'number' ? text.toString() : text

              const normalized = text
                .trim() // strip leading and trailing white-space characters
                .replace(/\s+/, ' ') // replace sequences of whitespace characters by a single space

              /**
               * find option element using xpath
               */
              const formatted = /"/.test(normalized)
                ? 'concat("' + normalized.split('"').join('", \'"\', "') + '")'
                : `"${normalized}"`
              const dotFormat = `[. = ${formatted}]`
              const spaceFormat = `[normalize-space(text()) = ${formatted}]`

              const selections = [
                `./option${dotFormat}`,
                `./option${spaceFormat}`,
                `./optgroup/option${dotFormat}`,
                `./optgroup/option${spaceFormat}`
              ]

              const optionElement = await this.element.findElement({
                xpath: selections.join('|')
              })
              if (await optionElement.isSelected()) {
                await optionElement.click()
              }
            }

            /**
             *
             * @param {Number} index       index of option element to deselect
             * Deselect the option at the given index.
             * This is done by examining the "index"
             * attribute of an element, and not merely by counting.
             * @returns {Promise<void>}
             */
            async deselectByIndex(index) {
              if (!(await this.isMultiple())) {
                throw new Error('You may only deselect options of a multi-select')
              }

              if (index < 0) {
                throw new Error('Index needs to be 0 or any other positive number')
              }

              let options = await this.element.findElements(By.tagName('option'))

              if (options.length === 0) {
                throw new Error("Select element doesn't contain any option element")
              }

              if (options.length - 1 < index) {
                throw new Error(
                  `Option with index "${index}" not found. Select element only contains ${
                    options.length - 1
                  } option elements`
                )
              }

              for (let option of options) {
                if ((await option.getAttribute('index')) === index.toString()) {
                  if (await option.isSelected()) {
                    await option.click()
                  }
                }
              }
            }

            /**
             *
             * @param {String} value value of an option to deselect
             * @returns {Promise<void>}
             */
            async deselectByValue(value) {
              if (!(await this.isMultiple())) {
                throw new Error('You may only deselect options of a multi-select')
              }

              let matched = false

              let options = await this.element.findElements({
                css: 'option[value =' + escapeCss(value) + ']'
              })

              for (let option of options) {
                if (await option.isSelected()) {
                  await option.click()
                }
                matched = true
              }

              if (!matched) {
                throw new Error(`Cannot locate option with value: ${value}`)
              }
            }

            async setSelected(option) {
              if (!(await option.isSelected())) {
                if (!(await option.isEnabled())) {
                  throw new error.UnsupportedOperationError(`You may not select a disabled option`)
                }
                await option.click()
              }
            }
          }

          module.exports = { Select }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/session.js':
        /*!********************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/session.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { Capabilities } = __webpack_require__(
            /*! ./capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )

          /**
           * Contains information about a single WebDriver session.
           */
          class Session {
            /**
             * @param {string} id The session ID.
             * @param {!./capabilities.Capabilities} capabilities
             *     The session capabilities.
             */
            constructor(id, capabilities) {
              /** @private {string} */
              this.id_ = id

              /** @private {!Capabilities} */
              this.caps_ =
                capabilities instanceof Capabilities
                  ? /** @type {!Capabilities} */ (capabilities)
                  : new Capabilities(capabilities)
            }

            /**
             * @return {string} This session's ID.
             */
            getId() {
              return this.id_
            }

            /**
             * @return {!Capabilities} This session's capabilities.
             */
            getCapabilities() {
              return this.caps_
            }

            /**
             * Retrieves the value of a specific capability.
             * @param {string} key The capability to retrieve.
             * @return {*} The capability value.
             */
            getCapability(key) {
              return this.caps_.get(key)
            }

            /**
             * Returns the JSON representation of this object, which is just the string
             * session ID.
             * @return {string} The JSON representation of this Session.
             */
            toJSON() {
              return this.getId()
            }
          }

          // PUBLIC API

          module.exports = { Session }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/symbols.js':
        /*!********************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/symbols.js ***!
  \********************************************************/
        /***/ (module) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines well-known symbols used within the selenium-webdriver
           * library.
           */

          module.exports = {
            /**
             * The serialize symbol specifies a method that returns an object's serialized
             * representation. If an object's serialized form is not immediately
             * available, the serialize method will return a promise that will be resolved
             * with the serialized form.
             *
             * Note that the described method is analogous to objects that define a
             * `toJSON()` method, except the serialized result may be a promise, or
             * another object with a promised property.
             */
            serialize: Symbol('serialize')
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/until.js':
        /*!******************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/until.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines common conditions for use with
           * {@link webdriver.WebDriver#wait WebDriver wait}.
           *
           * Sample usage:
           *
           *     driver.get('http://www.google.com/ncr');
           *
           *     var query = driver.wait(until.elementLocated(By.name('q')));
           *     query.sendKeys('webdriver\n');
           *
           *     driver.wait(until.titleIs('webdriver - Google Search'));
           *
           * To define a custom condition, simply call WebDriver.wait with a function
           * that will eventually return a truthy-value (neither null, undefined, false,
           * 0, or the empty string):
           *
           *     driver.wait(function() {
           *       return driver.getTitle().then(function(title) {
           *         return title === 'webdriver - Google Search';
           *       });
           *     }, 1000);
           */

          const by = __webpack_require__(/*! ./by */ './node_modules/selenium-webdriver/lib/by.js')
          const error = __webpack_require__(
            /*! ./error */ './node_modules/selenium-webdriver/lib/error.js'
          )
          const webdriver = __webpack_require__(
              /*! ./webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
            ),
            Condition = webdriver.Condition,
            WebElementCondition = webdriver.WebElementCondition

          /**
           * Creates a condition that will wait until the input driver is able to switch
           * to the designated frame. The target frame may be specified as
           *
           * 1. a numeric index into
           *     [window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window.frames)
           *     for the currently selected frame.
           * 2. a {@link ./webdriver.WebElement}, which must reference a FRAME or IFRAME
           *     element on the current page.
           * 3. a locator which may be used to first locate a FRAME or IFRAME on the
           *     current page before attempting to switch to it.
           *
           * Upon successful resolution of this condition, the driver will be left
           * focused on the new frame.
           *
           * @param {!(number|./webdriver.WebElement|By|
           *           function(!./webdriver.WebDriver): !./webdriver.WebElement)} frame
           *     The frame identifier.
           * @return {!Condition<boolean>} A new condition.
           */
          function ableToSwitchToFrame(frame) {
            let condition
            if (typeof frame === 'number' || frame instanceof webdriver.WebElement) {
              condition = (driver) => attemptToSwitchFrames(driver, frame)
            } else {
              condition = function (driver) {
                let locator = /** @type {!(By|Function)} */ (frame)
                return driver.findElements(locator).then(function (els) {
                  if (els.length) {
                    return attemptToSwitchFrames(driver, els[0])
                  }
                })
              }
            }

            return new Condition('to be able to switch to frame', condition)

            function attemptToSwitchFrames(driver, frame) {
              return driver
                .switchTo()
                .frame(frame)
                .then(
                  function () {
                    return true
                  },
                  function (e) {
                    if (!(e instanceof error.NoSuchFrameError)) {
                      throw e
                    }
                  }
                )
            }
          }

          /**
           * Creates a condition that waits for an alert to be opened. Upon success, the
           * returned promise will be fulfilled with the handle for the opened alert.
           *
           * @return {!Condition<!./webdriver.Alert>} The new condition.
           */
          function alertIsPresent() {
            return new Condition('for alert to be present', function (driver) {
              return driver
                .switchTo()
                .alert()
                .catch(function (e) {
                  if (
                    !(
                      e instanceof error.NoSuchAlertError ||
                      // XXX: Workaround for GeckoDriver error `TypeError: can't convert null
                      // to object`. For more details, see
                      // https://github.com/SeleniumHQ/selenium/pull/2137
                      (e instanceof error.WebDriverError &&
                        e.message === `can't convert null to object`)
                    )
                  ) {
                    throw e
                  }
                })
            })
          }

          /**
           * Creates a condition that will wait for the current page's title to match the
           * given value.
           *
           * @param {string} title The expected page title.
           * @return {!Condition<boolean>} The new condition.
           */
          function titleIs(title) {
            return new Condition('for title to be ' + JSON.stringify(title), function (driver) {
              return driver.getTitle().then(function (t) {
                return t === title
              })
            })
          }

          /**
           * Creates a condition that will wait for the current page's title to contain
           * the given substring.
           *
           * @param {string} substr The substring that should be present in the page
           *     title.
           * @return {!Condition<boolean>} The new condition.
           */
          function titleContains(substr) {
            return new Condition('for title to contain ' + JSON.stringify(substr), function (
              driver
            ) {
              return driver.getTitle().then(function (title) {
                return title.indexOf(substr) !== -1
              })
            })
          }

          /**
           * Creates a condition that will wait for the current page's title to match the
           * given regular expression.
           *
           * @param {!RegExp} regex The regular expression to test against.
           * @return {!Condition<boolean>} The new condition.
           */
          function titleMatches(regex) {
            return new Condition('for title to match ' + regex, function (driver) {
              return driver.getTitle().then(function (title) {
                return regex.test(title)
              })
            })
          }

          /**
           * Creates a condition that will wait for the current page's url to match the
           * given value.
           *
           * @param {string} url The expected page url.
           * @return {!Condition<boolean>} The new condition.
           */
          function urlIs(url) {
            return new Condition('for URL to be ' + JSON.stringify(url), function (driver) {
              return driver.getCurrentUrl().then(function (u) {
                return u === url
              })
            })
          }

          /**
           * Creates a condition that will wait for the current page's url to contain
           * the given substring.
           *
           * @param {string} substrUrl The substring that should be present in the current
           *     URL.
           * @return {!Condition<boolean>} The new condition.
           */
          function urlContains(substrUrl) {
            return new Condition('for URL to contain ' + JSON.stringify(substrUrl), function (
              driver
            ) {
              return driver.getCurrentUrl().then(function (url) {
                return url && url.includes(substrUrl)
              })
            })
          }

          /**
           * Creates a condition that will wait for the current page's url to match the
           * given regular expression.
           *
           * @param {!RegExp} regex The regular expression to test against.
           * @return {!Condition<boolean>} The new condition.
           */
          function urlMatches(regex) {
            return new Condition('for URL to match ' + regex, function (driver) {
              return driver.getCurrentUrl().then(function (url) {
                return regex.test(url)
              })
            })
          }

          /**
           * Creates a condition that will loop until an element is
           * {@link ./webdriver.WebDriver#findElement found} with the given locator.
           *
           * @param {!(By|Function)} locator The locator to use.
           * @return {!WebElementCondition} The new condition.
           */
          function elementLocated(locator) {
            locator = by.checkedLocator(locator)
            let locatorStr = typeof locator === 'function' ? 'by function()' : locator + ''
            return new WebElementCondition('for element to be located ' + locatorStr, function (
              driver
            ) {
              return driver.findElements(locator).then(function (elements) {
                return elements[0]
              })
            })
          }

          /**
           * Creates a condition that will loop until at least one element is
           * {@link ./webdriver.WebDriver#findElement found} with the given locator.
           *
           * @param {!(By|Function)} locator The locator to use.
           * @return {!Condition<!Array<!./webdriver.WebElement>>} The new
           *     condition.
           */
          function elementsLocated(locator) {
            locator = by.checkedLocator(locator)
            let locatorStr = typeof locator === 'function' ? 'by function()' : locator + ''
            return new Condition('for at least one element to be located ' + locatorStr, function (
              driver
            ) {
              return driver.findElements(locator).then(function (elements) {
                return elements.length > 0 ? elements : null
              })
            })
          }

          /**
           * Creates a condition that will wait for the given element to become stale. An
           * element is considered stale once it is removed from the DOM, or a new page
           * has loaded.
           *
           * @param {!./webdriver.WebElement} element The element that should become stale.
           * @return {!Condition<boolean>} The new condition.
           */
          function stalenessOf(element) {
            return new Condition('element to become stale', function () {
              return element.getTagName().then(
                function () {
                  return false
                },
                function (e) {
                  if (e instanceof error.StaleElementReferenceError) {
                    return true
                  }
                  throw e
                }
              )
            })
          }

          /**
           * Creates a condition that will wait for the given element to become visible.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @return {!WebElementCondition} The new condition.
           * @see ./webdriver.WebDriver#isDisplayed
           */
          function elementIsVisible(element) {
            return new WebElementCondition('until element is visible', function () {
              return element.isDisplayed().then((v) => (v ? element : null))
            })
          }

          /**
           * Creates a condition that will wait for the given element to be in the DOM,
           * yet not visible to the user.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @return {!WebElementCondition} The new condition.
           * @see ./webdriver.WebDriver#isDisplayed
           */
          function elementIsNotVisible(element) {
            return new WebElementCondition('until element is not visible', function () {
              return element.isDisplayed().then((v) => (v ? null : element))
            })
          }

          /**
           * Creates a condition that will wait for the given element to be enabled.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @return {!WebElementCondition} The new condition.
           * @see webdriver.WebDriver#isEnabled
           */
          function elementIsEnabled(element) {
            return new WebElementCondition('until element is enabled', function () {
              return element.isEnabled().then((v) => (v ? element : null))
            })
          }

          /**
           * Creates a condition that will wait for the given element to be disabled.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @return {!WebElementCondition} The new condition.
           * @see webdriver.WebDriver#isEnabled
           */
          function elementIsDisabled(element) {
            return new WebElementCondition('until element is disabled', function () {
              return element.isEnabled().then((v) => (v ? null : element))
            })
          }

          /**
           * Creates a condition that will wait for the given element to be selected.
           * @param {!./webdriver.WebElement} element The element to test.
           * @return {!WebElementCondition} The new condition.
           * @see webdriver.WebDriver#isSelected
           */
          function elementIsSelected(element) {
            return new WebElementCondition('until element is selected', function () {
              return element.isSelected().then((v) => (v ? element : null))
            })
          }

          /**
           * Creates a condition that will wait for the given element to be deselected.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @return {!WebElementCondition} The new condition.
           * @see webdriver.WebDriver#isSelected
           */
          function elementIsNotSelected(element) {
            return new WebElementCondition('until element is not selected', function () {
              return element.isSelected().then((v) => (v ? null : element))
            })
          }

          /**
           * Creates a condition that will wait for the given element's
           * {@link webdriver.WebDriver#getText visible text} to match the given
           * {@code text} exactly.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @param {string} text The expected text.
           * @return {!WebElementCondition} The new condition.
           * @see webdriver.WebDriver#getText
           */
          function elementTextIs(element, text) {
            return new WebElementCondition('until element text is', function () {
              return element.getText().then((t) => (t === text ? element : null))
            })
          }

          /**
           * Creates a condition that will wait for the given element's
           * {@link webdriver.WebDriver#getText visible text} to contain the given
           * substring.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @param {string} substr The substring to search for.
           * @return {!WebElementCondition} The new condition.
           * @see webdriver.WebDriver#getText
           */
          function elementTextContains(element, substr) {
            return new WebElementCondition('until element text contains', function () {
              return element.getText().then((t) => (t.indexOf(substr) != -1 ? element : null))
            })
          }

          /**
           * Creates a condition that will wait for the given element's
           * {@link webdriver.WebDriver#getText visible text} to match a regular
           * expression.
           *
           * @param {!./webdriver.WebElement} element The element to test.
           * @param {!RegExp} regex The regular expression to test against.
           * @return {!WebElementCondition} The new condition.
           * @see webdriver.WebDriver#getText
           */
          function elementTextMatches(element, regex) {
            return new WebElementCondition('until element text matches', function () {
              return element.getText().then((t) => (regex.test(t) ? element : null))
            })
          }

          // PUBLIC API

          module.exports = {
            elementTextMatches,
            elementTextContains,
            elementTextIs,
            elementIsNotSelected,
            elementIsSelected,
            elementIsDisabled,
            ableToSwitchToFrame,
            elementIsEnabled,
            elementIsNotVisible,
            elementIsVisible,
            stalenessOf,
            elementsLocated,
            elementLocated,
            urlMatches,
            urlContains,
            urlIs,
            titleMatches,
            titleContains,
            alertIsPresent,
            titleIs
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/util.js':
        /*!*****************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/util.js ***!
  \*****************************************************/
        /***/ (module) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * Determines whether a {@code value} should be treated as an object.
           * @param {?} value The value to test.
           * @returns {boolean} Whether the value is an object.
           */
          function isObject(value) {
            return Object.prototype.toString.call(value) === '[object Object]'
          }

          /**
           * Determines whether a {@code value} should be treated as a promise.
           * Any object whose "then" property is a function will be considered a promise.
           *
           * @param {?} value The value to test.
           * @return {boolean} Whether the value is a promise.
           */
          function isPromise(value) {
            try {
              // Use array notation so the Closure compiler does not obfuscate away our
              // contract.
              return (
                (typeof value === 'object' || typeof value === 'function') &&
                typeof value['then'] === 'function'
              )
            } catch (ex) {
              return false
            }
          }

          module.exports = {
            isObject,
            isPromise
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/virtual_authenticator.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/virtual_authenticator.js ***!
  \**********************************************************************/
        /***/ (module) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * Protocol for virtual authenticators
           * @enum {string}
           */
          const Protocol = {
            CTAP2: 'ctap2',
            U2F: 'ctap1/u2f'
          }

          /**
           * AuthenticatorTransport values
           * @enum {string}
           */
          const Transport = {
            BLE: 'ble',
            USB: 'usb',
            NFC: 'nfc',
            INTERNAL: 'internal'
          }

          /**
           * Options for the creation of virtual authenticators.
           * @see http://w3c.github.io/webauthn/#sctn-automation
           */
          class VirtualAuthenticatorOptions {
            /**
             * Constructor to initialise VirtualAuthenticatorOptions object.
             */
            constructor() {
              this._protocol = Protocol['CTAP2']
              this._transport = Transport['USB']
              this._hasResidentKey = false
              this._hasUserVerification = false
              this._isUserConsenting = true
              this._isUserVerified = false
            }

            getProtocol() {
              return this._protocol
            }

            setProtocol(protocol) {
              this._protocol = protocol
            }

            getTransport() {
              return this._transport
            }

            setTransport(transport) {
              this._transport = transport
            }

            getHasResidentKey() {
              return this._hasResidentKey
            }

            setHasResidentKey(value) {
              this._hasResidentKey = value
            }

            getHasUserVerification() {
              return this._hasUserVerification
            }

            setHasUserVerification(value) {
              this._hasUserVerification = value
            }

            getIsUserConsenting() {
              return this._isUserConsenting
            }

            setIsUserConsenting(value) {
              this._isUserConsenting = value
            }

            getIsUserVerified() {
              return this._isUserVerified
            }

            setIsUserVerified(value) {
              this._isUserVerified = value
            }

            toDict() {
              return {
                protocol: this.getProtocol(),
                transport: this.getTransport(),
                hasResidentKey: this.getHasResidentKey(),
                hasUserVerification: this.getHasUserVerification(),
                isUserConsenting: this.getIsUserConsenting(),
                isUserVerified: this.getIsUserVerified()
              }
            }
          }

          /**
           * A credential stored in a virtual authenticator.
           * @see https://w3c.github.io/webauthn/#credential-parameters
           */
          class Credential {
            constructor(
              credentialId,
              isResidentCredential,
              rpId,
              userHandle,
              privateKey,
              signCount
            ) {
              this._id = credentialId
              this._isResidentCredential = isResidentCredential
              this._rpId = rpId
              this._userHandle = userHandle
              this._privateKey = privateKey
              this._signCount = signCount
            }

            id() {
              return this._id
            }

            isResidentCredential() {
              return this._isResidentCredential
            }

            rpId() {
              return this._rpId
            }

            userHandle() {
              if (this._userHandle != null) {
                return this._userHandle
              }
              return null
            }

            privateKey() {
              return this._privateKey
            }

            signCount() {
              return this._signCount
            }

            /**
             * Creates a resident (i.e. stateless) credential.
             * @param id Unique base64 encoded string.
             * @param rpId Relying party identifier.
             * @param userHandle userHandle associated to the credential. Must be Base64 encoded string.
             * @param privateKey Base64 encoded PKCS
             * @param signCount initial value for a signature counter.
             * @deprecated This method has been made static. Call it with class name. Example, Credential.createResidentCredential()
             * @returns A resident credential
             */
            createResidentCredential(id, rpId, userHandle, privateKey, signCount) {
              return new Credential(id, true, rpId, userHandle, privateKey, signCount)
            }

            static createResidentCredential(id, rpId, userHandle, privateKey, signCount) {
              return new Credential(id, true, rpId, userHandle, privateKey, signCount)
            }

            /**
             * Creates a non-resident (i.e. stateless) credential.
             * @param id Unique base64 encoded string.
             * @param rpId Relying party identifier.
             * @param privateKey Base64 encoded PKCS
             * @param signCount initial value for a signature counter.
             * @deprecated This method has been made static. Call it with class name. Example, Credential.createNonResidentCredential()
             * @returns A non-resident credential
             */
            createNonResidentCredential(id, rpId, privateKey, signCount) {
              return new Credential(id, false, rpId, null, privateKey, signCount)
            }

            static createNonResidentCredential(id, rpId, privateKey, signCount) {
              return new Credential(id, false, rpId, null, privateKey, signCount)
            }

            toDict() {
              let credentialData = {
                credentialId: Buffer.from(this._id).toString('base64url'),
                isResidentCredential: this._isResidentCredential,
                rpId: this._rpId,
                privateKey: Buffer.from(this._privateKey, 'binary').toString('base64url'),
                signCount: this._signCount
              }

              if (this.userHandle() != null) {
                credentialData['userHandle'] = Buffer.from(this._userHandle).toString('base64url')
              }

              return credentialData
            }

            /**
             * Creates a credential from a map.
             */
            fromDict(data) {
              let id = new Uint8Array(Buffer.from(data['credentialId'], 'base64url'))
              let isResidentCredential = data['isResidentCredential']
              let rpId = data['rpId']
              let privateKey = Buffer.from(data['privateKey'], 'base64url').toString('binary')
              let signCount = data['signCount']
              let userHandle

              if ('userHandle' in data) {
                userHandle = new Uint8Array(Buffer.from(data['userHandle'], 'base64url'))
              } else {
                userHandle = null
              }
              return new Credential(
                id,
                isResidentCredential,
                rpId,
                userHandle,
                privateKey,
                signCount
              )
            }
          }

          // PUBLIC API

          module.exports = {
            Credential,
            VirtualAuthenticatorOptions,
            Transport,
            Protocol
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/webdriver.js':
        /*!**********************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/webdriver.js ***!
  \**********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview The heart of the WebDriver JavaScript API.
           */

          const by = __webpack_require__(/*! ./by */ './node_modules/selenium-webdriver/lib/by.js')
          const { RelativeBy } = __webpack_require__(
            /*! ./by */ './node_modules/selenium-webdriver/lib/by.js'
          )
          const command = __webpack_require__(
            /*! ./command */ './node_modules/selenium-webdriver/lib/command.js'
          )
          const error = __webpack_require__(
            /*! ./error */ './node_modules/selenium-webdriver/lib/error.js'
          )
          const input = __webpack_require__(
            /*! ./input */ './node_modules/selenium-webdriver/lib/input.js'
          )
          const logging = __webpack_require__(
            /*! ./logging */ './node_modules/selenium-webdriver/lib/logging.js'
          )
          const promise = __webpack_require__(
            /*! ./promise */ './node_modules/selenium-webdriver/lib/promise.js'
          )
          const Symbols = __webpack_require__(
            /*! ./symbols */ './node_modules/selenium-webdriver/lib/symbols.js'
          )
          const cdp = __webpack_require__(
            /*! ../devtools/CDPConnection */ './node_modules/selenium-webdriver/devtools/CDPConnection.js'
          )
          const WebSocket = __webpack_require__(/*! ws */ './node_modules/ws/browser.js')
          const http = __webpack_require__(
            /*! ../http/index */ './node_modules/selenium-webdriver/http/index.js'
          )
          const fs = __webpack_require__(/*! fs */ 'fs')
          const { Capabilities } = __webpack_require__(
            /*! ./capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )
          const path = __webpack_require__(/*! path */ 'path')
          const { NoSuchElementError } = __webpack_require__(
            /*! ./error */ './node_modules/selenium-webdriver/lib/error.js'
          )
          const cdpTargets = ['page', 'browser']
          const { Credential } = __webpack_require__(
            /*! ./virtual_authenticator */ './node_modules/selenium-webdriver/lib/virtual_authenticator.js'
          )
          const webElement = __webpack_require__(
            /*! ./webelement */ './node_modules/selenium-webdriver/lib/webelement.js'
          )
          const { isObject } = __webpack_require__(
            /*! ./util */ './node_modules/selenium-webdriver/lib/util.js'
          )
          const BIDI = __webpack_require__(
            /*! ../bidi */ './node_modules/selenium-webdriver/bidi/index.js'
          )
          const { PinnedScript } = __webpack_require__(
            /*! ./pinnedScript */ './node_modules/selenium-webdriver/lib/pinnedScript.js'
          )

          // Capability names that are defined in the W3C spec.
          const W3C_CAPABILITY_NAMES = new Set([
            'acceptInsecureCerts',
            'browserName',
            'browserVersion',
            'pageLoadStrategy',
            'platformName',
            'proxy',
            'setWindowRect',
            'strictFileInteractability',
            'timeouts',
            'unhandledPromptBehavior',
            'webSocketUrl'
          ])

          /**
           * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait
           * command}.
           *
           * @template OUT
           */
          class Condition {
            /**
             * @param {string} message A descriptive error message. Should complete the
             *     sentence "Waiting [...]"
             * @param {function(!WebDriver): OUT} fn The condition function to
             *     evaluate on each iteration of the wait loop.
             */
            constructor(message, fn) {
              /** @private {string} */
              this.description_ = 'Waiting ' + message

              /** @type {function(!WebDriver): OUT} */
              this.fn = fn
            }

            /** @return {string} A description of this condition. */
            description() {
              return this.description_
            }
          }

          /**
           * Defines a condition that will result in a {@link WebElement}.
           *
           * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}
           */
          class WebElementCondition extends Condition {
            /**
             * @param {string} message A descriptive error message. Should complete the
             *     sentence "Waiting [...]"
             * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}
             *     fn The condition function to evaluate on each iteration of the wait
             *     loop.
             */
            constructor(message, fn) {
              super(message, fn)
            }
          }

          //////////////////////////////////////////////////////////////////////////////
          //
          //  WebDriver
          //
          //////////////////////////////////////////////////////////////////////////////

          /**
           * Translates a command to its wire-protocol representation before passing it
           * to the given `executor` for execution.
           * @param {!command.Executor} executor The executor to use.
           * @param {!command.Command} command The command to execute.
           * @return {!Promise} A promise that will resolve with the command response.
           */
          function executeCommand(executor, command) {
            return toWireValue(command.getParameters()).then(function (parameters) {
              command.setParameters(parameters)
              return executor.execute(command)
            })
          }

          /**
           * Converts an object to its JSON representation in the WebDriver wire protocol.
           * When converting values of type object, the following steps will be taken:
           * <ol>
           * <li>if the object is a WebElement, the return value will be the element's
           *     server ID
           * <li>if the object defines a {@link Symbols.serialize} method, this algorithm
           *     will be recursively applied to the object's serialized representation
           * <li>if the object provides a "toJSON" function, this algorithm will
           *     recursively be applied to the result of that function
           * <li>otherwise, the value of each key will be recursively converted according
           *     to the rules above.
           * </ol>
           *
           * @param {*} obj The object to convert.
           * @return {!Promise<?>} A promise that will resolve to the input value's JSON
           *     representation.
           */
          async function toWireValue(obj) {
            let value = await Promise.resolve(obj)
            if (value === void 0 || value === null) {
              return value
            }

            if (
              typeof value === 'boolean' ||
              typeof value === 'number' ||
              typeof value === 'string'
            ) {
              return value
            }

            if (Array.isArray(value)) {
              return convertKeys(value)
            }

            if (typeof value === 'function') {
              return '' + value
            }

            if (typeof value[Symbols.serialize] === 'function') {
              return toWireValue(value[Symbols.serialize]())
            } else if (typeof value.toJSON === 'function') {
              return toWireValue(value.toJSON())
            }
            return convertKeys(value)
          }

          async function convertKeys(obj) {
            const isArray = Array.isArray(obj)
            const numKeys = isArray ? obj.length : Object.keys(obj).length
            const ret = isArray ? new Array(numKeys) : {}
            if (!numKeys) {
              return ret
            }

            async function forEachKey(obj, fn) {
              if (Array.isArray(obj)) {
                for (let i = 0, n = obj.length; i < n; i++) {
                  await fn(obj[i], i)
                }
              } else {
                for (let key in obj) {
                  await fn(obj[key], key)
                }
              }
            }

            await forEachKey(obj, async function (value, key) {
              ret[key] = await toWireValue(value)
            })

            return ret
          }

          /**
           * Converts a value from its JSON representation according to the WebDriver wire
           * protocol. Any JSON object that defines a WebElement ID will be decoded to a
           * {@link WebElement} object. All other values will be passed through as is.
           *
           * @param {!WebDriver} driver The driver to use as the parent of any unwrapped
           *     {@link WebElement} values.
           * @param {*} value The value to convert.
           * @return {*} The converted value.
           */
          function fromWireValue(driver, value) {
            if (Array.isArray(value)) {
              value = value.map((v) => fromWireValue(driver, v))
            } else if (WebElement.isId(value)) {
              let id = WebElement.extractId(value)
              value = new WebElement(driver, id)
            } else if (ShadowRoot.isId(value)) {
              let id = ShadowRoot.extractId(value)
              value = new ShadowRoot(driver, id)
            } else if (isObject(value)) {
              let result = {}
              for (let key in value) {
                if (Object.prototype.hasOwnProperty.call(value, key)) {
                  result[key] = fromWireValue(driver, value[key])
                }
              }
              value = result
            }
            return value
          }

          /**
           * Resolves a wait message from either a function or a string.
           * @param {(string|Function)=} message An optional message to use if the wait times out.
           * @return {string} The resolved message
           */
          function resolveWaitMessage(message) {
            return message ? `${typeof message === 'function' ? message() : message}\n` : ''
          }

          /**
           * Structural interface for a WebDriver client.
           *
           * @record
           */
          class IWebDriver {
            /**
             * Executes the provided {@link command.Command} using this driver's
             * {@link command.Executor}.
             *
             * @param {!command.Command} command The command to schedule.
             * @return {!Promise<T>} A promise that will be resolved with the command
             *     result.
             * @template T
             */
            execute(command) {} // eslint-disable-line

            /**
             * Sets the {@linkplain input.FileDetector file detector} that should be
             * used with this instance.
             * @param {input.FileDetector} detector The detector to use or `null`.
             */
            setFileDetector(detector) {} // eslint-disable-line

            /**
             * @return {!command.Executor} The command executor used by this instance.
             */
            getExecutor() {}

            /**
             * @return {!Promise<!Session>} A promise for this client's session.
             */
            getSession() {}

            /**
             * @return {!Promise<!Capabilities>} A promise that will resolve with
             *     the instance's capabilities.
             */
            getCapabilities() {}

            /**
             * Terminates the browser session. After calling quit, this instance will be
             * invalidated and may no longer be used to issue commands against the
             * browser.
             *
             * @return {!Promise<void>} A promise that will be resolved when the
             *     command has completed.
             */
            quit() {}

            /**
             * Creates a new action sequence using this driver. The sequence will not be
             * submitted for execution until
             * {@link ./input.Actions#perform Actions.perform()} is called.
             *
             * @param {{async: (boolean|undefined),
             *          bridge: (boolean|undefined)}=} options Configuration options for
             *     the action sequence (see {@link ./input.Actions Actions} documentation
             *     for details).
             * @return {!input.Actions} A new action sequence for this instance.
             */
            actions(options) {} // eslint-disable-line

            /**
             * Executes a snippet of JavaScript in the context of the currently selected
             * frame or window. The script fragment will be executed as the body of an
             * anonymous function. If the script is provided as a function object, that
             * function will be converted to a string for injection into the target
             * window.
             *
             * Any arguments provided in addition to the script will be included as script
             * arguments and may be referenced using the `arguments` object. Arguments may
             * be a boolean, number, string, or {@linkplain WebElement}. Arrays and
             * objects may also be used as script arguments as long as each item adheres
             * to the types previously mentioned.
             *
             * The script may refer to any variables accessible from the current window.
             * Furthermore, the script will execute in the window's context, thus
             * `document` may be used to refer to the current document. Any local
             * variables will not be available once the script has finished executing,
             * though global variables will persist.
             *
             * If the script has a return value (i.e. if the script contains a return
             * statement), then the following steps will be taken for resolving this
             * functions return value:
             *
             * - For a HTML element, the value will resolve to a {@linkplain WebElement}
             * - Null and undefined return values will resolve to null</li>
             * - Booleans, numbers, and strings will resolve as is</li>
             * - Functions will resolve to their string representation</li>
             * - For arrays and objects, each member item will be converted according to
             *     the rules above
             *
             * @param {!(string|Function)} script The script to execute.
             * @param {...*} args The arguments to pass to the script.
             * @return {!IThenable<T>} A promise that will resolve to the
             *    scripts return value.
             * @template T
             */
            executeScript(script, ...args) {} // eslint-disable-line

            /**
             * Executes a snippet of asynchronous JavaScript in the context of the
             * currently selected frame or window. The script fragment will be executed as
             * the body of an anonymous function. If the script is provided as a function
             * object, that function will be converted to a string for injection into the
             * target window.
             *
             * Any arguments provided in addition to the script will be included as script
             * arguments and may be referenced using the `arguments` object. Arguments may
             * be a boolean, number, string, or {@linkplain WebElement}. Arrays and
             * objects may also be used as script arguments as long as each item adheres
             * to the types previously mentioned.
             *
             * Unlike executing synchronous JavaScript with {@link #executeScript},
             * scripts executed with this function must explicitly signal they are
             * finished by invoking the provided callback. This callback will always be
             * injected into the executed function as the last argument, and thus may be
             * referenced with  `arguments[arguments.length - 1]`. The following steps
             * will be taken for resolving this functions return value against the first
             * argument to the script's callback function:
             *
             * - For a HTML element, the value will resolve to a {@link WebElement}
             * - Null and undefined return values will resolve to null
             * - Booleans, numbers, and strings will resolve as is
             * - Functions will resolve to their string representation
             * - For arrays and objects, each member item will be converted according to
             *     the rules above
             *
             * __Example #1:__ Performing a sleep that is synchronized with the currently
             * selected window:
             *
             *     var start = new Date().getTime();
             *     driver.executeAsyncScript(
             *         'window.setTimeout(arguments[arguments.length - 1], 500);').
             *         then(function() {
             *           console.log(
             *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
             *         });
             *
             * __Example #2:__ Synchronizing a test with an AJAX application:
             *
             *     var button = driver.findElement(By.id('compose-button'));
             *     button.click();
             *     driver.executeAsyncScript(
             *         'var callback = arguments[arguments.length - 1];' +
             *         'mailClient.getComposeWindowWidget().onload(callback);');
             *     driver.switchTo().frame('composeWidget');
             *     driver.findElement(By.id('to')).sendKeys('dog@example.com');
             *
             * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
             * this example, the inject script is specified with a function literal. When
             * using this format, the function is converted to a string for injection, so
             * it should not reference any symbols not defined in the scope of the page
             * under test.
             *
             *     driver.executeAsyncScript(function() {
             *       var callback = arguments[arguments.length - 1];
             *       var xhr = new XMLHttpRequest();
             *       xhr.open("GET", "/resource/data.json", true);
             *       xhr.onreadystatechange = function() {
             *         if (xhr.readyState == 4) {
             *           callback(xhr.responseText);
             *         }
             *       };
             *       xhr.send('');
             *     }).then(function(str) {
             *       console.log(JSON.parse(str)['food']);
             *     });
             *
             * @param {!(string|Function)} script The script to execute.
             * @param {...*} args The arguments to pass to the script.
             * @return {!IThenable<T>} A promise that will resolve to the scripts return
             *     value.
             * @template T
             */
            executeAsyncScript(script, ...args) {} // eslint-disable-line

            /**
             * Waits for a condition to evaluate to a "truthy" value. The condition may be
             * specified by a {@link Condition}, as a custom function, or as any
             * promise-like thenable.
             *
             * For a {@link Condition} or function, the wait will repeatedly
             * evaluate the condition until it returns a truthy value. If any errors occur
             * while evaluating the condition, they will be allowed to propagate. In the
             * event a condition returns a {@linkplain Promise}, the polling loop will
             * wait for it to be resolved and use the resolved value for whether the
             * condition has been satisfied. The resolution time for a promise is always
             * factored into whether a wait has timed out.
             *
             * If the provided condition is a {@link WebElementCondition}, then
             * the wait will return a {@link WebElementPromise} that will resolve to the
             * element that satisfied the condition.
             *
             * _Example:_ waiting up to 10 seconds for an element to be present on the
             * page.
             *
             *     async function example() {
             *       let button =
             *           await driver.wait(until.elementLocated(By.id('foo')), 10000);
             *       await button.click();
             *     }
             *
             * @param {!(IThenable<T>|
             *           Condition<T>|
             *           function(!WebDriver): T)} condition The condition to
             *     wait on, defined as a promise, condition object, or  a function to
             *     evaluate as a condition.
             * @param {number=} timeout The duration in milliseconds, how long to wait
             *     for the condition to be true.
             * @param {(string|Function)=} message An optional message to use if the wait times out.
             * @param {number=} pollTimeout The duration in milliseconds, how long to
             *     wait between polling the condition.
             * @return {!(IThenable<T>|WebElementPromise)} A promise that will be
             *     resolved with the first truthy value returned by the condition
             *     function, or rejected if the condition times out. If the input
             *     condition is an instance of a {@link WebElementCondition},
             *     the returned value will be a {@link WebElementPromise}.
             * @throws {TypeError} if the provided `condition` is not a valid type.
             * @template T
             */
            wait(
              condition, // eslint-disable-line
              timeout = undefined, // eslint-disable-line
              message = undefined, // eslint-disable-line
              pollTimeout = undefined // eslint-disable-line
            ) {}

            /**
             * Makes the driver sleep for the given amount of time.
             *
             * @param {number} ms The amount of time, in milliseconds, to sleep.
             * @return {!Promise<void>} A promise that will be resolved when the sleep has
             *     finished.
             */
            sleep(ms) {} // eslint-disable-line

            /**
             * Retrieves the current window handle.
             *
             * @return {!Promise<string>} A promise that will be resolved with the current
             *     window handle.
             */
            getWindowHandle() {}

            /**
             * Retrieves a list of all available window handles.
             *
             * @return {!Promise<!Array<string>>} A promise that will be resolved with an
             *     array of window handles.
             */
            getAllWindowHandles() {}

            /**
             * Retrieves the current page's source. The returned source is a representation
             * of the underlying DOM: do not expect it to be formatted or escaped in the
             * same way as the raw response sent from the web server.
             *
             * @return {!Promise<string>} A promise that will be resolved with the current
             *     page source.
             */
            getPageSource() {}

            /**
             * Closes the current window.
             *
             * @return {!Promise<void>} A promise that will be resolved when this command
             *     has completed.
             */
            close() {}

            /**
             * Navigates to the given URL.
             *
             * @param {string} url The fully qualified URL to open.
             * @return {!Promise<void>} A promise that will be resolved when the document
             *     has finished loading.
             */
            get(url) {} // eslint-disable-line

            /**
             * Retrieves the URL for the current page.
             *
             * @return {!Promise<string>} A promise that will be resolved with the
             *     current URL.
             */
            getCurrentUrl() {}

            /**
             * Retrieves the current page title.
             *
             * @return {!Promise<string>} A promise that will be resolved with the current
             *     page's title.
             */
            getTitle() {}

            /**
             * Locates an element on the page. If the element cannot be found, a
             * {@link error.NoSuchElementError} will be returned by the driver.
             *
             * This function should not be used to test whether an element is present on
             * the page. Rather, you should use {@link #findElements}:
             *
             *     driver.findElements(By.id('foo'))
             *         .then(found => console.log('Element found? %s', !!found.length));
             *
             * The search criteria for an element may be defined using one of the
             * factories in the {@link webdriver.By} namespace, or as a short-hand
             * {@link webdriver.By.Hash} object. For example, the following two statements
             * are equivalent:
             *
             *     var e1 = driver.findElement(By.id('foo'));
             *     var e2 = driver.findElement({id:'foo'});
             *
             * You may also provide a custom locator function, which takes as input this
             * instance and returns a {@link WebElement}, or a promise that will resolve
             * to a WebElement. If the returned promise resolves to an array of
             * WebElements, WebDriver will use the first element. For example, to find the
             * first visible link on a page, you could write:
             *
             *     var link = driver.findElement(firstVisibleLink);
             *
             *     function firstVisibleLink(driver) {
             *       var links = driver.findElements(By.tagName('a'));
             *       return promise.filter(links, function(link) {
             *         return link.isDisplayed();
             *       });
             *     }
             *
             * @param {!(by.By|Function)} locator The locator to use.
             * @return {!WebElementPromise} A WebElement that can be used to issue
             *     commands against the located element. If the element is not found, the
             *     element will be invalidated and all scheduled commands aborted.
             */
            findElement(locator) {} // eslint-disable-line

            /**
             * Search for multiple elements on the page. Refer to the documentation on
             * {@link #findElement(by)} for information on element locator strategies.
             *
             * @param {!(by.By|Function)} locator The locator to use.
             * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an
             *     array of WebElements.
             */
            findElements(locator) {} // eslint-disable-line

            /**
             * Takes a screenshot of the current page. The driver makes the best effort to
             * return a screenshot of the following, in order of preference:
             *
             * 1. Entire page
             * 2. Current window
             * 3. Visible portion of the current frame
             * 4. The entire display containing the browser
             *
             * @return {!Promise<string>} A promise that will be resolved to the
             *     screenshot as a base-64 encoded PNG.
             */
            takeScreenshot() {}

            /**
             * @return {!Options} The options interface for this instance.
             */
            manage() {}

            /**
             * @return {!Navigation} The navigation interface for this instance.
             */
            navigate() {}

            /**
             * @return {!TargetLocator} The target locator interface for this
             *     instance.
             */
            switchTo() {}

            /**
             *
             * Takes a PDF of the current page. The driver makes a best effort to
             * return a PDF based on the provided parameters.
             *
             * @param {{orientation:(string|undefined),
             *         scale:(number|undefined),
             *         background:(boolean|undefined),
             *         width:(number|undefined),
             *         height:(number|undefined),
             *         top:(number|undefined),
             *         bottom:(number|undefined),
             *         left:(number|undefined),
             *         right:(number|undefined),
             *         shrinkToFit:(boolean|undefined),
             *         pageRanges:(Array|undefined)}} options
             */
            printPage(options) {} // eslint-disable-line
          }

          /**
           * @param {!Capabilities} capabilities A capabilities object.
           * @return {!Capabilities} A copy of the parameter capabilities, omitting
           *     capability names that are not valid W3C names.
           */
          function filterNonW3CCaps(capabilities) {
            let newCaps = new Capabilities(capabilities)
            for (let k of newCaps.keys()) {
              // Any key containing a colon is a vendor-prefixed capability.
              if (!(W3C_CAPABILITY_NAMES.has(k) || k.indexOf(':') >= 0)) {
                newCaps.delete(k)
              }
            }
            return newCaps
          }

          /**
           * Each WebDriver instance provides automated control over a browser session.
           *
           * @implements {IWebDriver}
           */
          class WebDriver {
            /**
             * @param {!(./session.Session|IThenable<!./session.Session>)} session Either
             *     a known session or a promise that will be resolved to a session.
             * @param {!command.Executor} executor The executor to use when sending
             *     commands to the browser.
             * @param {(function(this: void): ?)=} onQuit A function to call, if any,
             *     when the session is terminated.
             */
            constructor(session, executor, onQuit = undefined) {
              /** @private {!Promise<!Session>} */
              this.session_ = Promise.resolve(session)

              // If session is a rejected promise, add a no-op rejection handler.
              // This effectively hides setup errors until users attempt to interact
              // with the session.
              this.session_.catch(function () {})

              /** @private {!command.Executor} */
              this.executor_ = executor

              /** @private {input.FileDetector} */
              this.fileDetector_ = null

              /** @private @const {(function(this: void): ?|undefined)} */
              this.onQuit_ = onQuit

              /** @private {./virtual_authenticator}*/
              this.authenticatorId_ = null

              this.pinnedScripts_ = {}
            }

            /**
             * Creates a new WebDriver session.
             *
             * This function will always return a WebDriver instance. If there is an error
             * creating the session, such as the aforementioned SessionNotCreatedError,
             * the driver will have a rejected {@linkplain #getSession session} promise.
             * This rejection will propagate through any subsequent commands scheduled
             * on the returned WebDriver instance.
             *
             *     let required = Capabilities.firefox();
             *     let driver = WebDriver.createSession(executor, {required});
             *
             *     // If the createSession operation failed, then this command will also
             *     // also fail, propagating the creation failure.
             *     driver.get('http://www.google.com').catch(e => console.log(e));
             *
             * @param {!command.Executor} executor The executor to create the new session
             *     with.
             * @param {!Capabilities} capabilities The desired capabilities for the new
             *     session.
             * @param {(function(this: void): ?)=} onQuit A callback to invoke when
             *    the newly created session is terminated. This should be used to clean
             *    up any resources associated with the session.
             * @return {!WebDriver} The driver for the newly created session.
             */
            static createSession(executor, capabilities, onQuit = undefined) {
              let cmd = new command.Command(command.Name.NEW_SESSION)

              // For W3C remote ends.
              cmd.setParameter('capabilities', {
                firstMatch: [{}],
                alwaysMatch: filterNonW3CCaps(capabilities)
              })

              let session = executeCommand(executor, cmd)
              if (typeof onQuit === 'function') {
                session = session.catch((err) => {
                  return Promise.resolve(onQuit.call(void 0)).then((_) => {
                    throw err
                  })
                })
              }
              return new this(session, executor, onQuit)
            }

            /** @override */
            async execute(command) {
              command.setParameter('sessionId', this.session_)

              let parameters = await toWireValue(command.getParameters())
              command.setParameters(parameters)
              let value = await this.executor_.execute(command)
              return fromWireValue(this, value)
            }

            /** @override */
            setFileDetector(detector) {
              this.fileDetector_ = detector
            }

            /** @override */
            getExecutor() {
              return this.executor_
            }

            /** @override */
            getSession() {
              return this.session_
            }

            /** @override */
            getCapabilities() {
              return this.session_.then((s) => s.getCapabilities())
            }

            /** @override */
            quit() {
              let result = this.execute(new command.Command(command.Name.QUIT))
              // Delete our session ID when the quit command finishes; this will allow us
              // to throw an error when attempting to use a driver post-quit.
              return promise.finally(result, () => {
                this.session_ = Promise.reject(
                  new error.NoSuchSessionError(
                    'This driver instance does not have a valid session ID ' +
                      '(did you call WebDriver.quit()?) and may no longer be used.'
                  )
                )

                // Only want the session rejection to bubble if accessed.
                this.session_.catch(function () {})

                if (this.onQuit_) {
                  return this.onQuit_.call(void 0)
                }
              })
            }

            /** @override */
            actions(options) {
              return new input.Actions(this, options || undefined)
            }

            /** @override */
            executeScript(script, ...args) {
              if (typeof script === 'function') {
                script = 'return (' + script + ').apply(null, arguments);'
              }

              if (script && script instanceof PinnedScript) {
                return this.execute(
                  new command.Command(command.Name.EXECUTE_SCRIPT)
                    .setParameter('script', script.executionScript())
                    .setParameter('args', args)
                )
              }

              return this.execute(
                new command.Command(command.Name.EXECUTE_SCRIPT)
                  .setParameter('script', script)
                  .setParameter('args', args)
              )
            }

            /** @override */
            executeAsyncScript(script, ...args) {
              if (typeof script === 'function') {
                script = 'return (' + script + ').apply(null, arguments);'
              }

              if (script && script instanceof PinnedScript) {
                return this.execute(
                  new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT)
                    .setParameter('script', script.executionScript())
                    .setParameter('args', args)
                )
              }

              return this.execute(
                new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT)
                  .setParameter('script', script)
                  .setParameter('args', args)
              )
            }

            /** @override */
            wait(condition, timeout = 0, message = undefined, pollTimeout = 200) {
              if (typeof timeout !== 'number' || timeout < 0) {
                throw TypeError('timeout must be a number >= 0: ' + timeout)
              }

              if (typeof pollTimeout !== 'number' || pollTimeout < 0) {
                throw TypeError('pollTimeout must be a number >= 0: ' + pollTimeout)
              }

              if (promise.isPromise(condition)) {
                return new Promise((resolve, reject) => {
                  if (!timeout) {
                    resolve(condition)
                    return
                  }

                  let start = Date.now()
                  let timer = setTimeout(function () {
                    timer = null
                    try {
                      let timeoutMessage = resolveWaitMessage(message)
                      reject(
                        new error.TimeoutError(
                          `${timeoutMessage}Timed out waiting for promise to resolve after ${
                            Date.now() - start
                          }ms`
                        )
                      )
                    } catch (ex) {
                      reject(
                        new error.TimeoutError(
                          `${ex.message}\nTimed out waiting for promise to resolve after ${
                            Date.now() - start
                          }ms`
                        )
                      )
                    }
                  }, timeout)
                  const clearTimer = () => timer && clearTimeout(timer)

                  /** @type {!IThenable} */ condition.then(
                    function (value) {
                      clearTimer()
                      resolve(value)
                    },
                    function (error) {
                      clearTimer()
                      reject(error)
                    }
                  )
                })
              }

              let fn = /** @type {!Function} */ (condition)
              if (condition instanceof Condition) {
                message = message || condition.description()
                fn = condition.fn
              }

              if (typeof fn !== 'function') {
                throw TypeError(
                  'Wait condition must be a promise-like object, function, or a ' +
                    'Condition object'
                )
              }

              const driver = this
              function evaluateCondition() {
                return new Promise((resolve, reject) => {
                  try {
                    resolve(fn(driver))
                  } catch (ex) {
                    reject(ex)
                  }
                })
              }

              let result = new Promise((resolve, reject) => {
                const startTime = Date.now()
                const pollCondition = async () => {
                  evaluateCondition().then(function (value) {
                    const elapsed = Date.now() - startTime
                    if (value) {
                      resolve(value)
                    } else if (timeout && elapsed >= timeout) {
                      try {
                        let timeoutMessage = resolveWaitMessage(message)
                        reject(
                          new error.TimeoutError(
                            `${timeoutMessage}Wait timed out after ${elapsed}ms`
                          )
                        )
                      } catch (ex) {
                        reject(
                          new error.TimeoutError(`${ex.message}\nWait timed out after ${elapsed}ms`)
                        )
                      }
                    } else {
                      setTimeout(pollCondition, pollTimeout)
                    }
                  }, reject)
                }
                pollCondition()
              })

              if (condition instanceof WebElementCondition) {
                result = new WebElementPromise(
                  this,
                  result.then(function (value) {
                    if (!(value instanceof WebElement)) {
                      throw TypeError(
                        'WebElementCondition did not resolve to a WebElement: ' +
                          Object.prototype.toString.call(value)
                      )
                    }
                    return value
                  })
                )
              }
              return result
            }

            /** @override */
            sleep(ms) {
              return new Promise((resolve) => setTimeout(resolve, ms))
            }

            /** @override */
            getWindowHandle() {
              return this.execute(new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE))
            }

            /** @override */
            getAllWindowHandles() {
              return this.execute(new command.Command(command.Name.GET_WINDOW_HANDLES))
            }

            /** @override */
            getPageSource() {
              return this.execute(new command.Command(command.Name.GET_PAGE_SOURCE))
            }

            /** @override */
            close() {
              return this.execute(new command.Command(command.Name.CLOSE))
            }

            /** @override */
            get(url) {
              return this.navigate().to(url)
            }

            /** @override */
            getCurrentUrl() {
              return this.execute(new command.Command(command.Name.GET_CURRENT_URL))
            }

            /** @override */
            getTitle() {
              return this.execute(new command.Command(command.Name.GET_TITLE))
            }

            /** @override */
            findElement(locator) {
              let id
              let cmd = null

              if (locator instanceof RelativeBy) {
                cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter(
                  'args',
                  locator.marshall()
                )
              } else {
                locator = by.checkedLocator(locator)
              }

              if (typeof locator === 'function') {
                id = this.findElementInternal_(locator, this)
                return new WebElementPromise(this, id)
              } else if (cmd === null) {
                cmd = new command.Command(command.Name.FIND_ELEMENT)
                  .setParameter('using', locator.using)
                  .setParameter('value', locator.value)
              }

              id = this.execute(cmd)
              if (locator instanceof RelativeBy) {
                return this.normalize_(id)
              } else {
                return new WebElementPromise(this, id)
              }
            }

            /**
             * @param {!Function} webElementPromise The webElement in unresolved state
             * @return {!Promise<!WebElement>} First single WebElement from array of resolved promises
             */
            async normalize_(webElementPromise) {
              let result = await webElementPromise
              if (result.length === 0) {
                throw new NoSuchElementError('Cannot locate an element with provided parameters')
              } else {
                return result[0]
              }
            }

            /**
             * @param {!Function} locatorFn The locator function to use.
             * @param {!(WebDriver|WebElement)} context The search context.
             * @return {!Promise<!WebElement>} A promise that will resolve to a list of
             *     WebElements.
             * @private
             */
            async findElementInternal_(locatorFn, context) {
              let result = await locatorFn(context)
              if (Array.isArray(result)) {
                result = result[0]
              }
              if (!(result instanceof WebElement)) {
                throw new TypeError('Custom locator did not return a WebElement')
              }
              return result
            }

            /** @override */
            async findElements(locator) {
              let cmd = null
              if (locator instanceof RelativeBy) {
                cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter(
                  'args',
                  locator.marshall()
                )
              } else {
                locator = by.checkedLocator(locator)
              }

              if (typeof locator === 'function') {
                return this.findElementsInternal_(locator, this)
              } else if (cmd === null) {
                cmd = new command.Command(command.Name.FIND_ELEMENTS)
                  .setParameter('using', locator.using)
                  .setParameter('value', locator.value)
              }
              try {
                let res = await this.execute(cmd)
                return Array.isArray(res) ? res : []
              } catch (ex) {
                if (ex instanceof error.NoSuchElementError) {
                  return []
                }
                throw ex
              }
            }

            /**
             * @param {!Function} locatorFn The locator function to use.
             * @param {!(WebDriver|WebElement)} context The search context.
             * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an
             *     array of WebElements.
             * @private
             */
            async findElementsInternal_(locatorFn, context) {
              const result = await locatorFn(context)
              if (result instanceof WebElement) {
                return [result]
              }

              if (!Array.isArray(result)) {
                return []
              }

              return result.filter(function (item) {
                return item instanceof WebElement
              })
            }

            /** @override */
            takeScreenshot() {
              return this.execute(new command.Command(command.Name.SCREENSHOT))
            }

            /** @override */
            manage() {
              return new Options(this)
            }

            /** @override */
            navigate() {
              return new Navigation(this)
            }

            /** @override */
            switchTo() {
              return new TargetLocator(this)
            }

            validatePrintPageParams(keys, object) {
              let page = {}
              let margin = {}
              let data
              Object.keys(keys).forEach(function (key) {
                data = keys[key]
                let obj = {
                  orientation: function () {
                    object.orientation = data
                  },

                  scale: function () {
                    object.scale = data
                  },

                  background: function () {
                    object.background = data
                  },

                  width: function () {
                    page.width = data
                    object.page = page
                  },

                  height: function () {
                    page.height = data
                    object.page = page
                  },

                  top: function () {
                    margin.top = data
                    object.margin = margin
                  },

                  left: function () {
                    margin.left = data
                    object.margin = margin
                  },

                  bottom: function () {
                    margin.bottom = data
                    object.margin = margin
                  },

                  right: function () {
                    margin.right = data
                    object.margin = margin
                  },

                  shrinkToFit: function () {
                    object.shrinkToFit = data
                  },

                  pageRanges: function () {
                    object.pageRanges = data
                  }
                }

                if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                  throw new error.InvalidArgumentError(`Invalid Argument '${key}'`)
                } else {
                  obj[key]()
                }
              })

              return object
            }

            /** @override */
            printPage(options = {}) {
              let keys = options
              let params = {}
              let resultObj

              let self = this
              resultObj = self.validatePrintPageParams(keys, params)

              return this.execute(
                new command.Command(command.Name.PRINT_PAGE).setParameters(resultObj)
              )
            }

            /**
             * Creates a new WebSocket connection.
             * @return {!Promise<resolved>} A new CDP instance.
             */
            async createCDPConnection(target) {
              let debuggerUrl = null

              const caps = await this.getCapabilities()

              if (process.env.SELENIUM_REMOTE_URL) {
                const host = new URL(process.env.SELENIUM_REMOTE_URL).host
                const sessionId = await this.getSession().then((session) => session.getId())
                debuggerUrl = `ws://${host}/session/${sessionId}/se/cdp`
              } else {
                const seCdp = caps['map_'].get('se:cdp')
                const vendorInfo =
                  caps['map_'].get(this.VENDOR_COMMAND_PREFIX + ':chromeOptions') ||
                  caps['map_'].get(this.VENDOR_CAPABILITY_PREFIX + ':edgeOptions') ||
                  caps['map_'].get('moz:debuggerAddress') ||
                  new Map()
                debuggerUrl = seCdp || vendorInfo['debuggerAddress'] || vendorInfo
              }
              this._wsUrl = await this.getWsUrl(debuggerUrl, target, caps)
              return new Promise((resolve, reject) => {
                try {
                  this._wsConnection = new WebSocket(this._wsUrl.replace('localhost', '127.0.0.1'))
                  this._cdpConnection = new cdp.CdpConnection(this._wsConnection)
                } catch (err) {
                  reject(err)
                  return
                }

                this._wsConnection.on('open', async () => {
                  await this.getCdpTargets()
                })

                this._wsConnection.on('message', async (message) => {
                  const params = JSON.parse(message)
                  if (params.result) {
                    if (params.result.targetInfos) {
                      const targets = params.result.targetInfos
                      const page = targets.find((info) => info.type === 'page')
                      if (page) {
                        this.targetID = page.targetId
                        this._cdpConnection.execute(
                          'Target.attachToTarget',
                          { targetId: this.targetID, flatten: true },
                          null
                        )
                      } else {
                        reject('Unable to find Page target.')
                      }
                    }
                    if (params.result.sessionId) {
                      this.sessionId = params.result.sessionId
                      this._cdpConnection.sessionId = this.sessionId
                      resolve(this._cdpConnection)
                    }
                  }
                })

                this._wsConnection.on('error', (error) => {
                  reject(error)
                })
              })
            }

            async getCdpTargets() {
              this._cdpConnection.execute('Target.getTargets')
            }

            /**
             * Initiates bidi connection using 'webSocketUrl'
             * @returns {BIDI}
             */
            async getBidi() {
              const caps = await this.getCapabilities()
              let WebSocketUrl = caps['map_'].get('webSocketUrl')
              return new BIDI(WebSocketUrl.replace('localhost', '127.0.0.1'))
            }

            /**
             * Retrieves 'webSocketDebuggerUrl' by sending a http request using debugger address
             * @param {string} debuggerAddress
             * @param target
             * @param caps
             * @return {string} Returns parsed webSocketDebuggerUrl obtained from the http request
             */
            async getWsUrl(debuggerAddress, target, caps) {
              if (target && cdpTargets.indexOf(target.toLowerCase()) === -1) {
                throw new error.InvalidArgumentError('invalid target value')
              }

              if (debuggerAddress.match(/\/se\/cdp/)) {
                return debuggerAddress
              }

              let path
              if (target === 'page' && caps['map_'].get('browserName') !== 'firefox') {
                path = '/json'
              } else if (target === 'page' && caps['map_'].get('browserName') === 'firefox') {
                path = '/json/list'
              } else {
                path = '/json/version'
              }

              let request = new http.Request('GET', path)
              let client = new http.HttpClient('http://' + debuggerAddress)
              let response = await client.send(request)

              if (target.toLowerCase() === 'page') {
                return JSON.parse(response.body)[0]['webSocketDebuggerUrl']
              } else {
                return JSON.parse(response.body)['webSocketDebuggerUrl']
              }
            }

            /**
             * Sets a listener for Fetch.authRequired event from CDP
             * If event is triggered, it enters username and password
             * and allows the test to move forward
             * @param {string} username
             * @param {string} password
             * @param connection CDP Connection
             */
            async register(username, password, connection) {
              this._wsConnection.on('message', (message) => {
                const params = JSON.parse(message)

                if (params.method === 'Fetch.authRequired') {
                  const requestParams = params['params']
                  connection.execute('Fetch.continueWithAuth', {
                    requestId: requestParams['requestId'],
                    authChallengeResponse: {
                      response: 'ProvideCredentials',
                      username: username,
                      password: password
                    }
                  })
                } else if (params.method === 'Fetch.requestPaused') {
                  const requestPausedParams = params['params']
                  connection.execute('Fetch.continueRequest', {
                    requestId: requestPausedParams['requestId']
                  })
                }
              })

              await connection.execute(
                'Fetch.enable',
                {
                  handleAuthRequests: true
                },
                null
              )
              await connection.execute(
                'Network.setCacheDisabled',
                {
                  cacheDisabled: true
                },
                null
              )
            }

            /**
             * Handle Network interception requests
             * @param connection WebSocket connection to the browser
             * @param httpResponse Object representing what we are intercepting
             *                     as well as what should be returned.
             * @param callback callback called when we intercept requests.
             */
            async onIntercept(connection, httpResponse, callback) {
              this._wsConnection.on('message', (message) => {
                const params = JSON.parse(message)
                if (params.method === 'Fetch.requestPaused') {
                  const requestPausedParams = params['params']
                  if (requestPausedParams.request.url == httpResponse.urlToIntercept) {
                    connection.execute('Fetch.fulfillRequest', {
                      requestId: requestPausedParams['requestId'],
                      responseCode: httpResponse.status,
                      responseHeaders: httpResponse.headers,
                      body: httpResponse.body
                    })
                    callback()
                  } else {
                    connection.execute('Fetch.continueRequest', {
                      requestId: requestPausedParams['requestId']
                    })
                  }
                }
              })

              await connection.execute('Fetch.enable', {}, null)
              await connection.execute(
                'Network.setCacheDisabled',
                {
                  cacheDisabled: true
                },
                null
              )
            }
            /**
             *
             * @param connection
             * @param callback
             * @returns {Promise<void>}
             */
            async onLogEvent(connection, callback) {
              this._wsConnection.on('message', (message) => {
                const params = JSON.parse(message)
                if (params.method === 'Runtime.consoleAPICalled') {
                  const consoleEventParams = params['params']
                  let event = {
                    type: consoleEventParams['type'],
                    timestamp: new Date(consoleEventParams['timestamp']),
                    args: consoleEventParams['args']
                  }

                  callback(event)
                }

                if (params.method === 'Log.entryAdded') {
                  const logEventParams = params['params']
                  const logEntry = logEventParams['entry']
                  let event = {
                    level: logEntry['level'],
                    timestamp: new Date(logEntry['timestamp']),
                    message: logEntry['text']
                  }

                  callback(event)
                }
              })
              await connection.execute('Runtime.enable', {}, null)
            }

            /**
             *
             * @param connection
             * @param callback
             * @returns {Promise<void>}
             */
            async onLogException(connection, callback) {
              await connection.execute('Runtime.enable', {}, null)

              this._wsConnection.on('message', (message) => {
                const params = JSON.parse(message)

                if (params.method === 'Runtime.exceptionThrown') {
                  const exceptionEventParams = params['params']
                  let event = {
                    exceptionDetails: exceptionEventParams['exceptionDetails'],
                    timestamp: new Date(exceptionEventParams['timestamp'])
                  }

                  callback(event)
                }
              })
            }

            /**
             * @param connection
             * @param callback
             * @returns {Promise<void>}
             */
            async logMutationEvents(connection, callback) {
              await connection.execute('Runtime.enable', {}, null)
              await connection.execute('Page.enable', {}, null)

              await connection.execute(
                'Runtime.addBinding',
                {
                  name: '__webdriver_attribute'
                },
                null
              )

              let mutationListener = ''
              try {
                // Depending on what is running the code it could appear in 2 different places which is why we try
                // here and then the other location
                mutationListener = fs
                  .readFileSync(
                    './javascript/node/selenium-webdriver/lib/atoms/mutation-listener.js',
                    'utf-8'
                  )
                  .toString()
              } catch {
                mutationListener = fs
                  .readFileSync(path.resolve(__dirname, './atoms/mutation-listener.js'), 'utf-8')
                  .toString()
              }

              this.executeScript(mutationListener)

              await connection.execute(
                'Page.addScriptToEvaluateOnNewDocument',
                {
                  source: mutationListener
                },
                null
              )

              this._wsConnection.on('message', async (message) => {
                const params = JSON.parse(message)
                if (params.method === 'Runtime.bindingCalled') {
                  let payload = JSON.parse(params['params']['payload'])
                  let elements = await this.findElements({
                    css: '*[data-__webdriver_id=' + by.escapeCss(payload['target']) + ']'
                  })

                  if (elements.length === 0) {
                    return
                  }

                  let event = {
                    element: elements[0],
                    attribute_name: payload['name'],
                    current_value: payload['value'],
                    old_value: payload['oldValue']
                  }
                  callback(event)
                }
              })
            }

            async pinScript(script) {
              let pinnedScript = new PinnedScript(script)
              let connection
              if (Object.is(this._cdpConnection, undefined)) {
                connection = await this.createCDPConnection('page')
              } else {
                connection = this._cdpConnection
              }

              await connection.execute('Page.enable', {}, null)

              await connection.execute(
                'Runtime.evaluate',
                {
                  expression: pinnedScript.creationScript()
                },
                null
              )

              let result = await connection.send('Page.addScriptToEvaluateOnNewDocument', {
                source: pinnedScript.creationScript()
              })

              pinnedScript.scriptId = result['result']['identifier']

              this.pinnedScripts_[pinnedScript.handle] = pinnedScript

              return pinnedScript
            }

            async unpinScript(script) {
              if (script && !(script instanceof PinnedScript)) {
                throw Error(`Pass valid PinnedScript object. Received: ${script}`)
              }

              if (script.handle in this.pinnedScripts_) {
                let connection
                if (Object.is(this._cdpConnection, undefined)) {
                  connection = this.createCDPConnection('page')
                } else {
                  connection = this._cdpConnection
                }

                await connection.execute('Page.enable', {}, null)

                await connection.execute(
                  'Runtime.evaluate',
                  {
                    expression: script.removalScript()
                  },
                  null
                )

                await connection.execute(
                  'Page.removeScriptToEvaluateOnLoad',
                  {
                    identifier: script.scriptId
                  },
                  null
                )

                delete this.pinnedScripts_[script.handle]
              }
            }

            /**
             *
             * @returns The value of authenticator ID added
             */
            virtualAuthenticatorId() {
              return this.authenticatorId_
            }

            /**
             * Adds a virtual authenticator with the given options.
             * @param options VirtualAuthenticatorOptions object to set authenticator options.
             */
            async addVirtualAuthenticator(options) {
              this.authenticatorId_ = await this.execute(
                new command.Command(command.Name.ADD_VIRTUAL_AUTHENTICATOR).setParameters(
                  options.toDict()
                )
              )
            }

            /**
             * Removes a previously added virtual authenticator. The authenticator is no
             * longer valid after removal, so no methods may be called.
             */
            async removeVirtualAuthenticator() {
              await this.execute(
                new command.Command(command.Name.REMOVE_VIRTUAL_AUTHENTICATOR).setParameter(
                  'authenticatorId',
                  this.authenticatorId_
                )
              )
              this.authenticatorId_ = null
            }

            /**
             * Injects a credential into the authenticator.
             * @param credential Credential to be added
             */
            async addCredential(credential) {
              credential = credential.toDict()
              credential['authenticatorId'] = this.authenticatorId_
              await this.execute(
                new command.Command(command.Name.ADD_CREDENTIAL).setParameters(credential)
              )
            }

            /**
             *
             * @returns The list of credentials owned by the authenticator.
             */
            async getCredentials() {
              let credential_data = await this.execute(
                new command.Command(command.Name.GET_CREDENTIALS).setParameter(
                  'authenticatorId',
                  this.virtualAuthenticatorId()
                )
              )
              var credential_list = []
              for (var i = 0; i < credential_data.length; i++) {
                credential_list.push(new Credential().fromDict(credential_data[i]))
              }
              return credential_list
            }

            /**
             * Removes a credential from the authenticator.
             * @param credential_id The ID of the credential to be removed.
             */
            async removeCredential(credential_id) {
              // If credential_id is not a base64url, then convert it to base64url.
              if (Array.isArray(credential_id)) {
                credential_id = Buffer.from(credential_id).toString('base64url')
              }

              await this.execute(
                new command.Command(command.Name.REMOVE_CREDENTIAL)
                  .setParameter('credentialId', credential_id)
                  .setParameter('authenticatorId', this.authenticatorId_)
              )
            }

            /**
             * Removes all the credentials from the authenticator.
             */
            async removeAllCredentials() {
              await this.execute(
                new command.Command(command.Name.REMOVE_ALL_CREDENTIALS).setParameter(
                  'authenticatorId',
                  this.authenticatorId_
                )
              )
            }

            /**
             * Sets whether the authenticator will simulate success or fail on user verification.
             * @param verified true if the authenticator will pass user verification, false otherwise.
             */
            async setUserVerified(verified) {
              await this.execute(
                new command.Command(command.Name.SET_USER_VERIFIED)
                  .setParameter('authenticatorId', this.authenticatorId_)
                  .setParameter('isUserVerified', verified)
              )
            }
          }

          /**
           * Interface for navigating back and forth in the browser history.
           *
           * This class should never be instantiated directly. Instead, obtain an instance
           * with
           *
           *    webdriver.navigate()
           *
           * @see WebDriver#navigate()
           */
          class Navigation {
            /**
             * @param {!WebDriver} driver The parent driver.
             * @private
             */
            constructor(driver) {
              /** @private {!WebDriver} */
              this.driver_ = driver
            }

            /**
             * Navigates to a new URL.
             *
             * @param {string} url The URL to navigate to.
             * @return {!Promise<void>} A promise that will be resolved when the URL
             *     has been loaded.
             */
            to(url) {
              return this.driver_.execute(
                new command.Command(command.Name.GET).setParameter('url', url)
              )
            }

            /**
             * Moves backwards in the browser history.
             *
             * @return {!Promise<void>} A promise that will be resolved when the
             *     navigation event has completed.
             */
            back() {
              return this.driver_.execute(new command.Command(command.Name.GO_BACK))
            }

            /**
             * Moves forwards in the browser history.
             *
             * @return {!Promise<void>} A promise that will be resolved when the
             *     navigation event has completed.
             */
            forward() {
              return this.driver_.execute(new command.Command(command.Name.GO_FORWARD))
            }

            /**
             * Refreshes the current page.
             *
             * @return {!Promise<void>} A promise that will be resolved when the
             *     navigation event has completed.
             */
            refresh() {
              return this.driver_.execute(new command.Command(command.Name.REFRESH))
            }
          }

          /**
           * Provides methods for managing browser and driver state.
           *
           * This class should never be instantiated directly. Instead, obtain an instance
           * with {@linkplain WebDriver#manage() webdriver.manage()}.
           */
          class Options {
            /**
             * @param {!WebDriver} driver The parent driver.
             * @private
             */
            constructor(driver) {
              /** @private {!WebDriver} */
              this.driver_ = driver
            }

            /**
             * Adds a cookie.
             *
             * __Sample Usage:__
             *
             *     // Set a basic cookie.
             *     driver.manage().addCookie({name: 'foo', value: 'bar'});
             *
             *     // Set a cookie that expires in 10 minutes.
             *     let expiry = new Date(Date.now() + (10 * 60 * 1000));
             *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});
             *
             *     // The cookie expiration may also be specified in seconds since epoch.
             *     driver.manage().addCookie({
             *       name: 'foo',
             *       value: 'bar',
             *       expiry: Math.floor(Date.now() / 1000)
             *     });
             *
             * @param {!Options.Cookie} spec Defines the cookie to add.
             * @return {!Promise<void>} A promise that will be resolved
             *     when the cookie has been added to the page.
             * @throws {error.InvalidArgumentError} if any of the cookie parameters are
             *     invalid.
             * @throws {TypeError} if `spec` is not a cookie object.
             */
            addCookie({ name, value, path, domain, secure, httpOnly, expiry, sameSite }) {
              // We do not allow '=' or ';' in the name.
              if (/[;=]/.test(name)) {
                throw new error.InvalidArgumentError('Invalid cookie name "' + name + '"')
              }

              // We do not allow ';' in value.
              if (/;/.test(value)) {
                throw new error.InvalidArgumentError('Invalid cookie value "' + value + '"')
              }

              if (typeof expiry === 'number') {
                expiry = Math.floor(expiry)
              } else if (expiry instanceof Date) {
                let date = /** @type {!Date} */ (expiry)
                expiry = Math.floor(date.getTime() / 1000)
              }

              if (sameSite && !['Strict', 'Lax', 'None'].includes(sameSite)) {
                throw new error.InvalidArgumentError(
                  `Invalid sameSite cookie value '${sameSite}'. It should be one of "Lax", "Strict" or "None"`
                )
              }

              if (sameSite === 'None' && !secure) {
                throw new error.InvalidArgumentError(
                  'Invalid cookie configuration: SameSite=None must be Secure'
                )
              }

              return this.driver_.execute(
                new command.Command(command.Name.ADD_COOKIE).setParameter('cookie', {
                  name: name,
                  value: value,
                  path: path,
                  domain: domain,
                  secure: !!secure,
                  httpOnly: !!httpOnly,
                  expiry: expiry,
                  sameSite: sameSite
                })
              )
            }

            /**
             * Deletes all cookies visible to the current page.
             *
             * @return {!Promise<void>} A promise that will be resolved
             *     when all cookies have been deleted.
             */
            deleteAllCookies() {
              return this.driver_.execute(new command.Command(command.Name.DELETE_ALL_COOKIES))
            }

            /**
             * Deletes the cookie with the given name. This command is a no-op if there is
             * no cookie with the given name visible to the current page.
             *
             * @param {string} name The name of the cookie to delete.
             * @return {!Promise<void>} A promise that will be resolved
             *     when the cookie has been deleted.
             */
            deleteCookie(name) {
              return this.driver_.execute(
                new command.Command(command.Name.DELETE_COOKIE).setParameter('name', name)
              )
            }

            /**
             * Retrieves all cookies visible to the current page. Each cookie will be
             * returned as a JSON object as described by the WebDriver wire protocol.
             *
             * @return {!Promise<!Array<!Options.Cookie>>} A promise that will be
             *     resolved with the cookies visible to the current browsing context.
             */
            getCookies() {
              return this.driver_.execute(new command.Command(command.Name.GET_ALL_COOKIES))
            }

            /**
             * Retrieves the cookie with the given name. Returns null if there is no such
             * cookie. The cookie will be returned as a JSON object as described by the
             * WebDriver wire protocol.
             *
             * @param {string} name The name of the cookie to retrieve.
             * @return {!Promise<?Options.Cookie>} A promise that will be resolved
             *     with the named cookie
             * @throws {error.NoSuchCookieError} if there is no such cookie.
             */
            async getCookie(name) {
              try {
                const cookie = await this.driver_.execute(
                  new command.Command(command.Name.GET_COOKIE).setParameter('name', name)
                )
                return cookie
              } catch (err) {
                if (
                  !(err instanceof error.UnknownCommandError) &&
                  !(err instanceof error.UnsupportedOperationError)
                ) {
                  throw err
                }

                const cookies = await this.getCookies()
                for (let cookie of cookies) {
                  if (cookie && cookie['name'] === name) {
                    return cookie
                  }
                }
                return null
              }
            }

            /**
             * Fetches the timeouts currently configured for the current session.
             *
             * @return {!Promise<{script: number,
             *                             pageLoad: number,
             *                             implicit: number}>} A promise that will be
             *     resolved with the timeouts currently configured for the current
             *     session.
             * @see #setTimeouts()
             */
            getTimeouts() {
              return this.driver_.execute(new command.Command(command.Name.GET_TIMEOUT))
            }

            /**
             * Sets the timeout durations associated with the current session.
             *
             * The following timeouts are supported (all timeouts are specified in
             * milliseconds):
             *
             * -  `implicit` specifies the maximum amount of time to wait for an element
             *    locator to succeed when {@linkplain WebDriver#findElement locating}
             *    {@linkplain WebDriver#findElements elements} on the page.
             *    Defaults to 0 milliseconds.
             *
             * -  `pageLoad` specifies the maximum amount of time to wait for a page to
             *    finishing loading. Defaults to 300000 milliseconds.
             *
             * -  `script` specifies the maximum amount of time to wait for an
             *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to
             *    `null`, the script timeout will be indefinite.
             *    Defaults to 30000 milliseconds.
             *
             * @param {{script: (number|null|undefined),
             *          pageLoad: (number|null|undefined),
             *          implicit: (number|null|undefined)}} conf
             *     The desired timeout configuration.
             * @return {!Promise<void>} A promise that will be resolved when the timeouts
             *     have been set.
             * @throws {!TypeError} if an invalid options object is provided.
             * @see #getTimeouts()
             * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>
             */
            setTimeouts({ script, pageLoad, implicit } = {}) {
              let cmd = new command.Command(command.Name.SET_TIMEOUT)

              let valid = false
              function setParam(key, value) {
                if (value === null || typeof value === 'number') {
                  valid = true
                  cmd.setParameter(key, value)
                } else if (typeof value !== 'undefined') {
                  throw TypeError(
                    'invalid timeouts configuration:' +
                      ` expected "${key}" to be a number, got ${typeof value}`
                  )
                }
              }
              setParam('implicit', implicit)
              setParam('pageLoad', pageLoad)
              setParam('script', script)

              if (valid) {
                return this.driver_.execute(cmd).catch(() => {
                  // Fallback to the legacy method.
                  let cmds = []
                  if (typeof script === 'number') {
                    cmds.push(legacyTimeout(this.driver_, 'script', script))
                  }
                  if (typeof implicit === 'number') {
                    cmds.push(legacyTimeout(this.driver_, 'implicit', implicit))
                  }
                  if (typeof pageLoad === 'number') {
                    cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad))
                  }
                  return Promise.all(cmds)
                })
              }
              throw TypeError('no timeouts specified')
            }

            /**
             * @return {!Logs} The interface for managing driver logs.
             */
            logs() {
              return new Logs(this.driver_)
            }

            /**
             * @return {!Window} The interface for managing the current window.
             */
            window() {
              return new Window(this.driver_)
            }
          }

          /**
           * @param {!WebDriver} driver
           * @param {string} type
           * @param {number} ms
           * @return {!Promise<void>}
           */
          function legacyTimeout(driver, type, ms) {
            return driver.execute(
              new command.Command(command.Name.SET_TIMEOUT)
                .setParameter('type', type)
                .setParameter('ms', ms)
            )
          }

          /**
           * A record object describing a browser cookie.
           *
           * @record
           */
          Options.Cookie = function () {}

          /**
           * The name of the cookie.
           *
           * @type {string}
           */
          Options.Cookie.prototype.name

          /**
           * The cookie value.
           *
           * @type {string}
           */
          Options.Cookie.prototype.value

          /**
           * The cookie path. Defaults to "/" when adding a cookie.
           *
           * @type {(string|undefined)}
           */
          Options.Cookie.prototype.path

          /**
           * The domain the cookie is visible to. Defaults to the current browsing
           * context's document's URL when adding a cookie.
           *
           * @type {(string|undefined)}
           */
          Options.Cookie.prototype.domain

          /**
           * Whether the cookie is a secure cookie. Defaults to false when adding a new
           * cookie.
           *
           * @type {(boolean|undefined)}
           */
          Options.Cookie.prototype.secure

          /**
           * Whether the cookie is an HTTP only cookie. Defaults to false when adding a
           * new cookie.
           *
           * @type {(boolean|undefined)}
           */
          Options.Cookie.prototype.httpOnly

          /**
           * When the cookie expires.
           *
           * When {@linkplain Options#addCookie() adding a cookie}, this may be specified
           * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).
           *
           * The expiry is always returned in seconds since epoch when
           * {@linkplain Options#getCookies() retrieving cookies} from the browser.
           *
           * @type {(!Date|number|undefined)}
           */
          Options.Cookie.prototype.expiry

          /**
           * When the cookie applies to a SameSite policy.
           *
           * When {@linkplain Options#addCookie() adding a cookie}, this may be specified
           * as a {@link string} object which is one of 'Lax', 'Strict' or 'None'.
           *
           *
           * @type {(string|undefined)}
           */
          Options.Cookie.prototype.sameSite

          /**
           * An interface for managing the current window.
           *
           * This class should never be instantiated directly. Instead, obtain an instance
           * with
           *
           *    webdriver.manage().window()
           *
           * @see WebDriver#manage()
           * @see Options#window()
           */
          class Window {
            /**
             * @param {!WebDriver} driver The parent driver.
             * @private
             */
            constructor(driver) {
              /** @private {!WebDriver} */
              this.driver_ = driver
            }

            /**
             * Retrieves a rect describing the current top-level window's size and
             * position.
             *
             * @return {!Promise<{x: number, y: number, width: number, height: number}>}
             *     A promise that will resolve to the window rect of the current window.
             */
            getRect() {
              return this.driver_.execute(new command.Command(command.Name.GET_WINDOW_RECT))
            }

            /**
             * Sets the current top-level window's size and position. You may update just
             * the size by omitting `x` & `y`, or just the position by omitting
             * `width` & `height` options.
             *
             * @param {{x: (number|undefined),
             *          y: (number|undefined),
             *          width: (number|undefined),
             *          height: (number|undefined)}} options
             *     The desired window size and position.
             * @return {!Promise<{x: number, y: number, width: number, height: number}>}
             *     A promise that will resolve to the current window's updated window
             *     rect.
             */
            setRect({ x, y, width, height }) {
              return this.driver_.execute(
                new command.Command(command.Name.SET_WINDOW_RECT).setParameters({
                  x,
                  y,
                  width,
                  height
                })
              )
            }

            /**
             * Maximizes the current window. The exact behavior of this command is
             * specific to individual window managers, but typically involves increasing
             * the window to the maximum available size without going full-screen.
             *
             * @return {!Promise<void>} A promise that will be resolved when the command
             *     has completed.
             */
            maximize() {
              return this.driver_.execute(
                new command.Command(command.Name.MAXIMIZE_WINDOW).setParameter(
                  'windowHandle',
                  'current'
                )
              )
            }

            /**
             * Minimizes the current window. The exact behavior of this command is
             * specific to individual window managers, but typically involves hiding
             * the window in the system tray.
             *
             * @return {!Promise<void>} A promise that will be resolved when the command
             *     has completed.
             */
            minimize() {
              return this.driver_.execute(new command.Command(command.Name.MINIMIZE_WINDOW))
            }

            /**
             * Invokes the "full screen" operation on the current window. The exact
             * behavior of this command is specific to individual window managers, but
             * this will typically increase the window size to the size of the physical
             * display and hide the browser chrome.
             *
             * @return {!Promise<void>} A promise that will be resolved when the command
             *     has completed.
             * @see <https://fullscreen.spec.whatwg.org/#fullscreen-an-element>
             */
            fullscreen() {
              return this.driver_.execute(new command.Command(command.Name.FULLSCREEN_WINDOW))
            }

            /**
             * Gets the width and height of the current window
             * @param windowHandle
             * @returns {Promise<{width: *, height: *}>}
             */
            async getSize(windowHandle = 'current') {
              if (windowHandle !== 'current') {
                console.warn(`Only 'current' window is supported for W3C compatible browsers.`)
              }

              const rect = await this.getRect()
              return { height: rect.height, width: rect.width }
            }

            /**
             * Sets the width and height of the current window. (window.resizeTo)
             * @param x
             * @param y
             * @param width
             * @param height
             * @param windowHandle
             * @returns {Promise<void>}
             */
            async setSize({ x = 0, y = 0, width = 0, height = 0 }, windowHandle = 'current') {
              if (windowHandle !== 'current') {
                console.warn(`Only 'current' window is supported for W3C compatible browsers.`)
              }

              await this.setRect({ x, y, width, height })
            }
          }

          /**
           * Interface for managing WebDriver log records.
           *
           * This class should never be instantiated directly. Instead, obtain an
           * instance with
           *
           *     webdriver.manage().logs()
           *
           * @see WebDriver#manage()
           * @see Options#logs()
           */
          class Logs {
            /**
             * @param {!WebDriver} driver The parent driver.
             * @private
             */
            constructor(driver) {
              /** @private {!WebDriver} */
              this.driver_ = driver
            }

            /**
             * Fetches available log entries for the given type.
             *
             * Note that log buffers are reset after each call, meaning that available
             * log entries correspond to those entries not yet returned for a given log
             * type. In practice, this means that this call will return the available log
             * entries since the last call, or from the start of the session.
             *
             * @param {!logging.Type} type The desired log type.
             * @return {!Promise<!Array.<!logging.Entry>>} A
             *   promise that will resolve to a list of log entries for the specified
             *   type.
             */
            get(type) {
              let cmd = new command.Command(command.Name.GET_LOG).setParameter('type', type)
              return this.driver_.execute(cmd).then(function (entries) {
                return entries.map(function (entry) {
                  if (!(entry instanceof logging.Entry)) {
                    return new logging.Entry(
                      entry['level'],
                      entry['message'],
                      entry['timestamp'],
                      entry['type']
                    )
                  }
                  return entry
                })
              })
            }

            /**
             * Retrieves the log types available to this driver.
             * @return {!Promise<!Array<!logging.Type>>} A
             *     promise that will resolve to a list of available log types.
             */
            getAvailableLogTypes() {
              return this.driver_.execute(new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES))
            }
          }

          /**
           * An interface for changing the focus of the driver to another frame or window.
           *
           * This class should never be instantiated directly. Instead, obtain an
           * instance with
           *
           *     webdriver.switchTo()
           *
           * @see WebDriver#switchTo()
           */
          class TargetLocator {
            /**
             * @param {!WebDriver} driver The parent driver.
             * @private
             */
            constructor(driver) {
              /** @private {!WebDriver} */
              this.driver_ = driver
            }

            /**
             * Locates the DOM element on the current page that corresponds to
             * `document.activeElement` or `document.body` if the active element is not
             * available.
             *
             * @return {!WebElementPromise} The active element.
             */
            activeElement() {
              const id = this.driver_.execute(new command.Command(command.Name.GET_ACTIVE_ELEMENT))
              return new WebElementPromise(this.driver_, id)
            }

            /**
             * Switches focus of all future commands to the topmost frame in the current
             * window.
             *
             * @return {!Promise<void>} A promise that will be resolved
             *     when the driver has changed focus to the default content.
             */
            defaultContent() {
              return this.driver_.execute(
                new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', null)
              )
            }

            /**
             * Changes the focus of all future commands to another frame on the page. The
             * target frame may be specified as one of the following:
             *
             * - A number that specifies a (zero-based) index into [window.frames](
             *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).
             * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`
             *   DOM element.
             * - The `null` value, to select the topmost frame on the page. Passing `null`
             *   is the same as calling {@link #defaultContent defaultContent()}.
             *
             * If the specified frame can not be found, the returned promise will be
             * rejected with a {@linkplain error.NoSuchFrameError}.
             *
             * @param {(number|string|WebElement|null)} id The frame locator.
             * @return {!Promise<void>} A promise that will be resolved
             *     when the driver has changed focus to the specified frame.
             */
            frame(id) {
              let frameReference = id
              if (typeof id === 'string') {
                frameReference = this.driver_
                  .findElement({ id })
                  .catch((_) => this.driver_.findElement({ name: id }))
              }

              return this.driver_.execute(
                new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', frameReference)
              )
            }

            /**
             * Changes the focus of all future commands to the parent frame of the
             * currently selected frame. This command has no effect if the driver is
             * already focused on the top-level browsing context.
             *
             * @return {!Promise<void>} A promise that will be resolved when the command
             *     has completed.
             */
            parentFrame() {
              return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME_PARENT))
            }

            /**
             * Changes the focus of all future commands to another window. Windows may be
             * specified by their {@code window.name} attribute or by its handle
             * (as returned by {@link WebDriver#getWindowHandles}).
             *
             * If the specified window cannot be found, the returned promise will be
             * rejected with a {@linkplain error.NoSuchWindowError}.
             *
             * @param {string} nameOrHandle The name or window handle of the window to
             *     switch focus to.
             * @return {!Promise<void>} A promise that will be resolved
             *     when the driver has changed focus to the specified window.
             */
            window(nameOrHandle) {
              return this.driver_.execute(
                new command.Command(command.Name.SWITCH_TO_WINDOW)
                  // "name" supports the legacy drivers. "handle" is the W3C
                  // compliant parameter.
                  .setParameter('name', nameOrHandle)
                  .setParameter('handle', nameOrHandle)
              )
            }

            /**
             * Creates a new browser window and switches the focus for future
             * commands of this driver to the new window.
             *
             * @param {string} typeHint 'window' or 'tab'. The created window is not
             *     guaranteed to be of the requested type; if the driver does not support
             *     the requested type, a new browser window will be created of whatever type
             *     the driver does support.
             * @return {!Promise<void>} A promise that will be resolved
             *     when the driver has changed focus to the new window.
             */
            newWindow(typeHint) {
              const driver = this.driver_
              return this.driver_
                .execute(
                  new command.Command(command.Name.SWITCH_TO_NEW_WINDOW).setParameter(
                    'type',
                    typeHint
                  )
                )
                .then(function (response) {
                  return driver.switchTo().window(response.handle)
                })
            }

            /**
             * Changes focus to the active modal dialog, such as those opened by
             * `window.alert()`, `window.confirm()`, and `window.prompt()`. The returned
             * promise will be rejected with a
             * {@linkplain error.NoSuchAlertError} if there are no open alerts.
             *
             * @return {!AlertPromise} The open alert.
             */
            alert() {
              const text = this.driver_.execute(new command.Command(command.Name.GET_ALERT_TEXT))
              const driver = this.driver_
              return new AlertPromise(
                driver,
                text.then(function (text) {
                  return new Alert(driver, text)
                })
              )
            }
          }

          //////////////////////////////////////////////////////////////////////////////
          //
          //  WebElement
          //
          //////////////////////////////////////////////////////////////////////////////

          const LEGACY_ELEMENT_ID_KEY = 'ELEMENT'
          const ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf'
          const SHADOW_ROOT_ID_KEY = 'shadow-6066-11e4-a52e-4f735466cecf'

          /**
           * Represents a DOM element. WebElements can be found by searching from the
           * document root using a {@link WebDriver} instance, or by searching
           * under another WebElement:
           *
           *     driver.get('http://www.google.com');
           *     var searchForm = driver.findElement(By.tagName('form'));
           *     var searchBox = searchForm.findElement(By.name('q'));
           *     searchBox.sendKeys('webdriver');
           */
          class WebElement {
            /**
             * @param {!WebDriver} driver the parent WebDriver instance for this element.
             * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for
             *     the underlying DOM element.
             */
            constructor(driver, id) {
              /** @private {!WebDriver} */
              this.driver_ = driver

              /** @private {!Promise<string>} */
              this.id_ = Promise.resolve(id)
            }

            /**
             * @param {string} id The raw ID.
             * @param {boolean=} noLegacy Whether to exclude the legacy element key.
             * @return {!Object} The element ID for use with WebDriver's wire protocol.
             */
            static buildId(id, noLegacy = false) {
              return noLegacy
                ? { [ELEMENT_ID_KEY]: id }
                : { [ELEMENT_ID_KEY]: id, [LEGACY_ELEMENT_ID_KEY]: id }
            }

            /**
             * Extracts the encoded WebElement ID from the object.
             *
             * @param {?} obj The object to extract the ID from.
             * @return {string} the extracted ID.
             * @throws {TypeError} if the object is not a valid encoded ID.
             */
            static extractId(obj) {
              return webElement.extractId(obj)
            }

            /**
             * @param {?} obj the object to test.
             * @return {boolean} whether the object is a valid encoded WebElement ID.
             */
            static isId(obj) {
              return webElement.isId(obj)
            }

            /**
             * Compares two WebElements for equality.
             *
             * @param {!WebElement} a A WebElement.
             * @param {!WebElement} b A WebElement.
             * @return {!Promise<boolean>} A promise that will be
             *     resolved to whether the two WebElements are equal.
             */
            static async equals(a, b) {
              if (a === b) {
                return true
              }
              return a.driver_.executeScript('return arguments[0] === arguments[1]', a, b)
            }

            /** @return {!WebDriver} The parent driver for this instance. */
            getDriver() {
              return this.driver_
            }

            /**
             * @return {!Promise<string>} A promise that resolves to
             *     the server-assigned opaque ID assigned to this element.
             */
            getId() {
              return this.id_
            }

            /**
             * @return {!Object} Returns the serialized representation of this WebElement.
             */
            [Symbols.serialize]() {
              return this.getId().then(WebElement.buildId)
            }

            /**
             * Schedules a command that targets this element with the parent WebDriver
             * instance. Will ensure this element's ID is included in the command
             * parameters under the "id" key.
             *
             * @param {!command.Command} command The command to schedule.
             * @return {!Promise<T>} A promise that will be resolved with the result.
             * @template T
             * @see WebDriver#schedule
             * @private
             */
            execute_(command) {
              command.setParameter('id', this)
              return this.driver_.execute(command)
            }

            /**
             * Schedule a command to find a descendant of this element. If the element
             * cannot be found, the returned promise will be rejected with a
             * {@linkplain error.NoSuchElementError NoSuchElementError}.
             *
             * The search criteria for an element may be defined using one of the static
             * factories on the {@link by.By} class, or as a short-hand
             * {@link ./by.ByHash} object. For example, the following two statements
             * are equivalent:
             *
             *     var e1 = element.findElement(By.id('foo'));
             *     var e2 = element.findElement({id:'foo'});
             *
             * You may also provide a custom locator function, which takes as input this
             * instance and returns a {@link WebElement}, or a promise that will resolve
             * to a WebElement. If the returned promise resolves to an array of
             * WebElements, WebDriver will use the first element. For example, to find the
             * first visible link on a page, you could write:
             *
             *     var link = element.findElement(firstVisibleLink);
             *
             *     function firstVisibleLink(element) {
             *       var links = element.findElements(By.tagName('a'));
             *       return promise.filter(links, function(link) {
             *         return link.isDisplayed();
             *       });
             *     }
             *
             * @param {!(by.By|Function)} locator The locator strategy to use when
             *     searching for the element.
             * @return {!WebElementPromise} A WebElement that can be used to issue
             *     commands against the located element. If the element is not found, the
             *     element will be invalidated and all scheduled commands aborted.
             */
            findElement(locator) {
              locator = by.checkedLocator(locator)
              let id
              if (typeof locator === 'function') {
                id = this.driver_.findElementInternal_(locator, this)
              } else {
                let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENT)
                  .setParameter('using', locator.using)
                  .setParameter('value', locator.value)
                id = this.execute_(cmd)
              }
              return new WebElementPromise(this.driver_, id)
            }

            /**
             * Locates all the descendants of this element that match the given search
             * criteria.
             *
             * @param {!(by.By|Function)} locator The locator strategy to use when
             *     searching for the element.
             * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an
             *     array of WebElements.
             */
            async findElements(locator) {
              locator = by.checkedLocator(locator)
              if (typeof locator === 'function') {
                return this.driver_.findElementsInternal_(locator, this)
              } else {
                let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS)
                  .setParameter('using', locator.using)
                  .setParameter('value', locator.value)
                let result = await this.execute_(cmd)
                return Array.isArray(result) ? result : []
              }
            }

            /**
             * Clicks on this element.
             *
             * @return {!Promise<void>} A promise that will be resolved when the click
             *     command has completed.
             */
            click() {
              return this.execute_(new command.Command(command.Name.CLICK_ELEMENT))
            }

            /**
             * Types a key sequence on the DOM element represented by this instance.
             *
             * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
             * processed in the key sequence, that key state is toggled until one of the
             * following occurs:
             *
             * - The modifier key is encountered again in the sequence. At this point the
             *   state of the key is toggled (along with the appropriate keyup/down
             *   events).
             * - The {@link input.Key.NULL} key is encountered in the sequence. When
             *   this key is encountered, all modifier keys current in the down state are
             *   released (with accompanying keyup events). The NULL key can be used to
             *   simulate common keyboard shortcuts:
             *
             *         element.sendKeys("text was",
             *                          Key.CONTROL, "a", Key.NULL,
             *                          "now text is");
             *         // Alternatively:
             *         element.sendKeys("text was",
             *                          Key.chord(Key.CONTROL, "a"),
             *                          "now text is");
             *
             * - The end of the key sequence is encountered. When there are no more keys
             *   to type, all depressed modifier keys are released (with accompanying
             *   keyup events).
             *
             * If this element is a file input ({@code <input type="file">}), the
             * specified key sequence should specify the path to the file to attach to
             * the element. This is analogous to the user clicking "Browse..." and entering
             * the path into the file select dialog.
             *
             *     var form = driver.findElement(By.css('form'));
             *     var element = form.findElement(By.css('input[type=file]'));
             *     element.sendKeys('/path/to/file.txt');
             *     form.submit();
             *
             * For uploads to function correctly, the entered path must reference a file
             * on the _browser's_ machine, not the local machine running this script. When
             * running against a remote Selenium server, a {@link input.FileDetector}
             * may be used to transparently copy files to the remote machine before
             * attempting to upload them in the browser.
             *
             * __Note:__ On browsers where native keyboard events are not supported
             * (e.g. Firefox on OS X), key events will be synthesized. Special
             * punctuation keys will be synthesized according to a standard QWERTY en-us
             * keyboard layout.
             *
             * @param {...(number|string|!IThenable<(number|string)>)} args The
             *     sequence of keys to type. Number keys may be referenced numerically or
             *     by string (1 or '1'). All arguments will be joined into a single
             *     sequence.
             * @return {!Promise<void>} A promise that will be resolved when all keys
             *     have been typed.
             */
            async sendKeys(...args) {
              let keys = []
              ;(await Promise.all(args)).forEach((key) => {
                let type = typeof key
                if (type === 'number') {
                  key = String(key)
                } else if (type !== 'string') {
                  throw TypeError('each key must be a number or string; got ' + type)
                }

                // The W3C protocol requires keys to be specified as an array where
                // each element is a single key.
                keys.push(...key)
              })

              if (!this.driver_.fileDetector_) {
                return this.execute_(
                  new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)
                    .setParameter('text', keys.join(''))
                    .setParameter('value', keys)
                )
              }

              try {
                keys = await this.driver_.fileDetector_.handleFile(this.driver_, keys.join(''))
              } catch (ex) {
                console.log(
                  'Error trying parse string as a file with file detector; sending keys instead' +
                    ex
                )
              }

              return this.execute_(
                new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)
                  .setParameter('text', keys)
                  .setParameter('value', keys.split(''))
              )
            }

            /**
             * Retrieves the element's tag name.
             *
             * @return {!Promise<string>} A promise that will be resolved with the
             *     element's tag name.
             */
            getTagName() {
              return this.execute_(new command.Command(command.Name.GET_ELEMENT_TAG_NAME))
            }

            /**
             * Retrieves the value of a computed style property for this instance. If
             * the element inherits the named style from its parent, the parent will be
             * queried for its value.  Where possible, color values will be converted to
             * their hex representation (e.g. #00ff00 instead of rgb(0, 255, 0)).
             *
             * _Warning:_ the value returned will be as the browser interprets it, so
             * it may be tricky to form a proper assertion.
             *
             * @param {string} cssStyleProperty The name of the CSS style property to look
             *     up.
             * @return {!Promise<string>} A promise that will be resolved with the
             *     requested CSS value.
             */
            getCssValue(cssStyleProperty) {
              const name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY
              return this.execute_(
                new command.Command(name).setParameter('propertyName', cssStyleProperty)
              )
            }

            /**
             * Retrieves the current value of the given attribute of this element.
             * Will return the current value, even if it has been modified after the page
             * has been loaded. More exactly, this method will return the value
             * of the given attribute, unless that attribute is not present, in which case
             * the value of the property with the same name is returned. If neither value
             * is set, null is returned (for example, the "value" property of a textarea
             * element). The "style" attribute is converted as best can be to a
             * text representation with a trailing semicolon. The following are deemed to
             * be "boolean" attributes and will return either "true" or null:
             *
             * async, autofocus, autoplay, checked, compact, complete, controls, declare,
             * defaultchecked, defaultselected, defer, disabled, draggable, ended,
             * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
             * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
             * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
             * selected, spellcheck, truespeed, willvalidate
             *
             * Finally, the following commonly mis-capitalized attribute/property names
             * are evaluated as expected:
             *
             * - "class"
             * - "readonly"
             *
             * @param {string} attributeName The name of the attribute to query.
             * @return {!Promise<?string>} A promise that will be
             *     resolved with the attribute's value. The returned value will always be
             *     either a string or null.
             */
            getAttribute(attributeName) {
              return this.execute_(
                new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).setParameter(
                  'name',
                  attributeName
                )
              )
            }

            /**
             * Get the value of the given attribute of the element.
             * <p>
             * This method, unlike {@link #getAttribute(String)}, returns the value of the attribute with the
             * given name but not the property with the same name.
             * <p>
             * The following are deemed to be "boolean" attributes, and will return either "true" or null:
             * <p>
             * async, autofocus, autoplay, checked, compact, complete, controls, declare, defaultchecked,
             * defaultselected, defer, disabled, draggable, ended, formnovalidate, hidden, indeterminate,
             * iscontenteditable, ismap, itemscope, loop, multiple, muted, nohref, noresize, noshade,
             * novalidate, nowrap, open, paused, pubdate, readonly, required, reversed, scoped, seamless,
             * seeking, selected, truespeed, willvalidate
             * <p>
             * See <a href="https://w3c.github.io/webdriver/#get-element-attribute">W3C WebDriver specification</a>
             * for more details.
             *
             * @param attributeName The name of the attribute.
             * @return The attribute's value or null if the value is not set.
             */

            getDomAttribute(attributeName) {
              return this.execute_(
                new command.Command(command.Name.GET_DOM_ATTRIBUTE).setParameter(
                  'name',
                  attributeName
                )
              )
            }

            /**
             * Get the given property of the referenced web element
             * @param {string} propertyName The name of the attribute to query.
             * @return {!Promise<string>} A promise that will be
             *     resolved with the element's property value
             */
            getProperty(propertyName) {
              return this.execute_(
                new command.Command(command.Name.GET_ELEMENT_PROPERTY).setParameter(
                  'name',
                  propertyName
                )
              )
            }

            /**
             * Get the shadow root of the current web element.
             * @returns {!Promise<ShadowRoot>} A promise that will be
             *      resolved with the elements shadow root or rejected
             *      with {@link NoSuchShadowRootError}
             */
            getShadowRoot() {
              return this.execute_(new command.Command(command.Name.GET_SHADOW_ROOT))
            }

            /**
             * Get the visible (i.e. not hidden by CSS) innerText of this element,
             * including sub-elements, without any leading or trailing whitespace.
             *
             * @return {!Promise<string>} A promise that will be
             *     resolved with the element's visible text.
             */
            getText() {
              return this.execute_(new command.Command(command.Name.GET_ELEMENT_TEXT))
            }

            /**
             * Get the computed WAI-ARIA role of element.
             *
             * @return {!Promise<string>} A promise that will be
             *     resolved with the element's computed role.
             */
            getAriaRole() {
              return this.execute_(new command.Command(command.Name.GET_COMPUTED_ROLE))
            }

            /**
             * Get the computed WAI-ARIA label of element.
             *
             * @return {!Promise<string>} A promise that will be
             *     resolved with the element's computed label.
             */
            getAccessibleName() {
              return this.execute_(new command.Command(command.Name.GET_COMPUTED_LABEL))
            }
            /**
             * Returns an object describing an element's location, in pixels relative to
             * the document element, and the element's size in pixels.
             *
             * @return {!Promise<{width: number, height: number, x: number, y: number}>}
             *     A promise that will resolve with the element's rect.
             */
            getRect() {
              return this.execute_(new command.Command(command.Name.GET_ELEMENT_RECT))
            }

            /**
             * Tests whether this element is enabled, as dictated by the `disabled`
             * attribute.
             *
             * @return {!Promise<boolean>} A promise that will be
             *     resolved with whether this element is currently enabled.
             */
            isEnabled() {
              return this.execute_(new command.Command(command.Name.IS_ELEMENT_ENABLED))
            }

            /**
             * Tests whether this element is selected.
             *
             * @return {!Promise<boolean>} A promise that will be
             *     resolved with whether this element is currently selected.
             */
            isSelected() {
              return this.execute_(new command.Command(command.Name.IS_ELEMENT_SELECTED))
            }

            /**
             * Submits the form containing this element (or this element if it is itself
             * a FORM element). his command is a no-op if the element is not contained in
             * a form.
             *
             * @return {!Promise<void>} A promise that will be resolved
             *     when the form has been submitted.
             */
            submit() {
              const script =
                '/* submitForm */var form = arguments[0];\n' +
                'while (form.nodeName != "FORM" && form.parentNode) {\n' +
                '  form = form.parentNode;\n' +
                '}\n' +
                "if (!form) { throw Error('Unable to find containing form element'); }\n" +
                "if (!form.ownerDocument) { throw Error('Unable to find owning document'); }\n" +
                "var e = form.ownerDocument.createEvent('Event');\n" +
                "e.initEvent('submit', true, true);\n" +
                'if (form.dispatchEvent(e)) { HTMLFormElement.prototype.submit.call(form) }\n'

              return this.driver_.executeScript(script, this)
            }

            /**
             * Clear the `value` of this element. This command has no effect if the
             * underlying DOM element is neither a text INPUT element nor a TEXTAREA
             * element.
             *
             * @return {!Promise<void>} A promise that will be resolved
             *     when the element has been cleared.
             */
            clear() {
              return this.execute_(new command.Command(command.Name.CLEAR_ELEMENT))
            }

            /**
             * Test whether this element is currently displayed.
             *
             * @return {!Promise<boolean>} A promise that will be
             *     resolved with whether this element is currently visible on the page.
             */
            isDisplayed() {
              return this.execute_(new command.Command(command.Name.IS_ELEMENT_DISPLAYED))
            }

            /**
             * Take a screenshot of the visible region encompassed by this element's
             * bounding rectangle.
             *
             * @return {!Promise<string>} A promise that will be
             *     resolved to the screenshot as a base-64 encoded PNG.
             */
            takeScreenshot() {
              return this.execute_(new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT))
            }
          }

          /**
           * WebElementPromise is a promise that will be fulfilled with a WebElement.
           * This serves as a forward proxy on WebElement, allowing calls to be
           * scheduled without directly on this instance before the underlying
           * WebElement has been fulfilled. In other words, the following two statements
           * are equivalent:
           *
           *     driver.findElement({id: 'my-button'}).click();
           *     driver.findElement({id: 'my-button'}).then(function(el) {
           *       return el.click();
           *     });
           *
           * @implements {IThenable<!WebElement>}
           * @final
           */
          class WebElementPromise extends WebElement {
            /**
             * @param {!WebDriver} driver The parent WebDriver instance for this
             *     element.
             * @param {!Promise<!WebElement>} el A promise
             *     that will resolve to the promised element.
             */
            constructor(driver, el) {
              super(driver, 'unused')

              /** @override */
              this.then = el.then.bind(el)

              /** @override */
              this.catch = el.catch.bind(el)

              /**
               * Defers returning the element ID until the wrapped WebElement has been
               * resolved.
               * @override
               */
              this.getId = function () {
                return el.then(function (el) {
                  return el.getId()
                })
              }
            }
          }

          //////////////////////////////////////////////////////////////////////////////
          //
          //  ShadowRoot
          //
          //////////////////////////////////////////////////////////////////////////////

          /**
           * Represents a ShadowRoot of a {@link WebElement}. Provides functions to
           * retrieve elements that live in the DOM below the ShadowRoot.
           */
          class ShadowRoot {
            constructor(driver, id) {
              this.driver_ = driver
              this.id_ = id
            }

            /**
             * Extracts the encoded ShadowRoot ID from the object.
             *
             * @param {?} obj The object to extract the ID from.
             * @return {string} the extracted ID.
             * @throws {TypeError} if the object is not a valid encoded ID.
             */
            static extractId(obj) {
              if (obj && typeof obj === 'object') {
                if (typeof obj[SHADOW_ROOT_ID_KEY] === 'string') {
                  return obj[SHADOW_ROOT_ID_KEY]
                }
              }
              throw new TypeError('object is not a ShadowRoot ID')
            }

            /**
             * @param {?} obj the object to test.
             * @return {boolean} whether the object is a valid encoded WebElement ID.
             */
            static isId(obj) {
              return obj && typeof obj === 'object' && typeof obj[SHADOW_ROOT_ID_KEY] === 'string'
            }

            /**
             * @return {!Object} Returns the serialized representation of this ShadowRoot.
             */
            [Symbols.serialize]() {
              return this.getId()
            }

            /**
             * Schedules a command that targets this element with the parent WebDriver
             * instance. Will ensure this element's ID is included in the command
             * parameters under the "id" key.
             *
             * @param {!command.Command} command The command to schedule.
             * @return {!Promise<T>} A promise that will be resolved with the result.
             * @template T
             * @see WebDriver#schedule
             * @private
             */
            execute_(command) {
              command.setParameter('id', this)
              return this.driver_.execute(command)
            }

            /**
             * Schedule a command to find a descendant of this ShadowROot. If the element
             * cannot be found, the returned promise will be rejected with a
             * {@linkplain error.NoSuchElementError NoSuchElementError}.
             *
             * The search criteria for an element may be defined using one of the static
             * factories on the {@link by.By} class, or as a short-hand
             * {@link ./by.ByHash} object. For example, the following two statements
             * are equivalent:
             *
             *     var e1 = shadowroot.findElement(By.id('foo'));
             *     var e2 = shadowroot.findElement({id:'foo'});
             *
             * You may also provide a custom locator function, which takes as input this
             * instance and returns a {@link WebElement}, or a promise that will resolve
             * to a WebElement. If the returned promise resolves to an array of
             * WebElements, WebDriver will use the first element. For example, to find the
             * first visible link on a page, you could write:
             *
             *     var link = element.findElement(firstVisibleLink);
             *
             *     function firstVisibleLink(shadowRoot) {
             *       var links = shadowRoot.findElements(By.tagName('a'));
             *       return promise.filter(links, function(link) {
             *         return link.isDisplayed();
             *       });
             *     }
             *
             * @param {!(by.By|Function)} locator The locator strategy to use when
             *     searching for the element.
             * @return {!WebElementPromise} A WebElement that can be used to issue
             *     commands against the located element. If the element is not found, the
             *     element will be invalidated and all scheduled commands aborted.
             */
            findElement(locator) {
              locator = by.checkedLocator(locator)
              let id
              if (typeof locator === 'function') {
                id = this.driver_.findElementInternal_(locator, this)
              } else {
                let cmd = new command.Command(command.Name.FIND_ELEMENT_FROM_SHADOWROOT)
                  .setParameter('using', locator.using)
                  .setParameter('value', locator.value)
                id = this.execute_(cmd)
              }
              return new ShadowRootPromise(this.driver_, id)
            }

            /**
             * Locates all the descendants of this element that match the given search
             * criteria.
             *
             * @param {!(by.By|Function)} locator The locator strategy to use when
             *     searching for the element.
             * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an
             *     array of WebElements.
             */
            async findElements(locator) {
              locator = by.checkedLocator(locator)
              if (typeof locator === 'function') {
                return this.driver_.findElementsInternal_(locator, this)
              } else {
                let cmd = new command.Command(command.Name.FIND_ELEMENTS_FROM_SHADOWROOT)
                  .setParameter('using', locator.using)
                  .setParameter('value', locator.value)
                let result = await this.execute_(cmd)
                return Array.isArray(result) ? result : []
              }
            }

            getId() {
              return this.id_
            }
          }

          /**
           * ShadowRootPromise is a promise that will be fulfilled with a WebElement.
           * This serves as a forward proxy on ShadowRoot, allowing calls to be
           * scheduled without directly on this instance before the underlying
           * ShadowRoot has been fulfilled.
           *
           * @implements { IThenable<!ShadowRoot>}
           * @final
           */
          class ShadowRootPromise extends ShadowRoot {
            /**
             * @param {!WebDriver} driver The parent WebDriver instance for this
             *     element.
             * @param {!Promise<!ShadowRoot>} shadow A promise
             *     that will resolve to the promised element.
             */
            constructor(driver, shadow) {
              super(driver, 'unused')

              /** @override */
              this.then = shadow.then.bind(shadow)

              /** @override */
              this.catch = shadow.catch.bind(shadow)

              /**
               * Defers returning the ShadowRoot ID until the wrapped WebElement has been
               * resolved.
               * @override
               */
              this.getId = function () {
                return shadow.then(function (shadow) {
                  return shadow.getId()
                })
              }
            }
          }

          //////////////////////////////////////////////////////////////////////////////
          //
          //  Alert
          //
          //////////////////////////////////////////////////////////////////////////////

          /**
           * Represents a modal dialog such as {@code alert}, {@code confirm}, or
           * {@code prompt}. Provides functions to retrieve the message displayed with
           * the alert, accept or dismiss the alert, and set the response text (in the
           * case of {@code prompt}).
           */
          class Alert {
            /**
             * @param {!WebDriver} driver The driver controlling the browser this alert
             *     is attached to.
             * @param {string} text The message text displayed with this alert.
             */
            constructor(driver, text) {
              /** @private {!WebDriver} */
              this.driver_ = driver

              /** @private {!Promise<string>} */
              this.text_ = Promise.resolve(text)
            }

            /**
             * Retrieves the message text displayed with this alert. For instance, if the
             * alert were opened with alert("hello"), then this would return "hello".
             *
             * @return {!Promise<string>} A promise that will be
             *     resolved to the text displayed with this alert.
             */
            getText() {
              return this.text_
            }

            /**
             * Accepts this alert.
             *
             * @return {!Promise<void>} A promise that will be resolved
             *     when this command has completed.
             */
            accept() {
              return this.driver_.execute(new command.Command(command.Name.ACCEPT_ALERT))
            }

            /**
             * Dismisses this alert.
             *
             * @return {!Promise<void>} A promise that will be resolved
             *     when this command has completed.
             */
            dismiss() {
              return this.driver_.execute(new command.Command(command.Name.DISMISS_ALERT))
            }

            /**
             * Sets the response text on this alert. This command will return an error if
             * the underlying alert does not support response text (e.g. window.alert and
             * window.confirm).
             *
             * @param {string} text The text to set.
             * @return {!Promise<void>} A promise that will be resolved
             *     when this command has completed.
             */
            sendKeys(text) {
              return this.driver_.execute(
                new command.Command(command.Name.SET_ALERT_TEXT).setParameter('text', text)
              )
            }
          }

          /**
           * AlertPromise is a promise that will be fulfilled with an Alert. This promise
           * serves as a forward proxy on an Alert, allowing calls to be scheduled
           * directly on this instance before the underlying Alert has been fulfilled. In
           * other words, the following two statements are equivalent:
           *
           *     driver.switchTo().alert().dismiss();
           *     driver.switchTo().alert().then(function(alert) {
           *       return alert.dismiss();
           *     });
           *
           * @implements {IThenable<!Alert>}
           * @final
           */
          class AlertPromise extends Alert {
            /**
             * @param {!WebDriver} driver The driver controlling the browser this
             *     alert is attached to.
             * @param {!Promise<!Alert>} alert A thenable
             *     that will be fulfilled with the promised alert.
             */
            constructor(driver, alert) {
              super(driver, 'unused')

              /** @override */
              this.then = alert.then.bind(alert)

              /** @override */
              this.catch = alert.catch.bind(alert)

              /**
               * Defer returning text until the promised alert has been resolved.
               * @override
               */
              this.getText = function () {
                return alert.then(function (alert) {
                  return alert.getText()
                })
              }

              /**
               * Defers action until the alert has been located.
               * @override
               */
              this.accept = function () {
                return alert.then(function (alert) {
                  return alert.accept()
                })
              }

              /**
               * Defers action until the alert has been located.
               * @override
               */
              this.dismiss = function () {
                return alert.then(function (alert) {
                  return alert.dismiss()
                })
              }

              /**
               * Defers action until the alert has been located.
               * @override
               */
              this.sendKeys = function (text) {
                return alert.then(function (alert) {
                  return alert.sendKeys(text)
                })
              }
            }
          }

          // PUBLIC API

          module.exports = {
            Alert,
            AlertPromise,
            Condition,
            Logs,
            Navigation,
            Options,
            ShadowRoot,
            TargetLocator,
            IWebDriver,
            WebDriver,
            WebElement,
            WebElementCondition,
            WebElementPromise,
            Window
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib/webelement.js':
        /*!***********************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/webelement.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const { isObject } = __webpack_require__(
            /*! ./util */ './node_modules/selenium-webdriver/lib/util.js'
          )

          /**
           * @fileoverview Defines some common methods used for WebElements.
           */

          const LEGACY_ELEMENT_ID_KEY = 'ELEMENT'
          const ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf'

          /**
           * Contains logic about WebElements.
           */
          /**
           * @param {?} obj the object to test.
           * @return {boolean} whether the object is a valid encoded WebElement ID.
           */
          function isId(obj) {
            return (
              isObject(obj) &&
              (typeof obj[ELEMENT_ID_KEY] === 'string' ||
                typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string')
            )
          }

          /**
           * Extracts the encoded WebElement ID from the object.
           *
           * @param {?} obj The object to extract the ID from.
           * @return {string} the extracted ID.
           * @throws {TypeError} if the object is not a valid encoded ID.
           */
          function extractId(obj) {
            if (isObject(obj)) {
              if (typeof obj[ELEMENT_ID_KEY] === 'string') {
                return obj[ELEMENT_ID_KEY]
              } else if (typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string') {
                return obj[LEGACY_ELEMENT_ID_KEY]
              }
            }
            throw new TypeError('object is not a WebElement ID')
          }

          // PUBLIC API

          module.exports = {
            isId,
            extractId
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/lib sync recursive':
        /*!***************************************************!*\
  !*** ./node_modules/selenium-webdriver/lib/ sync ***!
  \***************************************************/
        /***/ (module) => {
          function webpackEmptyContext(req) {
            var e = new Error("Cannot find module '" + req + "'")
            e.code = 'MODULE_NOT_FOUND'
            throw e
          }
          webpackEmptyContext.keys = () => []
          webpackEmptyContext.resolve = webpackEmptyContext
          webpackEmptyContext.id = './node_modules/selenium-webdriver/lib sync recursive'
          module.exports = webpackEmptyContext

          /***/
        },

      /***/ './node_modules/selenium-webdriver/net/index.js':
        /*!******************************************************!*\
  !*** ./node_modules/selenium-webdriver/net/index.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const os = __webpack_require__(/*! os */ 'os')

          function getLoInterface() {
            let name
            if (process.platform === 'darwin') {
              name = 'lo0'
            } else if (process.platform === 'linux') {
              name = 'lo'
            }
            return name ? os.networkInterfaces()[name] : null
          }

          /**
           * Queries the system network interfaces for an IP address.
           * @param {boolean} loopback Whether to find a loopback address.
           * @param {string} family The IP family (IPv4 or IPv6). Defaults to IPv4.
           * @return {(string|undefined)} The located IP address or undefined.
           */
          function getIPAddress(loopback, family) {
            let interfaces
            if (loopback) {
              const lo = getLoInterface()
              interfaces = lo ? [lo] : null
            }
            interfaces = interfaces || os.networkInterfaces()
            for (let key in interfaces) {
              if (!Object.prototype.hasOwnProperty.call(interfaces, key)) {
                continue
              }

              for (let ipAddress of interfaces[key]) {
                if (
                  (ipAddress.family === family || `IPv${ipAddress.family}` === family) &&
                  ipAddress.internal === loopback
                ) {
                  return ipAddress.address
                }
              }
            }
            return undefined
          }

          // PUBLIC API

          /**
           * Retrieves the external IP address for this host.
           * @param {string=} family The IP family to retrieve. Defaults to "IPv4".
           * @return {(string|undefined)} The IP address or undefined if not available.
           */
          function getAddress(family = 'IPv4') {
            return getIPAddress(false, family)
          }

          /**
           * Retrieves a loopback address for this machine.
           * @param {string=} family The IP family to retrieve. Defaults to "IPv4".
           * @return {(string|undefined)} The IP address or undefined if not available.
           */
          function getLoopbackAddress(family = 'IPv4') {
            return getIPAddress(true, family)
          }

          /**
           * Splits a hostport string, e.g. "www.example.com:80", into its component
           * parts.
           *
           * @param {string} hostport The string to split.
           * @return {{host: string, port: ?number}} A host and port. If no port is
           *     present in the argument `hostport`, port is null.
           */
          function splitHostAndPort(hostport) {
            let lastIndex = hostport.lastIndexOf(':')
            if (lastIndex < 0) {
              return { host: hostport, port: null }
            }

            let firstIndex = hostport.indexOf(':')
            if (firstIndex != lastIndex && !hostport.includes('[')) {
              // Multiple colons but no brackets, so assume the string is an IPv6 address
              // with no port (e.g. "1234:5678:9:0:1234:5678:9:0").
              return { host: hostport, port: null }
            }

            let host = hostport.slice(0, lastIndex)
            if (host.startsWith('[') && host.endsWith(']')) {
              host = host.slice(1, -1)
            }

            let port = parseInt(hostport.slice(lastIndex + 1), 10)
            return { host, port }
          }

          // PUBLIC API
          module.exports = {
            splitHostAndPort,
            getLoopbackAddress,
            getAddress
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/net/portprober.js':
        /*!***********************************************************!*\
  !*** ./node_modules/selenium-webdriver/net/portprober.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const net = __webpack_require__(/*! net */ 'net')

          /**
           * Tests if a port is free.
           * @param {number} port The port to test.
           * @param {string=} opt_host The bound host to test the {@code port} against.
           *     Defaults to {@code INADDR_ANY}.
           * @return {!Promise<boolean>} A promise that will resolve with whether the port
           *     is free.
           */
          function isFree(port, opt_host) {
            return new Promise((resolve, reject) => {
              const server = net.createServer().on('error', function (e) {
                if (e.code === 'EADDRINUSE' || e.code === 'EACCES') {
                  resolve(false)
                } else {
                  reject(e)
                }
              })

              server.listen(port, opt_host, function () {
                server.close(() => resolve(true))
              })
            })
          }

          /**
           * @param {string=} opt_host The bound host to test the {@code port} against.
           *     Defaults to {@code INADDR_ANY}.
           * @return {!Promise<number>} A promise that will resolve to a free port. If a
           *     port cannot be found, the promise will be rejected.
           */

          function findFreePort(opt_host) {
            return new Promise((resolve, reject) => {
              const server = net.createServer()
              server.on('listening', function () {
                resolve(server.address().port)
                server.close()
              })
              server.on('error', (e) => {
                if (e.code === 'EADDRINUSE' || e.code === 'EACCES') {
                  resolve('Unable to find a free port')
                } else {
                  reject(e)
                }
              })
              // By providing 0 we let the operative system find an arbitrary port
              server.listen(0, opt_host)
            })
          }

          // PUBLIC API
          module.exports = {
            findFreePort,
            isFree
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/remote/index.js':
        /*!*********************************************************!*\
  !*** ./node_modules/selenium-webdriver/remote/index.js ***!
  \*********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const fs = __webpack_require__(/*! fs */ 'fs')
          const url = __webpack_require__(/*! url */ 'url')

          const httpUtil = __webpack_require__(
            /*! ../http/util */ './node_modules/selenium-webdriver/http/util.js'
          )
          const io = __webpack_require__(
            /*! ../io */ './node_modules/selenium-webdriver/io/index.js'
          )
          const { exec } = __webpack_require__(
            /*! ../io/exec */ './node_modules/selenium-webdriver/io/exec.js'
          )
          const { Zip } = __webpack_require__(
            /*! ../io/zip */ './node_modules/selenium-webdriver/io/zip.js'
          )
          const cmd = __webpack_require__(
            /*! ../lib/command */ './node_modules/selenium-webdriver/lib/command.js'
          )
          const input = __webpack_require__(
            /*! ../lib/input */ './node_modules/selenium-webdriver/lib/input.js'
          )
          const net = __webpack_require__(
            /*! ../net */ './node_modules/selenium-webdriver/net/index.js'
          )
          const portprober = __webpack_require__(
            /*! ../net/portprober */ './node_modules/selenium-webdriver/net/portprober.js'
          )
          const logging = __webpack_require__(
            /*! ../lib/logging */ './node_modules/selenium-webdriver/lib/logging.js'
          )

          const { getJavaPath, formatSpawnArgs } = __webpack_require__(
            /*! ./util */ './node_modules/selenium-webdriver/remote/util.js'
          )

          /**
           * @typedef {(string|!Array<string|number|!stream.Stream|null|undefined>)}
           */
          let StdIoOptions // eslint-disable-line

          /**
           * @typedef {(string|!IThenable<string>)}
           */
          let CommandLineFlag // eslint-disable-line

          /**
           * A record object that defines the configuration options for a DriverService
           * instance.
           *
           * @record
           */
          function ServiceOptions() {}

          /**
           * Whether the service should only be accessed on this host's loopback address.
           *
           * @type {(boolean|undefined)}
           */
          ServiceOptions.prototype.loopback

          /**
           * The host name to access the server on. If this option is specified, the
           * {@link #loopback} option will be ignored.
           *
           * @type {(string|undefined)}
           */
          ServiceOptions.prototype.hostname

          /**
           * The port to start the server on (must be > 0). If the port is provided as a
           * promise, the service will wait for the promise to resolve before starting.
           *
           * @type {(number|!IThenable<number>)}
           */
          ServiceOptions.prototype.port

          /**
           * The arguments to pass to the service. If a promise is provided, the service
           * will wait for it to resolve before starting.
           *
           * @type {!(Array<CommandLineFlag>|IThenable<!Array<CommandLineFlag>>)}
           */
          ServiceOptions.prototype.args

          /**
           * The base path on the server for the WebDriver wire protocol (e.g. '/wd/hub').
           * Defaults to '/'.
           *
           * @type {(string|undefined|null)}
           */
          ServiceOptions.prototype.path

          /**
           * The environment variables that should be visible to the server process.
           * Defaults to inheriting the current process's environment.
           *
           * @type {(Object<string, string>|undefined)}
           */
          ServiceOptions.prototype.env

          /**
           * IO configuration for the spawned server process. For more information, refer
           * to the documentation of `child_process.spawn`.
           *
           * @type {(StdIoOptions|undefined)}
           * @see https://nodejs.org/dist/latest-v4.x/docs/api/child_process.html#child_process_options_stdio
           */
          ServiceOptions.prototype.stdio

          /**
           * Manages the life and death of a native executable WebDriver server.
           *
           * It is expected that the driver server implements the
           * https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol.
           * Furthermore, the managed server should support multiple concurrent sessions,
           * so that this class may be reused for multiple clients.
           */
          class DriverService {
            /**
             * @param {string} executable Path to the executable to run.
             * @param {!ServiceOptions} options Configuration options for the service.
             */
            constructor(executable, options) {
              /** @private @const */
              this.log_ = logging.getLogger('webdriver.DriverService')
              /** @private {string} */
              this.executable_ = executable

              /** @private {boolean} */
              this.loopbackOnly_ = !!options.loopback

              /** @private {(string|undefined)} */
              this.hostname_ = options.hostname

              /** @private {(number|!IThenable<number>)} */
              this.port_ = options.port

              /**
               * @private {!(Array<CommandLineFlag>|
               *             IThenable<!Array<CommandLineFlag>>)}
               */
              this.args_ = options.args

              /** @private {string} */
              this.path_ = options.path || '/'

              /** @private {!Object<string, string>} */
              this.env_ = options.env || process.env

              /**
               * @private {(string|!Array<string|number|!stream.Stream|null|undefined>)}
               */
              this.stdio_ = options.stdio || 'ignore'

              /**
               * A promise for the managed subprocess, or null if the server has not been
               * started yet. This promise will never be rejected.
               * @private {Promise<!exec.Command>}
               */
              this.command_ = null

              /**
               * Promise that resolves to the server's address or null if the server has
               * not been started. This promise will be rejected if the server terminates
               * before it starts accepting WebDriver requests.
               * @private {Promise<string>}
               */
              this.address_ = null
            }

            getExecutable() {
              return this.executable_
            }

            setExecutable(value) {
              this.executable_ = value
            }

            /**
             * @return {!Promise<string>} A promise that resolves to the server's address.
             * @throws {Error} If the server has not been started.
             */
            address() {
              if (this.address_) {
                return this.address_
              }
              throw Error('Server has not been started.')
            }

            /**
             * Returns whether the underlying process is still running. This does not take
             * into account whether the process is in the process of shutting down.
             * @return {boolean} Whether the underlying service process is running.
             */
            isRunning() {
              return !!this.address_
            }

            /**
             * Starts the server if it is not already running.
             * @param {number=} opt_timeoutMs How long to wait, in milliseconds, for the
             *     server to start accepting requests. Defaults to 30 seconds.
             * @return {!Promise<string>} A promise that will resolve to the server's base
             *     URL when it has started accepting requests. If the timeout expires
             *     before the server has started, the promise will be rejected.
             */
            start(opt_timeoutMs) {
              if (this.address_) {
                return this.address_
              }

              const timeout = opt_timeoutMs || DriverService.DEFAULT_START_TIMEOUT_MS
              const self = this

              let resolveCommand
              this.command_ = new Promise((resolve) => (resolveCommand = resolve))

              this.address_ = new Promise((resolveAddress, rejectAddress) => {
                resolveAddress(
                  Promise.resolve(this.port_).then((port) => {
                    if (port <= 0) {
                      throw Error('Port must be > 0: ' + port)
                    }

                    return resolveCommandLineFlags(this.args_).then((args) => {
                      const command = exec(self.executable_, {
                        args: args,
                        env: self.env_,
                        stdio: self.stdio_
                      })

                      resolveCommand(command)

                      const earlyTermination = command.result().then(function (result) {
                        const error =
                          result.code == null
                            ? Error('Server was killed with ' + result.signal)
                            : Error('Server terminated early with status ' + result.code)
                        rejectAddress(error)
                        self.address_ = null
                        self.command_ = null
                        throw error
                      })

                      let hostname = self.hostname_
                      if (!hostname) {
                        hostname =
                          (!self.loopbackOnly_ && net.getAddress()) || net.getLoopbackAddress()
                      }

                      const serverUrl = url.format({
                        protocol: 'http',
                        hostname: hostname,
                        port: port + '',
                        pathname: self.path_
                      })

                      return new Promise((fulfill, reject) => {
                        let cancelToken = earlyTermination.catch((e) => reject(Error(e.message)))

                        httpUtil.waitForServer(serverUrl, timeout, cancelToken).then(
                          (_) => fulfill(serverUrl),
                          (err) => {
                            if (err instanceof httpUtil.CancellationError) {
                              fulfill(serverUrl)
                            } else {
                              reject(err)
                            }
                          }
                        )
                      })
                    })
                  })
                )
              })

              return this.address_
            }

            /**
             * Stops the service if it is not currently running. This function will kill
             * the server immediately. To synchronize with the active control flow, use
             * {@link #stop()}.
             * @return {!Promise} A promise that will be resolved when the server has been
             *     stopped.
             */
            kill() {
              if (!this.address_ || !this.command_) {
                return Promise.resolve() // Not currently running.
              }
              let cmd = this.command_
              this.address_ = null
              this.command_ = null
              return cmd.then((c) => c.kill('SIGTERM'))
            }
          }

          /**
           * @param {!(Array<CommandLineFlag>|IThenable<!Array<CommandLineFlag>>)} args
           * @return {!Promise<!Array<string>>}
           */
          function resolveCommandLineFlags(args) {
            // Resolve the outer array, then the individual flags.
            return Promise.resolve(args).then(
              /** !Array<CommandLineFlag> */ (args) => Promise.all(args)
            )
          }

          /**
           * The default amount of time, in milliseconds, to wait for the server to
           * start.
           * @const {number}
           */
          DriverService.DEFAULT_START_TIMEOUT_MS = 30 * 1000

          /**
           * Creates {@link DriverService} objects that manage a WebDriver server in a
           * child process.
           */
          DriverService.Builder = class {
            /**
             * @param {string} exe Path to the executable to use. This executable must
             *     accept the `--port` flag for defining the port to start the server on.
             * @throws {Error} If the provided executable path does not exist.
             */
            constructor(exe) {
              /** @private @const {string} */
              this.exe_ = exe

              /** @private {!ServiceOptions} */
              this.options_ = {
                args: [],
                port: 0,
                env: null,
                stdio: 'ignore'
              }
            }

            /**
             * Define additional command line arguments to use when starting the server.
             *
             * @param {...CommandLineFlag} var_args The arguments to include.
             * @return {!THIS} A self reference.
             * @this {THIS}
             * @template THIS
             */
            addArguments(...arguments_) {
              this.options_.args = this.options_.args.concat(arguments_)
              return this
            }

            /**
             * Sets the host name to access the server on. If specified, the
             * {@linkplain #setLoopback() loopback} setting will be ignored.
             *
             * @param {string} hostname
             * @return {!DriverService.Builder} A self reference.
             */
            setHostname(hostname) {
              this.options_.hostname = hostname
              return this
            }

            /**
             * Sets whether the service should be accessed at this host's loopback
             * address.
             *
             * @param {boolean} loopback
             * @return {!DriverService.Builder} A self reference.
             */
            setLoopback(loopback) {
              this.options_.loopback = loopback
              return this
            }

            /**
             * Sets the base path for WebDriver REST commands (e.g. "/wd/hub").
             * By default, the driver will accept commands relative to "/".
             *
             * @param {?string} basePath The base path to use, or `null` to use the
             *     default.
             * @return {!DriverService.Builder} A self reference.
             */
            setPath(basePath) {
              this.options_.path = basePath
              return this
            }

            /**
             * Sets the port to start the server on.
             *
             * @param {number} port The port to use, or 0 for any free port.
             * @return {!DriverService.Builder} A self reference.
             * @throws {Error} If an invalid port is specified.
             */
            setPort(port) {
              if (port < 0) {
                throw Error(`port must be >= 0: ${port}`)
              }
              this.options_.port = port
              return this
            }

            /**
             * Defines the environment to start the server under. This setting will be
             * inherited by every browser session started by the server. By default, the
             * server will inherit the enviroment of the current process.
             *
             * @param {(Map<string, string>|Object<string, string>|null)} env The desired
             *     environment to use, or `null` if the server should inherit the
             *     current environment.
             * @return {!DriverService.Builder} A self reference.
             */
            setEnvironment(env) {
              if (env instanceof Map) {
                let tmp = {}
                env.forEach((value, key) => (tmp[key] = value))
                env = tmp
              }
              this.options_.env = env
              return this
            }

            /**
             * IO configuration for the spawned server process. For more information,
             * refer to the documentation of `child_process.spawn`.
             *
             * @param {StdIoOptions} config The desired IO configuration.
             * @return {!DriverService.Builder} A self reference.
             * @see https://nodejs.org/dist/latest-v4.x/docs/api/child_process.html#child_process_options_stdio
             */
            setStdio(config) {
              this.options_.stdio = config
              return this
            }

            /**
             * Creates a new DriverService using this instance's current configuration.
             *
             * @return {!DriverService} A new driver service.
             */
            build() {
              let port = this.options_.port || portprober.findFreePort()
              let args = Promise.resolve(port).then((port) => {
                return this.options_.args.concat('--port=' + port)
              })

              let options =
                /** @type {!ServiceOptions} */
                (Object.assign({}, this.options_, { args, port }))
              return new DriverService(this.exe_, options)
            }
          }

          /**
           * Manages the life and death of the
           * <a href="https://www.selenium.dev/downloads/">
           * standalone Selenium server</a>.
           */
          class SeleniumServer extends DriverService {
            /**
             * @param {string} jar Path to the Selenium server jar.
             * @param {SeleniumServer.Options=} opt_options Configuration options for the
             *     server.
             * @throws {Error} If the path to the Selenium jar is not specified or if an
             *     invalid port is specified.
             */
            constructor(jar, opt_options) {
              if (!jar) {
                throw Error('Path to the Selenium jar not specified')
              }

              const options = opt_options || {}

              if (options.port < 0) {
                throw Error('Port must be >= 0: ' + options.port)
              }

              let port = options.port || portprober.findFreePort()
              let args = Promise.all([port, options.jvmArgs || [], options.args || []]).then(
                (resolved) => {
                  let port = resolved[0]
                  let jvmArgs = resolved[1]
                  let args = resolved[2]

                  const fullArgsList = jvmArgs.concat('-jar', jar, '-port', port).concat(args)

                  return formatSpawnArgs(jar, fullArgsList)
                }
              )

              const java = getJavaPath()

              super(java, {
                loopback: options.loopback,
                port: port,
                args: args,
                path: '/wd/hub',
                env: options.env,
                stdio: options.stdio
              })
            }
          }

          /**
           * A record object describing configuration options for a {@link SeleniumServer}
           * instance.
           *
           * @record
           */
          SeleniumServer.Options = class {
            constructor() {
              /**
               * Whether the server should only be accessible on this host's loopback
               * address.
               *
               * @type {(boolean|undefined)}
               */
              this.loopback

              /**
               * The port to start the server on (must be > 0). If the port is provided as
               * a promise, the service will wait for the promise to resolve before
               * starting.
               *
               * @type {(number|!IThenable<number>)}
               */
              this.port

              /**
               * The arguments to pass to the service. If a promise is provided,
               * the service will wait for it to resolve before starting.
               *
               * @type {!(Array<string>|IThenable<!Array<string>>)}
               */
              this.args

              /**
               * The arguments to pass to the JVM. If a promise is provided,
               * the service will wait for it to resolve before starting.
               *
               * @type {(!Array<string>|!IThenable<!Array<string>>|undefined)}
               */
              this.jvmArgs

              /**
               * The environment variables that should be visible to the server
               * process. Defaults to inheriting the current process's environment.
               *
               * @type {(!Object<string, string>|undefined)}
               */
              this.env

              /**
               * IO configuration for the spawned server process. If unspecified, IO will
               * be ignored.
               *
               * @type {(string|!Array<string|number|!stream.Stream|null|undefined>|
               *         undefined)}
               * @see <https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html#child_process_options_stdio>
               */
              this.stdio
            }
          }

          /**
           * A {@link webdriver.FileDetector} that may be used when running
           * against a remote
           * [Selenium server](https://www.selenium.dev/downloads/).
           *
           * When a file path on the local machine running this script is entered with
           * {@link webdriver.WebElement#sendKeys WebElement#sendKeys}, this file detector
           * will transfer the specified file to the Selenium server's host; the sendKeys
           * command will be updated to use the transferred file's path.
           *
           * __Note:__ This class depends on a non-standard command supported on the
           * Java Selenium server. The file detector will fail if used with a server that
           * only supports standard WebDriver commands (such as the ChromeDriver).
           *
           * @final
           */
          class FileDetector extends input.FileDetector {
            /**
             * Prepares a `file` for use with the remote browser. If the provided path
             * does not reference a normal file (i.e. it does not exist or is a
             * directory), then the promise returned by this method will be resolved with
             * the original file path. Otherwise, this method will upload the file to the
             * remote server, which will return the file's path on the remote system so
             * it may be referenced in subsequent commands.
             *
             * @override
             */
            handleFile(driver, file) {
              return io.stat(file).then(
                function (stats) {
                  if (stats.isDirectory()) {
                    return file // Not a valid file, return original input.
                  }

                  let zip = new Zip()
                  return zip
                    .addFile(file)
                    .then(() => zip.toBuffer())
                    .then((buf) => buf.toString('base64'))
                    .then((encodedZip) => {
                      let command = new cmd.Command(cmd.Name.UPLOAD_FILE).setParameter(
                        'file',
                        encodedZip
                      )
                      return driver.execute(command)
                    })
                },
                function (err) {
                  if (err.code === 'ENOENT') {
                    return file // Not a file; return original input.
                  }
                  throw err
                }
              )
            }
          }

          // PUBLIC API

          module.exports = {
            DriverService,
            FileDetector,
            SeleniumServer,
            // Exported for API docs.
            ServiceOptions
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/remote/util.js':
        /*!********************************************************!*\
  !*** ./node_modules/selenium-webdriver/remote/util.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          const path = __webpack_require__(/*! path */ 'path')
          const cp = __webpack_require__(/*! child_process */ 'child_process')

          /**
           * returns path to java or 'java' string if JAVA_HOME does not exist in env obj
           * @returns {string}
           */
          function getJavaPath() {
            return process.env['JAVA_HOME']
              ? path.join(process.env['JAVA_HOME'], 'bin/java')
              : 'java'
          }

          /**
           * @param {string} seleniumStandalonePath path to standalone server
           * @returns {boolean}
           */
          function isSelenium3x(seleniumStandalonePath) {
            const javaPath = getJavaPath()

            const execRes = cp.execSync(`${javaPath} -jar ${seleniumStandalonePath} --version`)

            return execRes.toString().trim().startsWith('Selenium server version: 3')
          }

          /**
           * @param {string} seleniumStandalonePath path to standalone server
           * @param {Array.<string>} args spawn arguments array
           * returns formatted args based on selenium standalone server version
           * @returns {Array.<string>}
           */
          function formatSpawnArgs(seleniumStandalonePath, args) {
            if (isSelenium3x(seleniumStandalonePath)) {
              console.warn(
                'Deprecation: Support for Standalone Server 3.x will be removed soon. Please update to version 4.x'
              )
              return args
            }

            const standaloneArg = 'standalone'
            const port3xArgFormat = '-port'
            const port4xArgFormat = '--port'

            let formattedArgs = Array.from(args)

            const standaloneArgIndex = formattedArgs.findIndex(
              (arg) => arg === seleniumStandalonePath
            )
            const v3portArgFormat = formattedArgs.findIndex((arg) => arg === port3xArgFormat)

            // old v3x port arg format was -port, new v4x port arg format is --port
            if (v3portArgFormat !== -1) {
              formattedArgs[v3portArgFormat] = port4xArgFormat
            }

            // 'standalone' arg should be right after jar file path
            // in case if it is already in place - returns args
            if (formattedArgs[standaloneArgIndex + 1] === standaloneArg) return formattedArgs

            // insert 'standalone' right after jar file path
            formattedArgs.splice(standaloneArgIndex + 1, 0, standaloneArg)

            return formattedArgs
          }

          // PUBLIC API
          module.exports = {
            getJavaPath,
            isSelenium3x,
            formatSpawnArgs
          }

          /***/
        },

      /***/ './node_modules/selenium-webdriver/safari.js':
        /*!***************************************************!*\
  !*** ./node_modules/selenium-webdriver/safari.js ***!
  \***************************************************/
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
          'use strict'
          // Licensed to the Software Freedom Conservancy (SFC) under one
          // or more contributor license agreements.  See the NOTICE file
          // distributed with this work for additional information
          // regarding copyright ownership.  The SFC licenses this file
          // to you under the Apache License, Version 2.0 (the
          // "License"); you may not use this file except in compliance
          // with the License.  You may obtain a copy of the License at
          //
          //   http://www.apache.org/licenses/LICENSE-2.0
          //
          // Unless required by applicable law or agreed to in writing,
          // software distributed under the License is distributed on an
          // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
          // KIND, either express or implied.  See the License for the
          // specific language governing permissions and limitations
          // under the License.

          /**
           * @fileoverview Defines a WebDriver client for Safari.
           */

          const http = __webpack_require__(
            /*! ./http */ './node_modules/selenium-webdriver/http/index.js'
          )
          const io = __webpack_require__(
            /*! ./io */ './node_modules/selenium-webdriver/io/index.js'
          )
          const remote = __webpack_require__(
            /*! ./remote */ './node_modules/selenium-webdriver/remote/index.js'
          )
          const webdriver = __webpack_require__(
            /*! ./lib/webdriver */ './node_modules/selenium-webdriver/lib/webdriver.js'
          )
          const { Browser, Capabilities } = __webpack_require__(
            /*! ./lib/capabilities */ './node_modules/selenium-webdriver/lib/capabilities.js'
          )

          /**
           * _Synchronously_ attempts to locate the IE driver executable on the current
           * system.
           *
           * @return {?string} the located executable, or `null`.
           */
          function locateSynchronously() {
            return process.platform === 'darwin' ? io.findInPath('safaridriver', true) : null
          }

          /**
           * @return {string} .
           * @throws {Error}
           */
          function findSafariDriver() {
            let exe = locateSynchronously()
            if (!exe) {
              throw Error(
                `The safaridriver executable could not be found on the current PATH.
      Please ensure you are using Safari 10.0 or above.`
              )
            }
            return exe
          }

          /**
           * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
           * a [safaridriver] server in a child process.
           *
           * [safaridriver]: https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html#//apple_ref/doc/uid/TP40014305-CH11-DontLinkElementID_28
           */
          class ServiceBuilder extends remote.DriverService.Builder {
            /**
             * @param {string=} opt_exe Path to the server executable to use. If omitted,
             *     the builder will attempt to locate the safaridriver on the system PATH.
             */
            constructor(opt_exe) {
              super(opt_exe || findSafariDriver())
              this.setLoopback(true) // Required.
            }
          }

          const OPTIONS_CAPABILITY_KEY = 'safari.options'
          const TECHNOLOGY_PREVIEW_OPTIONS_KEY = 'technologyPreview'

          /**
           * Configuration options specific to the {@link Driver SafariDriver}.
           */
          class Options extends Capabilities {
            /**
             * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of
             *     capabilities to initialize this instance from.
             */
            constructor(other = undefined) {
              super(other)

              /** @private {!Object} */
              this.options_ = this.get(OPTIONS_CAPABILITY_KEY) || {}

              this.set(OPTIONS_CAPABILITY_KEY, this.options_)
              this.setBrowserName(Browser.SAFARI)
            }

            /**
             * Instruct the SafariDriver to use the Safari Technology Preview if true.
             * Otherwise, use the release version of Safari. Defaults to using the release version of Safari.
             *
             * @param {boolean} useTechnologyPreview
             * @return {!Options} A self reference.
             */
            setTechnologyPreview(useTechnologyPreview) {
              this.options_[TECHNOLOGY_PREVIEW_OPTIONS_KEY] = !!useTechnologyPreview
              return this
            }
          }

          /**
           * @param  {(Capabilities|Object<string, *>)=} o The options object
           * @return {boolean}
           */
          function useTechnologyPreview(o) {
            if (o instanceof Capabilities) {
              let options = o.get(OPTIONS_CAPABILITY_KEY)
              return !!(options && options[TECHNOLOGY_PREVIEW_OPTIONS_KEY])
            }

            if (o && typeof o === 'object') {
              return !!o[TECHNOLOGY_PREVIEW_OPTIONS_KEY]
            }

            return false
          }

          const SAFARIDRIVER_TECHNOLOGY_PREVIEW_EXE =
            '/Applications/Safari Technology Preview.app/Contents/MacOS/safaridriver'

          /**
           * A WebDriver client for Safari. This class should never be instantiated
           * directly; instead, use the {@linkplain ./builder.Builder Builder}:
           *
           *     var driver = new Builder()
           *         .forBrowser('safari')
           *         .build();
           *
           */
          class Driver extends webdriver.WebDriver {
            /**
             * Creates a new Safari session.
             *
             * @param {(Options|Capabilities)=} options The configuration options.
             * @return {!Driver} A new driver instance.
             */
            static createSession(options) {
              let caps = options || new Options()

              let exe
              if (useTechnologyPreview(caps.get(OPTIONS_CAPABILITY_KEY))) {
                exe = SAFARIDRIVER_TECHNOLOGY_PREVIEW_EXE
              }

              let service = new ServiceBuilder(exe).build()
              let executor = new http.Executor(
                service.start().then((url) => new http.HttpClient(url))
              )

              return /** @type {!Driver} */ (
                super.createSession(executor, caps, () => service.kill())
              )
            }
          }

          // Public API

          exports.Driver = Driver
          exports.Options = Options
          exports.ServiceBuilder = ServiceBuilder
          exports.locateSynchronously = locateSynchronously

          /***/
        },

      /***/ './node_modules/setimmediate/setImmediate.js':
        /*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
        /***/ function () {
          ;(function (global, undefined) {
            'use strict'

            if (global.setImmediate) {
              return
            }

            var nextHandle = 1 // Spec says greater than zero
            var tasksByHandle = {}
            var currentlyRunningATask = false
            var doc = global.document
            var registerImmediate

            function setImmediate(callback) {
              // Callback can either be a function or a string
              if (typeof callback !== 'function') {
                callback = new Function('' + callback)
              }
              // Copy function arguments
              var args = new Array(arguments.length - 1)
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i + 1]
              }
              // Store and register the task
              var task = { callback: callback, args: args }
              tasksByHandle[nextHandle] = task
              registerImmediate(nextHandle)
              return nextHandle++
            }

            function clearImmediate(handle) {
              delete tasksByHandle[handle]
            }

            function run(task) {
              var callback = task.callback
              var args = task.args
              switch (args.length) {
                case 0:
                  callback()
                  break
                case 1:
                  callback(args[0])
                  break
                case 2:
                  callback(args[0], args[1])
                  break
                case 3:
                  callback(args[0], args[1], args[2])
                  break
                default:
                  callback.apply(undefined, args)
                  break
              }
            }

            function runIfPresent(handle) {
              // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
              // So if we're currently running a task, we'll need to delay this invocation.
              if (currentlyRunningATask) {
                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                // "too much recursion" error.
                setTimeout(runIfPresent, 0, handle)
              } else {
                var task = tasksByHandle[handle]
                if (task) {
                  currentlyRunningATask = true
                  try {
                    run(task)
                  } finally {
                    clearImmediate(handle)
                    currentlyRunningATask = false
                  }
                }
              }
            }

            function installNextTickImplementation() {
              registerImmediate = function (handle) {
                process.nextTick(function () {
                  runIfPresent(handle)
                })
              }
            }

            function canUsePostMessage() {
              // The test against `importScripts` prevents this implementation from being installed inside a web worker,
              // where `global.postMessage` means something completely different and can't be used for this purpose.
              if (global.postMessage && !global.importScripts) {
                var postMessageIsAsynchronous = true
                var oldOnMessage = global.onmessage
                global.onmessage = function () {
                  postMessageIsAsynchronous = false
                }
                global.postMessage('', '*')
                global.onmessage = oldOnMessage
                return postMessageIsAsynchronous
              }
            }

            function installPostMessageImplementation() {
              // Installs an event handler on `global` for the `message` event: see
              // * https://developer.mozilla.org/en/DOM/window.postMessage
              // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

              var messagePrefix = 'setImmediate$' + Math.random() + '$'
              var onGlobalMessage = function (event) {
                if (
                  event.source === global &&
                  typeof event.data === 'string' &&
                  event.data.indexOf(messagePrefix) === 0
                ) {
                  runIfPresent(+event.data.slice(messagePrefix.length))
                }
              }

              if (global.addEventListener) {
                global.addEventListener('message', onGlobalMessage, false)
              } else {
                global.attachEvent('onmessage', onGlobalMessage)
              }

              registerImmediate = function (handle) {
                global.postMessage(messagePrefix + handle, '*')
              }
            }

            function installMessageChannelImplementation() {
              var channel = new MessageChannel()
              channel.port1.onmessage = function (event) {
                var handle = event.data
                runIfPresent(handle)
              }

              registerImmediate = function (handle) {
                channel.port2.postMessage(handle)
              }
            }

            function installReadyStateChangeImplementation() {
              var html = doc.documentElement
              registerImmediate = function (handle) {
                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                var script = doc.createElement('script')
                script.onreadystatechange = function () {
                  runIfPresent(handle)
                  script.onreadystatechange = null
                  html.removeChild(script)
                  script = null
                }
                html.appendChild(script)
              }
            }

            function installSetTimeoutImplementation() {
              registerImmediate = function (handle) {
                setTimeout(runIfPresent, 0, handle)
              }
            }

            // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
            var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global)
            attachTo = attachTo && attachTo.setTimeout ? attachTo : global

            // Don't get fooled by e.g. browserify environments.
            if ({}.toString.call(global.process) === '[object process]') {
              // For Node.js before 0.9
              installNextTickImplementation()
            } else if (canUsePostMessage()) {
              // For non-IE10 modern browsers
              installPostMessageImplementation()
            } else if (global.MessageChannel) {
              // For web workers, where supported
              installMessageChannelImplementation()
            } else if (doc && 'onreadystatechange' in doc.createElement('script')) {
              // For IE 6–8
              installReadyStateChangeImplementation()
            } else {
              // For older browsers
              installSetTimeoutImplementation()
            }

            attachTo.setImmediate = setImmediate
            attachTo.clearImmediate = clearImmediate
          })(typeof self === 'undefined' ? (typeof global === 'undefined' ? this : global) : self)

          /***/
        },

      /***/ './node_modules/tmp/lib/tmp.js':
        /*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          /*!
           * Tmp
           *
           * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
           *
           * MIT Licensed
           */

          /*
           * Module dependencies.
           */
          const fs = __webpack_require__(/*! fs */ 'fs')
          const os = __webpack_require__(/*! os */ 'os')
          const path = __webpack_require__(/*! path */ 'path')
          const crypto = __webpack_require__(/*! crypto */ 'crypto')
          const _c = { fs: fs.constants, os: os.constants }
          const rimraf = __webpack_require__(/*! rimraf */ './node_modules/rimraf/rimraf.js')

          /*
           * The working inner variables.
           */
          const // the random characters to choose from
            RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
            TEMPLATE_PATTERN = /XXXXXX/,
            DEFAULT_TRIES = 3,
            CREATE_FLAGS =
              (_c.O_CREAT || _c.fs.O_CREAT) |
              (_c.O_EXCL || _c.fs.O_EXCL) |
              (_c.O_RDWR || _c.fs.O_RDWR),
            // constants are off on the windows platform and will not match the actual errno codes
            IS_WIN32 = os.platform() === 'win32',
            EBADF = _c.EBADF || _c.os.errno.EBADF,
            ENOENT = _c.ENOENT || _c.os.errno.ENOENT,
            DIR_MODE = 0o700 /* 448 */,
            FILE_MODE = 0o600 /* 384 */,
            EXIT = 'exit',
            // this will hold the objects need to be removed on exit
            _removeObjects = [],
            // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
            FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),
            FN_RIMRAF_SYNC = rimraf.sync

          let _gracefulCleanup = false

          /**
           * Gets a temporary file name.
           *
           * @param {(Options|tmpNameCallback)} options options or callback
           * @param {?tmpNameCallback} callback the callback function
           */
          function tmpName(options, callback) {
            const args = _parseArguments(options, callback),
              opts = args[0],
              cb = args[1]

            try {
              _assertAndSanitizeOptions(opts)
            } catch (err) {
              return cb(err)
            }

            let tries = opts.tries
            ;(function _getUniqueName() {
              try {
                const name = _generateTmpName(opts)

                // check whether the path exists then retry if needed
                fs.stat(name, function (err) {
                  /* istanbul ignore else */
                  if (!err) {
                    /* istanbul ignore else */
                    if (tries-- > 0) return _getUniqueName()

                    return cb(
                      new Error('Could not get a unique tmp filename, max tries reached ' + name)
                    )
                  }

                  cb(null, name)
                })
              } catch (err) {
                cb(err)
              }
            })()
          }

          /**
           * Synchronous version of tmpName.
           *
           * @param {Object} options
           * @returns {string} the generated random name
           * @throws {Error} if the options are invalid or could not generate a filename
           */
          function tmpNameSync(options) {
            const args = _parseArguments(options),
              opts = args[0]

            _assertAndSanitizeOptions(opts)

            let tries = opts.tries
            do {
              const name = _generateTmpName(opts)
              try {
                fs.statSync(name)
              } catch (e) {
                return name
              }
            } while (tries-- > 0)

            throw new Error('Could not get a unique tmp filename, max tries reached')
          }

          /**
           * Creates and opens a temporary file.
           *
           * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
           * @param {?fileCallback} callback
           */
          function file(options, callback) {
            const args = _parseArguments(options, callback),
              opts = args[0],
              cb = args[1]

            // gets a temporary filename
            tmpName(opts, function _tmpNameCreated(err, name) {
              /* istanbul ignore else */
              if (err) return cb(err)

              // create and open the file
              fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
                /* istanbu ignore else */
                if (err) return cb(err)

                if (opts.discardDescriptor) {
                  return fs.close(fd, function _discardCallback(possibleErr) {
                    // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
                    return cb(
                      possibleErr,
                      name,
                      undefined,
                      _prepareTmpFileRemoveCallback(name, -1, opts, false)
                    )
                  })
                } else {
                  // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
                  // about the descriptor
                  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor
                  cb(
                    null,
                    name,
                    fd,
                    _prepareTmpFileRemoveCallback(
                      name,
                      discardOrDetachDescriptor ? -1 : fd,
                      opts,
                      false
                    )
                  )
                }
              })
            })
          }

          /**
           * Synchronous version of file.
           *
           * @param {Options} options
           * @returns {FileSyncObject} object consists of name, fd and removeCallback
           * @throws {Error} if cannot create a file
           */
          function fileSync(options) {
            const args = _parseArguments(options),
              opts = args[0]

            const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor
            const name = tmpNameSync(opts)
            var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE)
            /* istanbul ignore else */
            if (opts.discardDescriptor) {
              fs.closeSync(fd)
              fd = undefined
            }

            return {
              name: name,
              fd: fd,
              removeCallback: _prepareTmpFileRemoveCallback(
                name,
                discardOrDetachDescriptor ? -1 : fd,
                opts,
                true
              )
            }
          }

          /**
           * Creates a temporary directory.
           *
           * @param {(Options|dirCallback)} options the options or the callback function
           * @param {?dirCallback} callback
           */
          function dir(options, callback) {
            const args = _parseArguments(options, callback),
              opts = args[0],
              cb = args[1]

            // gets a temporary filename
            tmpName(opts, function _tmpNameCreated(err, name) {
              /* istanbul ignore else */
              if (err) return cb(err)

              // create the directory
              fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
                /* istanbul ignore else */
                if (err) return cb(err)

                cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false))
              })
            })
          }

          /**
           * Synchronous version of dir.
           *
           * @param {Options} options
           * @returns {DirSyncObject} object consists of name and removeCallback
           * @throws {Error} if it cannot create a directory
           */
          function dirSync(options) {
            const args = _parseArguments(options),
              opts = args[0]

            const name = tmpNameSync(opts)
            fs.mkdirSync(name, opts.mode || DIR_MODE)

            return {
              name: name,
              removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
            }
          }

          /**
           * Removes files asynchronously.
           *
           * @param {Object} fdPath
           * @param {Function} next
           * @private
           */
          function _removeFileAsync(fdPath, next) {
            const _handler = function (err) {
              if (err && !_isENOENT(err)) {
                // reraise any unanticipated error
                return next(err)
              }
              next()
            }

            if (0 <= fdPath[0])
              fs.close(fdPath[0], function () {
                fs.unlink(fdPath[1], _handler)
              })
            else fs.unlink(fdPath[1], _handler)
          }

          /**
           * Removes files synchronously.
           *
           * @param {Object} fdPath
           * @private
           */
          function _removeFileSync(fdPath) {
            let rethrownException = null
            try {
              if (0 <= fdPath[0]) fs.closeSync(fdPath[0])
            } catch (e) {
              // reraise any unanticipated error
              if (!_isEBADF(e) && !_isENOENT(e)) throw e
            } finally {
              try {
                fs.unlinkSync(fdPath[1])
              } catch (e) {
                // reraise any unanticipated error
                if (!_isENOENT(e)) rethrownException = e
              }
            }
            if (rethrownException !== null) {
              throw rethrownException
            }
          }

          /**
           * Prepares the callback for removal of the temporary file.
           *
           * Returns either a sync callback or a async callback depending on whether
           * fileSync or file was called, which is expressed by the sync parameter.
           *
           * @param {string} name the path of the file
           * @param {number} fd file descriptor
           * @param {Object} opts
           * @param {boolean} sync
           * @returns {fileCallback | fileCallbackSync}
           * @private
           */
          function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
            const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync)
            const removeCallback = _prepareRemoveCallback(
              _removeFileAsync,
              [fd, name],
              sync,
              removeCallbackSync
            )

            if (!opts.keep) _removeObjects.unshift(removeCallbackSync)

            return sync ? removeCallbackSync : removeCallback
          }

          /**
           * Prepares the callback for removal of the temporary directory.
           *
           * Returns either a sync callback or a async callback depending on whether
           * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
           *
           * @param {string} name
           * @param {Object} opts
           * @param {boolean} sync
           * @returns {Function} the callback
           * @private
           */
          function _prepareTmpDirRemoveCallback(name, opts, sync) {
            const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs)
            const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC
            const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync)
            const removeCallback = _prepareRemoveCallback(
              removeFunction,
              name,
              sync,
              removeCallbackSync
            )
            if (!opts.keep) _removeObjects.unshift(removeCallbackSync)

            return sync ? removeCallbackSync : removeCallback
          }

          /**
           * Creates a guarded function wrapping the removeFunction call.
           *
           * The cleanup callback is save to be called multiple times.
           * Subsequent invocations will be ignored.
           *
           * @param {Function} removeFunction
           * @param {string} fileOrDirName
           * @param {boolean} sync
           * @param {cleanupCallbackSync?} cleanupCallbackSync
           * @returns {cleanupCallback | cleanupCallbackSync}
           * @private
           */
          function _prepareRemoveCallback(
            removeFunction,
            fileOrDirName,
            sync,
            cleanupCallbackSync
          ) {
            let called = false

            // if sync is true, the next parameter will be ignored
            return function _cleanupCallback(next) {
              /* istanbul ignore else */
              if (!called) {
                // remove cleanupCallback from cache
                const toRemove = cleanupCallbackSync || _cleanupCallback
                const index = _removeObjects.indexOf(toRemove)
                /* istanbul ignore else */
                if (index >= 0) _removeObjects.splice(index, 1)

                called = true
                if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
                  return removeFunction(fileOrDirName)
                } else {
                  return removeFunction(fileOrDirName, next || function () {})
                }
              }
            }
          }

          /**
           * The garbage collector.
           *
           * @private
           */
          function _garbageCollector() {
            /* istanbul ignore else */
            if (!_gracefulCleanup) return

            // the function being called removes itself from _removeObjects,
            // loop until _removeObjects is empty
            while (_removeObjects.length) {
              try {
                _removeObjects[0]()
              } catch (e) {
                // already removed?
              }
            }
          }

          /**
           * Random name generator based on crypto.
           * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
           *
           * @param {number} howMany
           * @returns {string} the generated random name
           * @private
           */
          function _randomChars(howMany) {
            let value = [],
              rnd = null

            // make sure that we do not fail because we ran out of entropy
            try {
              rnd = crypto.randomBytes(howMany)
            } catch (e) {
              rnd = crypto.pseudoRandomBytes(howMany)
            }

            for (var i = 0; i < howMany; i++) {
              value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length])
            }

            return value.join('')
          }

          /**
           * Helper which determines whether a string s is blank, that is undefined, or empty or null.
           *
           * @private
           * @param {string} s
           * @returns {Boolean} true whether the string s is blank, false otherwise
           */
          function _isBlank(s) {
            return s === null || _isUndefined(s) || !s.trim()
          }

          /**
           * Checks whether the `obj` parameter is defined or not.
           *
           * @param {Object} obj
           * @returns {boolean} true if the object is undefined
           * @private
           */
          function _isUndefined(obj) {
            return typeof obj === 'undefined'
          }

          /**
           * Parses the function arguments.
           *
           * This function helps to have optional arguments.
           *
           * @param {(Options|null|undefined|Function)} options
           * @param {?Function} callback
           * @returns {Array} parsed arguments
           * @private
           */
          function _parseArguments(options, callback) {
            /* istanbul ignore else */
            if (typeof options === 'function') {
              return [{}, options]
            }

            /* istanbul ignore else */
            if (_isUndefined(options)) {
              return [{}, callback]
            }

            // copy options so we do not leak the changes we make internally
            const actualOptions = {}
            for (const key of Object.getOwnPropertyNames(options)) {
              actualOptions[key] = options[key]
            }

            return [actualOptions, callback]
          }

          /**
           * Generates a new temporary name.
           *
           * @param {Object} opts
           * @returns {string} the new random name according to opts
           * @private
           */
          function _generateTmpName(opts) {
            const tmpDir = opts.tmpdir

            /* istanbul ignore else */
            if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name)

            /* istanbul ignore else */
            if (!_isUndefined(opts.template))
              return path
                .join(tmpDir, opts.dir, opts.template)
                .replace(TEMPLATE_PATTERN, _randomChars(6))

            // prefix and postfix
            const name = [
              opts.prefix ? opts.prefix : 'tmp',
              '-',
              process.pid,
              '-',
              _randomChars(12),
              opts.postfix ? '-' + opts.postfix : ''
            ].join('')

            return path.join(tmpDir, opts.dir, name)
          }

          /**
           * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
           * options.
           *
           * @param {Options} options
           * @private
           */
          function _assertAndSanitizeOptions(options) {
            options.tmpdir = _getTmpDir(options)

            const tmpDir = options.tmpdir

            /* istanbul ignore else */
            if (!_isUndefined(options.name)) _assertIsRelative(options.name, 'name', tmpDir)
            /* istanbul ignore else */
            if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, 'dir', tmpDir)
            /* istanbul ignore else */
            if (!_isUndefined(options.template)) {
              _assertIsRelative(options.template, 'template', tmpDir)
              if (!options.template.match(TEMPLATE_PATTERN))
                throw new Error(`Invalid template, found "${options.template}".`)
            }
            /* istanbul ignore else */
            if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0)
              throw new Error(`Invalid tries, found "${options.tries}".`)

            // if a name was specified we will try once
            options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1
            options.keep = !!options.keep
            options.detachDescriptor = !!options.detachDescriptor
            options.discardDescriptor = !!options.discardDescriptor
            options.unsafeCleanup = !!options.unsafeCleanup

            // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
            options.dir = _isUndefined(options.dir)
              ? ''
              : path.relative(tmpDir, _resolvePath(options.dir, tmpDir))
            options.template = _isUndefined(options.template)
              ? undefined
              : path.relative(tmpDir, _resolvePath(options.template, tmpDir))
            // sanitize further if template is relative to options.dir
            options.template = _isBlank(options.template)
              ? undefined
              : path.relative(options.dir, options.template)

            // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
            options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name)
            options.prefix = _isUndefined(options.prefix) ? '' : options.prefix
            options.postfix = _isUndefined(options.postfix) ? '' : options.postfix
          }

          /**
           * Resolve the specified path name in respect to tmpDir.
           *
           * The specified name might include relative path components, e.g. ../
           * so we need to resolve in order to be sure that is is located inside tmpDir
           *
           * @param name
           * @param tmpDir
           * @returns {string}
           * @private
           */
          function _resolvePath(name, tmpDir) {
            const sanitizedName = _sanitizeName(name)
            if (sanitizedName.startsWith(tmpDir)) {
              return path.resolve(sanitizedName)
            } else {
              return path.resolve(path.join(tmpDir, sanitizedName))
            }
          }

          /**
           * Sanitize the specified path name by removing all quote characters.
           *
           * @param name
           * @returns {string}
           * @private
           */
          function _sanitizeName(name) {
            if (_isBlank(name)) {
              return name
            }
            return name.replace(/["']/g, '')
          }

          /**
           * Asserts whether specified name is relative to the specified tmpDir.
           *
           * @param {string} name
           * @param {string} option
           * @param {string} tmpDir
           * @throws {Error}
           * @private
           */
          function _assertIsRelative(name, option, tmpDir) {
            if (option === 'name') {
              // assert that name is not absolute and does not contain a path
              if (path.isAbsolute(name))
                throw new Error(
                  `${option} option must not contain an absolute path, found "${name}".`
                )
              // must not fail on valid .<name> or ..<name> or similar such constructs
              let basename = path.basename(name)
              if (basename === '..' || basename === '.' || basename !== name)
                throw new Error(`${option} option must not contain a path, found "${name}".`)
            } else {
              // if (option === 'dir' || option === 'template') {
              // assert that dir or template are relative to tmpDir
              if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
                throw new Error(
                  `${option} option must be relative to "${tmpDir}", found "${name}".`
                )
              }
              let resolvedPath = _resolvePath(name, tmpDir)
              if (!resolvedPath.startsWith(tmpDir))
                throw new Error(
                  `${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`
                )
            }
          }

          /**
           * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
           *
           * @private
           */
          function _isEBADF(error) {
            return _isExpectedError(error, -EBADF, 'EBADF')
          }

          /**
           * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
           *
           * @private
           */
          function _isENOENT(error) {
            return _isExpectedError(error, -ENOENT, 'ENOENT')
          }

          /**
           * Helper to determine whether the expected error code matches the actual code and errno,
           * which will differ between the supported node versions.
           *
           * - Node >= 7.0:
           *   error.code {string}
           *   error.errno {number} any numerical value will be negated
           *
           * CAVEAT
           *
           * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
           * is no different here.
           *
           * @param {SystemError} error
           * @param {number} errno
           * @param {string} code
           * @private
           */
          function _isExpectedError(error, errno, code) {
            return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno
          }

          /**
           * Sets the graceful cleanup.
           *
           * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
           * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
           * object removals.
           */
          function setGracefulCleanup() {
            _gracefulCleanup = true
          }

          /**
           * Returns the currently configured tmp dir from os.tmpdir().
           *
           * @private
           * @param {?Options} options
           * @returns {string} the currently configured tmp dir
           */
          function _getTmpDir(options) {
            return path.resolve(_sanitizeName((options && options.tmpdir) || os.tmpdir()))
          }

          // Install process exit listener
          process.addListener(EXIT, _garbageCollector)

          /**
           * Configuration options.
           *
           * @typedef {Object} Options
           * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
           * @property {?number} tries the number of tries before give up the name generation
           * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
           * @property {?string} template the "mkstemp" like filename template
           * @property {?string} name fixed name relative to tmpdir or the specified dir option
           * @property {?string} dir tmp directory relative to the root tmp directory in use
           * @property {?string} prefix prefix for the generated name
           * @property {?string} postfix postfix for the generated name
           * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
           * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
           * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
           * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
           */

          /**
           * @typedef {Object} FileSyncObject
           * @property {string} name the name of the file
           * @property {string} fd the file descriptor or -1 if the fd has been discarded
           * @property {fileCallback} removeCallback the callback function to remove the file
           */

          /**
           * @typedef {Object} DirSyncObject
           * @property {string} name the name of the directory
           * @property {fileCallback} removeCallback the callback function to remove the directory
           */

          /**
           * @callback tmpNameCallback
           * @param {?Error} err the error object if anything goes wrong
           * @param {string} name the temporary file name
           */

          /**
           * @callback fileCallback
           * @param {?Error} err the error object if anything goes wrong
           * @param {string} name the temporary file name
           * @param {number} fd the file descriptor or -1 if the fd had been discarded
           * @param {cleanupCallback} fn the cleanup callback function
           */

          /**
           * @callback fileCallbackSync
           * @param {?Error} err the error object if anything goes wrong
           * @param {string} name the temporary file name
           * @param {number} fd the file descriptor or -1 if the fd had been discarded
           * @param {cleanupCallbackSync} fn the cleanup callback function
           */

          /**
           * @callback dirCallback
           * @param {?Error} err the error object if anything goes wrong
           * @param {string} name the temporary file name
           * @param {cleanupCallback} fn the cleanup callback function
           */

          /**
           * @callback dirCallbackSync
           * @param {?Error} err the error object if anything goes wrong
           * @param {string} name the temporary file name
           * @param {cleanupCallbackSync} fn the cleanup callback function
           */

          /**
           * Removes the temporary created file or directory.
           *
           * @callback cleanupCallback
           * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
           */

          /**
           * Removes the temporary created file or directory.
           *
           * @callback cleanupCallbackSync
           */

          /**
           * Callback function for function composition.
           * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
           *
           * @callback simpleCallback
           */

          // exporting all the needed methods

          // evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
          // allow users to reconfigure the temporary directory
          Object.defineProperty(module.exports, 'tmpdir', {
            enumerable: true,
            configurable: false,
            get: function () {
              return _getTmpDir()
            }
          })

          module.exports.dir = dir
          module.exports.dirSync = dirSync

          module.exports.file = file
          module.exports.fileSync = fileSync

          module.exports.tmpName = tmpName
          module.exports.tmpNameSync = tmpNameSync

          module.exports.setGracefulCleanup = setGracefulCleanup

          /***/
        },

      /***/ './node_modules/util-deprecate/node.js':
        /*!*********************************************!*\
  !*** ./node_modules/util-deprecate/node.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
          /**
           * For Node.js, simply re-export the core `util.deprecate` function.
           */

          module.exports = __webpack_require__(/*! util */ 'util').deprecate

          /***/
        },

      /***/ './node_modules/wrappy/wrappy.js':
        /*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
        /***/ (module) => {
          // Returns a wrapper function that returns a wrapped callback
          // The wrapper function should do some stuff, and return a
          // presumably different callback function.
          // This makes sure that own properties are retained, so that
          // decorations and such are not lost along the way.
          module.exports = wrappy
          function wrappy(fn, cb) {
            if (fn && cb) return wrappy(fn)(cb)

            if (typeof fn !== 'function') throw new TypeError('need wrapper function')

            Object.keys(fn).forEach(function (k) {
              wrapper[k] = fn[k]
            })

            return wrapper

            function wrapper() {
              var args = new Array(arguments.length)
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i]
              }
              var ret = fn.apply(this, args)
              var cb = args[args.length - 1]
              if (typeof ret === 'function' && ret !== cb) {
                Object.keys(cb).forEach(function (k) {
                  ret[k] = cb[k]
                })
              }
              return ret
            }
          }

          /***/
        },

      /***/ './node_modules/ws/browser.js':
        /*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
        /***/ (module) => {
          'use strict'

          module.exports = function () {
            throw new Error(
              'ws does not work in the browser. Browser clients must use the native ' +
                'WebSocket object'
            )
          }

          /***/
        },

      /***/ assert:
        /*!*************************!*\
  !*** external "assert" ***!
  \*************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('assert')

          /***/
        },

      /***/ buffer:
        /*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('buffer')

          /***/
        },

      /***/ child_process:
        /*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('child_process')

          /***/
        },

      /***/ crypto:
        /*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('crypto')

          /***/
        },

      /***/ electron:
        /*!***************************!*\
  !*** external "electron" ***!
  \***************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('electron')

          /***/
        },

      /***/ events:
        /*!*************************!*\
  !*** external "events" ***!
  \*************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('events')

          /***/
        },

      /***/ fs:
        /*!*********************!*\
  !*** external "fs" ***!
  \*********************/
        /***/ (module) => {
          'use strict'
          module.exports = require('fs')

          /***/
        },

      /***/ http:
        /*!***********************!*\
  !*** external "http" ***!
  \***********************/
        /***/ (module) => {
          'use strict'
          module.exports = require('http')

          /***/
        },

      /***/ https:
        /*!************************!*\
  !*** external "https" ***!
  \************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('https')

          /***/
        },

      /***/ net:
        /*!**********************!*\
  !*** external "net" ***!
  \**********************/
        /***/ (module) => {
          'use strict'
          module.exports = require('net')

          /***/
        },

      /***/ 'node:events':
        /*!******************************!*\
  !*** external "node:events" ***!
  \******************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('node:events')

          /***/
        },

      /***/ os:
        /*!*********************!*\
  !*** external "os" ***!
  \*********************/
        /***/ (module) => {
          'use strict'
          module.exports = require('os')

          /***/
        },

      /***/ path:
        /*!***********************!*\
  !*** external "path" ***!
  \***********************/
        /***/ (module) => {
          'use strict'
          module.exports = require('path')

          /***/
        },

      /***/ process:
        /*!**************************!*\
  !*** external "process" ***!
  \**************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('process')

          /***/
        },

      /***/ stream:
        /*!*************************!*\
  !*** external "stream" ***!
  \*************************/
        /***/ (module) => {
          'use strict'
          module.exports = require('stream')

          /***/
        },

      /***/ url:
        /*!**********************!*\
  !*** external "url" ***!
  \**********************/
        /***/ (module) => {
          'use strict'
          module.exports = require('url')

          /***/
        },

      /***/ util:
        /*!***********************!*\
  !*** external "util" ***!
  \***********************/
        /***/ (module) => {
          'use strict'
          module.exports = require('util')

          /***/
        },

      /***/ './node_modules/selenium-webdriver/package.json':
        /*!******************************************************!*\
  !*** ./node_modules/selenium-webdriver/package.json ***!
  \******************************************************/
        /***/ (module) => {
          'use strict'
          module.exports = JSON.parse(
            '{"name":"selenium-webdriver","version":"4.10.0","description":"The official WebDriver JavaScript bindings from the Selenium project","license":"Apache-2.0","keywords":["automation","selenium","testing","webdriver","webdriverjs"],"homepage":"https://github.com/SeleniumHQ/selenium/tree/trunk/javascript/node/selenium-webdriver#readme","bugs":{"url":"https://github.com/SeleniumHQ/selenium/issues"},"main":"./index","repository":{"type":"git","url":"https://github.com/SeleniumHQ/selenium.git"},"engines":{"node":">= 14.20.0"},"dependencies":{"jszip":"^3.10.1","tmp":"^0.2.1","ws":">=8.13.0"},"devDependencies":{"eslint":"^8.41.0","eslint-config-prettier":"^8.8.0","eslint-plugin-no-only-tests":"^3.1.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","express":"^4.18.2","mocha":"^10.2.0","multer":"^1.4.5-lts.1","prettier":"^2.8.8","serve-index":"^1.9.1","sinon":"^15.1.0"},"scripts":{"lint":"eslint --ignore-pattern node_modules --ignore-pattern generator --ext js lib/http.js \\"**/*.js\\"","test":"npm run lint && mocha -t 600000 --recursive test","test-jasmine":"bazel test //javascript/node/selenium-webdriver:tests"},"mocha":{"recursive":true,"timeout":600000}}'
          )

          /***/
        }

      /******/
    }
    /************************************************************************/
    /******/ // The module cache
    /******/ var __webpack_module_cache__ = {}
    /******/
    /******/ // The require function
    /******/ function __webpack_require__(moduleId) {
      /******/ // Check if module is in cache
      /******/ var cachedModule = __webpack_module_cache__[moduleId]
      /******/ if (cachedModule !== undefined) {
        /******/ return cachedModule.exports
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/ var module = (__webpack_module_cache__[moduleId] = {
        /******/ // no module.id needed
        /******/ // no module.loaded needed
        /******/ exports: {}
        /******/
      })
      /******/
      /******/ // Execute the module function
      /******/ __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      )
      /******/
      /******/ // Return the exports of the module
      /******/ return module.exports
      /******/
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/ ;(() => {
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/ __webpack_require__.n = (module) => {
        /******/ var getter =
          module && module.__esModule ? /******/ () => module['default'] : /******/ () => module
        /******/ __webpack_require__.d(getter, { a: getter })
        /******/ return getter
        /******/
      }
      /******/
    })() /* webpack/runtime/define property getters */
    /******/
    /******/
    /******/
    ;(() => {
      /******/ // define getter functions for harmony exports
      /******/ __webpack_require__.d = (exports, definition) => {
        /******/ for (var key in definition) {
          /******/ if (
            __webpack_require__.o(definition, key) &&
            !__webpack_require__.o(exports, key)
          ) {
            /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] })
            /******/
          }
          /******/
        }
        /******/
      }
      /******/
    })() /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    /******/
    /******/
    ;(() => {
      /******/ __webpack_require__.o = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop)
      /******/
    })() /* webpack/runtime/make namespace object */
    /******/
    /******/
    /******/
    ;(() => {
      /******/ // define __esModule on exports
      /******/ __webpack_require__.r = (exports) => {
        /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' })
          /******/
        }
        /******/ Object.defineProperty(exports, '__esModule', { value: true })
        /******/
      }
      /******/
    })()
    /******/
    /************************************************************************/
    var __webpack_exports__ = {}
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    ;(() => {
      'use strict'
      /*!*****************************!*\
  !*** ./src/main/preload.ts ***!
  \*****************************/
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! electron */ 'electron'
      )
      /* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default =
        /*#__PURE__*/ __webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__)
      /* harmony import */ var selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__ =
        __webpack_require__(/*! selenium-webdriver */ './node_modules/selenium-webdriver/index.js')
      /* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ 'fs')
      /* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default =
        /*#__PURE__*/ __webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__)

      const log = (message) => {
        console.log(message)
        electron__WEBPACK_IMPORTED_MODULE_0__.ipcRenderer.send('ipc-example', [message])
      }
      function delay(time) {
        return new Promise(function (resolve) {
          setTimeout(resolve, time)
        })
      }
      let GlobalDriver
      electron__WEBPACK_IMPORTED_MODULE_0__.contextBridge.exposeInMainWorld('electron', {
        checkFilePath: (path) => {
          return fs__WEBPACK_IMPORTED_MODULE_2___default().existsSync(path)
        },
        extractContacts: async (group_name, config) => {
          let contacts_extracted = []
          log('Iniciando instancia do navegador')
          const initiated_at = Date.now()
          let driver = await new selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Builder()
            .forBrowser(selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Browser.CHROME)
            .build()
          log('Abrindo Login Whatsapp')
          await driver.get(`https://web.whatsapp.com/`)
          try {
            log('Aguardando Validar a página de inicio')
            const result = await driver.wait(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                  "h1[data-testid='intro-title']"
                )
              )
            )
            log('Autenticado')
            await delay(config.start)
            log('Procurando grupo')
            const group = await driver.wait(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                  `span[title='${group_name}']`
                )
              )
            )
            log('Abrindo o grupo')
            group.click()
            log('Clicando em informações')
            const groupInfoTitle = await driver.wait(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                  "span[data-testid='conversation-info-header-chat-title']"
                )
              )
            )
            groupInfoTitle.click()
            log('Obtendo total de participantes')
            const participants = await driver.wait(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                  "div[data-testid='section-participants'] span[class='x2dsD _1lF7t bze30y65 a4ywakfo']"
                )
              )
            )
            const pq = await participants.getAttribute('value')
            console.log('participants', participants)
            log(`Aqui está o total de participantes ${pq}`)
          } catch (error) {}
          return contacts_extracted
        },
        createGlobalInstanceOfDriver: async () => {
          GlobalDriver = new selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Builder()
            .forBrowser(selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Browser.CHROME)
            .build()
        },
        loginWhatsapp: async (config) => {
          log('Abrindo Login Whatsapp')
          await GlobalDriver.get(`https://web.whatsapp.com/`)
          log('Aguardando Validar a página de inicio')
          await GlobalDriver.wait(
            selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                "h1[data-testid='intro-title']"
              )
            )
          )
          log('Autenticado')
          await delay(config.start)
        },
        closeGlobalInstanceOfDriver: async () => {
          await GlobalDriver.quit()
        },
        sendMessage: async (contact, message, attachments, config) => {
          try {
            let finalMessage = message
              .replaceAll('{primeiroNome}', contact.name.split(' ')[0])
              .replaceAll('{nomeCompleto}', contact.name)
              .replaceAll('{telefone}', contact.phone)
              .replaceAll('{var1}', contact.var1)
              .replaceAll('{var2}', contact.var2)
              .replaceAll('{var3}', contact.var3)
            await GlobalDriver.get(
              `https://web.whatsapp.com/send/?phone=%2B55${contact.phone.replace(
                /\D/g,
                ''
              )}&text=${encodeURI(finalMessage)
                .replace(/&/g, '%26')
                .replace(/\+/g, '%2B')}&amp;text&amp;type=phone_number&amp;app_absent=0`
            )
            await delay(config.initiate_send)
            log('Verificando se tem mensagem de erro')
            await GlobalDriver.wait(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                  "div[data-testid='confirm-popup']"
                )
              ),
              10000
            )
            await delay(config.check_error)
            const element = await GlobalDriver.findElement(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                'div[data-testid="popup-contents"]'
              )
            )
            const text = await element.getText()
            log('Houve mensagem de erro')
            log(text)
            await delay(config.finalize_send)
            return {
              status: false,
              error: text
            }
          } catch (error) {
            log('Procurando botão para enviar mensagem')
            await delay(config.send_message)
            const sendButton = await GlobalDriver.wait(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                  "button[data-testid='compose-btn-send']"
                )
              )
            )
            await delay(config.send_message)
            sendButton.click()
            if (attachments.length > 0) {
              log('Enviando arquivos')
              const tiposImagemSuportados = ['jpeg', 'jpg', 'png', 'gif', 'bmp', 'tiff', 'webp']
              const tiposVideoSuportados = ['mp4', 'mov', 'avi', '3gp', 'wmv', 'mkv']
              for (const file of attachments) {
                if (config.new_whatsapp_send_button) {
                  log('Procurando novo botão drop up')
                  const attachMenuPlus = await GlobalDriver.wait(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                      selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                        "span[data-testid='attach-menu-plus']"
                      )
                    )
                  )
                  attachMenuPlus.click()
                  await delay(config.send_message)
                  const isImageOrVideo =
                    tiposImagemSuportados.includes(file.name.split('.').pop().toLowerCase()) ||
                    tiposVideoSuportados.includes(file.name.split('.').pop().toLowerCase())
                  const selectButtonByTypes = isImageOrVideo
                    ? "li[data-testid='mi-attach-media']"
                    : "li[data-testid='mi-attach-document']"
                  log(
                    `BOTÃO SELECIONADO: ${selectButtonByTypes}, é imagem ou video? ${file.isImageOrVideo}`
                  )
                  log('Procurando botão de anexar o tipo')
                  const attachButton = await GlobalDriver.wait(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                      selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(selectButtonByTypes)
                    )
                  )
                  log('Inserindo anexo')
                  const inputElement = await attachButton.findElement(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(`input`)
                  )
                  inputElement.sendKeys(file.path)
                } else {
                  log('Procurando botão clip')
                  const clipButton = await GlobalDriver.wait(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                      selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                        "div[data-testid='conversation-clip']"
                      )
                    )
                  )
                  clipButton.click()
                  await delay(config.send_message)
                  const isImageOrVideo =
                    tiposImagemSuportados.includes(file.name.split('.').pop().toLowerCase()) ||
                    tiposVideoSuportados.includes(file.name.split('.').pop().toLowerCase())
                  console.log('TO AQUI', isImageOrVideo, file)
                  const selectButtonByTypes = isImageOrVideo
                    ? "button[aria-label='Fotos e vídeos']"
                    : "button[aria-label='Documento']"
                  log(
                    `BOTÃO SELECIONADO: ${selectButtonByTypes}, é imagem ou video? ${file.isImageOrVideo}`
                  )
                  log('Procurando botão de anexar o tipo')
                  const attachButton = await GlobalDriver.wait(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                      selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(selectButtonByTypes)
                    )
                  )
                  log('Inserindo anexo')
                  const inputElement = await attachButton.findElement(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(`input`)
                  )
                  inputElement.sendKeys(file.path)
                }
                await delay(config.send_message)
                log('Procurando botão para enviar anexo')
                const sendImageButton = await GlobalDriver.wait(
                  selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                      "span[data-testid='send']"
                    )
                  )
                )
                sendImageButton.click()
                await delay(config.send_attachment)
              }
            }
            log('Finalizei o envio')
            await delay(config.send_message)
            return {
              status: true,
              error: 'false'
            }
          }
        },
        initiateSendProcess: async (rows, message, images, isNewLineReturnCharacter, config) => {
          log('Iniciando instancia do navegador')
          const initiated_at = Date.now()
          let driver = await new selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Builder()
            .forBrowser(selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Browser.CHROME)
            .build()
          try {
            log('Abrindo Login Whatsapp')
            await driver.get(`https://web.whatsapp.com/`)
            log('Aguardando Validar a página de inicio')
            const result = await driver.wait(
              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                  "h1[data-testid='intro-title']"
                )
              )
            )
            log('Autenticado')
            await delay(config.start)
            if (result) {
              let newRows = []
              for (const contact of rows) {
                log('Abrindo contato')
                if (!isNewLineReturnCharacter) {
                  let finalMessage = message
                    .replaceAll('{primeiroNome}', contact.name.split(' ')[0])
                    .replaceAll('{nomeCompleto}', contact.name)
                    .replaceAll('{telefone}', contact.phone)
                    .replaceAll('{var1}', contact.var1)
                    .replaceAll('{var2}', contact.var2)
                    .replaceAll('{var3}', contact.var3)
                  await driver.get(
                    `https://web.whatsapp.com/send/?phone=%2B55${contact.phone.replace(
                      /\D/g,
                      ''
                    )}&text=${encodeURI(
                      finalMessage
                    )}&amp;text&amp;type=phone_number&amp;app_absent=0`
                  )
                } else {
                  await driver.get(
                    `https://web.whatsapp.com/send/?phone=%2B55${contact.phone.replace(
                      /\D/g,
                      ''
                    )}&amp;text&amp;type=phone_number&amp;app_absent=0`
                  )
                }
                await delay(config.initiate_send)
                try {
                  log('Verificando se tem mensagem de erro')
                  await driver.wait(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                      selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                        "div[data-testid='confirm-popup']"
                      )
                    ),
                    10000
                  )
                  await delay(config.check_error)
                  const element = await driver.findElement(
                    selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                      'div[data-testid="popup-contents"]'
                    )
                  )
                  const text = await element.getText()
                  log('Houve mensagem de erro')
                  log(text)
                  await delay(config.finalize_send)
                  newRows.push({
                    ...contact,
                    statusInfo: text
                  })
                } catch (error) {
                  if (!isNewLineReturnCharacter) {
                    log('Procurando botão para enviar mensagem')
                    await delay(config.send_message)
                    const sendButton = await driver.wait(
                      selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                        selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                          "button[data-testid='compose-btn-send']"
                        )
                      )
                    )
                    sendButton.click()
                  } else {
                    log('Procurando input')
                    const input = await driver.wait(
                      selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                        selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                          'p.selectable-text.copyable-text'
                        )
                      )
                    )
                    log('Inserindo texto')
                    let finalMessage = message
                      .replaceAll('{primeiroNome}', contact.name.split(' ')[0])
                      .replaceAll('{nomeCompleto}', contact.name)
                      .replaceAll('{telefone}', contact.phone)
                      .replaceAll('{var1}', contact.var1)
                      .replaceAll('{var2}', contact.var2)
                      .replaceAll('{var3}', contact.var3)
                    input.click()
                    const finalMessageArray = finalMessage.split('\n')
                    for (const message of finalMessageArray) {
                      input.sendKeys(message)
                      await delay(config.send_message)
                      input.sendKeys(
                        isNewLineReturnCharacter
                          ? selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Key.ENTER
                          : selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Key.chord(
                              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Key.SHIFT,
                              selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.Key.ENTER
                            )
                      )
                      await delay(config.send_message)
                    }
                  }
                  if (images.length > 0) {
                    log('Enviando imagens anexadas')
                    for (const image of images) {
                      log('Procurando botão clipe')
                      const clipButton = await driver.wait(
                        selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                          selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                            "div[data-testid='conversation-clip']"
                          )
                        )
                      )
                      clipButton.click()
                      await delay(config.send_message)
                      log('Procurando botão anexar imagens')
                      const attachButton = await driver.wait(
                        selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                          selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                            "button[aria-label='Fotos e vídeos']"
                          )
                        )
                      )
                      log('Inserindo imagem')
                      const inputElement = await attachButton.findElement(
                        selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(`input`)
                      )
                      inputElement.sendKeys(image.path)
                      await delay(config.send_message)
                      log('Procurando botão para enviar imagem')
                      const sendImageButton = await driver.wait(
                        selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.until.elementLocated(
                          selenium_webdriver__WEBPACK_IMPORTED_MODULE_1__.By.css(
                            "span[data-testid='send']"
                          )
                        )
                      )
                      sendImageButton.click()
                      await delay(config.send_message)
                    }
                  }
                  newRows.push({
                    ...contact,
                    status: true,
                    statusInfo: 'Mensagem enviada!'
                  })
                }
              }
              await delay(config.finalize_send)
              await driver.quit()
              return {
                rows: newRows,
                message,
                status: true,
                initiated_at,
                finalized_at: Date.now()
              }
            } else {
              await driver.quit()
              return {
                rows: rows,
                message,
                error: 'Não foi possivel autenticar',
                status: false,
                initiated_at,
                finalized_at: Date.now()
              }
            }
          } catch (error) {
            console.log('Estou aqui', error)
            log('Houve um erro e fechamos o navegador')
            await driver.quit()
            return {
              rows,
              error,
              message,
              status: false,
              initiated_at,
              finalized_at: Date.now()
            }
          }
        },
        ipcRenderer: {
          sendMessage(channel, args) {
            electron__WEBPACK_IMPORTED_MODULE_0__.ipcRenderer.send(channel, args)
          },
          on(channel, func) {
            const subscription = (_event, ...args) => func(...args)
            electron__WEBPACK_IMPORTED_MODULE_0__.ipcRenderer.on(channel, subscription)
            return () => {
              electron__WEBPACK_IMPORTED_MODULE_0__.ipcRenderer.removeListener(
                channel,
                subscription
              )
            }
          },
          once(channel, func) {
            electron__WEBPACK_IMPORTED_MODULE_0__.ipcRenderer.once(channel, (_event, ...args) =>
              func(...args)
            )
          }
        }
      })
    })()

    /******/ return __webpack_exports__
    /******/
  })()
})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLG1CQUFPLENBQUMsd0RBQWE7QUFDOUIsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVc7QUFDbkM7QUFDQSxlQUFlLG1CQUFPLENBQUMscURBQVU7QUFDakMsU0FBUywwREFBOEI7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLDhDQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxrREFBYTtBQUNsQztBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QjtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyx5Q0FBTTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUNyeEJBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLHdEQUFhO0FBQzlCLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFXO0FBQ25DO0FBQ0EsV0FBVywwRUFBeUI7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsa0VBQWtCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxrREFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxzQ0FBc0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7Ozs7Ozs7Ozs7O0FDcFFhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQW9CO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3Qix1QkFBdUIsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLGtEQUFTO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxnREFBUTtBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLHNEQUFXOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QSw0RkFBNEY7QUFDNUYsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxvSUFBd0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCLHNDQUFzQyxtQkFBbUI7QUFDekQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNB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QTBGOztBQUUzSTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGlHQUFrQjs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQ0FBc0Msc0NBQXNDO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2U2E7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBVzs7QUFFbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7Ozs7Ozs7Ozs7O0FDelNBO0FBQ0E7O0FBRUEsMEJBQTBCLE1BQU0sT0FBTyxtQkFBTyxDQUFDLGtCQUFNLElBQUksYUFBYTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsZ0VBQWlCOztBQUV0QztBQUNBLFNBQVMsc0NBQXNDO0FBQy9DLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVCxLQUFLLEdBQUc7QUFDUixLQUFLLEtBQUs7QUFDVixLQUFLLElBQUksSUFBSSxFQUFFO0FBQ2YsS0FBSyxJQUFJLEVBQUUsSUFBSTtBQUNmO0FBQ0E7QUFDQSxLQUFLLElBQUksT0FBTyxJQUFJO0FBQ3BCLEtBQUssRUFBRSxPQUFPLEVBQUU7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSxNQUFNO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTixJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxFQUFFLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDRDQUE0Qzs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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UUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQzlCLG1DQUFtQztBQUNuQzs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDBCQUEwQjs7O0FBR3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuaERhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxnRUFBaUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUIsNENBQTRDLGtCQUFrQjtBQUM5RCwyQ0FBMkMsbUJBQW1CO0FBQzlEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdDQUF3Qyw2QkFBNkI7QUFDckUsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdFZhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9CYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsZ0VBQWlCOztBQUVyQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTs7O0FBR0EscUJBQXFCLHNCQUFzQixxQkFBcUI7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhELDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFlBQVk7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0EsMkNBQTJDO0FBQzNDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxlQUFlO0FBQzlCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLGNBQWMsY0FBYyxPQUFPO0FBQ25DLGNBQWMsY0FBYyxPQUFPO0FBQ25DLGNBQWMsY0FBYyxPQUFPOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxPQUFPOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0IseUNBQXlDOztBQUV6Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpELGNBQWMsZUFBZTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07O0FBRU4sZ0NBQWdDO0FBQ2hDOztBQUVBLE1BQU07QUFDTjs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3Qix5Q0FBeUM7O0FBRXpDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ04sV0FBVyxtQ0FBbUM7O0FBRTlDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGlDQUFpQztBQUNqQyxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6Qzs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUksTUFBTSxHQUFHLE1BQU0sR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUksS0FBSyxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0EsNERBQTREO0FBQzVELHdDQUF3QztBQUN4Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQyxJQUFJO0FBQ0o7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLGlCQUFpQjtBQUNqQixpQkFBaUI7Ozs7Ozs7Ozs7OztBQ3JzQ0o7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDOUNhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7Ozs7Ozs7Ozs7OztBQ25CUDs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0NBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkI7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyx5Q0FBTTtBQUN2QixFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLGVBQWU7O0FBRWxEO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7Ozs7Ozs7Ozs7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0VBQVk7QUFDekMsUUFBUSx1REFBdUQsRUFBRSxtQkFBTyxDQUFDLDBFQUFjOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7O0FBRUE7O0FBRUE7QUFDQSxjQUFjLFNBQVM7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxTQUFTOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7Ozs7Ozs7Ozs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw4RUFBZ0I7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDOUIsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyx3RUFBYTtBQUMzQyxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLGdGQUFpQjtBQUNqRCxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsb0VBQWM7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUiw2QkFBNkI7QUFDN0I7QUFDQSxNQUFNO0FBQ04sMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSLDZCQUE2QjtBQUM3QjtBQUNBLE1BQU07QUFDTiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN0V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTyxtQkFBbUI7QUFDMUIsK0JBQStCLG1DQUFtQztBQUNsRSxhQUFhLDZDQUE2QztBQUMxRCxhQUFhLHVEQUF1RDtBQUNwRTtBQUNBO0FBQ0EsT0FBTyxrQkFBa0Isd0JBQXdCO0FBQ2pEO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtDQUErQztBQUNuRDtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUksOENBQThDO0FBQ2xELFNBQVMsNkNBQTZDO0FBQ3REO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFrRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksOEJBQThCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQywyREFBTTtBQUN6QixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLGlGQUFvQjtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBWTs7QUFFckM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLHNCQUFzQjs7QUFFakM7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUVBQW1FO0FBQ3pFLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQSxVQUFVLGdEQUFnRDtBQUMxRDtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBCQUEwQjtBQUNqQyxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU8sbUJBQW1CO0FBQzFCLCtCQUErQixtQ0FBbUM7QUFDbEUsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSx1REFBdUQ7QUFDcEU7QUFDQTtBQUNBLE9BQU8sa0JBQWtCLHdCQUF3QjtBQUNqRDtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQ0FBK0M7QUFDbkQ7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxNQUFNLGNBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsK0RBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLDJEQUFNO0FBQ3pCLFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDakUsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQWU7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLG1FQUFhO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFlO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsbUVBQVU7QUFDakMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyx1RkFBdUI7O0FBRW5EO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pEO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEIsY0FBYyxHQUFHO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBdUQ7QUFDL0Q7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQztBQUM5QyxjQUFjLFVBQVU7QUFDeEIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sR0FBRyxPQUFPO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhDQUE4QztBQUMzRDtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGtDQUFrQztBQUN4RTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0JBQXNCO0FBQzVCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQztBQUN0QztBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRyxtQkFBbUI7QUFDbkMsZ0JBQWdCLGtEQUFrRCxHQUFHO0FBQ3JFO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsZ0RBQWdEO0FBQzFEO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLCtCQUErQjtBQUM1QyxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsc0ZBQW1CO0FBQ3RELFdBQVcsbUJBQU8sQ0FBQyxjQUFJOztBQUV2QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixFQUFFO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7Ozs7Ozs7Ozs7QUMxRG5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHdCQUFTO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixrQkFBa0IscUVBQWtDOztBQUVwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QseUJBQXlCO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVSxPQUFPLEtBQUssSUFBSSxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EscUNBQXFDLFVBQVUsT0FBTyxLQUFLLElBQUksYUFBYTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7Ozs7Ozs7Ozs7QUNqSm5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLGdCQUFnQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHFCQUFxQjs7Ozs7Ozs7Ozs7O0FDNUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTyxtQkFBbUI7QUFDMUI7QUFDQSxRQUFRLG1DQUFtQztBQUMzQztBQUNBLE9BQU8sa0JBQWtCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4Q0FBOEM7QUFDbEQsU0FBUyw2Q0FBNkM7QUFDdEQ7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQSxJQUFJLG1EQUFtRDtBQUN2RDtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDaEQsV0FBVyxtQkFBTyxDQUFDLDJEQUFNO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFZOztBQUVyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsc0JBQXNCOztBQUVqQztBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSx1QkFBdUIsd0NBQXdDO0FBQzVFLG9EQUFvRCxvQkFBb0I7QUFDeEUsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQWU7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQWU7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLCtEQUFRO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQywyREFBTTtBQUN6QixlQUFlLG1CQUFPLENBQUMsbUVBQVU7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsMkVBQWlCO0FBQzNDLFlBQVksbUJBQU8sQ0FBQyw2REFBVTtBQUM5QixRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsaUZBQW9CO0FBQzlELFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsNkRBQVU7QUFDbEMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyx1RkFBdUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsNEJBQTRCO0FBQ3BDLGdCQUFnQiwyQkFBMkIsT0FBTyxjQUFjO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsZUFBZTtBQUN2QixnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDbkQ7QUFDQTtBQUNBLCtEQUErRCxVQUFVO0FBQ3pFOztBQUVBLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNLGVBQWUsT0FBTztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx5QkFBeUI7QUFDdEMsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZUFBZTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxjQUFjLFVBQVU7QUFDeEIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsR0FBRztBQUNIOztBQUVBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0EsU0FBUyxlQUFlLElBQUksbUJBQW1CO0FBQy9DLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsc0NBQXNDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEMsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsMENBQTBDO0FBQ3ZFO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7O0FBRXpCLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFhOztBQUVyQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxRQUFRO0FBQ3BCO0FBQ0Esa0JBQWtCLHNHQUFrQztBQUNwRDtBQUNBLE1BQU0saUNBQWlDO0FBQ3ZDLHFCQUFxQixTQUFTLE1BQU0sU0FBUztBQUM3QyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQSxrRUFBa0U7QUFDbEUsa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFVBQVU7QUFDckIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdCQUFnQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7Ozs7Ozs7Ozs7O0FDMVZ2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixpQkFBaUIsZ0dBQTJCO0FBQzVDLG1CQUFtQixrR0FBNkI7QUFDaEQsb0JBQW9CLCtGQUEwQjtBQUM5QyxnQkFBZ0IsdUdBQWlDO0FBQ2pELG9CQUFvQixvR0FBOEI7QUFDbEQsY0FBYyxtQkFBTyxDQUFDLG9FQUFjOztBQUVwQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QyxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RCxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1Qix5QkFBeUI7Ozs7Ozs7Ozs7OztBQ3JLekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLCtEQUFRO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQywyREFBTTtBQUN6QixtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLG1FQUFVO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFpQjtBQUMzQyxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsaUZBQW9CO0FBQzlELGNBQWMsbUJBQU8sQ0FBQyxtRUFBYTtBQUNuQyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLHVGQUF1Qjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBEQUEwRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDZDQUE2QztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsY0FBYyxVQUFVO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qyw2QkFBNkI7QUFDckU7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxzQkFBc0Isa0NBQWtDO0FBQ3hELGNBQWMsVUFBVTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9ELGFBQWEsT0FBTztBQUNwQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixLQUFLLHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLHlCQUF5QjtBQUN0QztBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWM7QUFDZCxlQUFlO0FBQ2YsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1gsNkJBQTZCO0FBQzdCLGdCQUFnQjtBQUNoQiwyQkFBMkI7Ozs7Ozs7Ozs7OztBQ2pmM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsK0RBQVE7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLDZEQUFVO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFvQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHlEQUFRO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxtRUFBYTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywrREFBVztBQUNuQyxXQUFXLG1CQUFPLENBQUMscURBQU07QUFDekIsY0FBYyxtQkFBTyxDQUFDLG1FQUFhO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFlO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQWU7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLG1FQUFhO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMscUVBQWM7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLHlGQUF3QjtBQUN4RCxnQ0FBZ0MsbUJBQU8sQ0FBQywyR0FBaUM7QUFDekUsc0JBQXNCLG1CQUFPLENBQUMscUZBQXNCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFFBQVEscUJBQXFCLEtBQUsscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBMEM7QUFDckQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakUsV0FBVyxNQUFNO0FBQ2pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkMsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1QkFBdUI7QUFDN0IsTUFBTSxtQ0FBbUM7QUFDekM7QUFDQSxNQUFNLDBCQUEwQjtBQUNoQztBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBLE1BQU0sMEJBQTBCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQzs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7O0FBRUEsa0JBQWtCLDhCQUE4QjtBQUNoRDs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQywrQ0FBK0MseUJBQXlCO0FBQ3hFLGFBQWEsU0FBUywrQkFBK0I7QUFDckQ7QUFDQSxhQUFhLGtDQUFrQztBQUMvQywrQkFBK0I7QUFDL0IsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCO0FBQ3ZFLGFBQWEscURBQXFEO0FBQ2xFO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlDQUFpQztBQUM5QyxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0EsTUFBTSx3QkFBd0IsS0FBSyxnQkFBZ0I7QUFDbkQ7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBLE1BQU0sd0JBQXdCLEtBQUssZ0JBQWdCO0FBQ25EO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLCtCQUErQjtBQUNwRTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQSxhQUFhLGFBQWE7QUFDMUIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0EsTUFBTSxnQkFBZ0I7QUFDdEI7QUFDQSxhQUFhLGVBQWU7QUFDNUIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0Esa0RBQWtELHVCQUF1QjtBQUN6RTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBLE1BQU0sMENBQTBDO0FBQ2hEO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLDZCQUE2QjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWUsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQ0FBZ0M7QUFDOUU7QUFDQSxRQUFRO0FBQ1IsOENBQThDLGdDQUFnQztBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJLEdBQUc7QUFDbkIsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZTtBQUNmLGVBQWU7QUFDZixjQUFjO0FBQ2QsVUFBVTtBQUNWLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1gsY0FBYztBQUNkLGVBQWU7QUFDZix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYixlQUFlO0FBQ2YsZUFBZTtBQUNmLGFBQWE7QUFDYixjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IscUJBQXFCOzs7Ozs7Ozs7Ozs7QUNweUJyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLHFCQUFxQixtQkFBTyxDQUFDLG9DQUFlOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyx3QkFBd0IsWUFBWTtBQUMxRDtBQUNBLGFBQWEsU0FBUztBQUN0QixVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVUsV0FBVyxZQUFZO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLGtCQUFrQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQywwQ0FBSzs7QUFFekI7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFDQUFxQztBQUNoRDtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0QsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFOztBQUVBO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSxTQUFTLDhCQUE4QixZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCLDJCQUEyQixJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosY0FBYyxtQkFBTyxDQUFDLGdEQUFPO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0IsV0FBVyxtQkFBTyxDQUFDLDhEQUFTO0FBQzVCLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxvRUFBYzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUs7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsTUFBTSwwQkFBMEI7QUFDaEM7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZSxRQUFRLFlBQVk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsbUJBQW1COzs7Ozs7Ozs7OztBQzVObkI7QUFDQSw0QkFBNEIsbUJBQW1CLGtCQUFrQixlQUFlLHlCQUF5QixpQkFBaUIsZUFBZSxTQUFTLHNFQUFzRSxVQUFVLHdCQUF3Qix1RUFBdUU7QUFDalUsZUFBZSxlQUFlLHFCQUFxQixvQ0FBb0MsZ0NBQWdDLHdDQUF3Qyx1Q0FBdUMsNktBQTZLLG9KQUFvSjtBQUN2Z0IsaUVBQWlFLFNBQVMsZUFBZSx3QkFBd0IsZUFBZSxlQUFlLDBDQUEwQyxtQkFBbUI7QUFDNU0sbUJBQW1CLG9CQUFvQix1QkFBdUIsOENBQThDLGtCQUFrQiw0Q0FBNEMsbUNBQW1DLHFCQUFxQixrQkFBa0IsNkJBQTZCLG1CQUFtQixtR0FBbUc7QUFDdlksaUJBQWlCLDhDQUE4QyxrQkFBa0IsZ0JBQWdCLDBCQUEwQix3QkFBd0IsZ0JBQWdCLGNBQWMsd0JBQXdCLGtCQUFrQiwyQkFBMkI7O0FBRXRQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTLFlBQVksYUFBYSxPQUFPLDZDQUE2QyxnREFBZ0QsZUFBZSxnRkFBZ0YsWUFBWSxXQUFXLGlDQUFpQyxTQUFTLDJDQUEyQyxvQ0FBb0MsaUJBQWlCLDJEQUEyRCxJQUFJLCtCQUErQix5Q0FBeUM7QUFDaGlCLFVBQVUsZUFBZSxvRUFBb0UsSUFBSSxlQUFlLFdBQVcsaUNBQWlDLFNBQVMsc0NBQXNDLDRDQUE0QyxlQUFlLHNFQUFzRSxJQUFJLDJDQUEyQyxTQUFTLDJDQUEyQywwQ0FBMEMsaUJBQWlCLFFBQVE7QUFDbGYsY0FBYyx5QkFBeUIsRUFBRSxTQUFTLHVDQUF1Qyw2Q0FBNkMsZUFBZSwyREFBMkQsSUFBSSxnREFBZ0QsU0FBUywwQ0FBMEMseUNBQXlDLGlCQUFpQiwyREFBMkQsSUFBSSw0Q0FBNEM7QUFDNWQsaUJBQWlCLEdBQUcsMkRBQTJELElBQUksd0NBQXdDLElBQUksUUFBUSxLQUFLLHFEQUFxRCxlQUFlLGtEQUFrRCxtQkFBbUIsNkZBQTZGLGlCQUFpQixjQUFjLGlCQUFpQix1QkFBdUIsZUFBZSxpQkFBaUIsaUNBQWlDLHlDQUF5QyxnQkFBZ0IsYUFBYTtBQUNoa0IsaUJBQWlCLFFBQVEsMkJBQTJCLDJCQUEyQiwwQ0FBMEMsVUFBVSxLQUFLLDBCQUEwQixHQUFHLDBDQUEwQywwQ0FBMEMsd0NBQXdDLDhIQUE4SCxPQUFPLE9BQU8sWUFBWSxTQUFTLGlCQUFpQix1QkFBdUIsTUFBTSxHQUFHLG9CQUFvQixPQUFPLG9CQUFvQixPQUFPLEtBQUssU0FBUyxLQUFLLGNBQWMsd0JBQXdCLGNBQWMsZ0NBQWdDLGNBQWMsNkNBQTZDLGVBQWUsb0RBQW9ELHVCQUF1QixHQUFHLGNBQWMsNENBQTRDLGlCQUFpQixTQUFTLGlFQUFpRSwwTkFBME4sY0FBYyxrQkFBa0IsK0JBQStCO0FBQ3R0QyxHQUFHLHdCQUF3QixRQUFRLHNCQUFzQixRQUFRLFdBQVcsc0NBQXNDLG1DQUFtQyxRQUFRLFdBQVcsb0NBQW9DLDZDQUE2QyxHQUFHLHFCQUFxQixNQUFNLFlBQVksZ0NBQWdDLGNBQWMsU0FBUyxNQUFNLFVBQVUsZUFBZSx1QkFBdUIsbUJBQW1CLEVBQUUsTUFBTSw2QkFBNkIsK0NBQStDLHFCQUFxQixTQUFTLGdCQUFnQixpQkFBaUIsZ0JBQWdCLG9DQUFvQyxpQkFBaUIsc0VBQXNFLGlDQUFpQyxlQUFlLFNBQVMsU0FBUyxlQUFlLGNBQWMsWUFBWSxXQUFXLGlDQUFpQyxpQkFBaUIsaUpBQWlKLGdCQUFnQix1QkFBdUIsY0FBYyxrQkFBa0IsZUFBZSx3QkFBd0IsaUJBQWlCLHNCQUFzQixzQkFBc0IsNkJBQTZCLHlCQUF5Qix5QkFBeUIsYUFBYSw4QkFBOEIsMEJBQTBCLDBCQUEwQixhQUFhLDhCQUE4QiwwQkFBMEIsMEJBQTBCLGFBQWEsaUJBQWlCLGFBQWEsY0FBYyxvQ0FBb0MsK0JBQStCLDZCQUE2QixpQ0FBaUMsbUNBQW1DLGFBQWEsOEJBQThCLGtDQUFrQyxvQ0FBb0MsYUFBYSw4QkFBOEIsa0NBQWtDLG9DQUFvQyxhQUFhLGVBQWUsc0NBQXNDLGVBQWUsS0FBSyxpQkFBaUIscUJBQXFCLFNBQVMsaUJBQWlCLG1CQUFtQix3REFBd0Qsa0dBQWtHLEtBQUssUUFBUSxnQkFBZ0I7QUFDanRFLGlCQUFpQixpQkFBaUIsd0VBQXdFLHVCQUF1QiwwQkFBMEIsMEJBQTBCLGtFQUFrRSxvQ0FBb0MsMkNBQTJDLGtDQUFrQywrSEFBK0gsT0FBTztBQUM5ZSxnQkFBZ0IsZUFBZSxrQkFBa0IsZ0JBQWdCLGVBQWUsd0RBQXdELGlCQUFpQixtQkFBbUIsaUJBQWlCLEtBQUssZ0JBQWdCLGdCQUFnQixlQUFlLGlCQUFpQixLQUFLLG9CQUFvQixrQkFBa0IsU0FBUyxjQUFjLG1EQUFtRCxpQkFBaUIsb0JBQW9CLFlBQVksRUFBRSxFQUFFLGlCQUFpQixlQUFlLElBQUk7QUFDaGQsZUFBZSxnQ0FBZ0MsZ0RBQWdEO0FBQy9GLHFCQUFxQixTQUFTLDJDQUEyQyxvRkFBb0Ysd0VBQXdFLEtBQUssZ0JBQWdCLE9BQU8sOEJBQThCLFdBQVcsSUFBSSxTQUFTLDRDQUE0QyxLQUFLLFVBQVUsT0FBTyxLQUFLLGNBQWMsTUFBTSwwREFBMEQsY0FBYyxXQUFXLElBQUksU0FBUztBQUNsZixDQUFDLGNBQWMsd0JBQXdCLHFGQUFxRiw2RUFBNkUsb0JBQW9CLHNDQUFzQyxJQUFJLFNBQVMsU0FBUyxFQUFFLEVBQUUsOEZBQThGLHNCQUFzQixLQUFLLDJCQUEyQixJQUFJLG1CQUFtQjtBQUN4YyxtQkFBbUIscUJBQXFCLElBQUksNEJBQTRCLFNBQVMsU0FBUyxnQ0FBZ0MsMERBQTBELHVCQUF1QjtBQUMzTSx1QkFBdUIsMkNBQTJDLFlBQVksZUFBZSxRQUFRLHFEQUFxRCxNQUFNLGlCQUFpQixTQUFTLHNCQUFzQixJQUFJLFFBQVEsU0FBUyxrQ0FBa0MsU0FBUyxjQUFjO0FBQzlSLHVCQUF1QixnRkFBZ0YsaUJBQWlCLDBGQUEwRixpQ0FBaUMseUdBQXlHLG9CQUFvQixHQUFHO0FBQ25YLHVCQUF1QixNQUFNLCtEQUErRCxZQUFZLCtCQUErQiw2Q0FBNkMsZUFBZSx1QkFBdUIsaUJBQWlCLEdBQUcsZ0JBQWdCLDBEQUEwRCxFQUFFLFNBQVMscUJBQXFCLHVCQUF1QixtQkFBbUIsRUFBRSw0Q0FBNEM7QUFDaGIsdUJBQXVCLG1CQUFtQixFQUFFLDBEQUEwRCxlQUFlLG1CQUFtQixvQkFBb0Isd0JBQXdCLGNBQWMsYUFBYSxtQkFBbUIsU0FBUyxlQUFlLFNBQVMsbUJBQW1CLGlCQUFpQixpQkFBaUIsaUJBQWlCLFVBQVUsTUFBTSxxQkFBcUIsS0FBSyxFQUFFLE1BQU0sVUFBVSx5R0FBeUcsb0JBQW9CLElBQUksSUFBSSxXQUFXLEVBQUUseUJBQXlCLE1BQU0sTUFBTSxTQUFTLGlCQUFpQixZQUFZLFFBQVEsc0JBQXNCLE1BQU07QUFDdG9CLDRCQUE0QixZQUFZLFdBQVcsa0NBQWtDLFNBQVMsVUFBVSxlQUFlLHVCQUF1QixlQUFlLHdCQUF3QixpQkFBaUIscUJBQXFCLGlCQUFpQixTQUFTLDBCQUEwQixZQUFZLGNBQWMsVUFBVSx1QkFBdUIsWUFBWSxnQkFBZ0IsWUFBWSxjQUFjLFNBQVMsaUJBQWlCLFlBQVksY0FBYyxtREFBbUQsaUJBQWlCLE1BQU0saUJBQWlCLE1BQU0sZ0JBQWdCLFNBQVMsZ0NBQWdDLGdCQUFnQixTQUFTLGlDQUFpQyxpQkFBaUIsU0FBUyxpQ0FBaUMsbUJBQW1CLGlCQUFpQixTQUFTLFNBQVMsU0FBUyxnQkFBZ0IsZ0JBQWdCLHFGQUFxRixrQkFBa0IsVUFBVSxrQkFBa0IsRUFBRTtBQUN2NkIsdUJBQXVCLFNBQVMsU0FBUyxNQUFNLG1DQUFtQyxRQUFRLFdBQVcsRUFBRSwwQkFBMEIsRUFBRSxnQ0FBZ0MsU0FBUyxtQ0FBbUMsbUNBQW1DLFFBQVEsMEJBQTBCLEVBQUUsUUFBUSxVQUFVLHNCQUFzQixNQUFNLHdCQUF3QixNQUFNLHFCQUFxQixNQUFNLCtEQUErRCx1Q0FBdUMsU0FBUztBQUM1ZSxvSEFBb0gsMkJBQTJCLGtDQUFrQyxpQ0FBaUMsbUNBQW1DLGFBQWEscUJBQXFCLHFCQUFxQixTQUFTLFNBQVMsU0FBUyxTQUFTLGlDQUFpQyxlQUFlO0FBQ2hZLG9CQUFvQiwyRUFBMkUsa0JBQWtCLDBCQUEwQiw0QkFBNEIscUJBQXFCLEVBQUUsNEJBQTRCLHFCQUFxQixFQUFFLDBCQUEwQixxQkFBcUIsRUFBRSwwQkFBMEIscUJBQXFCLEVBQUUsMEJBQTBCLHFCQUFxQixFQUFFLDBCQUEwQix3QkFBd0IsV0FBVyxRQUFRO0FBQ3pjLDBCQUEwQix3QkFBd0IsV0FBVyxRQUFRLEVBQUUsMkJBQTJCLHdCQUF3QixZQUFZLFFBQVEsRUFBRSwyQkFBMkIsd0JBQXdCLFlBQVksUUFBUSxFQUFFLGlDQUFpQyx3QkFBd0IsWUFBWSxXQUFXLEVBQUUsMkJBQTJCLHdCQUF3QixZQUFZLFdBQVcsRUFBRSw0QkFBNEIsd0JBQXdCLEVBQUUsMkJBQTJCLHdCQUF3QixFQUFFLGlCQUFpQiw2R0FBNkcsaUJBQWlCLFNBQVMsU0FBUyxXQUFXLFdBQVcsUUFBUSwyQkFBMkIsY0FBYyxxQkFBcUIsaUNBQWlDLDBCQUEwQixxQkFBcUIsaUJBQWlCLHNHQUFzRyxrSEFBa0gsdUJBQXVCLHdGQUF3RixFQUFFLGlCQUFpQixTQUFTLFNBQVMsOEJBQThCLFdBQVcsR0FBRywwREFBMEQsV0FBVztBQUM3eEMsUUFBUSwyQkFBMkIsMENBQTBDLGlDQUFpQywwQkFBMEIsa0JBQWtCLDhCQUE4QixjQUFjLGVBQWUsUUFBUSxVQUFVLDZCQUE2QixTQUFTLFNBQVMsU0FBUyxTQUFTLFVBQVUsU0FBUyxTQUFTLHNCQUFzQixXQUFXLGlDQUFpQyxlQUFlO0FBQ3JaLDRCQUE0Qix3RUFBd0UsOEJBQThCLGtDQUFrQyxlQUFlLElBQUksa0NBQWtDLHlCQUF5QixJQUFJLGlDQUFpQyx3Q0FBd0MsZ0JBQWdCLEtBQUssU0FBUyxxQ0FBcUMsU0FBUyxTQUFTLDBCQUEwQixJQUFJLGdDQUFnQyxnQkFBZ0I7QUFDbGUsNkJBQTZCLFNBQVMsSUFBSSxnQ0FBZ0MsMEJBQTBCLElBQUksNkJBQTZCLGNBQWMsTUFBTSxlQUFlLE1BQU0sZ0NBQWdDLG9DQUFvQyxlQUFlLEVBQUUsWUFBWSwyQkFBMkIsNENBQTRDLHNCQUFzQixTQUFTLGdCQUFnQixPQUFPLDBCQUEwQixFQUFFLFdBQVcsWUFBWSxnQkFBZ0IsU0FBUyxFQUFFLFNBQVM7QUFDbmUsNEJBQTRCLFNBQVMsSUFBSSw2QkFBNkIsK0RBQStELFdBQVcsSUFBSSxxQ0FBcUMsb0VBQW9FLFNBQVMsK0JBQStCLHVEQUF1RCxTQUFTLHFDQUFxQyxTQUFTO0FBQ25aLDBDQUEwQywyRUFBMkUsTUFBTSw4QkFBOEIsZUFBZSxJQUFJLGlDQUFpQyx3QkFBd0IsTUFBTSxpQ0FBaUMsV0FBVyxJQUFJLGdDQUFnQywwQkFBMEIsSUFBSSx3Q0FBd0MsU0FBUyxTQUFTLDZCQUE2QixJQUFJLGlDQUFpQyx1QkFBdUI7QUFDNWUsd0NBQXdDLCtCQUErQixNQUFNLHdDQUF3QyxTQUFTLGdEQUFnRCxvQkFBb0Isb0NBQW9DLGtCQUFrQixvQkFBb0IsU0FBUyxpRUFBaUUsTUFBTSw0Q0FBNEMsU0FBUyxTQUFTLGVBQWUsdUNBQXVDO0FBQ2hkLDZDQUE2QyxTQUFTLFNBQVMsZUFBZSxnQ0FBZ0MsSUFBSSw4QkFBOEIsYUFBYSxJQUFJLGVBQWUsRUFBRSxnQkFBZ0IsU0FBUyxTQUFTLHdDQUF3QyxTQUFTLFNBQVMsYUFBYSxLQUFLLFFBQVEsV0FBVyxLQUFLLGtCQUFrQiwyQkFBMkIsS0FBSyxRQUFRLFdBQVcsbUNBQW1DLFNBQVMsSUFBSSw0QkFBNEIsU0FBUyxJQUFJLGdCQUFnQixTQUFTLHlCQUF5QixZQUFZLFVBQVUsd0JBQXdCLE1BQU0scUJBQXFCLE1BQU0sdUNBQXVDLE1BQU0sa0JBQWtCLDZDQUE2QyxlQUFlLHNFQUFzRSwwQkFBMEIsMENBQTBDLHlCQUF5QjtBQUNyM0IsZ0NBQWdDLDJCQUEyQiw4QkFBOEIsVUFBVSxlQUFlLGVBQWUsaUNBQWlDLFFBQVEsMEJBQTBCLGVBQWUsaUNBQWlDLDBCQUEwQixpQkFBaUIsdUJBQXVCLGlEQUFpRCwyQkFBMkIsMkJBQTJCLGlCQUFpQix1QkFBdUIsOENBQThDLG1KQUFtSiwwQkFBMEI7QUFDaHFCLGlDQUFpQyxtRkFBbUYsZUFBZSxlQUFlLFNBQVMsUUFBUSwwQkFBMEIsZUFBZSxpQ0FBaUMseUJBQXlCLGlCQUFpQixpQkFBaUIsU0FBUyxTQUFTLFdBQVcsV0FBVyx5RUFBeUUsa0JBQWtCLElBQUksUUFBUSxjQUFjLGVBQWUsUUFBUSwyQkFBMkIsWUFBWSxNQUFNLDhDQUE4QyxVQUFVLGlDQUFpQyxnQ0FBZ0MsY0FBYyxlQUFlLFFBQVEsMkJBQTJCLFlBQVksV0FBVyxVQUFVLGlDQUFpQztBQUNwd0IsZUFBZSxzQkFBc0IsMkJBQTJCLGtCQUFrQixnRkFBZ0YsU0FBUyx1QkFBdUIsU0FBUyxLQUFLLHlCQUF5QixpQ0FBaUMsV0FBVyxxQkFBcUIsZUFBZSw0QkFBNEIsNkJBQTZCLEtBQUssV0FBVyx1RUFBdUUsS0FBSyxrQkFBa0I7QUFDaGUsaUNBQWlDLG1DQUFtQyxrQkFBa0IsOEJBQThCLGNBQWMsV0FBVyxRQUFRLFVBQVUsaUJBQWlCLFNBQVM7QUFDekwsbUJBQW1CLFdBQVcsYUFBYSx5Q0FBeUMsT0FBTyxLQUFLLGtCQUFrQixxQkFBcUIsNkJBQTZCLHNEQUFzRCwrQkFBK0Isb0VBQW9FLE9BQU8sSUFBSSxNQUFNLFVBQVUsc0VBQXNFLFVBQVUsTUFBTSxjQUFjLGNBQWMsTUFBTSxVQUFVO0FBQzFkLGlDQUFpQywrQkFBK0IsY0FBYyxpQkFBaUIscUJBQXFCLGVBQWUsU0FBUyxTQUFTLHFCQUFxQixXQUFXLFNBQVMsNkJBQTZCLGlEQUFpRCxhQUFhLEVBQUUsR0FBRyxTQUFTLFFBQVEsYUFBYSxxQ0FBcUMsS0FBSyxRQUFRLEtBQUssU0FBUztBQUM1WCwyQkFBMkIscUNBQXFDLHNDQUFzQyxzR0FBc0csZUFBZSx5QkFBeUIsYUFBYSx5Q0FBeUMseUJBQXlCLFVBQVUsaUNBQWlDLHlCQUF5QjtBQUN2WSxpQ0FBaUMsZ0RBQWdELGtDQUFrQyxhQUFhLG9CQUFvQixnQ0FBZ0MsY0FBYyxnQkFBZ0IsUUFBUSxVQUFVLHFCQUFxQixTQUFTLFNBQVMsU0FBUyxVQUFVLGlDQUFpQyxlQUFlLFVBQVUsb0JBQW9CLGdFQUFnRSxvQkFBb0I7QUFDaGMsMkJBQTJCLGdCQUFnQixlQUFlLGlCQUFpQixTQUFTLEtBQUssbUNBQW1DLFlBQVksbUJBQW1CLHNCQUFzQixTQUFTO0FBQzFMLG1DQUFtQyxvQkFBb0Isb0ZBQW9GLG1CQUFtQixtREFBbUQsT0FBTywyQ0FBMkMsb0VBQW9FLFNBQVMsc0NBQXNDLGtFQUFrRSxRQUFRO0FBQ2hjLGdEQUFnRCxZQUFZLDRCQUE0QixxQkFBcUIsMkNBQTJDLFlBQVksZUFBZSxnQkFBZ0IsNkNBQTZDLHNCQUFzQixTQUFTLFFBQVEsb0NBQW9DLGdCQUFnQixnQkFBZ0Isa0JBQWtCLFNBQVMsS0FBSyx5QkFBeUIsYUFBYTtBQUNqYSxnQ0FBZ0MsWUFBWSwwQkFBMEIsZ0RBQWdELGVBQWUsaUJBQWlCLFNBQVMsd0NBQXdDLGlCQUFpQixnQkFBZ0Isc0JBQXNCLHVCQUF1QixJQUFJLEtBQUssU0FBUyxXQUFXLG9CQUFvQixjQUFjLHVCQUF1QixJQUFJLHVEQUF1RCxTQUFTO0FBQy9hLG9DQUFvQyxnQkFBZ0Isb0JBQW9CLGlCQUFpQixTQUFTLEtBQUssOEJBQThCLFlBQVksaUJBQWlCLFNBQVMsS0FBSyxlQUFlLGVBQWUsU0FBUyxXQUFXLFdBQVcsUUFBUSwyQkFBMkIsb0JBQW9CLGlDQUFpQyx1Q0FBdUMsZUFBZSxlQUFlLFNBQVMsOEJBQThCLFdBQVcsR0FBRyw4QkFBOEIsV0FBVyxHQUFHLFFBQVEsMkJBQTJCLFlBQVkscUJBQXFCLFNBQVMsOEVBQThFLFVBQVUsRUFBRSxVQUFVLGlDQUFpQywrQkFBK0IsY0FBYyx1QkFBdUIsaUJBQWlCLFNBQVMsU0FBUyxlQUFlLGdCQUFnQixFQUFFLHFEQUFxRCxRQUFRLGFBQWEsWUFBWSwyQkFBMkIsT0FBTyxRQUFRLE1BQU0sS0FBSyw2QkFBNkIsNkJBQTZCLFlBQVksS0FBSyxTQUFTLDZCQUE2QixTQUFTLGdCQUFnQiwyQkFBMkIsaUJBQWlCLFNBQVM7QUFDL29DLGVBQWUsU0FBUyx3Q0FBd0MsZUFBZSxTQUFTLHFEQUFxRDtBQUM3SSxlQUFlLFNBQVMsZUFBZSxhQUFhLGFBQWEsOEZBQThGLFNBQVMsbUNBQW1DLFVBQVUsVUFBVSxLQUFLLEdBQUcsU0FBUyxjQUFjLFVBQVUscUVBQXFFLGdCQUFnQixRQUFRLG9CQUFvQixVQUFVLE1BQU0sMEJBQTBCLE1BQU0sd0VBQXdFO0FBQ2pmLGNBQWMsT0FBTyxTQUFTLFlBQVksRUFBRSx1Q0FBdUMsY0FBYyxxQkFBcUIsT0FBTyx3Q0FBd0MsTUFBTSxjQUFjLEtBQUssT0FBTyxRQUFRLHVCQUF1Qiw2Q0FBNkMsdUJBQXVCLGNBQWMsb0NBQW9DLEtBQUssV0FBVyxpRUFBaUU7QUFDM2EsaUJBQWlCLGdFQUFnRSxnQkFBZ0IsK0JBQStCLE9BQU8sU0FBUywyREFBMkQsZ0JBQWdCLFNBQVMsT0FBTyw4QkFBOEIsd0JBQXdCLDZFQUE2RSxhQUFhLGNBQWMsMkNBQTJDLE9BQU8seUJBQXlCLFVBQVUsU0FBUztBQUN2ZSxVQUFVLCtDQUErQyxTQUFTLCtDQUErQyxVQUFVLG9CQUFvQiw4QkFBOEIsMEJBQTBCLG9CQUFvQixNQUFNLGFBQWEsb0RBQW9ELEtBQUssbUJBQW1CLG9CQUFvQixxRUFBcUUsZ0JBQWdCLGNBQWMsdUNBQXVDLG9CQUFvQjtBQUM1ZSxzQkFBc0IsZUFBZSxhQUFhLFlBQVksRUFBRSxPQUFPLHFDQUFxQyxZQUFZLFVBQVUsc0NBQXNDLFVBQVUsU0FBUyxlQUFlLDJDQUEyQyxZQUFZLG1CQUFtQixLQUFLLFVBQVUsWUFBWSx3REFBd0QsUUFBUSxZQUFZLFVBQVUsZUFBZSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx5Q0FBeUMsaURBQWlELGNBQWMsWUFBWSxpQkFBaUIscUVBQXFFLHFDQUFxQyxvR0FBb0csaUJBQWlCLG9EQUFvRCxRQUFRLGtEQUFrRCxxREFBcUQsYUFBYSxzQkFBc0IsMENBQTBDLDRCQUE0QixpQkFBaUI7QUFDbm1DLGdCQUFnQiw4QkFBOEIsK0JBQStCLCtCQUErQixnQ0FBZ0Msa0RBQWtELHlHQUF5RyxrQkFBa0IsVUFBVSxrREFBa0QsTUFBTSxpREFBaUQsTUFBTSxrREFBa0QsTUFBTTtBQUMxZSxNQUFNLFNBQVMsZUFBZSxFQUFFLHFDQUFxQyx3QkFBd0IsNkJBQTZCLE1BQU0sc0JBQXNCLDJDQUEyQyxNQUFNLGtEQUFrRCxRQUFRLDRCQUE0Qix1RUFBdUUsZ0NBQWdDLDhCQUE4Qix3RUFBd0U7QUFDMWUsZUFBZSxhQUFhLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlDQUFpQywrQkFBK0IsaUNBQWlDLCtCQUErQiw0QkFBNEIsNEJBQTRCLGVBQWU7QUFDcFIsaUJBQWlCLFFBQVEsbURBQW1ELCtEQUErRCxrQ0FBa0Msa0NBQWtDLG1CQUFtQixnQ0FBZ0Msa0JBQWtCLHlCQUF5Qix5QkFBeUIsY0FBYyxnQkFBZ0IsWUFBWSxnQkFBZ0IsbUJBQW1CLGlEQUFpRCxpREFBaUQsRUFBRSxhQUFhLDJDQUEyQyxZQUFZLHNCQUFzQixpQkFBaUIsdUJBQXVCLFdBQVcsMEJBQTBCLHNEQUFzRCxTQUFTLFNBQVMsOEJBQThCLG9DQUFvQztBQUN4eUIseUJBQXlCLHlCQUF5Qix5QkFBeUIseUJBQXlCLCtCQUErQixrQ0FBa0Msc0JBQXNCLHVCQUF1QixxQkFBcUIsdUJBQXVCLHVCQUF1Qiw0QkFBNEIsZ0NBQWdDLGdCQUFnQiw2QkFBNkIsOEJBQThCLFNBQVMsdUJBQXVCLFFBQVEsY0FBYywrQ0FBK0MsaUJBQWlCLGdEQUFnRCxRQUFRLDRFQUE0RSxlQUFlLHlEQUF5RCxTQUFTLGtFQUFrRSxvQkFBb0IsMEJBQTBCLGlCQUFpQixnREFBZ0QsUUFBUTtBQUNoNkIsc0NBQXNDLGVBQWUsc0RBQXNELFNBQVMsa0VBQWtFLDJCQUEyQix3UEFBd1AsZUFBZSw0QkFBNEIsWUFBWSxzQ0FBc0MsdUJBQXVCLHVGQUF1RixxRUFBcUUsV0FBVyw4Q0FBOEMsMEJBQTBCLDBFQUEwRSxTQUFTLElBQUksZ0RBQWdELFFBQVEsZ0JBQWdCLHFIQUFxSCw4Q0FBOEMsUUFBUSxJQUFJLHlCQUF5QixTQUFTLGdFQUFnRSwrQkFBK0IsaUJBQWlCLHdIQUF3SDtBQUNwNEMsUUFBUSxJQUFJLDZCQUE2QixTQUFTLG1FQUFtRSxRQUFRO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOFhBQThYLHlMQUF5TCxFQUFFLEVBQUUsSUFBSSx3QkFBd0IsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJLGlEQUFpRCxJQUFJLGdCQUFnQixJQUFJLGdCQUFnQixJQUFJLE9BQU8saUJBQWlCLGtCQUFrQixzS0FBc0ssVUFBVSxtQkFBbUIsRUFBRSwwQkFBMEIsRUFBRTtBQUM3OUIsZUFBZSxTQUFTLDBCQUEwQixxQkFBcUIsc0ZBQXNGLElBQUksRUFBRSxhQUFhLFdBQVcsOEJBQThCLEVBQUUsZ0JBQWdCLHlDQUF5Qyw0REFBNEQsU0FBUyxlQUFlLE9BQU8saUNBQWlDLG1CQUFtQixtQkFBbUI7QUFDdGIsb0JBQW9CLFdBQVcsa0NBQWtDLG9EQUFvRCxJQUFJLG1FQUFtRSxvREFBb0QscUJBQXFCLFlBQVksbUNBQW1DLFdBQVcsS0FBSyw0QkFBNEIsYUFBYSx3QkFBd0IsT0FBTyw4QkFBOEIsaUJBQWlCLFFBQVEsUUFBUSxJQUFJLHdCQUF3QixjQUFjO0FBQ3JmLE1BQU0sSUFBSSxnQ0FBZ0MsU0FBUyx1SEFBdUgsVUFBVSxTQUFTLDhKQUE4SixrQkFBa0I7QUFDN1csa0JBQWtCLGlCQUFpQixpQkFBaUIsa0pBQWtKLEdBQUcsbUJBQW1CO0FBQzVOLGtCQUFrQixpQkFBaUIsaUJBQWlCLE1BQU0sb0NBQW9DLElBQUksOEJBQThCLFNBQVMsNEdBQTRHLEdBQUcsZ0JBQWdCLFNBQVMsRUFBRSxVQUFVLHFCQUFxQixTQUFTLFNBQVMsU0FBUyxTQUFTLDZCQUE2Qix5QkFBeUIseUJBQXlCLHlCQUF5Qix5QkFBeUIsYUFBYSw4QkFBOEIsMEJBQTBCLDBCQUEwQiwwQkFBMEIsMEJBQTBCLGFBQWEsOEJBQThCLDBCQUEwQiwwQkFBMEIsMEJBQTBCLDBCQUEwQixhQUFhLG9CQUFvQixTQUFTLFNBQVMsYUFBYSxjQUFjLDRCQUE0Qix5QkFBeUIseUJBQXlCLGlDQUFpQyxtQ0FBbUMsYUFBYSw2QkFBNkIsMEJBQTBCLDBCQUEwQixrQ0FBa0Msb0NBQW9DO0FBQ2pvQyw2QkFBNkIsMEJBQTBCLDBCQUEwQixrQ0FBa0Msb0NBQW9DLGFBQWEsc0NBQXNDLGVBQWUsbUJBQW1CLGdEQUFnRCxnQkFBZ0I7QUFDNVMsZ0JBQWdCLFFBQVEsMkVBQTJFLEdBQUcsUUFBUSxXQUFXLDhGQUE4RixrQ0FBa0MsUUFBUSxLQUFLLGFBQWEsbUJBQW1CLHFCQUFxQixHQUFHLGtCQUFrQiwwSEFBMEgsWUFBWSxRQUFRLE9BQU8sU0FBUztBQUM5ZSxxRkFBcUYsWUFBWSxRQUFRLE9BQU8sU0FBUyxrQkFBa0Isc0JBQXNCLGdHQUFnRyxPQUFPLFFBQVEsdUZBQXVGLCtCQUErQjtBQUN0WSxpQkFBaUIscUNBQXFDLDhEQUE4RDtBQUNwSCxtQkFBbUIsY0FBYyxXQUFXLDBLQUEwSyxpQ0FBaUMsRUFBRSxjQUFjLDZDQUE2Qyx5QkFBeUIsRUFBRSxvRUFBb0Usd0JBQXdCLDREQUE0RCxxQkFBcUI7QUFDNWYsZ0JBQWdCLFlBQVksdUVBQXVFLDBFQUEwRSxvQkFBb0I7QUFDak0sZUFBZSxjQUFjLHlDQUF5QyxNQUFNLDJHQUEyRyx5Q0FBeUMsd0NBQXdDLDhCQUE4QixnQ0FBZ0Msa0NBQWtDLFNBQVMsb0dBQW9HLGtCQUFrQjtBQUN2ZSxlQUFlLGNBQWMsZUFBZSxrQkFBa0IsdUJBQXVCLHVHQUF1Ryx1QkFBdUIsdUNBQXVDLFlBQVksU0FBUyxTQUFTLFNBQVMsY0FBYyxRQUFRLCtCQUErQixvQkFBb0IseUJBQXlCLEdBQUcseUNBQXlDLG9FQUFvRTtBQUNuZixjQUFjLFNBQVMsb0JBQW9CLG1IQUFtSCxnQ0FBZ0MsMElBQTBJLHdDQUF3QyxTQUFTLG9FQUFvRSxXQUFXLEVBQUUsUUFBUSxXQUFXO0FBQzdkLEtBQUssV0FBVyxvQ0FBb0MseUJBQXlCLGdEQUFnRCwwQ0FBMEMsT0FBTyxlQUFlLDREQUE0RCxRQUFRLHVCQUF1QixtQkFBbUIsb0JBQW9CLCtDQUErQyx5Q0FBeUMsd0VBQXdFLFFBQVE7QUFDdmUsV0FBVztBQUNYLGNBQWMsWUFBWSxtQkFBbUIsb05BQW9OLElBQUksZ0NBQWdDLFNBQVMsc0JBQXNCLG9EQUFvRDtBQUN4WCxTQUFTLGVBQWUsaUJBQWlCLGdDQUFnQyxnRUFBZ0Usb1JBQW9SLE9BQU87QUFDcGEsZUFBZSw0QkFBNEIsc0JBQXNCLDJCQUEyQixPQUFPLFdBQVcsZ0NBQWdDLHVFQUF1RSwwQkFBMEIsT0FBTyxPQUFPLG9CQUFvQixhQUFhLHFGQUFxRiwwQkFBMEIsc0JBQXNCLGVBQWUsT0FBTztBQUN6YixlQUFlLGdEQUFnRCxlQUFlLFNBQVMsbUJBQW1CLFdBQVc7QUFDckgsbUJBQW1CLHdCQUF3QixLQUFLLHlJQUF5SSxzQkFBc0IsdURBQXVELDhFQUE4RSwwQkFBMEIsa0RBQWtELDJCQUEyQixhQUFhLEVBQUUsb0JBQW9CO0FBQzlkLDRCQUE0QixvREFBb0QsaUJBQWlCLDJCQUEyQiwyQ0FBMkMsRUFBRTtBQUN6SyxxQkFBcUIsa0RBQWtELGtDQUFrQyxtREFBbUQsZ0hBQWdILDBEQUEwRCxFQUFFLEdBQUcsRUFBRSxPQUFPLEdBQUcsSUFBSSxFQUFFLHNCQUFzQix5QkFBeUIsdUVBQXVFLGNBQWM7QUFDamUsb0JBQW9CLFlBQVksZUFBZSxPQUFPLHdDQUF3QyxnQkFBZ0Isc0lBQXNJLGFBQWEsZUFBZSx5QkFBeUIsaUJBQWlCLHNCQUFzQjtBQUNoVix1QkFBdUIsZ0NBQWdDLDZDQUE2QyxZQUFZLGFBQWEsZ0JBQWdCLG9HQUFvRyxjQUFjLFdBQVcsdUJBQXVCLFFBQVEsYUFBYSxnQkFBZ0IsMERBQTBELEVBQUUsNEJBQTRCLGNBQWMsc0JBQXNCO0FBQ2xjLGlCQUFpQixvREFBb0QscUJBQXFCLEVBQUUsMkJBQTJCLFdBQVcsdUNBQXVDLDRIQUE0SCxHQUFHLFFBQVEsZ0JBQWdCLGlFQUFpRSxpQkFBaUIsMERBQTBELGlFQUFpRSxvQ0FBb0MsT0FBTyxpQkFBaUIsZUFBZSxpQkFBaUIsdUNBQXVDLFNBQVMsU0FBUyx1QkFBdUIsd0JBQXdCLHFCQUFxQixFQUFFLGVBQWUsOEJBQThCLGtCQUFrQjtBQUN2eUIsVUFBVSxRQUFRLE9BQU8sb0JBQW9CLElBQUksa0JBQWtCLFNBQVMsdUJBQXVCLHdCQUF3QixRQUFRLGlDQUFpQyxpQ0FBaUMsR0FBRyxvQkFBb0IsSUFBSSxrQkFBa0IsU0FBUyx1QkFBdUIsd0JBQXdCLFFBQVEsaUNBQWlDLGlDQUFpQyxHQUFHLGtCQUFrQixvQkFBb0Isa0JBQWtCLG9CQUFvQixtQkFBbUI7QUFDdGQsbUJBQW1CLG9CQUFvQixPQUFPLGdCQUFnQixtQkFBbUIsYUFBYSxPQUFPLE9BQU8seUJBQXlCLGVBQWUsMkJBQTJCLHdCQUF3QixFQUFFLGVBQWUsMkJBQTJCLHdCQUF3QixFQUFFLGVBQWUsMkJBQTJCLHVCQUF1QixFQUFFLGdCQUFnQiwyQkFBMkIsdUJBQXVCLEVBQUUsaUJBQWlCLE1BQU0sa0RBQWtELFVBQVUsbUJBQW1CLGFBQWEsa0JBQWtCO0FBQ3poQixPQUFPLDhDQUE4QyxpRkFBaUYsZUFBZSxpQ0FBaUMsa0NBQWtDLFVBQVUsTUFBTSxHQUFHLFlBQVksWUFBWSxlQUFlLHdCQUF3QixTQUFTLG9EQUFvRCx1RUFBdUUsU0FBUztBQUN2YixHQUFHLEtBQUssa0RBQWtELEtBQUssaURBQWlELGtCQUFrQixTQUFTLGdCQUFnQixvQkFBb0Isc0JBQXNCLDJEQUEyRCwrQkFBK0Isa0JBQWtCLE9BQU8sZ0JBQWdCLDhCQUE4QjtBQUN0VyxtQkFBbUIsY0FBYyxPQUFPLHVHQUF1RyxPQUFPLDZEQUE2RCxtQkFBbUIsaUJBQWlCLEVBQUUsVUFBVSxrQkFBa0IsV0FBVztBQUNoUyxrQkFBa0IsNElBQTRJLHdCQUF3Qix5SEFBeUgsTUFBTSxvQ0FBb0Msd0NBQXdDLFFBQVEsZ0JBQWdCLDRFQUE0RSwwQ0FBMEMsaUJBQWlCLDRFQUE0RSxtQ0FBbUMsUUFBUSxzR0FBc0csZ0JBQWdCLHVCQUF1Qix3QkFBd0IsdUJBQXVCLEVBQUUsaUJBQWlCLHVCQUF1Qix3QkFBd0IsdUJBQXVCLEdBQUcsNkVBQTZFLGVBQWUsK0NBQStDO0FBQzFqQyxpQkFBaUIsWUFBWSxNQUFNLFlBQVksOENBQThDLHFEQUFxRCxhQUFhLHFDQUFxQyxTQUFTLG9IQUFvSDs7Ozs7Ozs7Ozs7QUN6SGpVO0FBQ0EsNEJBQTRCLG1CQUFtQixpQkFBaUIsZUFBZSx5QkFBeUIsaUJBQWlCLGVBQWUsUUFBUSxzRUFBc0UsVUFBVSx3QkFBd0IsdUVBQXVFO0FBQy9ULGVBQWUsZUFBZSxxQkFBcUIsb0NBQW9DLGdDQUFnQyx3Q0FBd0MsdUNBQXVDLDZLQUE2SyxvSkFBb0o7QUFDdmdCLGlFQUFpRSxTQUFTLGVBQWUsZUFBZSwwQ0FBMEMsbUJBQW1CLHNDQUFzQyxtQkFBbUIsb0JBQW9CLHVCQUF1Qiw4Q0FBOEMsa0JBQWtCLDRDQUE0QyxtQ0FBbUMscUJBQXFCLGtCQUFrQjtBQUMvYixtQkFBbUIsbUdBQW1HLGdDQUFnQyxpQkFBaUIsOENBQThDLGtCQUFrQixnQkFBZ0IsMEJBQTBCLHdCQUF3QixnQkFBZ0IsY0FBYyx3QkFBd0IsZ0JBQWdCLGtCQUFrQjtBQUNqWSxtQkFBbUIsOEJBQThCLDZCQUE2Qix3Q0FBd0MsbUJBQW1CLHdCQUF3QiwyQkFBMkIsS0FBSyx5SEFBeUgsNEJBQTRCLFFBQVEsbUJBQW1CLHdCQUF3QixLQUFLLGtDQUFrQyxFQUFFLDRDQUE0QyxXQUFXO0FBQ3plLEdBQUcsT0FBTyxrREFBa0Qsa0dBQWtHOztBQUU5Sjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxZQUFZLGFBQWEsT0FBTyw2Q0FBNkMsZ0RBQWdELGVBQWUsZ0ZBQWdGLFlBQVksV0FBVyxpQ0FBaUMsU0FBUyx5Q0FBeUMseUNBQXlDLGVBQWUsMkRBQTJELElBQUksb0NBQW9DLHlDQUF5QztBQUN0aUIsVUFBVSxlQUFlLG9FQUFvRSxJQUFJLGVBQWUsV0FBVyxpQ0FBaUMsU0FBUyxzQ0FBc0MsNENBQTRDLGVBQWUsc0VBQXNFLElBQUksMkNBQTJDLFNBQVMsMkNBQTJDLDBDQUEwQyxpQkFBaUIsUUFBUTtBQUNsZixjQUFjLHlCQUF5QixFQUFFLFNBQVMsdUNBQXVDLDZDQUE2QyxlQUFlLDJEQUEyRCxJQUFJLGdEQUFnRCxVQUFVLGlCQUFpQixHQUFHLDJEQUEyRCxJQUFJLHdDQUF3QyxJQUFJLFFBQVEsS0FBSztBQUMxWixlQUFlLGtEQUFrRCxtQkFBbUIsOEZBQThGLHlDQUF5QyxnQkFBZ0IsYUFBYTtBQUN4UCxpQkFBaUIsUUFBUSwyQkFBMkIsMkJBQTJCLDBDQUEwQyxVQUFVLEtBQUssMEJBQTBCLEdBQUcsMENBQTBDLDBDQUEwQyx3Q0FBd0MsOEhBQThILE9BQU8sT0FBTyxZQUFZLFNBQVMsaUJBQWlCLHVCQUF1QixNQUFNLEdBQUcsbUJBQW1CLE9BQU8sb0JBQW9CLE9BQU8sS0FBSyxTQUFTLEtBQUssY0FBYyx3QkFBd0IsY0FBYyxnQ0FBZ0MsY0FBYyw2Q0FBNkMsY0FBYyw0Q0FBNEMsaUJBQWlCLFNBQVMsaUVBQWlFLDJQQUEyUCxjQUFjLGlCQUFpQiwrQkFBK0I7QUFDeHBDLEdBQUcsd0JBQXdCLFFBQVEscUJBQXFCLFFBQVEsV0FBVyxzQ0FBc0MsbUNBQW1DLFFBQVEsV0FBVyxvQ0FBb0MsNkNBQTZDLEdBQUcscUJBQXFCLE1BQU0sWUFBWSxnQ0FBZ0MsY0FBYyxTQUFTLE1BQU0sVUFBVSxlQUFlLHVCQUF1QixtQkFBbUIsRUFBRSxNQUFNLDRCQUE0QiwrQ0FBK0MscUJBQXFCLFNBQVMsZ0JBQWdCLGlCQUFpQixnQkFBZ0Isb0NBQW9DLGlCQUFpQixzRUFBc0UsaUNBQWlDLGVBQWUsU0FBUyxTQUFTLGVBQWUsY0FBYyxZQUFZLFdBQVcsaUNBQWlDLGlCQUFpQixpSkFBaUosZ0JBQWdCLHVCQUF1QixjQUFjLGtCQUFrQixlQUFlLHdCQUF3QixlQUFlLHdIQUF3SCxpQkFBaUIsbUJBQW1CLHdEQUF3RCxrR0FBa0csS0FBSyxRQUFRLGdCQUFnQjtBQUN4OEMsaUJBQWlCLGlCQUFpQix3RUFBd0UsdUJBQXVCLDBCQUEwQiwwQkFBMEIsa0VBQWtFLG9DQUFvQywyQ0FBMkMsa0NBQWtDLCtIQUErSCxPQUFPO0FBQzllLGdCQUFnQixlQUFlLGtCQUFrQixnQkFBZ0IsZUFBZSx1REFBdUQsaUJBQWlCLG1CQUFtQixpQkFBaUIsS0FBSyxnQkFBZ0IsZ0JBQWdCLGVBQWUsaUJBQWlCLEtBQUssb0JBQW9CLGtCQUFrQixTQUFTLGNBQWMsbURBQW1ELFFBQVEsMENBQTBDLEtBQUs7QUFDN2EsbUJBQW1CLHNIQUFzSCxnREFBZ0Qsd0JBQXdCLEVBQUUsMkJBQTJCLGVBQWUsK0JBQStCLGdEQUFnRCxtREFBbUQsY0FBYyx3QkFBd0IscUZBQXFGLDZFQUE2RSxvQkFBb0Isc0NBQXNDLElBQUksU0FBUyxTQUFTLEVBQUUsRUFBRSw4RkFBOEYsc0JBQXNCLEtBQUssMkJBQTJCLElBQUksbUJBQW1CO0FBQ3QwQixrQkFBa0IscUJBQXFCLElBQUksNEJBQTRCLFNBQVMsU0FBUyxnQ0FBZ0MsMERBQTBELHVCQUF1QjtBQUMxTSx1QkFBdUIsMkNBQTJDLFlBQVksZUFBZSxRQUFRLHFEQUFxRCxNQUFNLGlCQUFpQixTQUFTLHFCQUFxQixJQUFJLFFBQVEsU0FBUyxrQ0FBa0MsU0FBUyxjQUFjO0FBQzdSLHVCQUF1QixnRkFBZ0YsaUJBQWlCLDBGQUEwRixpQ0FBaUMseUdBQXlHLG1CQUFtQixHQUFHO0FBQ2xYLHVCQUF1QixNQUFNLCtEQUErRCxZQUFZLCtCQUErQiw2Q0FBNkMsZUFBZSx1QkFBdUIsZ0JBQWdCLEdBQUcsZ0JBQWdCLDBEQUEwRCxFQUFFLFNBQVMscUJBQXFCLHVCQUF1QixtQkFBbUIsRUFBRSwyQ0FBMkM7QUFDOWEsdUJBQXVCLG1CQUFtQixFQUFFLHlEQUF5RCxlQUFlLG1CQUFtQixvQkFBb0Isd0JBQXdCLGNBQWMsYUFBYSxtQkFBbUIsU0FBUyxlQUFlLFNBQVMsbUJBQW1CLGlCQUFpQixpQkFBaUIsaUJBQWlCLFVBQVUsTUFBTSxxQkFBcUIsS0FBSyxFQUFFLE1BQU0sVUFBVSx5R0FBeUcsb0JBQW9CLElBQUksSUFBSSxXQUFXLEVBQUUseUJBQXlCLE1BQU0sTUFBTSxTQUFTLGlCQUFpQixZQUFZLFFBQVEsc0JBQXNCLE1BQU07QUFDcm9CLDRCQUE0QixZQUFZLFdBQVcsa0NBQWtDLFNBQVMsVUFBVSxlQUFlLHVCQUF1QixlQUFlLHdCQUF3QixnQkFBZ0IscUJBQXFCLGlCQUFpQixTQUFTLDBCQUEwQixZQUFZLGNBQWMsVUFBVSx1QkFBdUIsWUFBWSxnQkFBZ0IsWUFBWSxjQUFjLFNBQVMsaUJBQWlCLFlBQVksY0FBYyxtREFBbUQsaUJBQWlCLE1BQU0saUJBQWlCLE1BQU0sZ0JBQWdCLFNBQVMsZ0NBQWdDLGdCQUFnQixTQUFTLGlDQUFpQyxpQkFBaUIsU0FBUyxpQ0FBaUMsbUJBQW1CLGlCQUFpQixTQUFTLFNBQVMsU0FBUyxnQkFBZ0IsZ0JBQWdCLHFGQUFxRixrQkFBa0IsVUFBVSxrQkFBa0IsRUFBRTtBQUN0NkIsdUJBQXVCLFNBQVMsU0FBUyxNQUFNLG1DQUFtQyxPQUFPLFdBQVcsRUFBRSx5QkFBeUIsRUFBRSxnQ0FBZ0MsU0FBUyxtQ0FBbUMsbUNBQW1DLE9BQU8sMEJBQTBCLEVBQUUsUUFBUSxVQUFVLHNCQUFzQixNQUFNLHdCQUF3QixNQUFNLHFCQUFxQixNQUFNLCtEQUErRCx1Q0FBdUMsU0FBUztBQUN6ZSx5R0FBeUcsMkJBQTJCLGtDQUFrQyxpQ0FBaUMsbUNBQW1DLGFBQWEscUJBQXFCLHFCQUFxQixTQUFTLFNBQVMsU0FBUyxTQUFTLGlDQUFpQyxlQUFlO0FBQ3JYLG9CQUFvQiwyRUFBMkUsa0JBQWtCLDBCQUEwQiw0QkFBNEIscUJBQXFCLEVBQUUsNEJBQTRCLHFCQUFxQixFQUFFLDBCQUEwQixxQkFBcUIsRUFBRSwwQkFBMEIscUJBQXFCLEVBQUUsMEJBQTBCLHFCQUFxQixFQUFFLDBCQUEwQix3QkFBd0IsV0FBVyxRQUFRO0FBQ3pjLDBCQUEwQix3QkFBd0IsV0FBVyxRQUFRLEVBQUUsMkJBQTJCLHdCQUF3QixZQUFZLFFBQVEsRUFBRSwyQkFBMkIsd0JBQXdCLFlBQVksUUFBUSxFQUFFLGlDQUFpQyx3QkFBd0IsWUFBWSxXQUFXLEVBQUUsMkJBQTJCLHdCQUF3QixZQUFZLFdBQVcsRUFBRSw0QkFBNEIsd0JBQXdCLEVBQUUsMkJBQTJCLHdCQUF3QixFQUFFLGlCQUFpQiw2R0FBNkcsaUJBQWlCLFNBQVMsU0FBUyxXQUFXLFdBQVcsUUFBUSwyQkFBMkIsY0FBYyxxQkFBcUIsaUNBQWlDLDBCQUEwQixxQkFBcUIsaUJBQWlCLHNHQUFzRyxrSEFBa0gsdUJBQXVCLHdGQUF3RixFQUFFLGlCQUFpQixTQUFTLFNBQVMsOEJBQThCLFdBQVcsR0FBRywwREFBMEQsV0FBVztBQUM3eEMsUUFBUSwyQkFBMkIsMENBQTBDLGlDQUFpQywwQkFBMEIsa0JBQWtCLDhCQUE4QixjQUFjLGVBQWUsUUFBUSxVQUFVLDZCQUE2QixTQUFTLFNBQVMsU0FBUyxTQUFTLFVBQVUsU0FBUyxTQUFTLHNCQUFzQixXQUFXLGlDQUFpQyxlQUFlO0FBQ3JaLDRCQUE0Qix3RUFBd0UsOEJBQThCLGtDQUFrQyxlQUFlLElBQUksa0NBQWtDLHlCQUF5QixJQUFJLGlDQUFpQyx3Q0FBd0MsZ0JBQWdCLEtBQUssU0FBUyxxQ0FBcUMsU0FBUyxTQUFTLHVCQUF1QixJQUFJLGdDQUFnQyxnQkFBZ0I7QUFDL2QsNkJBQTZCLFNBQVMsSUFBSSxnQ0FBZ0MsMEJBQTBCLElBQUksNkJBQTZCLGNBQWMsTUFBTSxlQUFlLE1BQU0sZ0NBQWdDLG9DQUFvQyxlQUFlLEVBQUUsWUFBWSwyQkFBMkIsNENBQTRDLHNCQUFzQixTQUFTLGdCQUFnQixPQUFPLDBCQUEwQixFQUFFLFdBQVcsWUFBWSxnQkFBZ0IsU0FBUyxFQUFFLFNBQVM7QUFDbmUsNEJBQTRCLFNBQVMsSUFBSSw2QkFBNkIsK0RBQStELFdBQVcsSUFBSSxxQ0FBcUMsb0VBQW9FLFNBQVMsK0JBQStCLHVEQUF1RCxTQUFTLHFDQUFxQyxTQUFTO0FBQ25aLDBDQUEwQywyRUFBMkUsTUFBTSw4QkFBOEIsZUFBZSxJQUFJLGlDQUFpQyx3QkFBd0IsTUFBTSxpQ0FBaUMsV0FBVyxJQUFJLGdDQUFnQywwQkFBMEIsSUFBSSx3Q0FBd0MsU0FBUyxTQUFTLDZCQUE2QixJQUFJLGlDQUFpQyx1QkFBdUI7QUFDNWUsd0NBQXdDLCtCQUErQixNQUFNLHdDQUF3QyxTQUFTLGdEQUFnRCxvQkFBb0Isb0NBQW9DLGtCQUFrQixvQkFBb0IsU0FBUyxpRUFBaUUsTUFBTSw0Q0FBNEMsU0FBUyxTQUFTLGVBQWUsdUNBQXVDO0FBQ2hkLDZDQUE2QyxTQUFTLFNBQVMsZUFBZSxnQ0FBZ0MsSUFBSSw4QkFBOEIsWUFBWSxJQUFJLGVBQWUsRUFBRSxnQkFBZ0IsU0FBUyxTQUFTLHdDQUF3QyxTQUFTLFNBQVMsYUFBYSxLQUFLLFFBQVEsV0FBVyxLQUFLLGtCQUFrQiwyQkFBMkIsS0FBSyxRQUFRLFdBQVcsbUNBQW1DLFNBQVMsSUFBSSw0QkFBNEIsU0FBUyxJQUFJLGdCQUFnQixTQUFTLHlCQUF5QixZQUFZLFVBQVUsd0JBQXdCLE1BQU0scUJBQXFCLE1BQU0sdUNBQXVDLE1BQU0sa0JBQWtCLDZDQUE2QyxlQUFlLHNFQUFzRSwwQkFBMEIsMENBQTBDLHlCQUF5QjtBQUNwM0IsZ0NBQWdDLDJCQUEyQiw4QkFBOEIsVUFBVSxlQUFlLGVBQWUsaUNBQWlDLFFBQVEsMEJBQTBCLGVBQWUsaUNBQWlDLDBCQUEwQixpQkFBaUIsdUJBQXVCLGlEQUFpRCwyQkFBMkIsMkJBQTJCLGlCQUFpQix1QkFBdUIsOENBQThDLG1KQUFtSiwwQkFBMEI7QUFDaHFCLGlDQUFpQyxtRkFBbUYsZUFBZSxlQUFlLFNBQVMsUUFBUSwwQkFBMEIsZUFBZSxpQ0FBaUMseUJBQXlCLGlCQUFpQixpQkFBaUIsU0FBUyxTQUFTLFdBQVcsV0FBVyx5RUFBeUUsa0JBQWtCLElBQUksUUFBUSxjQUFjLGVBQWUsUUFBUSwyQkFBMkIsWUFBWSxNQUFNLDhDQUE4QyxVQUFVLGlDQUFpQyxnQ0FBZ0MsY0FBYyxlQUFlLFFBQVEsMkJBQTJCLFlBQVksV0FBVyxVQUFVLGlDQUFpQztBQUNwd0IsZUFBZSxzQkFBc0IsMkJBQTJCLGtCQUFrQixnRkFBZ0YsU0FBUyx1QkFBdUIsU0FBUyxLQUFLLHdCQUF3QixpQ0FBaUMsV0FBVyxxQkFBcUIsZUFBZSw0QkFBNEIsNkJBQTZCLEtBQUssV0FBVyx1RUFBdUUsS0FBSyxrQkFBa0I7QUFDL2QsaUNBQWlDLG1DQUFtQyxrQkFBa0IsOEJBQThCLGNBQWMsV0FBVyxRQUFRLFVBQVUsaUJBQWlCLFNBQVM7QUFDekwsbUJBQW1CLFdBQVcsYUFBYSx3Q0FBd0MsT0FBTyxLQUFLLGtCQUFrQixxQkFBcUIsNkJBQTZCLHNEQUFzRCwrQkFBK0Isb0VBQW9FLE9BQU8sSUFBSSxNQUFNLFVBQVUsc0VBQXNFLFVBQVUsTUFBTSxjQUFjLGNBQWMsTUFBTSxVQUFVO0FBQ3pkLGlDQUFpQywrQkFBK0IsY0FBYyxpQkFBaUIsb0JBQW9CLGVBQWUsU0FBUyxTQUFTLHFCQUFxQixXQUFXLFNBQVMsNkJBQTZCLGdEQUFnRCxhQUFhLEVBQUUsR0FBRyxTQUFTLFFBQVEsYUFBYSxxQ0FBcUMsS0FBSyxRQUFRLEtBQUssU0FBUztBQUMxWCwwQkFBMEIscUNBQXFDLHNDQUFzQyxvR0FBb0csZUFBZSx5QkFBeUIsYUFBYSx5Q0FBeUMseUJBQXlCLFVBQVUsZ0NBQWdDLHlCQUF5QjtBQUNuWSxnQ0FBZ0MsZ0RBQWdELGtDQUFrQyxhQUFhLG9CQUFvQixnQ0FBZ0MsY0FBYyxnQkFBZ0IsUUFBUSxVQUFVLHFCQUFxQixTQUFTLFNBQVMsU0FBUyxTQUFTLGlDQUFpQyxlQUFlLFVBQVUsb0JBQW9CLGdFQUFnRSxvQkFBb0I7QUFDOWIsMkJBQTJCLGdCQUFnQixlQUFlLGlCQUFpQixTQUFTLEtBQUssbUNBQW1DLFlBQVksbUJBQW1CLHNCQUFzQixTQUFTO0FBQzFMLG1DQUFtQyxvQkFBb0Isb0ZBQW9GLG1CQUFtQixtREFBbUQsT0FBTywyQ0FBMkMsb0VBQW9FLFNBQVMsc0NBQXNDLGtFQUFrRSxRQUFRO0FBQ2hjLGdEQUFnRCxZQUFZLDJCQUEyQixxQkFBcUIsMkNBQTJDLFlBQVksZUFBZSxnQkFBZ0IsNENBQTRDLHNCQUFzQixTQUFTLFFBQVEsb0NBQW9DLGdCQUFnQixnQkFBZ0Isa0JBQWtCLFNBQVMsS0FBSyx5QkFBeUIsYUFBYTtBQUMvWixnQ0FBZ0MsWUFBWSwwQkFBMEIsZ0RBQWdELGVBQWUsaUJBQWlCLFNBQVMsd0NBQXdDLGlCQUFpQixnQkFBZ0Isc0JBQXNCLHVCQUF1QixJQUFJLEtBQUssU0FBUyxXQUFXLG9CQUFvQixjQUFjLHVCQUF1QixJQUFJLHNEQUFzRCxTQUFTO0FBQzlhLG9DQUFvQyxnQkFBZ0Isb0JBQW9CLGlCQUFpQixTQUFTLEtBQUssOEJBQThCLFlBQVksaUJBQWlCLFNBQVMsS0FBSyxlQUFlLGVBQWUsU0FBUyxXQUFXLFdBQVcsUUFBUSwyQkFBMkIsb0JBQW9CLGlDQUFpQyx1Q0FBdUMsZUFBZSxlQUFlLFNBQVMsOEJBQThCLFdBQVcsR0FBRyw4QkFBOEIsV0FBVyxHQUFHLFFBQVEsMkJBQTJCLFlBQVkscUJBQXFCLFNBQVMsOEVBQThFLFVBQVUsRUFBRSxVQUFVLGlDQUFpQywrQkFBK0IsY0FBYyx1QkFBdUIsaUJBQWlCLFNBQVMsU0FBUyxlQUFlLGdCQUFnQixFQUFFLHFEQUFxRCxRQUFRLGFBQWEsWUFBWSwyQkFBMkIsT0FBTyxRQUFRLE1BQU0sS0FBSyw2QkFBNkIsNkJBQTZCLFlBQVksS0FBSyxTQUFTLDZCQUE2QixTQUFTLGdCQUFnQiwyQkFBMkIsaUJBQWlCLFNBQVM7QUFDL29DLGVBQWUsU0FBUyx3Q0FBd0MsZUFBZSxTQUFTLHFEQUFxRDtBQUM3SSxlQUFlLFNBQVMsZUFBZSxhQUFhLGFBQWEsOEZBQThGLFNBQVMsbUNBQW1DLFVBQVUsVUFBVSxLQUFLLEdBQUcsU0FBUyxjQUFjLFVBQVUscUVBQXFFLGdCQUFnQixRQUFRLG9CQUFvQixVQUFVLE1BQU0sMEJBQTBCLE1BQU0sd0VBQXdFO0FBQ2pmLGNBQWMsT0FBTyxTQUFTLFlBQVksRUFBRSx1Q0FBdUMsY0FBYyxxQkFBcUIsT0FBTyx3Q0FBd0MsTUFBTSxjQUFjLEtBQUssT0FBTyxRQUFRLHVCQUF1Qiw2Q0FBNkMsdUJBQXVCLGNBQWMsb0NBQW9DLEtBQUssV0FBVyxpRUFBaUU7QUFDM2EsaUJBQWlCLGdFQUFnRSxnQkFBZ0IsOEJBQThCLE9BQU8sU0FBUywwREFBMEQsZ0JBQWdCLFNBQVMsT0FBTyw4QkFBOEIsd0JBQXdCLDZFQUE2RSxhQUFhLGNBQWMsMkNBQTJDLE9BQU8seUJBQXlCLFVBQVUsU0FBUztBQUNyZSxVQUFVLCtDQUErQyxTQUFTLCtDQUErQyxVQUFVLG9CQUFvQiw4QkFBOEIsMEJBQTBCLG9CQUFvQixNQUFNLGFBQWEsb0RBQW9ELEtBQUssbUJBQW1CLG9CQUFvQixxRUFBcUUsZ0JBQWdCLGNBQWMsdUNBQXVDLG9CQUFvQjtBQUM1ZSxxQkFBcUIsZUFBZSxhQUFhLFlBQVksRUFBRSxPQUFPLHFDQUFxQyxZQUFZLFVBQVUsc0NBQXNDLFVBQVUsU0FBUyxlQUFlLDJDQUEyQyxZQUFZLG1CQUFtQixLQUFLLFVBQVUsWUFBWSx3REFBd0QsUUFBUSxZQUFZLFVBQVUsZUFBZSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx5Q0FBeUMsaURBQWlELGNBQWMsWUFBWSxpQkFBaUIscUVBQXFFLHFDQUFxQyxvR0FBb0csaUJBQWlCLG9EQUFvRCxRQUFRLGtEQUFrRCxpRUFBaUUsYUFBYSxzQkFBc0IsMENBQTBDLDRCQUE0QixpQkFBaUI7QUFDOW1DLGdCQUFnQiw4QkFBOEIsK0JBQStCLCtCQUErQixnQ0FBZ0Msa0RBQWtELHlHQUF5RyxrQkFBa0IsVUFBVSxrREFBa0QsTUFBTSxpREFBaUQsTUFBTSxrREFBa0QsTUFBTTtBQUMxZSxLQUFLLFNBQVMsZUFBZSxFQUFFLHFDQUFxQyx3QkFBd0IsNkJBQTZCLE1BQU0sc0JBQXNCLDJDQUEyQyxNQUFNLGtEQUFrRCxRQUFRLDRCQUE0Qix1RUFBdUUsZ0NBQWdDLDhCQUE4Qix3RUFBd0U7QUFDemUsZUFBZSxhQUFhLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlDQUFpQywrQkFBK0IsaUNBQWlDLCtCQUErQiw0QkFBNEIsNEJBQTRCLGVBQWU7QUFDcFIsaUJBQWlCLE9BQU8sbURBQW1ELCtEQUErRCxrQ0FBa0Msa0NBQWtDLG1CQUFtQixnQ0FBZ0Msa0JBQWtCLHlCQUF5Qix5QkFBeUIsY0FBYyxnQkFBZ0IsWUFBWSxnQkFBZ0IsbUJBQW1CLGlEQUFpRCxpREFBaUQsRUFBRSxhQUFhLDJDQUEyQyxZQUFZLHNCQUFzQixpQkFBaUIsdUJBQXVCLFdBQVcsMEJBQTBCLHNEQUFzRCxTQUFTLFNBQVMsOEJBQThCLG9DQUFvQztBQUN2eUIseUJBQXlCLHlCQUF5Qix5QkFBeUIseUJBQXlCLCtCQUErQixrQ0FBa0Msc0JBQXNCLHVCQUF1QixxQkFBcUIsdUJBQXVCLHVCQUF1Qiw0QkFBNEIsZ0NBQWdDLGdCQUFnQiw2QkFBNkIsOEJBQThCLFNBQVMsdUJBQXVCLHdQQUF3UCxlQUFlLDRCQUE0QixrQkFBa0Isc0NBQXNDLHVCQUF1Qix1RkFBdUYscUVBQXFFLFdBQVcsOENBQThDLDBCQUEwQiwwRUFBMEUsU0FBUyxHQUFHLGlCQUFpQixPQUFPLHNDQUFzQyxnQkFBZ0IsWUFBWSxzREFBc0QsaUJBQWlCLGtCQUFrQix1S0FBdUssVUFBVSxtQkFBbUIsRUFBRSwwQkFBMEIsRUFBRTtBQUN4Z0QsZUFBZSxTQUFTLDBCQUEwQixxQkFBcUIsc0ZBQXNGLElBQUksRUFBRSxhQUFhLFdBQVcsOEJBQThCLEVBQUUsaUJBQWlCLDJGQUEyRixTQUFTLGlCQUFpQix5Q0FBeUM7QUFDMVksZUFBZSw4RkFBOEYsZUFBZSxrQkFBa0IsOEdBQThHLGlIQUFpSCxtQkFBbUIsU0FBUyxTQUFTLFNBQVMsZ0NBQWdDLGlDQUFpQyxrQ0FBa0MsVUFBVSxpQ0FBaUMsZUFBZSxrQkFBa0IsZUFBZTtBQUN6bEIsaUNBQWlDLHNGQUFzRixvREFBb0QsbUNBQW1DLFFBQVEsbUVBQW1FLDhCQUE4QixvSkFBb0osdURBQXVEO0FBQ2xnQix1Q0FBdUMsUUFBUSw4RUFBOEUsaUNBQWlDLGVBQWUsVUFBVSxFQUFFLGlDQUFpQyxlQUFlLFVBQVUsRUFBRSxVQUFVLG1CQUFtQixlQUFlO0FBQ2pTLGtDQUFrQyxXQUFXLCtCQUErQix5Q0FBeUMsNkJBQTZCLGlDQUFpQyw0RkFBNEYsaURBQWlEO0FBQ2hVLG1DQUFtQyxVQUFVLG1CQUFtQixlQUFlO0FBQy9FLGtDQUFrQyxjQUFjLG1CQUFtQiwyRUFBMkUsRUFBRSxvQ0FBb0MsY0FBYyx1QkFBdUIsT0FBTyxzSUFBc0ksRUFBRSxtQkFBbUIsYUFBYSxTQUFTLGNBQWMsd0JBQXdCLGtCQUFrQjtBQUN6Yyx5RUFBeUUsRUFBRSxFQUFFLGdCQUFnQixVQUFVLG1CQUFtQixtQkFBbUIsbUJBQW1CLFlBQVksc0VBQXNFLG9EQUFvRCxjQUFjLGdEQUFnRCw0Q0FBNEMsc0VBQXNFO0FBQ3RkLDhGQUE4Riw0UEFBNFA7QUFDMVYsZ0xBQWdMLHNDQUFzQyxxSkFBcUosRUFBRSx3RUFBd0UsVUFBVSxrQkFBa0IsZUFBZTtBQUNoZSxpQ0FBaUMsbUVBQW1FLFdBQVcseUNBQXlDLGtDQUFrQyx5T0FBeU8sVUFBVSxrQkFBa0IsZUFBZTtBQUM5YyxpQ0FBaUMsbUVBQW1FLFdBQVcseUNBQXlDLGtDQUFrQyx5T0FBeU8sVUFBVSxxQkFBcUIsMkJBQTJCO0FBQzdkLHlCQUF5Qix5QkFBeUIsd0JBQXdCLHlCQUF5Qix1QkFBdUIsMEZBQTBGLHdCQUF3QixnQ0FBZ0Msc0JBQXNCLHlCQUF5QiwwQkFBMEIsMkJBQTJCLCtCQUErQiw0QkFBNEIsNkJBQTZCO0FBQ3hjLDRCQUE0Qiw4QkFBOEIsbUNBQW1DLG9DQUFvQywrQkFBK0IsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNEJBQTRCLDJCQUEyQixpQkFBaUIsVUFBVSxVQUFVLFNBQVMsdUJBQXVCLFFBQVEsaURBQWlELFlBQVksSUFBSSwyQ0FBMkMsNkNBQTZDLFdBQVcsK0JBQStCO0FBQzlqQixlQUFlLG9CQUFvQixnQkFBZ0IsYUFBYSxFQUFFLGFBQWEsMERBQTBELElBQUksYUFBYSxvQkFBb0IsU0FBUyxVQUFVLGFBQWEsNkVBQTZFLGFBQWEsb0JBQW9CLCtCQUErQjtBQUMzViwrQkFBK0IsMEVBQTBFLGFBQWEsVUFBVSxrQkFBa0IscUJBQXFCLFlBQVkseUJBQXlCLGVBQWUsWUFBWSxlQUFlLEdBQUcsU0FBUyxlQUFlLFlBQVksS0FBSyxLQUFLLE1BQU0sK0JBQStCLE1BQU0sTUFBTSxNQUFNLFVBQVUsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWM7QUFDaG1CLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsYUFBYSxVQUFVLEtBQUssV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLFVBQVUsS0FBSyxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sVUFBVSxLQUFLLFFBQVEsRUFBRSxZQUFZLEVBQUUsR0FBRyxVQUFVLE1BQU0sR0FBRyxVQUFVO0FBQ2xlLEdBQUcsVUFBVSxNQUFNLEdBQUcsVUFBVSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLEdBQUcsWUFBWSxNQUFNLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sR0FBRyxZQUFZLFVBQVUsV0FBVyxHQUFHLFlBQVksVUFBVSxlQUFlLGVBQWUsZUFBZSxlQUFlLFlBQVk7QUFDN2UsZ0JBQWdCLFlBQVksR0FBRyxHQUFHLFdBQVcsR0FBRyxPQUFPLGVBQWUsY0FBYyxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxvQkFBb0IsdUJBQXVCLEVBQUUsU0FBUyxNQUFNLFFBQVEsd0NBQXdDLGlkQUFpZCxxQkFBcUIsNkJBQTZCLHlEQUF5RCx5Q0FBeUMsc0RBQXNELGFBQWEsK0JBQStCLHlDQUF5QywyQkFBMkIsZ0JBQWdCLHdFQUF3RSxvQkFBb0IsVUFBVSxhQUFhLDBDQUEwQyx3Q0FBd0M7QUFDOXVDLE1BQU0sV0FBVyw2REFBNkQsSUFBSSxjQUFjLFVBQVUsNkJBQTZCLGlDQUFpQyxJQUFJLHFDQUFxQyxTQUFTLG9IQUFvSDs7Ozs7Ozs7Ozs7QUNwRzlVO0FBQ0EsNEJBQTRCLG1CQUFtQixpQkFBaUIsZUFBZSx5QkFBeUIsaUJBQWlCLGVBQWUsUUFBUSxzRUFBc0UsVUFBVSx3QkFBd0IsdUVBQXVFO0FBQy9ULGVBQWUsZUFBZSxxQkFBcUIsb0NBQW9DLGdDQUFnQyx3Q0FBd0MsdUNBQXVDLDZLQUE2SyxvSkFBb0o7QUFDdmdCLGlFQUFpRSxTQUFTLG1CQUFtQixzQ0FBc0MsbUJBQW1CLG9CQUFvQix1QkFBdUIsOENBQThDLGtCQUFrQiw0Q0FBNEMsbUNBQW1DLHFCQUFxQixrQkFBa0I7QUFDdlgsbUJBQW1CLG1HQUFtRyxnQ0FBZ0MsaUJBQWlCLDhDQUE4QyxrQkFBa0IsZ0JBQWdCLDBCQUEwQix3QkFBd0IsZ0JBQWdCLGNBQWMsd0JBQXdCLGtCQUFrQiwyQkFBMkI7O0FBRTVZOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTLFlBQVksYUFBYSw2Q0FBNkMsZ0RBQWdELGVBQWUsZ0ZBQWdGLFlBQVksV0FBVyxpQ0FBaUMsU0FBUyx5Q0FBeUMseUNBQXlDLGVBQWUsMkRBQTJELElBQUksb0NBQW9DLHlDQUF5QztBQUMvaEIsVUFBVSxlQUFlLG9FQUFvRSxJQUFJLGVBQWUsV0FBVyxpQ0FBaUMsU0FBUywyQ0FBMkMsMENBQTBDLGlCQUFpQixRQUFRLGtCQUFrQix5QkFBeUIsRUFBRSxTQUFTLHVDQUF1Qyw2Q0FBNkMsZUFBZSwyREFBMkQsSUFBSTtBQUMzZSxvQ0FBb0MsU0FBUyx3Q0FBd0MsOENBQThDLGVBQWUsMkRBQTJELElBQUksaURBQWlELFVBQVUsaUJBQWlCLEdBQUcsMkRBQTJELElBQUksd0NBQXdDLElBQUksUUFBUSxLQUFLO0FBQ3haLGVBQWUsa0RBQWtELG1CQUFtQiw4RkFBOEYseUNBQXlDLGdCQUFnQixhQUFhLG1EQUFtRCxpQkFBaUIsdUJBQXVCLE1BQU0sR0FBRyxtQkFBbUIsT0FBTyxvQkFBb0IsT0FBTyxLQUFLLFNBQVMsS0FBSyxjQUFjLHdCQUF3QixjQUFjLGdDQUFnQyxjQUFjLDZDQUE2QyxlQUFlLG9EQUFvRCx1QkFBdUIsR0FBRyxjQUFjLDRDQUE0QyxpQkFBaUIsU0FBUyxpRUFBaUUsME5BQTBOLGNBQWMsaUJBQWlCLCtCQUErQjtBQUM3akMsR0FBRyx3QkFBd0IsUUFBUSxzQkFBc0IsUUFBUSxXQUFXLHNDQUFzQyxtQ0FBbUMsUUFBUSxXQUFXLG9DQUFvQyw2Q0FBNkMsR0FBRyxxQkFBcUIsTUFBTSxZQUFZLGdDQUFnQyxjQUFjLFNBQVMsTUFBTTtBQUNoVyxlQUFlLHVCQUF1QixxR0FBcUcsVUFBVSxLQUFLLDBCQUEwQixHQUFHLDBDQUEwQywwQ0FBMEMsd0NBQXdDLDhIQUE4SCxPQUFPLE9BQU8sWUFBWSxZQUFZLEVBQUU7QUFDemQsNkJBQTZCLGlEQUFpRCxxQkFBcUIsU0FBUyxnQkFBZ0IsaUJBQWlCLGdCQUFnQixvQ0FBb0MsaUJBQWlCLHNFQUFzRSxpQ0FBaUMsZUFBZSxTQUFTLFNBQVMsZUFBZSxjQUFjLFlBQVksV0FBVyxpQ0FBaUMsaUJBQWlCLGlKQUFpSixnQkFBZ0IsdUJBQXVCLGNBQWMsa0JBQWtCLGVBQWUsd0JBQXdCLGlCQUFpQixzQkFBc0Isc0JBQXNCLDZCQUE2Qix5QkFBeUIseUJBQXlCLGFBQWEsOEJBQThCLDBCQUEwQiwwQkFBMEIsYUFBYSw4QkFBOEIsMEJBQTBCLDBCQUEwQixhQUFhLGlCQUFpQixhQUFhLGNBQWMsb0NBQW9DLCtCQUErQiw2QkFBNkIsaUNBQWlDLG1DQUFtQyxhQUFhLDhCQUE4QixrQ0FBa0Msb0NBQW9DLGFBQWEsOEJBQThCLGtDQUFrQyxvQ0FBb0MsYUFBYSxpQkFBaUIsbUJBQW1CLHdEQUF3RCxrR0FBa0csS0FBSyxRQUFRLGdCQUFnQjtBQUNockQsaUJBQWlCLGlCQUFpQix3RUFBd0Usd0JBQXdCLDBCQUEwQiwwQkFBMEIsa0VBQWtFLG9DQUFvQywyQ0FBMkMsa0NBQWtDLCtIQUErSCxPQUFPO0FBQy9lLGdCQUFnQixlQUFlLGtCQUFrQixnQkFBZ0IsZUFBZSx1REFBdUQsaUJBQWlCLG1CQUFtQixpQkFBaUIsS0FBSyxnQkFBZ0IsZ0JBQWdCLGVBQWUsaUJBQWlCLEtBQUssb0JBQW9CLGtCQUFrQixTQUFTLGNBQWMsbURBQW1ELGlCQUFpQixvQkFBb0IsWUFBWSxFQUFFLEVBQUUsaUJBQWlCLGVBQWUsSUFBSTtBQUMvYyxlQUFlLCtCQUErQixnREFBZ0QsbURBQW1ELGNBQWMsd0JBQXdCLHFGQUFxRiw2RUFBNkUsb0JBQW9CLHNDQUFzQyxJQUFJLFNBQVMsU0FBUyxFQUFFLEVBQUUsOEZBQThGLHNCQUFzQixLQUFLLDJCQUEyQixJQUFJLG1CQUFtQjtBQUN4bEIsa0JBQWtCLHFCQUFxQixJQUFJLDRCQUE0QixTQUFTLFNBQVMsZ0NBQWdDLDBEQUEwRCx1QkFBdUI7QUFDMU0sdUJBQXVCLDBDQUEwQyxZQUFZLGVBQWUsUUFBUSxxREFBcUQsTUFBTSxpQkFBaUIsU0FBUyxxQkFBcUIsSUFBSSxRQUFRLFNBQVMsa0NBQWtDLFNBQVMsY0FBYztBQUM1Uix1QkFBdUIsZ0ZBQWdGLGlCQUFpQiwwRkFBMEYsaUNBQWlDLHlHQUF5RyxtQkFBbUIsR0FBRztBQUNsWCx1QkFBdUIsTUFBTSw4REFBOEQsWUFBWSwrQkFBK0IsNkNBQTZDLGVBQWUsdUJBQXVCLGdCQUFnQixHQUFHLGdCQUFnQiwwREFBMEQsRUFBRSxTQUFTLHFCQUFxQix1QkFBdUIsbUJBQW1CLEVBQUUsMkNBQTJDO0FBQzdhLHVCQUF1QixtQkFBbUIsRUFBRSx5REFBeUQsZUFBZSxtQkFBbUIsb0JBQW9CLHdCQUF3QixjQUFjLGFBQWEsbUJBQW1CLFNBQVMsZUFBZSxTQUFTLG1CQUFtQixpQkFBaUIsaUJBQWlCLGlCQUFpQixVQUFVLE1BQU0scUJBQXFCLEtBQUssRUFBRSxNQUFNLFVBQVUseUdBQXlHLG9CQUFvQixJQUFJLElBQUksV0FBVyxFQUFFLHlCQUF5QixNQUFNLE1BQU0sU0FBUyxpQkFBaUIsWUFBWSxRQUFRLHNCQUFzQixNQUFNO0FBQ3JvQiw0QkFBNEIsWUFBWSxXQUFXLGtDQUFrQyxTQUFTLFVBQVUsZUFBZSx1QkFBdUIsZUFBZSx3QkFBd0IsZ0JBQWdCLHFCQUFxQixpQkFBaUIsU0FBUywwQkFBMEIsWUFBWSxjQUFjLFVBQVUsdUJBQXVCLFlBQVksZ0JBQWdCLFlBQVksY0FBYyxTQUFTLGlCQUFpQixZQUFZLGNBQWMsbURBQW1ELGlCQUFpQixNQUFNLGlCQUFpQixNQUFNLGdCQUFnQixTQUFTLGdDQUFnQyxnQkFBZ0IsU0FBUyxpQ0FBaUMsaUJBQWlCLFNBQVMsaUNBQWlDLG1CQUFtQixpQkFBaUIsU0FBUyxTQUFTLFNBQVMsZ0JBQWdCLGdCQUFnQixxRkFBcUYsa0JBQWtCLFVBQVUsa0JBQWtCLEVBQUU7QUFDdDZCLHVCQUF1QixTQUFTLFNBQVMsTUFBTSxtQ0FBbUMsT0FBTyxXQUFXLEVBQUUseUJBQXlCLEVBQUUsZ0NBQWdDLFNBQVMsbUNBQW1DLG1DQUFtQyxPQUFPLDBCQUEwQixFQUFFLFFBQVEsVUFBVSxzQkFBc0IsTUFBTSx3QkFBd0IsTUFBTSxxQkFBcUIsTUFBTSwrREFBK0QsdUNBQXVDLFNBQVM7QUFDemUseUdBQXlHLDJCQUEyQixrQ0FBa0MsaUNBQWlDLG1DQUFtQyxhQUFhLHFCQUFxQixxQkFBcUIsU0FBUyxTQUFTLFNBQVMsU0FBUyxpQ0FBaUMsZUFBZTtBQUNyWCxvQkFBb0IsMkVBQTJFLGtCQUFrQiwwQkFBMEIsNEJBQTRCLHFCQUFxQixFQUFFLDRCQUE0QixxQkFBcUIsRUFBRSwwQkFBMEIscUJBQXFCLEVBQUUsMEJBQTBCLHFCQUFxQixFQUFFLDBCQUEwQixxQkFBcUIsRUFBRSwwQkFBMEIsd0JBQXdCLFdBQVcsUUFBUTtBQUN6YywwQkFBMEIsd0JBQXdCLFdBQVcsUUFBUSxFQUFFLDJCQUEyQix3QkFBd0IsWUFBWSxRQUFRLEVBQUUsMkJBQTJCLHdCQUF3QixZQUFZLFFBQVEsRUFBRSxpQ0FBaUMsd0JBQXdCLFlBQVksV0FBVyxFQUFFLDJCQUEyQix3QkFBd0IsWUFBWSxXQUFXLEVBQUUsNEJBQTRCLHdCQUF3QixFQUFFLDJCQUEyQix3QkFBd0IsRUFBRSxpQkFBaUIsNkdBQTZHLGlCQUFpQixTQUFTLFNBQVMsV0FBVyxXQUFXLFFBQVEsMkJBQTJCLGNBQWMscUJBQXFCLGlDQUFpQywwQkFBMEIscUJBQXFCLGlCQUFpQixzR0FBc0csa0hBQWtILHVCQUF1Qix3RkFBd0YsRUFBRSxpQkFBaUIsU0FBUyxTQUFTLDhCQUE4QixXQUFXLEdBQUcsMERBQTBELFdBQVc7QUFDN3hDLFFBQVEsMkJBQTJCLDBDQUEwQyxpQ0FBaUMsMEJBQTBCLGtCQUFrQiw4QkFBOEIsY0FBYyxlQUFlLFFBQVEsVUFBVSw2QkFBNkIsU0FBUyxTQUFTLFNBQVMsU0FBUyxVQUFVLFNBQVMsU0FBUyxzQkFBc0IsV0FBVyxpQ0FBaUMsZUFBZTtBQUNyWiw0QkFBNEIsd0VBQXdFLDhCQUE4QixrQ0FBa0MsZUFBZSxJQUFJLGtDQUFrQyx5QkFBeUIsSUFBSSxpQ0FBaUMsd0NBQXdDLGdCQUFnQixLQUFLLFNBQVMscUNBQXFDLFNBQVMsU0FBUyx1QkFBdUIsSUFBSSxnQ0FBZ0MsZ0JBQWdCO0FBQy9kLDZCQUE2QixTQUFTLElBQUksZ0NBQWdDLDBCQUEwQixJQUFJLDZCQUE2QixjQUFjLE1BQU0sZUFBZSxNQUFNLGdDQUFnQyxvQ0FBb0MsZUFBZSxFQUFFLFlBQVksMkJBQTJCLDRDQUE0QyxzQkFBc0IsU0FBUyxnQkFBZ0IsT0FBTywwQkFBMEIsRUFBRSxXQUFXLFlBQVksZ0JBQWdCLFNBQVMsRUFBRSxTQUFTO0FBQ25lLDRCQUE0QixTQUFTLElBQUksNkJBQTZCLCtEQUErRCxXQUFXLElBQUkscUNBQXFDLG9FQUFvRSxTQUFTLCtCQUErQix1REFBdUQsU0FBUyxxQ0FBcUMsU0FBUztBQUNuWiwwQ0FBMEMsMkVBQTJFLE1BQU0sOEJBQThCLGVBQWUsSUFBSSxpQ0FBaUMsd0JBQXdCLE1BQU0saUNBQWlDLFdBQVcsSUFBSSxnQ0FBZ0MsMEJBQTBCLElBQUksd0NBQXdDLFNBQVMsU0FBUyw2QkFBNkIsSUFBSSxpQ0FBaUMsdUJBQXVCO0FBQzVlLHdDQUF3QywrQkFBK0IsTUFBTSx3Q0FBd0MsU0FBUyxnREFBZ0Qsb0JBQW9CLG9DQUFvQyxrQkFBa0Isb0JBQW9CLFNBQVMsaUVBQWlFLE1BQU0sNENBQTRDLFNBQVMsU0FBUyxlQUFlLHVDQUF1QztBQUNoZCw2Q0FBNkMsU0FBUyxTQUFTLGVBQWUsZ0NBQWdDLElBQUksOEJBQThCLFlBQVksSUFBSSxlQUFlLEVBQUUsZ0JBQWdCLFNBQVMsU0FBUyx3Q0FBd0MsU0FBUyxTQUFTLGFBQWEsS0FBSyxRQUFRLFdBQVcsS0FBSyxrQkFBa0IsMkJBQTJCLEtBQUssUUFBUSxXQUFXLG1DQUFtQyxTQUFTLElBQUksNEJBQTRCLFNBQVMsSUFBSSxnQkFBZ0IsU0FBUyx5QkFBeUIsWUFBWSxVQUFVLHdCQUF3QixNQUFNLHFCQUFxQixNQUFNLHVDQUF1QyxNQUFNLGtCQUFrQiw2Q0FBNkMsZUFBZSxzRUFBc0UsMEJBQTBCLDBDQUEwQyx5QkFBeUI7QUFDcDNCLGdDQUFnQywyQkFBMkIsOEJBQThCLFVBQVUsZUFBZSxlQUFlLGlDQUFpQyxRQUFRLDBCQUEwQixlQUFlLGlDQUFpQywwQkFBMEIsZ0JBQWdCLHVCQUF1QixpREFBaUQsMkJBQTJCLDBCQUEwQixpQkFBaUIsdUJBQXVCLDhDQUE4QyxtSkFBbUoseUJBQXlCO0FBQzdwQixnQ0FBZ0MsbUZBQW1GLGVBQWUsZUFBZSxTQUFTLFFBQVEsMEJBQTBCLGVBQWUsaUNBQWlDLHlCQUF5QixpQkFBaUIsaUJBQWlCLFNBQVMsU0FBUyxXQUFXLFdBQVcseUVBQXlFLGtCQUFrQixJQUFJLFFBQVEsY0FBYyxlQUFlLFFBQVEsMkJBQTJCLFlBQVksTUFBTSw4Q0FBOEMsVUFBVSxpQ0FBaUMsZ0NBQWdDLGNBQWMsZUFBZSxRQUFRLDJCQUEyQixZQUFZLFdBQVcsVUFBVSxpQ0FBaUM7QUFDbndCLGVBQWUsc0JBQXNCLDJCQUEyQixrQkFBa0IsZ0ZBQWdGLFNBQVMsdUJBQXVCLFNBQVMsS0FBSyx3QkFBd0IsaUNBQWlDLFdBQVcscUJBQXFCLGVBQWUsNEJBQTRCLDZCQUE2QixLQUFLLFdBQVcsdUVBQXVFLEtBQUssa0JBQWtCO0FBQy9kLGlDQUFpQyxtQ0FBbUMsa0JBQWtCLDhCQUE4QixjQUFjLFdBQVcsUUFBUSxVQUFVLGlCQUFpQixTQUFTO0FBQ3pMLG1CQUFtQixXQUFXLGFBQWEsd0NBQXdDLE9BQU8sS0FBSyxrQkFBa0IscUJBQXFCLDZCQUE2QixzREFBc0QsK0JBQStCLG9FQUFvRSxPQUFPLElBQUksTUFBTSxVQUFVLHNFQUFzRSxVQUFVLE1BQU0sY0FBYyxjQUFjLE1BQU0sVUFBVTtBQUN6ZCxpQ0FBaUMsK0JBQStCLGNBQWMsaUJBQWlCLG9CQUFvQixlQUFlLFNBQVMsU0FBUyxxQkFBcUIsV0FBVyxTQUFTLDZCQUE2QixnREFBZ0QsYUFBYSxFQUFFLEdBQUcsU0FBUyxRQUFRLGFBQWEscUNBQXFDLEtBQUssUUFBUSxLQUFLLFNBQVM7QUFDMVgsMEJBQTBCLHFDQUFxQyxzQ0FBc0Msb0dBQW9HLGVBQWUseUJBQXlCLGFBQWEseUNBQXlDLHlCQUF5QixVQUFVLGdDQUFnQyx5QkFBeUI7QUFDblksZ0NBQWdDLGdEQUFnRCxrQ0FBa0MsYUFBYSxvQkFBb0IsZ0NBQWdDLGNBQWMsZ0JBQWdCLFFBQVEsVUFBVSxxQkFBcUIsU0FBUyxTQUFTLFNBQVMsU0FBUyxpQ0FBaUMsZUFBZSxVQUFVLG9CQUFvQixnRUFBZ0Usb0JBQW9CO0FBQzliLDJCQUEyQixnQkFBZ0IsZUFBZSxpQkFBaUIsU0FBUyxLQUFLLG1DQUFtQyxZQUFZLG1CQUFtQixzQkFBc0IsU0FBUztBQUMxTCxtQ0FBbUMsb0JBQW9CLG9GQUFvRixtQkFBbUIsbURBQW1ELE9BQU8sMkNBQTJDLG9FQUFvRSxTQUFTLHNDQUFzQyxrRUFBa0UsUUFBUTtBQUNoYyxnREFBZ0QsWUFBWSwyQkFBMkIscUJBQXFCLDJDQUEyQyxZQUFZLGVBQWUsZ0JBQWdCLDRDQUE0QyxzQkFBc0IsU0FBUyxRQUFRLG9DQUFvQyxnQkFBZ0IsZ0JBQWdCLGtCQUFrQixTQUFTLEtBQUsseUJBQXlCLGFBQWE7QUFDL1osZ0NBQWdDLFlBQVksMEJBQTBCLGdEQUFnRCxlQUFlLGlCQUFpQixTQUFTLHdDQUF3QyxpQkFBaUIsZ0JBQWdCLHNCQUFzQix1QkFBdUIsSUFBSSxLQUFLLFNBQVMsV0FBVyxvQkFBb0IsY0FBYyx1QkFBdUIsSUFBSSxzREFBc0QsU0FBUztBQUM5YSxvQ0FBb0MsZ0JBQWdCLG9CQUFvQixpQkFBaUIsU0FBUyxLQUFLLDhCQUE4QixZQUFZLGlCQUFpQixTQUFTLEtBQUssZUFBZSxlQUFlLFNBQVMsV0FBVyxXQUFXLFFBQVEsMkJBQTJCLG9CQUFvQixpQ0FBaUMsdUNBQXVDLGVBQWUsZUFBZSxTQUFTLDhCQUE4QixXQUFXLEdBQUcsOEJBQThCLFdBQVcsR0FBRyxRQUFRLDJCQUEyQixZQUFZLHFCQUFxQixTQUFTLDhFQUE4RSxVQUFVLEVBQUUsVUFBVSxpQ0FBaUMsK0JBQStCLGNBQWMsdUJBQXVCLGlCQUFpQixTQUFTLFNBQVMsZUFBZSxnQkFBZ0IsRUFBRSxxREFBcUQsUUFBUSxhQUFhLFlBQVksMkJBQTJCLE9BQU8sUUFBUSxNQUFNLEtBQUssNkJBQTZCLDZCQUE2QixZQUFZLEtBQUssU0FBUyw2QkFBNkIsU0FBUyxnQkFBZ0IsMkJBQTJCLGlCQUFpQixTQUFTO0FBQy9vQyxlQUFlLFNBQVMsd0NBQXdDLGVBQWUsU0FBUyxxREFBcUQ7QUFDN0ksZUFBZSxTQUFTLGVBQWUsYUFBYSxhQUFhLDhGQUE4RixTQUFTLG1DQUFtQyxVQUFVLFVBQVUsS0FBSyxHQUFHLFNBQVMsY0FBYyxVQUFVLHFFQUFxRSxnQkFBZ0IsUUFBUSxvQkFBb0IsVUFBVSxNQUFNLDBCQUEwQixNQUFNLHdFQUF3RTtBQUNqZixjQUFjLE9BQU8sU0FBUyxZQUFZLEVBQUUsdUNBQXVDLGNBQWMscUJBQXFCLE9BQU8sd0NBQXdDLE1BQU0sY0FBYyxLQUFLLE9BQU8sUUFBUSx1QkFBdUIsNkNBQTZDLHVCQUF1QixjQUFjLG9DQUFvQyxLQUFLLFdBQVcsaUVBQWlFO0FBQzNhLGlCQUFpQixnRUFBZ0UsZ0JBQWdCLDhCQUE4QixPQUFPLFNBQVMsMERBQTBELGdCQUFnQixTQUFTLE9BQU8sOEJBQThCLHdCQUF3Qiw2RUFBNkUsYUFBYSxjQUFjLDJDQUEyQyxPQUFPLHlCQUF5QixVQUFVLFNBQVM7QUFDcmUsVUFBVSwrQ0FBK0MsU0FBUywrQ0FBK0MsVUFBVSxvQkFBb0IsOEJBQThCLDBCQUEwQixvQkFBb0IsTUFBTSxhQUFhLG1EQUFtRCxLQUFLLG1CQUFtQixvQkFBb0IscUVBQXFFLGdCQUFnQixhQUFhLHVDQUF1QyxvQkFBb0I7QUFDMWUsYUFBYSxlQUFlLGFBQWEsWUFBWSxFQUFFLE9BQU8scUNBQXFDLFlBQVksVUFBVSxzQ0FBc0MsVUFBVSxTQUFTLGVBQWUsMkNBQTJDLFlBQVksbUJBQW1CLEtBQUssVUFBVSxZQUFZLHdEQUF3RCxRQUFRLFlBQVksVUFBVSxlQUFlLG1CQUFtQix1QkFBdUIsb0NBQW9DLHlDQUF5QyxpREFBaUQsY0FBYyxZQUFZLGlCQUFpQixxRUFBcUUscUNBQXFDLG9HQUFvRyxpQkFBaUIsb0RBQW9ELFFBQVEsa0RBQWtELGlFQUFpRSxhQUFhLHNCQUFzQiwwQ0FBMEMsNEJBQTRCLGlCQUFpQjtBQUN0bUMsZ0JBQWdCLDhCQUE4QiwrQkFBK0IsK0JBQStCLGdDQUFnQyxrREFBa0QseUdBQXlHLGtCQUFrQixVQUFVLGtEQUFrRCxNQUFNLGlEQUFpRCxNQUFNLGtEQUFrRCxNQUFNO0FBQzFlLEtBQUssU0FBUyxlQUFlLEVBQUUscUNBQXFDLHdCQUF3Qiw2QkFBNkIsTUFBTSxzQkFBc0IsMkNBQTJDLE1BQU0sa0RBQWtELFFBQVEsNEJBQTRCLHVFQUF1RSxnQ0FBZ0MsOEJBQThCLHdFQUF3RTtBQUN6ZSxlQUFlLGFBQWEsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUNBQWlDLCtCQUErQixpQ0FBaUMsK0JBQStCLDRCQUE0Qiw0QkFBNEIsZUFBZTtBQUNwUixpQkFBaUIsT0FBTyxtREFBbUQsK0RBQStELGtDQUFrQyxrQ0FBa0MsbUJBQW1CLGdDQUFnQyxrQkFBa0IseUJBQXlCLHlCQUF5QixRQUFRO0FBQzdVO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOFhBQThYLHlMQUF5TCxFQUFFLEVBQUUsSUFBSSx3QkFBd0IsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJLGlEQUFpRCxJQUFJLGdCQUFnQixJQUFJLGdCQUFnQixJQUFJLE9BQU8saUJBQWlCLFlBQVksZ0JBQWdCLG1CQUFtQixpREFBaUQsaURBQWlELEVBQUUsYUFBYSwyQ0FBMkMsWUFBWSxzQkFBc0IsaUJBQWlCLHVCQUF1QixZQUFZLDBCQUEwQixzREFBc0QsU0FBUyxTQUFTLDhCQUE4QixvQ0FBb0M7QUFDL3FDLHlCQUF5Qix5QkFBeUIseUJBQXlCLHlCQUF5QiwrQkFBK0Isa0NBQWtDLHNCQUFzQix1QkFBdUIscUJBQXFCLHVCQUF1Qix1QkFBdUIsNEJBQTRCLGdDQUFnQyxnQkFBZ0IsNkJBQTZCLDhCQUE4QixTQUFTLHVCQUF1Qix3UEFBd1AsZUFBZSw0QkFBNEIsWUFBWSxzQ0FBc0MsdUJBQXVCLHVGQUF1RixxRUFBcUUsV0FBVyw4Q0FBOEMsMEJBQTBCLDBFQUEwRSxTQUFTLElBQUksMkJBQTJCLGdCQUFnQix5Q0FBeUMsNERBQTRELGtCQUFrQixPQUFPLGdDQUFnQyxtQkFBbUIsbUJBQW1CO0FBQzcxQyxpQkFBaUIsV0FBVyxrQ0FBa0Msb0RBQW9ELElBQUksa0VBQWtFLG9EQUFvRCxzQkFBc0IsWUFBWSxtQ0FBbUMsV0FBVyxLQUFLLDRCQUE0QixhQUFhLHdCQUF3QixPQUFPLDhCQUE4QixpQkFBaUIsUUFBUSxRQUFRLEdBQUcscUJBQXFCLGNBQWM7QUFDOWUsTUFBTSxJQUFJLGdDQUFnQyxTQUFTLHNIQUFzSCxVQUFVLFNBQVM7QUFDNUwsaUJBQWlCLGlCQUFpQixjQUFjLGtKQUFrSixHQUFHLG1JQUFtSSxVQUFVLHFCQUFxQixTQUFTLFNBQVMsU0FBUyxTQUFTLDZCQUE2Qix5QkFBeUIseUJBQXlCLHlCQUF5Qix5QkFBeUIsYUFBYSw4QkFBOEIsMEJBQTBCLDBCQUEwQiwwQkFBMEIsMEJBQTBCLGFBQWEsOEJBQThCLDBCQUEwQiwwQkFBMEIsMEJBQTBCLDBCQUEwQixhQUFhLG9CQUFvQixTQUFTLFNBQVMsYUFBYSxjQUFjLDRCQUE0Qix5QkFBeUIseUJBQXlCLGlDQUFpQyxtQ0FBbUMsYUFBYSw2QkFBNkIsMEJBQTBCLDBCQUEwQixrQ0FBa0Msb0NBQW9DO0FBQ3RyQyw2QkFBNkIsMEJBQTBCLDBCQUEwQixrQ0FBa0Msb0NBQW9DLGFBQWEsc0NBQXNDLGVBQWUsbUJBQW1CLGdEQUFnRCxnQkFBZ0I7QUFDNVMsZ0JBQWdCLFFBQVEsMkVBQTJFLEdBQUcsUUFBUSxXQUFXLDhGQUE4RixrQ0FBa0MsUUFBUSxLQUFLLGFBQWEsbUJBQW1CLHFCQUFxQixHQUFHLGtCQUFrQiwwSEFBMEgsWUFBWSxRQUFRLE9BQU8sU0FBUztBQUM5ZSxxRkFBcUYsWUFBWSxRQUFRLE9BQU8sU0FBUyxrQkFBa0Isc0JBQXNCLGdHQUFnRyxPQUFPLFFBQVEsdUZBQXVGLCtCQUErQjtBQUN0WSxpQkFBaUIscUNBQXFDLDBFQUEwRTtBQUNoSSxtQkFBbUIsY0FBYyxZQUFZLDBLQUEwSyxpQ0FBaUMsRUFBRSxjQUFjLDZDQUE2Qyx5QkFBeUIsRUFBRSxvRUFBb0Usd0JBQXdCLDREQUE0RCxxQkFBcUI7QUFDN2YsZ0JBQWdCLFlBQVksdUVBQXVFLDBFQUEwRSxvQkFBb0IscUVBQXFFO0FBQ3RRLGVBQWUsY0FBYyxlQUFlLGtCQUFrQix1QkFBdUIsdUdBQXVHLHVCQUF1Qix1Q0FBdUMsWUFBWSxTQUFTLFNBQVMsU0FBUyxjQUFjLFFBQVEsK0JBQStCLG9CQUFvQix5QkFBeUIsR0FBRyx5Q0FBeUMsb0VBQW9FO0FBQ25mLGNBQWMsU0FBUyxvQkFBb0IsbUhBQW1ILGdDQUFnQywwSUFBMEksd0NBQXdDLFNBQVMsb0VBQW9FLFdBQVcsRUFBRSxRQUFRLFdBQVc7QUFDN2QsS0FBSyxZQUFZLG9DQUFvQyx3QkFBd0IsK0NBQStDLHlDQUF5QyxPQUFPLGNBQWMsMkRBQTJELFFBQVEsdUJBQXVCLG1CQUFtQixvQkFBb0IsK0NBQStDLHlDQUF5Qyx3RUFBd0UsUUFBUSx5QkFBeUI7QUFDNWYsZUFBZSxZQUFZLG1CQUFtQixvTkFBb04sSUFBSSxnQ0FBZ0MsU0FBUyxzQkFBc0Isb0RBQW9EO0FBQ3pYLFNBQVMsZUFBZSxpQkFBaUIsZ0NBQWdDLGdFQUFnRSxvUkFBb1IsT0FBTztBQUNwYSxlQUFlLDRCQUE0QixzQkFBc0IsMkJBQTJCLE9BQU8sV0FBVyxnQ0FBZ0MsdUVBQXVFLDBCQUEwQixPQUFPLE9BQU8sb0JBQW9CLGFBQWEscUZBQXFGLDBCQUEwQixzQkFBc0IsZUFBZSxRQUFRO0FBQzFiLGVBQWUsT0FBTyx3Q0FBd0MsZ0JBQWdCLHNJQUFzSSxhQUFhLGVBQWUseUJBQXlCLGlCQUFpQixzQkFBc0IsVUFBVSxxQkFBcUIsY0FBYyx5Q0FBeUMsTUFBTSwyR0FBMkcseUNBQXlDLHdDQUF3Qyw4QkFBOEIsZ0NBQWdDLGtDQUFrQyxTQUFTLG9HQUFvRyxtQkFBbUIsSUFBSSxxQ0FBcUMsU0FBUyxvSEFBb0g7Ozs7Ozs7Ozs7O0FDcEc5OEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7QUN0REQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUSxZQUFZO0FBQ3BCLFFBQVEsV0FBVztBQUNuQixRQUFRLFdBQVc7QUFDbkIsUUFBUSxpQkFBaUI7QUFDekIsUUFBUSxhQUFhO0FBQ3JCLFFBQVEsd0JBQXdCO0FBQ2hDLFFBQVEsZ0JBQWdCO0FBQ3hCLFFBQVEsY0FBYyxHQUFHO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sc0RBQXNEO0FBQzVEO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxNQUFNO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHNEQUFzRDtBQUM1RDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXLElBQUksV0FBVztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxjQUFjLFNBQVMsNEJBQTRCO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQVc7O0FBRW5DO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDBEQUEwRDtBQUM5RCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksc0RBQXNEO0FBQzFEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxzQ0FBc0M7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0NBQXNDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0saUVBQWlFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHFEQUFxRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBOztBQUVBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtEQUFrRDtBQUMvRDtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNkJBQTZCO0FBQ25DO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkNBQTJDO0FBQ2pEO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDemlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxHQUFHO0FBQ2hCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLDZEQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQix1REFBdUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFD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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0YsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFsYW5jZWQtbWF0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JyYWNlLWV4cGFuc2lvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29uY2F0LW1hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mcy5yZWFscGF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnMucmVhbHBhdGgvb2xkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYi9nbG9iLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iL3N5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luZmxpZ2h0L2luZmxpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jcmMzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZXh0ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0FycmF5UmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0RhdGFSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvTm9kZUJ1ZmZlclJlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9TdHJpbmdSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvVWludDhBcnJheVJlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zaWduYXR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ29udmVydFdvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFMZW5ndGhQcm9iZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhV29ya2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0dlbmVyaWNXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vU3RyZWFtSGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9taW5pbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhdGgtaXMtYWJzb2x1dGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yaW1yYWYvcmltcmFmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvYmlkaS9icm93c2luZ0NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9iaWRpL2Jyb3dzaW5nQ29udGV4dEluc3BlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2JpZGkvYnJvd3NpbmdDb250ZXh0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9iaWRpL2V2YWx1YXRlUmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvYmlkaS9maWx0ZXJCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2JpZGkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9iaWRpL2xvZ0VudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9iaWRpL2xvZ0luc3BlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2JpZGkvcHJvdG9jb2xUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvYmlkaS9wcm90b2NvbFZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvYmlkaS9yZWFsbUluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9iaWRpL3NjcmlwdE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9jaHJvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9jaHJvbWl1bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2NvbW1vbi9kcml2ZXJGaW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9jb21tb24vc2VsZW5pdW1NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvZGV2dG9vbHMvQ0RQQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2VkZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9maXJlZm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvaHR0cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2h0dHAvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2llLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9pby9leGVjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvaW8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9pby96aXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvYXRvbXMvZmluZC1lbGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9nZXQtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2F0b21zL2lzLWRpc3BsYXllZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9tdXRhdGlvbi1saXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy8gc3luYyBeXFwuXFwvLiokIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2NhcGFiaWxpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9jb21tYW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2h0dHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvbG9nZ2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9waW5uZWRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9zeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL3VudGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvdmlydHVhbF9hdXRoZW50aWNhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL3dlYmRyaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi93ZWJlbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliLyBzeW5jIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbmV0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbmV0L3BvcnRwcm9iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9yZW1vdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9yZW1vdGUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL3NhZmFyaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG1wL2xpYi90bXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL25vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImJ1ZmZlclwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY2hpbGRfcHJvY2Vzc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY3J5cHRvXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJlbGVjdHJvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTpldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm9zXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwcm9jZXNzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJzdHJlYW1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInVybFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXRpbFwiIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9wcmVsb2FkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShnbG9iYWwsICgpID0+IHtcbnJldHVybiAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGJhbGFuY2VkO1xuZnVuY3Rpb24gYmFsYW5jZWQoYSwgYiwgc3RyKSB7XG4gIGlmIChhIGluc3RhbmNlb2YgUmVnRXhwKSBhID0gbWF5YmVNYXRjaChhLCBzdHIpO1xuICBpZiAoYiBpbnN0YW5jZW9mIFJlZ0V4cCkgYiA9IG1heWJlTWF0Y2goYiwgc3RyKTtcblxuICB2YXIgciA9IHJhbmdlKGEsIGIsIHN0cik7XG5cbiAgcmV0dXJuIHIgJiYge1xuICAgIHN0YXJ0OiByWzBdLFxuICAgIGVuZDogclsxXSxcbiAgICBwcmU6IHN0ci5zbGljZSgwLCByWzBdKSxcbiAgICBib2R5OiBzdHIuc2xpY2UoclswXSArIGEubGVuZ3RoLCByWzFdKSxcbiAgICBwb3N0OiBzdHIuc2xpY2UoclsxXSArIGIubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXliZU1hdGNoKHJlZywgc3RyKSB7XG4gIHZhciBtID0gc3RyLm1hdGNoKHJlZyk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5cbmJhbGFuY2VkLnJhbmdlID0gcmFuZ2U7XG5mdW5jdGlvbiByYW5nZShhLCBiLCBzdHIpIHtcbiAgdmFyIGJlZ3MsIGJlZywgbGVmdCwgcmlnaHQsIHJlc3VsdDtcbiAgdmFyIGFpID0gc3RyLmluZGV4T2YoYSk7XG4gIHZhciBiaSA9IHN0ci5pbmRleE9mKGIsIGFpICsgMSk7XG4gIHZhciBpID0gYWk7XG5cbiAgaWYgKGFpID49IDAgJiYgYmkgPiAwKSB7XG4gICAgaWYoYT09PWIpIHtcbiAgICAgIHJldHVybiBbYWksIGJpXTtcbiAgICB9XG4gICAgYmVncyA9IFtdO1xuICAgIGxlZnQgPSBzdHIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPj0gMCAmJiAhcmVzdWx0KSB7XG4gICAgICBpZiAoaSA9PSBhaSkge1xuICAgICAgICBiZWdzLnB1c2goaSk7XG4gICAgICAgIGFpID0gc3RyLmluZGV4T2YoYSwgaSArIDEpO1xuICAgICAgfSBlbHNlIGlmIChiZWdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IFsgYmVncy5wb3AoKSwgYmkgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlZyA9IGJlZ3MucG9wKCk7XG4gICAgICAgIGlmIChiZWcgPCBsZWZ0KSB7XG4gICAgICAgICAgbGVmdCA9IGJlZztcbiAgICAgICAgICByaWdodCA9IGJpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmkgPSBzdHIuaW5kZXhPZihiLCBpICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGkgPSBhaSA8IGJpICYmIGFpID49IDAgPyBhaSA6IGJpO1xuICAgIH1cblxuICAgIGlmIChiZWdzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gWyBsZWZ0LCByaWdodCBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJ2YXIgY29uY2F0TWFwID0gcmVxdWlyZSgnY29uY2F0LW1hcCcpO1xudmFyIGJhbGFuY2VkID0gcmVxdWlyZSgnYmFsYW5jZWQtbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBhbmRUb3A7XG5cbnZhciBlc2NTbGFzaCA9ICdcXDBTTEFTSCcrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NPcGVuID0gJ1xcME9QRU4nK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ2xvc2UgPSAnXFwwQ0xPU0UnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ29tbWEgPSAnXFwwQ09NTUEnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjUGVyaW9kID0gJ1xcMFBFUklPRCcrTWF0aC5yYW5kb20oKSsnXFwwJztcblxuZnVuY3Rpb24gbnVtZXJpYyhzdHIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApID09IHN0clxuICAgID8gcGFyc2VJbnQoc3RyLCAxMClcbiAgICA6IHN0ci5jaGFyQ29kZUF0KDApO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcXFxcXFxcJykuam9pbihlc2NTbGFzaClcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXHsnKS5qb2luKGVzY09wZW4pXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx9Jykuam9pbihlc2NDbG9zZSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXCwnKS5qb2luKGVzY0NvbW1hKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLicpLmpvaW4oZXNjUGVyaW9kKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoZXNjU2xhc2gpLmpvaW4oJ1xcXFwnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY09wZW4pLmpvaW4oJ3snKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0Nsb3NlKS5qb2luKCd9JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDb21tYSkuam9pbignLCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjUGVyaW9kKS5qb2luKCcuJyk7XG59XG5cblxuLy8gQmFzaWNhbGx5IGp1c3Qgc3RyLnNwbGl0KFwiLFwiKSwgYnV0IGhhbmRsaW5nIGNhc2VzXG4vLyB3aGVyZSB3ZSBoYXZlIG5lc3RlZCBicmFjZWQgc2VjdGlvbnMsIHdoaWNoIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBhcyBpbmRpdmlkdWFsIG1lbWJlcnMsIGxpa2Uge2Ese2IsY30sZH1cbmZ1bmN0aW9uIHBhcnNlQ29tbWFQYXJ0cyhzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFsnJ107XG5cbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG5cbiAgaWYgKCFtKVxuICAgIHJldHVybiBzdHIuc3BsaXQoJywnKTtcblxuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBib2R5ID0gbS5ib2R5O1xuICB2YXIgcG9zdCA9IG0ucG9zdDtcbiAgdmFyIHAgPSBwcmUuc3BsaXQoJywnKTtcblxuICBwW3AubGVuZ3RoLTFdICs9ICd7JyArIGJvZHkgKyAnfSc7XG4gIHZhciBwb3N0UGFydHMgPSBwYXJzZUNvbW1hUGFydHMocG9zdCk7XG4gIGlmIChwb3N0Lmxlbmd0aCkge1xuICAgIHBbcC5sZW5ndGgtMV0gKz0gcG9zdFBhcnRzLnNoaWZ0KCk7XG4gICAgcC5wdXNoLmFwcGx5KHAsIHBvc3RQYXJ0cyk7XG4gIH1cblxuICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwKTtcblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvcChzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIC8vIEkgZG9uJ3Qga25vdyB3aHkgQmFzaCA0LjMgZG9lcyB0aGlzLCBidXQgaXQgZG9lcy5cbiAgLy8gQW55dGhpbmcgc3RhcnRpbmcgd2l0aCB7fSB3aWxsIGhhdmUgdGhlIGZpcnN0IHR3byBieXRlcyBwcmVzZXJ2ZWRcbiAgLy8gYnV0ICpvbmx5KiBhdCB0aGUgdG9wIGxldmVsLCBzbyB7fSxhfWIgd2lsbCBub3QgZXhwYW5kIHRvIGFueXRoaW5nLFxuICAvLyBidXQgYXt9LGJ9YyB3aWxsIGJlIGV4cGFuZGVkIHRvIFthfWMsYWJjXS5cbiAgLy8gT25lIGNvdWxkIGFyZ3VlIHRoYXQgdGhpcyBpcyBhIGJ1ZyBpbiBCYXNoLCBidXQgc2luY2UgdGhlIGdvYWwgb2ZcbiAgLy8gdGhpcyBtb2R1bGUgaXMgdG8gbWF0Y2ggQmFzaCdzIHJ1bGVzLCB3ZSBlc2NhcGUgYSBsZWFkaW5nIHt9XG4gIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAne30nKSB7XG4gICAgc3RyID0gJ1xcXFx7XFxcXH0nICsgc3RyLnN1YnN0cigyKTtcbiAgfVxuXG4gIHJldHVybiBleHBhbmQoZXNjYXBlQnJhY2VzKHN0ciksIHRydWUpLm1hcCh1bmVzY2FwZUJyYWNlcyk7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KGUpIHtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGVtYnJhY2Uoc3RyKSB7XG4gIHJldHVybiAneycgKyBzdHIgKyAnfSc7XG59XG5mdW5jdGlvbiBpc1BhZGRlZChlbCkge1xuICByZXR1cm4gL14tPzBcXGQvLnRlc3QoZWwpO1xufVxuXG5mdW5jdGlvbiBsdGUoaSwgeSkge1xuICByZXR1cm4gaSA8PSB5O1xufVxuZnVuY3Rpb24gZ3RlKGksIHkpIHtcbiAgcmV0dXJuIGkgPj0geTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHN0ciwgaXNUb3ApIHtcbiAgdmFyIGV4cGFuc2lvbnMgPSBbXTtcblxuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuICBpZiAoIW0gfHwgL1xcJCQvLnRlc3QobS5wcmUpKSByZXR1cm4gW3N0cl07XG5cbiAgdmFyIGlzTnVtZXJpY1NlcXVlbmNlID0gL14tP1xcZCtcXC5cXC4tP1xcZCsoPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgdmFyIGlzQWxwaGFTZXF1ZW5jZSA9IC9eW2EtekEtWl1cXC5cXC5bYS16QS1aXSg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICB2YXIgaXNTZXF1ZW5jZSA9IGlzTnVtZXJpY1NlcXVlbmNlIHx8IGlzQWxwaGFTZXF1ZW5jZTtcbiAgdmFyIGlzT3B0aW9ucyA9IG0uYm9keS5pbmRleE9mKCcsJykgPj0gMDtcbiAgaWYgKCFpc1NlcXVlbmNlICYmICFpc09wdGlvbnMpIHtcbiAgICAvLyB7YX0sYn1cbiAgICBpZiAobS5wb3N0Lm1hdGNoKC8sLipcXH0vKSkge1xuICAgICAgc3RyID0gbS5wcmUgKyAneycgKyBtLmJvZHkgKyBlc2NDbG9zZSArIG0ucG9zdDtcbiAgICAgIHJldHVybiBleHBhbmQoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJdO1xuICB9XG5cbiAgdmFyIG47XG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgbiA9IG0uYm9keS5zcGxpdCgvXFwuXFwuLyk7XG4gIH0gZWxzZSB7XG4gICAgbiA9IHBhcnNlQ29tbWFQYXJ0cyhtLmJvZHkpO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8geHt7YSxifX15ID09PiB4e2F9eSB4e2J9eVxuICAgICAgbiA9IGV4cGFuZChuWzBdLCBmYWxzZSkubWFwKGVtYnJhY2UpO1xuICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgICAgICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgICAgICAgOiBbJyddO1xuICAgICAgICByZXR1cm4gcG9zdC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBtLnByZSArIG5bMF0gKyBwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCBuIGlzIHRoZSBwYXJ0cywgYW5kIHdlIGtub3cgaXQncyBub3QgYSBjb21tYSBzZXRcbiAgLy8gd2l0aCBhIHNpbmdsZSBlbnRyeS5cblxuICAvLyBubyBuZWVkIHRvIGV4cGFuZCBwcmUsIHNpbmNlIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgZnJlZSBvZiBicmFjZS1zZXRzXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIHBvc3QgPSBtLnBvc3QubGVuZ3RoXG4gICAgPyBleHBhbmQobS5wb3N0LCBmYWxzZSlcbiAgICA6IFsnJ107XG5cbiAgdmFyIE47XG5cbiAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICB2YXIgeCA9IG51bWVyaWMoblswXSk7XG4gICAgdmFyIHkgPSBudW1lcmljKG5bMV0pO1xuICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KG5bMF0ubGVuZ3RoLCBuWzFdLmxlbmd0aClcbiAgICB2YXIgaW5jciA9IG4ubGVuZ3RoID09IDNcbiAgICAgID8gTWF0aC5hYnMobnVtZXJpYyhuWzJdKSlcbiAgICAgIDogMTtcbiAgICB2YXIgdGVzdCA9IGx0ZTtcbiAgICB2YXIgcmV2ZXJzZSA9IHkgPCB4O1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBpbmNyICo9IC0xO1xuICAgICAgdGVzdCA9IGd0ZTtcbiAgICB9XG4gICAgdmFyIHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG5cbiAgICBOID0gW107XG5cbiAgICBmb3IgKHZhciBpID0geDsgdGVzdChpLCB5KTsgaSArPSBpbmNyKSB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmIChpc0FscGhhU2VxdWVuY2UpIHtcbiAgICAgICAgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpXG4gICAgICAgICAgYyA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IFN0cmluZyhpKTtcbiAgICAgICAgaWYgKHBhZCkge1xuICAgICAgICAgIHZhciBuZWVkID0gd2lkdGggLSBjLmxlbmd0aDtcbiAgICAgICAgICBpZiAobmVlZCA+IDApIHtcbiAgICAgICAgICAgIHZhciB6ID0gbmV3IEFycmF5KG5lZWQgKyAxKS5qb2luKCcwJyk7XG4gICAgICAgICAgICBpZiAoaSA8IDApXG4gICAgICAgICAgICAgIGMgPSAnLScgKyB6ICsgYy5zbGljZSgxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYyA9IHogKyBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTi5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBOID0gY29uY2F0TWFwKG4sIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBleHBhbmQoZWwsIGZhbHNlKSB9KTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgTi5sZW5ndGg7IGorKykge1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSArIE5bal0gKyBwb3N0W2tdO1xuICAgICAgaWYgKCFpc1RvcCB8fCBpc1NlcXVlbmNlIHx8IGV4cGFuc2lvbilcbiAgICAgICAgZXhwYW5zaW9ucy5wdXNoKGV4cGFuc2lvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuc2lvbnM7XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gZm4oeHNbaV0sIGkpO1xuICAgICAgICBpZiAoaXNBcnJheSh4KSkgcmVzLnB1c2guYXBwbHkocmVzLCB4KTtcbiAgICAgICAgZWxzZSByZXMucHVzaCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWxwYXRoXG5yZWFscGF0aC5yZWFscGF0aCA9IHJlYWxwYXRoXG5yZWFscGF0aC5zeW5jID0gcmVhbHBhdGhTeW5jXG5yZWFscGF0aC5yZWFscGF0aFN5bmMgPSByZWFscGF0aFN5bmNcbnJlYWxwYXRoLm1vbmtleXBhdGNoID0gbW9ua2V5cGF0Y2hcbnJlYWxwYXRoLnVubW9ua2V5cGF0Y2ggPSB1bm1vbmtleXBhdGNoXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBvcmlnUmVhbHBhdGggPSBmcy5yZWFscGF0aFxudmFyIG9yaWdSZWFscGF0aFN5bmMgPSBmcy5yZWFscGF0aFN5bmNcblxudmFyIHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25cbnZhciBvayA9IC9edlswLTVdXFwuLy50ZXN0KHZlcnNpb24pXG52YXIgb2xkID0gcmVxdWlyZSgnLi9vbGQuanMnKVxuXG5mdW5jdGlvbiBuZXdFcnJvciAoZXIpIHtcbiAgcmV0dXJuIGVyICYmIGVyLnN5c2NhbGwgPT09ICdyZWFscGF0aCcgJiYgKFxuICAgIGVyLmNvZGUgPT09ICdFTE9PUCcgfHxcbiAgICBlci5jb2RlID09PSAnRU5PTUVNJyB8fFxuICAgIGVyLmNvZGUgPT09ICdFTkFNRVRPT0xPTkcnXG4gIClcbn1cblxuZnVuY3Rpb24gcmVhbHBhdGggKHAsIGNhY2hlLCBjYikge1xuICBpZiAob2spIHtcbiAgICByZXR1cm4gb3JpZ1JlYWxwYXRoKHAsIGNhY2hlLCBjYilcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FjaGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNhY2hlXG4gICAgY2FjaGUgPSBudWxsXG4gIH1cbiAgb3JpZ1JlYWxwYXRoKHAsIGNhY2hlLCBmdW5jdGlvbiAoZXIsIHJlc3VsdCkge1xuICAgIGlmIChuZXdFcnJvcihlcikpIHtcbiAgICAgIG9sZC5yZWFscGF0aChwLCBjYWNoZSwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGVyLCByZXN1bHQpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFscGF0aFN5bmMgKHAsIGNhY2hlKSB7XG4gIGlmIChvaykge1xuICAgIHJldHVybiBvcmlnUmVhbHBhdGhTeW5jKHAsIGNhY2hlKVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gb3JpZ1JlYWxwYXRoU3luYyhwLCBjYWNoZSlcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAobmV3RXJyb3IoZXIpKSB7XG4gICAgICByZXR1cm4gb2xkLnJlYWxwYXRoU3luYyhwLCBjYWNoZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ua2V5cGF0Y2ggKCkge1xuICBmcy5yZWFscGF0aCA9IHJlYWxwYXRoXG4gIGZzLnJlYWxwYXRoU3luYyA9IHJlYWxwYXRoU3luY1xufVxuXG5mdW5jdGlvbiB1bm1vbmtleXBhdGNoICgpIHtcbiAgZnMucmVhbHBhdGggPSBvcmlnUmVhbHBhdGhcbiAgZnMucmVhbHBhdGhTeW5jID0gb3JpZ1JlYWxwYXRoU3luY1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwYXRoTW9kdWxlID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG4vLyBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHJlYWxwYXRoLCBwb3J0ZWQgZnJvbSBub2RlIHByZS12NlxuXG52YXIgREVCVUcgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmIC9mcy8udGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKTtcblxuZnVuY3Rpb24gcmV0aHJvdygpIHtcbiAgLy8gT25seSBlbmFibGUgaW4gZGVidWcgbW9kZS4gQSBiYWNrdHJhY2UgdXNlcyB+MTAwMCBieXRlcyBvZiBoZWFwIHNwYWNlIGFuZFxuICAvLyBpcyBmYWlybHkgc2xvdyB0byBnZW5lcmF0ZS5cbiAgdmFyIGNhbGxiYWNrO1xuICBpZiAoREVCVUcpIHtcbiAgICB2YXIgYmFja3RyYWNlID0gbmV3IEVycm9yO1xuICAgIGNhbGxiYWNrID0gZGVidWdDYWxsYmFjaztcbiAgfSBlbHNlXG4gICAgY2FsbGJhY2sgPSBtaXNzaW5nQ2FsbGJhY2s7XG5cbiAgcmV0dXJuIGNhbGxiYWNrO1xuXG4gIGZ1bmN0aW9uIGRlYnVnQ2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgYmFja3RyYWNlLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgIGVyciA9IGJhY2t0cmFjZTtcbiAgICAgIG1pc3NpbmdDYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1pc3NpbmdDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKVxuICAgICAgICB0aHJvdyBlcnI7ICAvLyBGb3Jnb3QgYSBjYWxsYmFjayBidXQgZG9uJ3Qga25vdyB3aGVyZT8gVXNlIE5PREVfREVCVUc9ZnNcbiAgICAgIGVsc2UgaWYgKCFwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICAgICAgdmFyIG1zZyA9ICdmczogbWlzc2luZyBjYWxsYmFjayAnICsgKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pXG4gICAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZUNhbGxiYWNrKGNiKSB7XG4gIHJldHVybiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgPyBjYiA6IHJldGhyb3coKTtcbn1cblxudmFyIG5vcm1hbGl6ZSA9IHBhdGhNb2R1bGUubm9ybWFsaXplO1xuXG4vLyBSZWdleHAgdGhhdCBmaW5kcyB0aGUgbmV4dCBwYXJ0aW9uIG9mIGEgKHBhcnRpYWwpIHBhdGhcbi8vIHJlc3VsdCBpcyBbYmFzZV93aXRoX3NsYXNoLCBiYXNlXSwgZS5nLiBbJ3NvbWVkaXIvJywgJ3NvbWVkaXInXVxuaWYgKGlzV2luZG93cykge1xuICB2YXIgbmV4dFBhcnRSZSA9IC8oLio/KSg/OltcXC9cXFxcXSt8JCkvZztcbn0gZWxzZSB7XG4gIHZhciBuZXh0UGFydFJlID0gLyguKj8pKD86W1xcL10rfCQpL2c7XG59XG5cbi8vIFJlZ2V4IHRvIGZpbmQgdGhlIGRldmljZSByb290LCBpbmNsdWRpbmcgdHJhaWxpbmcgc2xhc2guIEUuZy4gJ2M6XFxcXCcuXG5pZiAoaXNXaW5kb3dzKSB7XG4gIHZhciBzcGxpdFJvb3RSZSA9IC9eKD86W2EtekEtWl06fFtcXFxcXFwvXXsyfVteXFxcXFxcL10rW1xcXFxcXC9dW15cXFxcXFwvXSspP1tcXFxcXFwvXSovO1xufSBlbHNlIHtcbiAgdmFyIHNwbGl0Um9vdFJlID0gL15bXFwvXSovO1xufVxuXG5leHBvcnRzLnJlYWxwYXRoU3luYyA9IGZ1bmN0aW9uIHJlYWxwYXRoU3luYyhwLCBjYWNoZSkge1xuICAvLyBtYWtlIHAgaXMgYWJzb2x1dGVcbiAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShwKTtcblxuICBpZiAoY2FjaGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBwKSkge1xuICAgIHJldHVybiBjYWNoZVtwXTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbCA9IHAsXG4gICAgICBzZWVuTGlua3MgPSB7fSxcbiAgICAgIGtub3duSGFyZCA9IHt9O1xuXG4gIC8vIGN1cnJlbnQgY2hhcmFjdGVyIHBvc2l0aW9uIGluIHBcbiAgdmFyIHBvcztcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzbyBmYXIsIGluY2x1ZGluZyBhIHRyYWlsaW5nIHNsYXNoIGlmIGFueVxuICB2YXIgY3VycmVudDtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2ggKGV4Y2VwdCB3aGVuIHBvaW50aW5nIGF0IGEgcm9vdClcbiAgdmFyIGJhc2U7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggc2Nhbm5lZCBpbiB0aGUgcHJldmlvdXMgcm91bmQsIHdpdGggc2xhc2hcbiAgdmFyIHByZXZpb3VzO1xuXG4gIHN0YXJ0KCk7XG5cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgLy8gU2tpcCBvdmVyIHJvb3RzXG4gICAgdmFyIG0gPSBzcGxpdFJvb3RSZS5leGVjKHApO1xuICAgIHBvcyA9IG1bMF0ubGVuZ3RoO1xuICAgIGN1cnJlbnQgPSBtWzBdO1xuICAgIGJhc2UgPSBtWzBdO1xuICAgIHByZXZpb3VzID0gJyc7XG5cbiAgICAvLyBPbiB3aW5kb3dzLCBjaGVjayB0aGF0IHRoZSByb290IGV4aXN0cy4gT24gdW5peCB0aGVyZSBpcyBubyBuZWVkLlxuICAgIGlmIChpc1dpbmRvd3MgJiYgIWtub3duSGFyZFtiYXNlXSkge1xuICAgICAgZnMubHN0YXRTeW5jKGJhc2UpO1xuICAgICAga25vd25IYXJkW2Jhc2VdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyB3YWxrIGRvd24gdGhlIHBhdGgsIHN3YXBwaW5nIG91dCBsaW5rZWQgcGF0aHBhcnRzIGZvciB0aGVpciByZWFsXG4gIC8vIHZhbHVlc1xuICAvLyBOQjogcC5sZW5ndGggY2hhbmdlcy5cbiAgd2hpbGUgKHBvcyA8IHAubGVuZ3RoKSB7XG4gICAgLy8gZmluZCB0aGUgbmV4dCBwYXJ0XG4gICAgbmV4dFBhcnRSZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgdmFyIHJlc3VsdCA9IG5leHRQYXJ0UmUuZXhlYyhwKTtcbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgY3VycmVudCArPSByZXN1bHRbMF07XG4gICAgYmFzZSA9IHByZXZpb3VzICsgcmVzdWx0WzFdO1xuICAgIHBvcyA9IG5leHRQYXJ0UmUubGFzdEluZGV4O1xuXG4gICAgLy8gY29udGludWUgaWYgbm90IGEgc3ltbGlua1xuICAgIGlmIChrbm93bkhhcmRbYmFzZV0gfHwgKGNhY2hlICYmIGNhY2hlW2Jhc2VdID09PSBiYXNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkTGluaztcbiAgICBpZiAoY2FjaGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBiYXNlKSkge1xuICAgICAgLy8gc29tZSBrbm93biBzeW1ib2xpYyBsaW5rLiAgbm8gbmVlZCB0byBzdGF0IGFnYWluLlxuICAgICAgcmVzb2x2ZWRMaW5rID0gY2FjaGVbYmFzZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGF0ID0gZnMubHN0YXRTeW5jKGJhc2UpO1xuICAgICAgaWYgKCFzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAga25vd25IYXJkW2Jhc2VdID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhY2hlKSBjYWNoZVtiYXNlXSA9IGJhc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyByZWFkIHRoZSBsaW5rIGlmIGl0IHdhc24ndCByZWFkIGJlZm9yZVxuICAgICAgLy8gZGV2L2lubyBhbHdheXMgcmV0dXJuIDAgb24gd2luZG93cywgc28gc2tpcCB0aGUgY2hlY2suXG4gICAgICB2YXIgbGlua1RhcmdldCA9IG51bGw7XG4gICAgICBpZiAoIWlzV2luZG93cykge1xuICAgICAgICB2YXIgaWQgPSBzdGF0LmRldi50b1N0cmluZygzMikgKyAnOicgKyBzdGF0Lmluby50b1N0cmluZygzMik7XG4gICAgICAgIGlmIChzZWVuTGlua3MuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgbGlua1RhcmdldCA9IHNlZW5MaW5rc1tpZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaW5rVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIGZzLnN0YXRTeW5jKGJhc2UpO1xuICAgICAgICBsaW5rVGFyZ2V0ID0gZnMucmVhZGxpbmtTeW5jKGJhc2UpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRMaW5rID0gcGF0aE1vZHVsZS5yZXNvbHZlKHByZXZpb3VzLCBsaW5rVGFyZ2V0KTtcbiAgICAgIC8vIHRyYWNrIHRoaXMsIGlmIGdpdmVuIGEgY2FjaGUuXG4gICAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gcmVzb2x2ZWRMaW5rO1xuICAgICAgaWYgKCFpc1dpbmRvd3MpIHNlZW5MaW5rc1tpZF0gPSBsaW5rVGFyZ2V0O1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgdGhlIGxpbmssIHRoZW4gc3RhcnQgb3ZlclxuICAgIHAgPSBwYXRoTW9kdWxlLnJlc29sdmUocmVzb2x2ZWRMaW5rLCBwLnNsaWNlKHBvcykpO1xuICAgIHN0YXJ0KCk7XG4gIH1cblxuICBpZiAoY2FjaGUpIGNhY2hlW29yaWdpbmFsXSA9IHA7XG5cbiAgcmV0dXJuIHA7XG59O1xuXG5cbmV4cG9ydHMucmVhbHBhdGggPSBmdW5jdGlvbiByZWFscGF0aChwLCBjYWNoZSwgY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gbWF5YmVDYWxsYmFjayhjYWNoZSk7XG4gICAgY2FjaGUgPSBudWxsO1xuICB9XG5cbiAgLy8gbWFrZSBwIGlzIGFic29sdXRlXG4gIHAgPSBwYXRoTW9kdWxlLnJlc29sdmUocCk7XG5cbiAgaWYgKGNhY2hlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwgcCkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIGNhY2hlW3BdKSk7XG4gIH1cblxuICB2YXIgb3JpZ2luYWwgPSBwLFxuICAgICAgc2VlbkxpbmtzID0ge30sXG4gICAgICBrbm93bkhhcmQgPSB7fTtcblxuICAvLyBjdXJyZW50IGNoYXJhY3RlciBwb3NpdGlvbiBpbiBwXG4gIHZhciBwb3M7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggc28gZmFyLCBpbmNsdWRpbmcgYSB0cmFpbGluZyBzbGFzaCBpZiBhbnlcbiAgdmFyIGN1cnJlbnQ7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggd2l0aG91dCBhIHRyYWlsaW5nIHNsYXNoIChleGNlcHQgd2hlbiBwb2ludGluZyBhdCBhIHJvb3QpXG4gIHZhciBiYXNlO1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHNjYW5uZWQgaW4gdGhlIHByZXZpb3VzIHJvdW5kLCB3aXRoIHNsYXNoXG4gIHZhciBwcmV2aW91cztcblxuICBzdGFydCgpO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIC8vIFNraXAgb3ZlciByb290c1xuICAgIHZhciBtID0gc3BsaXRSb290UmUuZXhlYyhwKTtcbiAgICBwb3MgPSBtWzBdLmxlbmd0aDtcbiAgICBjdXJyZW50ID0gbVswXTtcbiAgICBiYXNlID0gbVswXTtcbiAgICBwcmV2aW91cyA9ICcnO1xuXG4gICAgLy8gT24gd2luZG93cywgY2hlY2sgdGhhdCB0aGUgcm9vdCBleGlzdHMuIE9uIHVuaXggdGhlcmUgaXMgbm8gbmVlZC5cbiAgICBpZiAoaXNXaW5kb3dzICYmICFrbm93bkhhcmRbYmFzZV0pIHtcbiAgICAgIGZzLmxzdGF0KGJhc2UsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAga25vd25IYXJkW2Jhc2VdID0gdHJ1ZTtcbiAgICAgICAgTE9PUCgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soTE9PUCk7XG4gICAgfVxuICB9XG5cbiAgLy8gd2FsayBkb3duIHRoZSBwYXRoLCBzd2FwcGluZyBvdXQgbGlua2VkIHBhdGhwYXJ0cyBmb3IgdGhlaXIgcmVhbFxuICAvLyB2YWx1ZXNcbiAgZnVuY3Rpb24gTE9PUCgpIHtcbiAgICAvLyBzdG9wIGlmIHNjYW5uZWQgcGFzdCBlbmQgb2YgcGF0aFxuICAgIGlmIChwb3MgPj0gcC5sZW5ndGgpIHtcbiAgICAgIGlmIChjYWNoZSkgY2FjaGVbb3JpZ2luYWxdID0gcDtcbiAgICAgIHJldHVybiBjYihudWxsLCBwKTtcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBuZXh0IHBhcnRcbiAgICBuZXh0UGFydFJlLmxhc3RJbmRleCA9IHBvcztcbiAgICB2YXIgcmVzdWx0ID0gbmV4dFBhcnRSZS5leGVjKHApO1xuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICBjdXJyZW50ICs9IHJlc3VsdFswXTtcbiAgICBiYXNlID0gcHJldmlvdXMgKyByZXN1bHRbMV07XG4gICAgcG9zID0gbmV4dFBhcnRSZS5sYXN0SW5kZXg7XG5cbiAgICAvLyBjb250aW51ZSBpZiBub3QgYSBzeW1saW5rXG4gICAgaWYgKGtub3duSGFyZFtiYXNlXSB8fCAoY2FjaGUgJiYgY2FjaGVbYmFzZV0gPT09IGJhc2UpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhMT09QKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBiYXNlKSkge1xuICAgICAgLy8ga25vd24gc3ltYm9saWMgbGluay4gIG5vIG5lZWQgdG8gc3RhdCBhZ2Fpbi5cbiAgICAgIHJldHVybiBnb3RSZXNvbHZlZExpbmsoY2FjaGVbYmFzZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBmcy5sc3RhdChiYXNlLCBnb3RTdGF0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdFN0YXQoZXJyLCBzdGF0KSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAvLyBpZiBub3QgYSBzeW1saW5rLCBza2lwIHRvIHRoZSBuZXh0IHBhdGggcGFydFxuICAgIGlmICghc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgICAgaWYgKGNhY2hlKSBjYWNoZVtiYXNlXSA9IGJhc2U7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhMT09QKTtcbiAgICB9XG5cbiAgICAvLyBzdGF0ICYgcmVhZCB0aGUgbGluayBpZiBub3QgcmVhZCBiZWZvcmVcbiAgICAvLyBjYWxsIGdvdFRhcmdldCBhcyBzb29uIGFzIHRoZSBsaW5rIHRhcmdldCBpcyBrbm93blxuICAgIC8vIGRldi9pbm8gYWx3YXlzIHJldHVybiAwIG9uIHdpbmRvd3MsIHNvIHNraXAgdGhlIGNoZWNrLlxuICAgIGlmICghaXNXaW5kb3dzKSB7XG4gICAgICB2YXIgaWQgPSBzdGF0LmRldi50b1N0cmluZygzMikgKyAnOicgKyBzdGF0Lmluby50b1N0cmluZygzMik7XG4gICAgICBpZiAoc2VlbkxpbmtzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICByZXR1cm4gZ290VGFyZ2V0KG51bGwsIHNlZW5MaW5rc1tpZF0sIGJhc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmcy5zdGF0KGJhc2UsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGZzLnJlYWRsaW5rKGJhc2UsIGZ1bmN0aW9uKGVyciwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghaXNXaW5kb3dzKSBzZWVuTGlua3NbaWRdID0gdGFyZ2V0O1xuICAgICAgICBnb3RUYXJnZXQoZXJyLCB0YXJnZXQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb3RUYXJnZXQoZXJyLCB0YXJnZXQsIGJhc2UpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIHZhciByZXNvbHZlZExpbmsgPSBwYXRoTW9kdWxlLnJlc29sdmUocHJldmlvdXMsIHRhcmdldCk7XG4gICAgaWYgKGNhY2hlKSBjYWNoZVtiYXNlXSA9IHJlc29sdmVkTGluaztcbiAgICBnb3RSZXNvbHZlZExpbmsocmVzb2x2ZWRMaW5rKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdFJlc29sdmVkTGluayhyZXNvbHZlZExpbmspIHtcbiAgICAvLyByZXNvbHZlIHRoZSBsaW5rLCB0aGVuIHN0YXJ0IG92ZXJcbiAgICBwID0gcGF0aE1vZHVsZS5yZXNvbHZlKHJlc29sdmVkTGluaywgcC5zbGljZShwb3MpKTtcbiAgICBzdGFydCgpO1xuICB9XG59O1xuIiwiZXhwb3J0cy5zZXRvcHRzID0gc2V0b3B0c1xuZXhwb3J0cy5vd25Qcm9wID0gb3duUHJvcFxuZXhwb3J0cy5tYWtlQWJzID0gbWFrZUFic1xuZXhwb3J0cy5maW5pc2ggPSBmaW5pc2hcbmV4cG9ydHMubWFyayA9IG1hcmtcbmV4cG9ydHMuaXNJZ25vcmVkID0gaXNJZ25vcmVkXG5leHBvcnRzLmNoaWxkcmVuSWdub3JlZCA9IGNoaWxkcmVuSWdub3JlZFxuXG5mdW5jdGlvbiBvd25Qcm9wIChvYmosIGZpZWxkKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBmaWVsZClcbn1cblxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKFwicGF0aC1pcy1hYnNvbHV0ZVwiKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcblxuZnVuY3Rpb24gYWxwaGFzb3J0IChhLCBiKSB7XG4gIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYiwgJ2VuJylcbn1cblxuZnVuY3Rpb24gc2V0dXBJZ25vcmVzIChzZWxmLCBvcHRpb25zKSB7XG4gIHNlbGYuaWdub3JlID0gb3B0aW9ucy5pZ25vcmUgfHwgW11cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZi5pZ25vcmUpKVxuICAgIHNlbGYuaWdub3JlID0gW3NlbGYuaWdub3JlXVxuXG4gIGlmIChzZWxmLmlnbm9yZS5sZW5ndGgpIHtcbiAgICBzZWxmLmlnbm9yZSA9IHNlbGYuaWdub3JlLm1hcChpZ25vcmVNYXApXG4gIH1cbn1cblxuLy8gaWdub3JlIHBhdHRlcm5zIGFyZSBhbHdheXMgaW4gZG90OnRydWUgbW9kZS5cbmZ1bmN0aW9uIGlnbm9yZU1hcCAocGF0dGVybikge1xuICB2YXIgZ21hdGNoZXIgPSBudWxsXG4gIGlmIChwYXR0ZXJuLnNsaWNlKC0zKSA9PT0gJy8qKicpIHtcbiAgICB2YXIgZ3BhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLyhcXC9cXCpcXCopKyQvLCAnJylcbiAgICBnbWF0Y2hlciA9IG5ldyBNaW5pbWF0Y2goZ3BhdHRlcm4sIHsgZG90OiB0cnVlIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoZXI6IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgeyBkb3Q6IHRydWUgfSksXG4gICAgZ21hdGNoZXI6IGdtYXRjaGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0b3B0cyAoc2VsZiwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgLy8gYmFzZS1tYXRjaGluZzoganVzdCB1c2UgZ2xvYnN0YXIgZm9yIHRoYXQuXG4gIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiAtMSA9PT0gcGF0dGVybi5pbmRleE9mKFwiL1wiKSkge1xuICAgIGlmIChvcHRpb25zLm5vZ2xvYnN0YXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2UgbWF0Y2hpbmcgcmVxdWlyZXMgZ2xvYnN0YXJcIilcbiAgICB9XG4gICAgcGF0dGVybiA9IFwiKiovXCIgKyBwYXR0ZXJuXG4gIH1cblxuICBzZWxmLnNpbGVudCA9ICEhb3B0aW9ucy5zaWxlbnRcbiAgc2VsZi5wYXR0ZXJuID0gcGF0dGVyblxuICBzZWxmLnN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9PSBmYWxzZVxuICBzZWxmLnJlYWxwYXRoID0gISFvcHRpb25zLnJlYWxwYXRoXG4gIHNlbGYucmVhbHBhdGhDYWNoZSA9IG9wdGlvbnMucmVhbHBhdGhDYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuZm9sbG93ID0gISFvcHRpb25zLmZvbGxvd1xuICBzZWxmLmRvdCA9ICEhb3B0aW9ucy5kb3RcbiAgc2VsZi5tYXJrID0gISFvcHRpb25zLm1hcmtcbiAgc2VsZi5ub2RpciA9ICEhb3B0aW9ucy5ub2RpclxuICBpZiAoc2VsZi5ub2RpcilcbiAgICBzZWxmLm1hcmsgPSB0cnVlXG4gIHNlbGYuc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gIHNlbGYubm91bmlxdWUgPSAhIW9wdGlvbnMubm91bmlxdWVcbiAgc2VsZi5ub251bGwgPSAhIW9wdGlvbnMubm9udWxsXG4gIHNlbGYubm9zb3J0ID0gISFvcHRpb25zLm5vc29ydFxuICBzZWxmLm5vY2FzZSA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgc2VsZi5zdGF0ID0gISFvcHRpb25zLnN0YXRcbiAgc2VsZi5ub3Byb2Nlc3MgPSAhIW9wdGlvbnMubm9wcm9jZXNzXG4gIHNlbGYuYWJzb2x1dGUgPSAhIW9wdGlvbnMuYWJzb2x1dGVcbiAgc2VsZi5mcyA9IG9wdGlvbnMuZnMgfHwgZnNcblxuICBzZWxmLm1heExlbmd0aCA9IG9wdGlvbnMubWF4TGVuZ3RoIHx8IEluZmluaXR5XG4gIHNlbGYuY2FjaGUgPSBvcHRpb25zLmNhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5zdGF0Q2FjaGUgPSBvcHRpb25zLnN0YXRDYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuc3ltbGlua3MgPSBvcHRpb25zLnN5bWxpbmtzIHx8IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBzZXR1cElnbm9yZXMoc2VsZiwgb3B0aW9ucylcblxuICBzZWxmLmNoYW5nZWRDd2QgPSBmYWxzZVxuICB2YXIgY3dkID0gcHJvY2Vzcy5jd2QoKVxuICBpZiAoIW93blByb3Aob3B0aW9ucywgXCJjd2RcIikpXG4gICAgc2VsZi5jd2QgPSBjd2RcbiAgZWxzZSB7XG4gICAgc2VsZi5jd2QgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QpXG4gICAgc2VsZi5jaGFuZ2VkQ3dkID0gc2VsZi5jd2QgIT09IGN3ZFxuICB9XG5cbiAgc2VsZi5yb290ID0gb3B0aW9ucy5yb290IHx8IHBhdGgucmVzb2x2ZShzZWxmLmN3ZCwgXCIvXCIpXG4gIHNlbGYucm9vdCA9IHBhdGgucmVzb2x2ZShzZWxmLnJvb3QpXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpXG4gICAgc2VsZi5yb290ID0gc2VsZi5yb290LnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG5cbiAgLy8gVE9ETzogaXMgYW4gYWJzb2x1dGUgYGN3ZGAgc3VwcG9zZWQgdG8gYmUgcmVzb2x2ZWQgYWdhaW5zdCBgcm9vdGA/XG4gIC8vIGUuZy4geyBjd2Q6ICcvdGVzdCcsIHJvb3Q6IF9fZGlybmFtZSB9ID09PSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnL3Rlc3QnKVxuICBzZWxmLmN3ZEFicyA9IGlzQWJzb2x1dGUoc2VsZi5jd2QpID8gc2VsZi5jd2QgOiBtYWtlQWJzKHNlbGYsIHNlbGYuY3dkKVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKVxuICAgIHNlbGYuY3dkQWJzID0gc2VsZi5jd2RBYnMucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgc2VsZi5ub21vdW50ID0gISFvcHRpb25zLm5vbW91bnRcblxuICAvLyBkaXNhYmxlIGNvbW1lbnRzIGFuZCBuZWdhdGlvbiBpbiBNaW5pbWF0Y2guXG4gIC8vIE5vdGUgdGhhdCB0aGV5IGFyZSBub3Qgc3VwcG9ydGVkIGluIEdsb2IgaXRzZWxmIGFueXdheS5cbiAgb3B0aW9ucy5ub25lZ2F0ZSA9IHRydWVcbiAgb3B0aW9ucy5ub2NvbW1lbnQgPSB0cnVlXG4gIC8vIGFsd2F5cyB0cmVhdCBcXCBpbiBwYXR0ZXJucyBhcyBlc2NhcGVzLCBub3QgcGF0aCBzZXBhcmF0b3JzXG4gIG9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlID0gZmFsc2VcblxuICBzZWxmLm1pbmltYXRjaCA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgc2VsZi5vcHRpb25zID0gc2VsZi5taW5pbWF0Y2gub3B0aW9uc1xufVxuXG5mdW5jdGlvbiBmaW5pc2ggKHNlbGYpIHtcbiAgdmFyIG5vdSA9IHNlbGYubm91bmlxdWVcbiAgdmFyIGFsbCA9IG5vdSA/IFtdIDogT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZi5tYXRjaGVzLmxlbmd0aDsgaSA8IGw7IGkgKyspIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHNlbGYubWF0Y2hlc1tpXVxuICAgIGlmICghbWF0Y2hlcyB8fCBPYmplY3Qua2V5cyhtYXRjaGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChzZWxmLm5vbnVsbCkge1xuICAgICAgICAvLyBkbyBsaWtlIHRoZSBzaGVsbCwgYW5kIHNwaXQgb3V0IHRoZSBsaXRlcmFsIGdsb2JcbiAgICAgICAgdmFyIGxpdGVyYWwgPSBzZWxmLm1pbmltYXRjaC5nbG9iU2V0W2ldXG4gICAgICAgIGlmIChub3UpXG4gICAgICAgICAgYWxsLnB1c2gobGl0ZXJhbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFsbFtsaXRlcmFsXSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFkIG1hdGNoZXNcbiAgICAgIHZhciBtID0gT2JqZWN0LmtleXMobWF0Y2hlcylcbiAgICAgIGlmIChub3UpXG4gICAgICAgIGFsbC5wdXNoLmFwcGx5KGFsbCwgbSlcbiAgICAgIGVsc2VcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgYWxsW21dID0gdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghbm91KVxuICAgIGFsbCA9IE9iamVjdC5rZXlzKGFsbClcblxuICBpZiAoIXNlbGYubm9zb3J0KVxuICAgIGFsbCA9IGFsbC5zb3J0KGFscGhhc29ydClcblxuICAvLyBhdCAqc29tZSogcG9pbnQgd2Ugc3RhdHRlZCBhbGwgb2YgdGhlc2VcbiAgaWYgKHNlbGYubWFyaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbGxbaV0gPSBzZWxmLl9tYXJrKGFsbFtpXSlcbiAgICB9XG4gICAgaWYgKHNlbGYubm9kaXIpIHtcbiAgICAgIGFsbCA9IGFsbC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG5vdERpciA9ICEoL1xcLyQvLnRlc3QoZSkpXG4gICAgICAgIHZhciBjID0gc2VsZi5jYWNoZVtlXSB8fCBzZWxmLmNhY2hlW21ha2VBYnMoc2VsZiwgZSldXG4gICAgICAgIGlmIChub3REaXIgJiYgYylcbiAgICAgICAgICBub3REaXIgPSBjICE9PSAnRElSJyAmJiAhQXJyYXkuaXNBcnJheShjKVxuICAgICAgICByZXR1cm4gbm90RGlyXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxmLmlnbm9yZS5sZW5ndGgpXG4gICAgYWxsID0gYWxsLmZpbHRlcihmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gIWlzSWdub3JlZChzZWxmLCBtKVxuICAgIH0pXG5cbiAgc2VsZi5mb3VuZCA9IGFsbFxufVxuXG5mdW5jdGlvbiBtYXJrIChzZWxmLCBwKSB7XG4gIHZhciBhYnMgPSBtYWtlQWJzKHNlbGYsIHApXG4gIHZhciBjID0gc2VsZi5jYWNoZVthYnNdXG4gIHZhciBtID0gcFxuICBpZiAoYykge1xuICAgIHZhciBpc0RpciA9IGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYylcbiAgICB2YXIgc2xhc2ggPSBwLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgICBpZiAoaXNEaXIgJiYgIXNsYXNoKVxuICAgICAgbSArPSAnLydcbiAgICBlbHNlIGlmICghaXNEaXIgJiYgc2xhc2gpXG4gICAgICBtID0gbS5zbGljZSgwLCAtMSlcblxuICAgIGlmIChtICE9PSBwKSB7XG4gICAgICB2YXIgbWFicyA9IG1ha2VBYnMoc2VsZiwgbSlcbiAgICAgIHNlbGYuc3RhdENhY2hlW21hYnNdID0gc2VsZi5zdGF0Q2FjaGVbYWJzXVxuICAgICAgc2VsZi5jYWNoZVttYWJzXSA9IHNlbGYuY2FjaGVbYWJzXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtXG59XG5cbi8vIGxvdHRhIHNpdHVwcy4uLlxuZnVuY3Rpb24gbWFrZUFicyAoc2VsZiwgZikge1xuICB2YXIgYWJzID0gZlxuICBpZiAoZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIGFicyA9IHBhdGguam9pbihzZWxmLnJvb3QsIGYpXG4gIH0gZWxzZSBpZiAoaXNBYnNvbHV0ZShmKSB8fCBmID09PSAnJykge1xuICAgIGFicyA9IGZcbiAgfSBlbHNlIGlmIChzZWxmLmNoYW5nZWRDd2QpIHtcbiAgICBhYnMgPSBwYXRoLnJlc29sdmUoc2VsZi5jd2QsIGYpXG4gIH0gZWxzZSB7XG4gICAgYWJzID0gcGF0aC5yZXNvbHZlKGYpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICBhYnMgPSBhYnMucmVwbGFjZSgvXFxcXC9nLCAnLycpXG5cbiAgcmV0dXJuIGFic1xufVxuXG5cbi8vIFJldHVybiB0cnVlLCBpZiBwYXR0ZXJuIGVuZHMgd2l0aCBnbG9ic3RhciAnKionLCBmb3IgdGhlIGFjY29tcGFueWluZyBwYXJlbnQgZGlyZWN0b3J5LlxuLy8gRXg6LSBJZiBub2RlX21vZHVsZXMvKiogaXMgdGhlIHBhdHRlcm4sIGFkZCAnbm9kZV9tb2R1bGVzJyB0byBpZ25vcmUgbGlzdCBhbG9uZyB3aXRoIGl0J3MgY29udGVudHNcbmZ1bmN0aW9uIGlzSWdub3JlZCAoc2VsZiwgcGF0aCkge1xuICBpZiAoIXNlbGYuaWdub3JlLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gc2VsZi5pZ25vcmUuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0ubWF0Y2hlci5tYXRjaChwYXRoKSB8fCAhIShpdGVtLmdtYXRjaGVyICYmIGl0ZW0uZ21hdGNoZXIubWF0Y2gocGF0aCkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuSWdub3JlZCAoc2VsZiwgcGF0aCkge1xuICBpZiAoIXNlbGYuaWdub3JlLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gc2VsZi5pZ25vcmUuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuICEhKGl0ZW0uZ21hdGNoZXIgJiYgaXRlbS5nbWF0Y2hlci5tYXRjaChwYXRoKSlcbiAgfSlcbn1cbiIsIi8vIEFwcHJvYWNoOlxuLy9cbi8vIDEuIEdldCB0aGUgbWluaW1hdGNoIHNldFxuLy8gMi4gRm9yIGVhY2ggcGF0dGVybiBpbiB0aGUgc2V0LCBQUk9DRVNTKHBhdHRlcm4sIGZhbHNlKVxuLy8gMy4gU3RvcmUgbWF0Y2hlcyBwZXItc2V0LCB0aGVuIHVuaXEgdGhlbVxuLy9cbi8vIFBST0NFU1MocGF0dGVybiwgaW5HbG9iU3Rhcilcbi8vIEdldCB0aGUgZmlyc3QgW25dIGl0ZW1zIGZyb20gcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5nc1xuLy8gSm9pbiB0aGVzZSB0b2dldGhlci4gIFRoaXMgaXMgUFJFRklYLlxuLy8gICBJZiB0aGVyZSBpcyBubyBtb3JlIHJlbWFpbmluZywgdGhlbiBzdGF0KFBSRUZJWCkgYW5kXG4vLyAgIGFkZCB0byBtYXRjaGVzIGlmIGl0IHN1Y2NlZWRzLiAgRU5ELlxuLy9cbi8vIElmIGluR2xvYlN0YXIgYW5kIFBSRUZJWCBpcyBzeW1saW5rIGFuZCBwb2ludHMgdG8gZGlyXG4vLyAgIHNldCBFTlRSSUVTID0gW11cbi8vIGVsc2UgcmVhZGRpcihQUkVGSVgpIGFzIEVOVFJJRVNcbi8vICAgSWYgZmFpbCwgRU5EXG4vL1xuLy8gd2l0aCBFTlRSSUVTXG4vLyAgIElmIHBhdHRlcm5bbl0gaXMgR0xPQlNUQVJcbi8vICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGdsb2JzdGFyIG1hdGNoIGlzIGVtcHR5XG4vLyAgICAgLy8gYnkgcHJ1bmluZyBpdCBvdXQsIGFuZCB0ZXN0aW5nIHRoZSByZXN1bHRpbmcgcGF0dGVyblxuLy8gICAgIFBST0NFU1MocGF0dGVyblswLi5uXSArIHBhdHRlcm5bbisxIC4uICRdLCBmYWxzZSlcbi8vICAgICAvLyBoYW5kbGUgb3RoZXIgY2FzZXMuXG4vLyAgICAgZm9yIEVOVFJZIGluIEVOVFJJRVMgKG5vdCBkb3RmaWxlcylcbi8vICAgICAgIC8vIGF0dGFjaCBnbG9ic3RhciArIHRhaWwgb250byB0aGUgZW50cnlcbi8vICAgICAgIC8vIE1hcmsgdGhhdCB0aGlzIGVudHJ5IGlzIGEgZ2xvYnN0YXIgbWF0Y2hcbi8vICAgICAgIFBST0NFU1MocGF0dGVyblswLi5uXSArIEVOVFJZICsgcGF0dGVybltuIC4uICRdLCB0cnVlKVxuLy9cbi8vICAgZWxzZSAvLyBub3QgZ2xvYnN0YXJcbi8vICAgICBmb3IgRU5UUlkgaW4gRU5UUklFUyAobm90IGRvdGZpbGVzLCB1bmxlc3MgcGF0dGVybltuXSBpcyBkb3QpXG4vLyAgICAgICBUZXN0IEVOVFJZIGFnYWluc3QgcGF0dGVybltuXVxuLy8gICAgICAgSWYgZmFpbHMsIGNvbnRpbnVlXG4vLyAgICAgICBJZiBwYXNzZXMsIFBST0NFU1MocGF0dGVyblswLi5uXSArIGl0ZW0gKyBwYXR0ZXJuW24rMSAuLiAkXSlcbi8vXG4vLyBDYXZlYXQ6XG4vLyAgIENhY2hlIGFsbCBzdGF0cyBhbmQgcmVhZGRpcnMgcmVzdWx0cyB0byBtaW5pbWl6ZSBzeXNjYWxsLiAgU2luY2UgYWxsXG4vLyAgIHdlIGV2ZXIgY2FyZSBhYm91dCBpcyBleGlzdGVuY2UgYW5kIGRpcmVjdG9yeS1uZXNzLCB3ZSBjYW4ganVzdCBrZWVwXG4vLyAgIGB0cnVlYCBmb3IgZmlsZXMsIGFuZCBbY2hpbGRyZW4sLi4uXSBmb3IgZGlyZWN0b3JpZXMsIG9yIGBmYWxzZWAgZm9yXG4vLyAgIHRoaW5ncyB0aGF0IGRvbid0IGV4aXN0LlxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JcblxudmFyIHJwID0gcmVxdWlyZSgnZnMucmVhbHBhdGgnKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoJ3BhdGgtaXMtYWJzb2x1dGUnKVxudmFyIGdsb2JTeW5jID0gcmVxdWlyZSgnLi9zeW5jLmpzJylcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpXG52YXIgc2V0b3B0cyA9IGNvbW1vbi5zZXRvcHRzXG52YXIgb3duUHJvcCA9IGNvbW1vbi5vd25Qcm9wXG52YXIgaW5mbGlnaHQgPSByZXF1aXJlKCdpbmZsaWdodCcpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIGNoaWxkcmVuSWdub3JlZCA9IGNvbW1vbi5jaGlsZHJlbklnbm9yZWRcbnZhciBpc0lnbm9yZWQgPSBjb21tb24uaXNJZ25vcmVkXG5cbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbmZ1bmN0aW9uIGdsb2IgKHBhdHRlcm4sIG9wdGlvbnMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgY2IgPSBvcHRpb25zLCBvcHRpb25zID0ge31cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICBpZiAob3B0aW9ucy5zeW5jKSB7XG4gICAgaWYgKGNiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iJylcbiAgICByZXR1cm4gZ2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYilcbn1cblxuZ2xvYi5zeW5jID0gZ2xvYlN5bmNcbnZhciBHbG9iU3luYyA9IGdsb2IuR2xvYlN5bmMgPSBnbG9iU3luYy5HbG9iU3luY1xuXG4vLyBvbGQgYXBpIHN1cmZhY2Vcbmdsb2IuZ2xvYiA9IGdsb2JcblxuZnVuY3Rpb24gZXh0ZW5kIChvcmlnaW4sIGFkZCkge1xuICBpZiAoYWRkID09PSBudWxsIHx8IHR5cGVvZiBhZGQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9yaWdpblxuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpXG4gIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXVxuICB9XG4gIHJldHVybiBvcmlnaW5cbn1cblxuZ2xvYi5oYXNNYWdpYyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zXykge1xuICB2YXIgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9uc18pXG4gIG9wdGlvbnMubm9wcm9jZXNzID0gdHJ1ZVxuXG4gIHZhciBnID0gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucylcbiAgdmFyIHNldCA9IGcubWluaW1hdGNoLnNldFxuXG4gIGlmICghcGF0dGVybilcbiAgICByZXR1cm4gZmFsc2VcblxuICBpZiAoc2V0Lmxlbmd0aCA+IDEpXG4gICAgcmV0dXJuIHRydWVcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHNldFswXS5sZW5ndGg7IGorKykge1xuICAgIGlmICh0eXBlb2Ygc2V0WzBdW2pdICE9PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZ2xvYi5HbG9iID0gR2xvYlxuaW5oZXJpdHMoR2xvYiwgRUUpXG5mdW5jdGlvbiBHbG9iIChwYXR0ZXJuLCBvcHRpb25zLCBjYikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gbnVsbFxuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zeW5jKSB7XG4gICAgaWYgKGNiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iJylcbiAgICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2xvYikpXG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKVxuXG4gIHNldG9wdHModGhpcywgcGF0dGVybiwgb3B0aW9ucylcbiAgdGhpcy5fZGlkUmVhbFBhdGggPSBmYWxzZVxuXG4gIC8vIHByb2Nlc3MgZWFjaCBwYXR0ZXJuIGluIHRoZSBtaW5pbWF0Y2ggc2V0XG4gIHZhciBuID0gdGhpcy5taW5pbWF0Y2guc2V0Lmxlbmd0aFxuXG4gIC8vIFRoZSBtYXRjaGVzIGFyZSBzdG9yZWQgYXMgezxmaWxlbmFtZT46IHRydWUsLi4ufSBzbyB0aGF0XG4gIC8vIGR1cGxpY2F0ZXMgYXJlIGF1dG9tYWdpY2FsbHkgcHJ1bmVkLlxuICAvLyBMYXRlciwgd2UgZG8gYW4gT2JqZWN0LmtleXMoKSBvbiB0aGVzZS5cbiAgLy8gS2VlcCB0aGVtIGFzIGEgbGlzdCBzbyB3ZSBjYW4gZmlsbCBpbiB3aGVuIG5vbnVsbCBpcyBzZXQuXG4gIHRoaXMubWF0Y2hlcyA9IG5ldyBBcnJheShuKVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9uY2UoY2IpXG4gICAgdGhpcy5vbignZXJyb3InLCBjYilcbiAgICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbiAobWF0Y2hlcykge1xuICAgICAgY2IobnVsbCwgbWF0Y2hlcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3Byb2Nlc3NpbmcgPSAwXG5cbiAgdGhpcy5fZW1pdFF1ZXVlID0gW11cbiAgdGhpcy5fcHJvY2Vzc1F1ZXVlID0gW11cbiAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuXG4gIGlmICh0aGlzLm5vcHJvY2VzcylcbiAgICByZXR1cm4gdGhpc1xuXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiBkb25lKClcblxuICB2YXIgc3luYyA9IHRydWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICsrKSB7XG4gICAgdGhpcy5fcHJvY2Vzcyh0aGlzLm1pbmltYXRjaC5zZXRbaV0sIGksIGZhbHNlLCBkb25lKVxuICB9XG4gIHN5bmMgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgIC0tc2VsZi5fcHJvY2Vzc2luZ1xuICAgIGlmIChzZWxmLl9wcm9jZXNzaW5nIDw9IDApIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9maW5pc2goKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2IpXG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMucmVhbHBhdGggJiYgIXRoaXMuX2RpZFJlYWxwYXRoKVxuICAgIHJldHVybiB0aGlzLl9yZWFscGF0aCgpXG5cbiAgY29tbW9uLmZpbmlzaCh0aGlzKVxuICB0aGlzLmVtaXQoJ2VuZCcsIHRoaXMuZm91bmQpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFscGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RpZFJlYWxwYXRoKVxuICAgIHJldHVyblxuXG4gIHRoaXMuX2RpZFJlYWxwYXRoID0gdHJ1ZVxuXG4gIHZhciBuID0gdGhpcy5tYXRjaGVzLmxlbmd0aFxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoKClcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpKyspXG4gICAgdGhpcy5fcmVhbHBhdGhTZXQoaSwgbmV4dClcblxuICBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICBpZiAoLS1uID09PSAwKVxuICAgICAgc2VsZi5fZmluaXNoKClcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhbHBhdGhTZXQgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHZhciBtYXRjaHNldCA9IHRoaXMubWF0Y2hlc1tpbmRleF1cbiAgaWYgKCFtYXRjaHNldClcbiAgICByZXR1cm4gY2IoKVxuXG4gIHZhciBmb3VuZCA9IE9iamVjdC5rZXlzKG1hdGNoc2V0KVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG4gPSBmb3VuZC5sZW5ndGhcblxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gY2IoKVxuXG4gIHZhciBzZXQgPSB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBmb3VuZC5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgLy8gSWYgdGhlcmUncyBhIHByb2JsZW0gd2l0aCB0aGUgc3RhdCwgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgLy8gb25lIG9yIG1vcmUgb2YgdGhlIGxpbmtzIGluIHRoZSByZWFscGF0aCBjb3VsZG4ndCBiZVxuICAgIC8vIHJlc29sdmVkLiAganVzdCByZXR1cm4gdGhlIGFicyB2YWx1ZSBpbiB0aGF0IGNhc2UuXG4gICAgcCA9IHNlbGYuX21ha2VBYnMocClcbiAgICBycC5yZWFscGF0aChwLCBzZWxmLnJlYWxwYXRoQ2FjaGUsIGZ1bmN0aW9uIChlciwgcmVhbCkge1xuICAgICAgaWYgKCFlcilcbiAgICAgICAgc2V0W3JlYWxdID0gdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXIuc3lzY2FsbCA9PT0gJ3N0YXQnKVxuICAgICAgICBzZXRbcF0gPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcikgLy8gc3JzbHkgd3RmIHJpZ2h0IGhlcmVcblxuICAgICAgaWYgKC0tbiA9PT0gMCkge1xuICAgICAgICBzZWxmLm1hdGNoZXNbaW5kZXhdID0gc2V0XG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5HbG9iLnByb3RvdHlwZS5fbWFyayA9IGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBjb21tb24ubWFyayh0aGlzLCBwKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fbWFrZUFicyA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBjb21tb24ubWFrZUFicyh0aGlzLCBmKVxufVxuXG5HbG9iLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICB0aGlzLmVtaXQoJ2Fib3J0Jylcbn1cblxuR2xvYi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJylcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX2VtaXRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBlcSA9IHRoaXMuX2VtaXRRdWV1ZS5zbGljZSgwKVxuICAgICAgdGhpcy5fZW1pdFF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXEubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBlID0gZXFbaV1cbiAgICAgICAgdGhpcy5fZW1pdE1hdGNoKGVbMF0sIGVbMV0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcm9jZXNzUXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgcHEgPSB0aGlzLl9wcm9jZXNzUXVldWUuc2xpY2UoMClcbiAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZS5sZW5ndGggPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBxLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIgcCA9IHBxW2ldXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmctLVxuICAgICAgICB0aGlzLl9wcm9jZXNzKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKHBhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYikge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2IpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICB0aGlzLl9wcm9jZXNzaW5nKytcbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlLnB1c2goW3BhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYl0pXG4gICAgcmV0dXJuXG4gIH1cblxuICAvL2NvbnNvbGUuZXJyb3IoJ1BST0NFU1MgJWQnLCB0aGlzLl9wcm9jZXNzaW5nLCBwYXR0ZXJuKVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgW25dIHBhcnRzIG9mIHBhdHRlcm4gdGhhdCBhcmUgYWxsIHN0cmluZ3MuXG4gIHZhciBuID0gMFxuICB3aGlsZSAodHlwZW9mIHBhdHRlcm5bbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgbiArK1xuICB9XG4gIC8vIG5vdyBuIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgKm5vdCogYSBzdHJpbmcuXG5cbiAgLy8gc2VlIGlmIHRoZXJlJ3MgYW55dGhpbmcgZWxzZVxuICB2YXIgcHJlZml4XG4gIHN3aXRjaCAobikge1xuICAgIC8vIGlmIG5vdCwgdGhlbiB0aGlzIGlzIHJhdGhlciBzaW1wbGVcbiAgICBjYXNlIHBhdHRlcm4ubGVuZ3RoOlxuICAgICAgdGhpcy5fcHJvY2Vzc1NpbXBsZShwYXR0ZXJuLmpvaW4oJy8nKSwgaW5kZXgsIGNiKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlIDA6XG4gICAgICAvLyBwYXR0ZXJuICpzdGFydHMqIHdpdGggc29tZSBub24tdHJpdmlhbCBpdGVtLlxuICAgICAgLy8gZ29pbmcgdG8gcmVhZGRpcihjd2QpLCBidXQgbm90IGluY2x1ZGUgdGhlIHByZWZpeCBpbiBtYXRjaGVzLlxuICAgICAgcHJlZml4ID0gbnVsbFxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBwYXR0ZXJuIGhhcyBzb21lIHN0cmluZyBiaXRzIGluIHRoZSBmcm9udC5cbiAgICAgIC8vIHdoYXRldmVyIGl0IHN0YXJ0cyB3aXRoLCB3aGV0aGVyIHRoYXQncyAnYWJzb2x1dGUnIGxpa2UgL2Zvby9iYXIsXG4gICAgICAvLyBvciAncmVsYXRpdmUnIGxpa2UgJy4uL2JheidcbiAgICAgIHByZWZpeCA9IHBhdHRlcm4uc2xpY2UoMCwgbikuam9pbignLycpXG4gICAgICBicmVha1xuICB9XG5cbiAgdmFyIHJlbWFpbiA9IHBhdHRlcm4uc2xpY2UobilcblxuICAvLyBnZXQgdGhlIGxpc3Qgb2YgZW50cmllcy5cbiAgdmFyIHJlYWRcbiAgaWYgKHByZWZpeCA9PT0gbnVsbClcbiAgICByZWFkID0gJy4nXG4gIGVsc2UgaWYgKGlzQWJzb2x1dGUocHJlZml4KSB8fFxuICAgICAgaXNBYnNvbHV0ZShwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6ICdbKl0nXG4gICAgICB9KS5qb2luKCcvJykpKSB7XG4gICAgaWYgKCFwcmVmaXggfHwgIWlzQWJzb2x1dGUocHJlZml4KSlcbiAgICAgIHByZWZpeCA9ICcvJyArIHByZWZpeFxuICAgIHJlYWQgPSBwcmVmaXhcbiAgfSBlbHNlXG4gICAgcmVhZCA9IHByZWZpeFxuXG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKHJlYWQpXG5cbiAgLy9pZiBpZ25vcmVkLCBza2lwIF9wcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgaXNHbG9iU3RhciA9IHJlbWFpblswXSA9PT0gbWluaW1hdGNoLkdMT0JTVEFSXG4gIGlmIChpc0dsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3NHbG9iU3RhcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICByZXR1cm4gc2VsZi5fcHJvY2Vzc1JlYWRkaXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcblxuICAvLyBpZiB0aGUgYWJzIGlzbid0IGEgZGlyLCB0aGVuIG5vdGhpbmcgY2FuIG1hdGNoIVxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyBJdCB3aWxsIG9ubHkgbWF0Y2ggZG90IGVudHJpZXMgaWYgaXQgc3RhcnRzIHdpdGggYSBkb3QsIG9yIGlmXG4gIC8vIGRvdCBpcyBzZXQuICBTdHVmZiBsaWtlIEAoLmZvb3wuYmFyKSBpc24ndCBhbGxvd2VkLlxuICB2YXIgcG4gPSByZW1haW5bMF1cbiAgdmFyIG5lZ2F0ZSA9ICEhdGhpcy5taW5pbWF0Y2gubmVnYXRlXG4gIHZhciByYXdHbG9iID0gcG4uX2dsb2JcbiAgdmFyIGRvdE9rID0gdGhpcy5kb3QgfHwgcmF3R2xvYi5jaGFyQXQoMCkgPT09ICcuJ1xuXG4gIHZhciBtYXRjaGVkRW50cmllcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gJy4nIHx8IGRvdE9rKSB7XG4gICAgICB2YXIgbVxuICAgICAgaWYgKG5lZ2F0ZSAmJiAhcHJlZml4KSB7XG4gICAgICAgIG0gPSAhZS5tYXRjaChwbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBlLm1hdGNoKHBuKVxuICAgICAgfVxuICAgICAgaWYgKG0pXG4gICAgICAgIG1hdGNoZWRFbnRyaWVzLnB1c2goZSlcbiAgICB9XG4gIH1cblxuICAvL2NvbnNvbGUuZXJyb3IoJ3ByZDInLCBwcmVmaXgsIGVudHJpZXMsIHJlbWFpblswXS5fZ2xvYiwgbWF0Y2hlZEVudHJpZXMpXG5cbiAgdmFyIGxlbiA9IG1hdGNoZWRFbnRyaWVzLmxlbmd0aFxuICAvLyBJZiB0aGVyZSBhcmUgbm8gbWF0Y2hlZCBlbnRyaWVzLCB0aGVuIG5vdGhpbmcgbWF0Y2hlcy5cbiAgaWYgKGxlbiA9PT0gMClcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nIHBhdHRlcm4gYml0LCB0aGVuIG5vIG5lZWQgZm9yXG4gIC8vIGFuIGFkZGl0aW9uYWwgc3RhdCAqdW5sZXNzKiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG1hcmsgb3JcbiAgLy8gc3RhdCBleHBsaWNpdGx5LiAgV2Uga25vdyB0aGV5IGV4aXN0LCBzaW5jZSByZWFkZGlyIHJldHVybmVkXG4gIC8vIHRoZW0uXG5cbiAgaWYgKHJlbWFpbi5sZW5ndGggPT09IDEgJiYgIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgLy8gbm93IHRlc3QgYWxsIG1hdGNoZWQgZW50cmllcyBhcyBzdGFuZC1pbnMgZm9yIHRoYXQgcGFydFxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgcmVtYWluLnNoaWZ0KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgdmFyIG5ld1BhdHRlcm5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBpZiAocHJlZml4ICE9PSAnLycpXG4gICAgICAgIGUgPSBwcmVmaXggKyAnLycgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgfVxuICAgIHRoaXMuX3Byb2Nlc3MoW2VdLmNvbmNhdChyZW1haW4pLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIH1cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fZW1pdE1hdGNoID0gZnVuY3Rpb24gKGluZGV4LCBlKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLl9lbWl0UXVldWUucHVzaChbaW5kZXgsIGVdKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGFicyA9IGlzQWJzb2x1dGUoZSkgPyBlIDogdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSlcbiAgICBlID0gYWJzXG5cbiAgaWYgKHRoaXMubWF0Y2hlc1tpbmRleF1bZV0pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMubm9kaXIpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmIChjID09PSAnRElSJyB8fCBBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLm1hdGNoZXNbaW5kZXhdW2VdID0gdHJ1ZVxuXG4gIHZhciBzdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0KVxuICAgIHRoaXMuZW1pdCgnc3RhdCcsIGUsIHN0KVxuXG4gIHRoaXMuZW1pdCgnbWF0Y2gnLCBlKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckluR2xvYlN0YXIgPSBmdW5jdGlvbiAoYWJzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGZvbGxvdyBhbGwgc3ltbGlua2VkIGRpcmVjdG9yaWVzIGZvcmV2ZXJcbiAgLy8ganVzdCBwcm9jZWVkIGFzIGlmIHRoaXMgaXMgYSBub24tZ2xvYnN0YXIgc2l0dWF0aW9uXG4gIGlmICh0aGlzLmZvbGxvdylcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlLCBjYilcblxuICB2YXIgbHN0YXRrZXkgPSAnbHN0YXRcXDAnICsgYWJzXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbHN0YXRjYiA9IGluZmxpZ2h0KGxzdGF0a2V5LCBsc3RhdGNiXylcblxuICBpZiAobHN0YXRjYilcbiAgICBzZWxmLmZzLmxzdGF0KGFicywgbHN0YXRjYilcblxuICBmdW5jdGlvbiBsc3RhdGNiXyAoZXIsIGxzdGF0KSB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIHZhciBpc1N5bSA9IGxzdGF0ICYmIGxzdGF0LmlzU3ltYm9saWNMaW5rKClcbiAgICBzZWxmLnN5bWxpbmtzW2Fic10gPSBpc1N5bVxuXG4gICAgLy8gSWYgaXQncyBub3QgYSBzeW1saW5rIG9yIGEgZGlyLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBhIHJlZ3VsYXIgZmlsZS5cbiAgICAvLyBkb24ndCBib3RoZXIgZG9pbmcgYSByZWFkZGlyIGluIHRoYXQgY2FzZS5cbiAgICBpZiAoIWlzU3ltICYmIGxzdGF0ICYmICFsc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBzZWxmLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGNiKClcbiAgICB9IGVsc2VcbiAgICAgIHNlbGYuX3JlYWRkaXIoYWJzLCBmYWxzZSwgY2IpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXIgPSBmdW5jdGlvbiAoYWJzLCBpbkdsb2JTdGFyLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGNiID0gaW5mbGlnaHQoJ3JlYWRkaXJcXDAnK2FicysnXFwwJytpbkdsb2JTdGFyLCBjYilcbiAgaWYgKCFjYilcbiAgICByZXR1cm5cblxuICAvL2NvbnNvbGUuZXJyb3IoJ1JEICVqICVqJywgK2luR2xvYlN0YXIsIGFicylcbiAgaWYgKGluR2xvYlN0YXIgJiYgIW93blByb3AodGhpcy5zeW1saW5rcywgYWJzKSlcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckluR2xvYlN0YXIoYWJzLCBjYilcblxuICBpZiAob3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoIWMgfHwgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGMpXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5mcy5yZWFkZGlyKGFicywgcmVhZGRpckNiKHRoaXMsIGFicywgY2IpKVxufVxuXG5mdW5jdGlvbiByZWFkZGlyQ2IgKHNlbGYsIGFicywgY2IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlciwgZW50cmllcykge1xuICAgIGlmIChlcilcbiAgICAgIHNlbGYuX3JlYWRkaXJFcnJvcihhYnMsIGVyLCBjYilcbiAgICBlbHNlXG4gICAgICBzZWxmLl9yZWFkZGlyRW50cmllcyhhYnMsIGVudHJpZXMsIGNiKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyRW50cmllcyA9IGZ1bmN0aW9uIChhYnMsIGVudHJpZXMsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gaWYgd2UgaGF2ZW4ndCBhc2tlZCB0byBzdGF0IGV2ZXJ5dGhpbmcsIHRoZW4ganVzdFxuICAvLyBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIGluIHRoZXJlIGV4aXN0cywgc28gd2UgY2FuIGF2b2lkXG4gIC8vIGhhdmluZyB0byBzdGF0IGl0IGEgc2Vjb25kIHRpbWUuXG4gIGlmICghdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICAgIGlmIChhYnMgPT09ICcvJylcbiAgICAgICAgZSA9IGFicyArIGVcbiAgICAgIGVsc2VcbiAgICAgICAgZSA9IGFicyArICcvJyArIGVcbiAgICAgIHRoaXMuY2FjaGVbZV0gPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5jYWNoZVthYnNdID0gZW50cmllc1xuICByZXR1cm4gY2IobnVsbCwgZW50cmllcylcbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXJFcnJvciA9IGZ1bmN0aW9uIChmLCBlciwgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICAvLyBoYW5kbGUgZXJyb3JzLCBhbmQgY2FjaGUgdGhlIGluZm9ybWF0aW9uXG4gIHN3aXRjaCAoZXIuY29kZSkge1xuICAgIGNhc2UgJ0VOT1RTVVAnOiAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMjA1XG4gICAgY2FzZSAnRU5PVERJUic6IC8vIHRvdGFsbHkgbm9ybWFsLiBtZWFucyBpdCAqZG9lcyogZXhpc3QuXG4gICAgICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICAgICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBpZiAoYWJzID09PSB0aGlzLmN3ZEFicykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXIuY29kZSArICcgaW52YWxpZCBjd2QgJyArIHRoaXMuY3dkKVxuICAgICAgICBlcnJvci5wYXRoID0gdGhpcy5jd2RcbiAgICAgICAgZXJyb3IuY29kZSA9IGVyLmNvZGVcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgICAgICB0aGlzLmFib3J0KClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdFTk9FTlQnOiAvLyBub3QgdGVycmlibHkgdW51c3VhbFxuICAgIGNhc2UgJ0VMT09QJzpcbiAgICBjYXNlICdFTkFNRVRPT0xPTkcnOlxuICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDogLy8gc29tZSB1bnVzdWFsIGVycm9yLiAgVHJlYXQgYXMgZmFpbHVyZS5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuc3RyaWN0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgICAgLy8gSWYgdGhlIGVycm9yIGlzIGhhbmRsZWQsIHRoZW4gd2UgYWJvcnRcbiAgICAgICAgLy8gaWYgbm90LCB3ZSB0aHJldyBvdXQgb2YgaGVyZVxuICAgICAgICB0aGlzLmFib3J0KClcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zaWxlbnQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsb2IgZXJyb3InLCBlcilcbiAgICAgIGJyZWFrXG4gIH1cblxuICByZXR1cm4gY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc0dsb2JTdGFyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIsIGZ1bmN0aW9uIChlciwgZW50cmllcykge1xuICAgIHNlbGYuX3Byb2Nlc3NHbG9iU3RhcjIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKVxuICB9KVxufVxuXG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzR2xvYlN0YXIyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYikge1xuICAvL2NvbnNvbGUuZXJyb3IoJ3BnczInLCBwcmVmaXgsIHJlbWFpblswXSwgZW50cmllcylcblxuICAvLyBubyBlbnRyaWVzIG1lYW5zIG5vdCBhIGRpciwgc28gaXQgY2FuIG5ldmVyIGhhdmUgbWF0Y2hlc1xuICAvLyBmb28udHh0LyoqIGRvZXNuJ3QgbWF0Y2ggZm9vLnR4dFxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyB0ZXN0IHdpdGhvdXQgdGhlIGdsb2JzdGFyLCBhbmQgd2l0aCBldmVyeSBjaGlsZCBib3RoIGJlbG93XG4gIC8vIGFuZCByZXBsYWNpbmcgdGhlIGdsb2JzdGFyLlxuICB2YXIgcmVtYWluV2l0aG91dEdsb2JTdGFyID0gcmVtYWluLnNsaWNlKDEpXG4gIHZhciBnc3ByZWYgPSBwcmVmaXggPyBbIHByZWZpeCBdIDogW11cbiAgdmFyIG5vR2xvYlN0YXIgPSBnc3ByZWYuY29uY2F0KHJlbWFpbldpdGhvdXRHbG9iU3RhcilcblxuICAvLyB0aGUgbm9HbG9iU3RhciBwYXR0ZXJuIGV4aXRzIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gIHRoaXMuX3Byb2Nlc3Mobm9HbG9iU3RhciwgaW5kZXgsIGZhbHNlLCBjYilcblxuICB2YXIgaXNTeW0gPSB0aGlzLnN5bWxpbmtzW2Fic11cbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoXG5cbiAgLy8gSWYgaXQncyBhIHN5bWxpbmssIGFuZCB3ZSdyZSBpbiBhIGdsb2JzdGFyLCB0aGVuIHN0b3BcbiAgaWYgKGlzU3ltICYmIGluR2xvYlN0YXIpXG4gICAgcmV0dXJuIGNiKClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApID09PSAnLicgJiYgIXRoaXMuZG90KVxuICAgICAgY29udGludWVcblxuICAgIC8vIHRoZXNlIHR3byBjYXNlcyBlbnRlciB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICAgIHZhciBpbnN0ZWFkID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW5XaXRob3V0R2xvYlN0YXIpXG4gICAgdGhpcy5fcHJvY2VzcyhpbnN0ZWFkLCBpbmRleCwgdHJ1ZSwgY2IpXG5cbiAgICB2YXIgYmVsb3cgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbilcbiAgICB0aGlzLl9wcm9jZXNzKGJlbG93LCBpbmRleCwgdHJ1ZSwgY2IpXG4gIH1cblxuICBjYigpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgsIGNiKSB7XG4gIC8vIFhYWCByZXZpZXcgdGhpcy4gIFNob3VsZG4ndCBpdCBiZSBkb2luZyB0aGUgbW91bnRpbmcgZXRjXG4gIC8vIGJlZm9yZSBkb2luZyBzdGF0PyAga2luZGEgd2VpcmQ/XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9zdGF0KHByZWZpeCwgZnVuY3Rpb24gKGVyLCBleGlzdHMpIHtcbiAgICBzZWxmLl9wcm9jZXNzU2ltcGxlMihwcmVmaXgsIGluZGV4LCBlciwgZXhpc3RzLCBjYilcbiAgfSlcbn1cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlMiA9IGZ1bmN0aW9uIChwcmVmaXgsIGluZGV4LCBlciwgZXhpc3RzLCBjYikge1xuXG4gIC8vY29uc29sZS5lcnJvcigncHMyJywgcHJlZml4LCBleGlzdHMpXG5cbiAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgIHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdGhlbiBqdXN0IG1hcmsgdGhlIGxhY2sgb2YgcmVzdWx0c1xuICBpZiAoIWV4aXN0cylcbiAgICByZXR1cm4gY2IoKVxuXG4gIGlmIChwcmVmaXggJiYgaXNBYnNvbHV0ZShwcmVmaXgpICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICB2YXIgdHJhaWwgPSAvW1xcL1xcXFxdJC8udGVzdChwcmVmaXgpXG4gICAgaWYgKHByZWZpeC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgcHJlZml4ID0gcGF0aC5qb2luKHRoaXMucm9vdCwgcHJlZml4KVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXggPSBwYXRoLnJlc29sdmUodGhpcy5yb290LCBwcmVmaXgpXG4gICAgICBpZiAodHJhaWwpXG4gICAgICAgIHByZWZpeCArPSAnLydcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvXFxcXC9nLCAnLycpXG5cbiAgLy8gTWFyayB0aGlzIGFzIGEgbWF0Y2hcbiAgdGhpcy5fZW1pdE1hdGNoKGluZGV4LCBwcmVmaXgpXG4gIGNiKClcbn1cblxuLy8gUmV0dXJucyBlaXRoZXIgJ0RJUicsICdGSUxFJywgb3IgZmFsc2Vcbkdsb2IucHJvdG90eXBlLl9zdGF0ID0gZnVuY3Rpb24gKGYsIGNiKSB7XG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuXG4gIGlmIChmLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKVxuICAgIHJldHVybiBjYigpXG5cbiAgaWYgKCF0aGlzLnN0YXQgJiYgb3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgYyA9ICdESVInXG5cbiAgICAvLyBJdCBleGlzdHMsIGJ1dCBtYXliZSBub3QgaG93IHdlIG5lZWQgaXRcbiAgICBpZiAoIW5lZWREaXIgfHwgYyA9PT0gJ0RJUicpXG4gICAgICByZXR1cm4gY2IobnVsbCwgYylcblxuICAgIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICAvLyBvdGhlcndpc2Ugd2UgaGF2ZSB0byBzdGF0LCBiZWNhdXNlIG1heWJlIGM9dHJ1ZVxuICAgIC8vIGlmIHdlIGtub3cgaXQgZXhpc3RzLCBidXQgbm90IHdoYXQgaXQgaXMuXG4gIH1cblxuICB2YXIgZXhpc3RzXG4gIHZhciBzdGF0ID0gdGhpcy5zdGF0Q2FjaGVbYWJzXVxuICBpZiAoc3RhdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHN0YXQgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIHN0YXQpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgdHlwZSA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG4gICAgICBpZiAobmVlZERpciAmJiB0eXBlID09PSAnRklMRScpXG4gICAgICAgIHJldHVybiBjYigpXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBjYihudWxsLCB0eXBlLCBzdGF0KVxuICAgIH1cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgc3RhdGNiID0gaW5mbGlnaHQoJ3N0YXRcXDAnICsgYWJzLCBsc3RhdGNiXylcbiAgaWYgKHN0YXRjYilcbiAgICBzZWxmLmZzLmxzdGF0KGFicywgc3RhdGNiKVxuXG4gIGZ1bmN0aW9uIGxzdGF0Y2JfIChlciwgbHN0YXQpIHtcbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgLy8gSWYgaXQncyBhIHN5bWxpbmssIHRoZW4gdHJlYXQgaXQgYXMgdGhlIHRhcmdldCwgdW5sZXNzXG4gICAgICAvLyB0aGUgdGFyZ2V0IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRyZWF0IGl0IGFzIGEgZmlsZS5cbiAgICAgIHJldHVybiBzZWxmLmZzLnN0YXQoYWJzLCBmdW5jdGlvbiAoZXIsIHN0YXQpIHtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgbnVsbCwgbHN0YXQsIGNiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgc3RhdCwgY2IpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIGVyLCBsc3RhdCwgY2IpXG4gICAgfVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9zdGF0MiA9IGZ1bmN0aW9uIChmLCBhYnMsIGVyLCBzdGF0LCBjYikge1xuICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVyLmNvZGUgPT09ICdFTk9URElSJykpIHtcbiAgICB0aGlzLnN0YXRDYWNoZVthYnNdID0gZmFsc2VcbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG4gIHRoaXMuc3RhdENhY2hlW2Fic10gPSBzdGF0XG5cbiAgaWYgKGFicy5zbGljZSgtMSkgPT09ICcvJyAmJiBzdGF0ICYmICFzdGF0LmlzRGlyZWN0b3J5KCkpXG4gICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlLCBzdGF0KVxuXG4gIHZhciBjID0gdHJ1ZVxuICBpZiAoc3RhdClcbiAgICBjID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcbiAgdGhpcy5jYWNoZVthYnNdID0gdGhpcy5jYWNoZVthYnNdIHx8IGNcblxuICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgcmV0dXJuIGNiKClcblxuICByZXR1cm4gY2IobnVsbCwgYywgc3RhdClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYlN5bmNcbmdsb2JTeW5jLkdsb2JTeW5jID0gR2xvYlN5bmNcblxudmFyIHJwID0gcmVxdWlyZSgnZnMucmVhbHBhdGgnKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxudmFyIEdsb2IgPSByZXF1aXJlKCcuL2dsb2IuanMnKS5HbG9iXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJylcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpXG52YXIgc2V0b3B0cyA9IGNvbW1vbi5zZXRvcHRzXG52YXIgb3duUHJvcCA9IGNvbW1vbi5vd25Qcm9wXG52YXIgY2hpbGRyZW5JZ25vcmVkID0gY29tbW9uLmNoaWxkcmVuSWdub3JlZFxudmFyIGlzSWdub3JlZCA9IGNvbW1vbi5pc0lnbm9yZWRcblxuZnVuY3Rpb24gZ2xvYlN5bmMgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDMpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iXFxuJytcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8xNjcnKVxuXG4gIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucykuZm91bmRcbn1cblxuZnVuY3Rpb24gR2xvYlN5bmMgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFwYXR0ZXJuKVxuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIHBhdHRlcm4nKVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYlxcbicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMTY3JylcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpKVxuICAgIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcblxuICBzZXRvcHRzKHRoaXMsIHBhdHRlcm4sIG9wdGlvbnMpXG5cbiAgaWYgKHRoaXMubm9wcm9jZXNzKVxuICAgIHJldHVybiB0aGlzXG5cbiAgdmFyIG4gPSB0aGlzLm1pbmltYXRjaC5zZXQubGVuZ3RoXG4gIHRoaXMubWF0Y2hlcyA9IG5ldyBBcnJheShuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkgKyspIHtcbiAgICB0aGlzLl9wcm9jZXNzKHRoaXMubWluaW1hdGNoLnNldFtpXSwgaSwgZmFsc2UpXG4gIH1cbiAgdGhpcy5fZmluaXNoKClcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydC5vayh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpXG4gIGlmICh0aGlzLnJlYWxwYXRoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdGhpcy5tYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoc2V0LCBpbmRleCkge1xuICAgICAgdmFyIHNldCA9IHNlbGYubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICBmb3IgKHZhciBwIGluIG1hdGNoc2V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IHNlbGYuX21ha2VBYnMocClcbiAgICAgICAgICB2YXIgcmVhbCA9IHJwLnJlYWxwYXRoU3luYyhwLCBzZWxmLnJlYWxwYXRoQ2FjaGUpXG4gICAgICAgICAgc2V0W3JlYWxdID0gdHJ1ZVxuICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIGlmIChlci5zeXNjYWxsID09PSAnc3RhdCcpXG4gICAgICAgICAgICBzZXRbc2VsZi5fbWFrZUFicyhwKV0gPSB0cnVlXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgY29tbW9uLmZpbmlzaCh0aGlzKVxufVxuXG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgW25dIHBhcnRzIG9mIHBhdHRlcm4gdGhhdCBhcmUgYWxsIHN0cmluZ3MuXG4gIHZhciBuID0gMFxuICB3aGlsZSAodHlwZW9mIHBhdHRlcm5bbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgbiArK1xuICB9XG4gIC8vIG5vdyBuIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgKm5vdCogYSBzdHJpbmcuXG5cbiAgLy8gU2VlIGlmIHRoZXJlJ3MgYW55dGhpbmcgZWxzZVxuICB2YXIgcHJlZml4XG4gIHN3aXRjaCAobikge1xuICAgIC8vIGlmIG5vdCwgdGhlbiB0aGlzIGlzIHJhdGhlciBzaW1wbGVcbiAgICBjYXNlIHBhdHRlcm4ubGVuZ3RoOlxuICAgICAgdGhpcy5fcHJvY2Vzc1NpbXBsZShwYXR0ZXJuLmpvaW4oJy8nKSwgaW5kZXgpXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgMDpcbiAgICAgIC8vIHBhdHRlcm4gKnN0YXJ0cyogd2l0aCBzb21lIG5vbi10cml2aWFsIGl0ZW0uXG4gICAgICAvLyBnb2luZyB0byByZWFkZGlyKGN3ZCksIGJ1dCBub3QgaW5jbHVkZSB0aGUgcHJlZml4IGluIG1hdGNoZXMuXG4gICAgICBwcmVmaXggPSBudWxsXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHBhdHRlcm4gaGFzIHNvbWUgc3RyaW5nIGJpdHMgaW4gdGhlIGZyb250LlxuICAgICAgLy8gd2hhdGV2ZXIgaXQgc3RhcnRzIHdpdGgsIHdoZXRoZXIgdGhhdCdzICdhYnNvbHV0ZScgbGlrZSAvZm9vL2JhcixcbiAgICAgIC8vIG9yICdyZWxhdGl2ZScgbGlrZSAnLi4vYmF6J1xuICAgICAgcHJlZml4ID0gcGF0dGVybi5zbGljZSgwLCBuKS5qb2luKCcvJylcbiAgICAgIGJyZWFrXG4gIH1cblxuICB2YXIgcmVtYWluID0gcGF0dGVybi5zbGljZShuKVxuXG4gIC8vIGdldCB0aGUgbGlzdCBvZiBlbnRyaWVzLlxuICB2YXIgcmVhZFxuICBpZiAocHJlZml4ID09PSBudWxsKVxuICAgIHJlYWQgPSAnLidcbiAgZWxzZSBpZiAoaXNBYnNvbHV0ZShwcmVmaXgpIHx8XG4gICAgICBpc0Fic29sdXRlKHBhdHRlcm4ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyBwIDogJ1sqXSdcbiAgICAgIH0pLmpvaW4oJy8nKSkpIHtcbiAgICBpZiAoIXByZWZpeCB8fCAhaXNBYnNvbHV0ZShwcmVmaXgpKVxuICAgICAgcHJlZml4ID0gJy8nICsgcHJlZml4XG4gICAgcmVhZCA9IHByZWZpeFxuICB9IGVsc2VcbiAgICByZWFkID0gcHJlZml4XG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMocmVhZClcblxuICAvL2lmIGlnbm9yZWQsIHNraXAgcHJvY2Vzc2luZ1xuICBpZiAoY2hpbGRyZW5JZ25vcmVkKHRoaXMsIHJlYWQpKVxuICAgIHJldHVyblxuXG4gIHZhciBpc0dsb2JTdGFyID0gcmVtYWluWzBdID09PSBtaW5pbWF0Y2guR0xPQlNUQVJcbiAgaWYgKGlzR2xvYlN0YXIpXG4gICAgdGhpcy5fcHJvY2Vzc0dsb2JTdGFyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKVxuICBlbHNlXG4gICAgdGhpcy5fcHJvY2Vzc1JlYWRkaXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuICB2YXIgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyKVxuXG4gIC8vIGlmIHRoZSBhYnMgaXNuJ3QgYSBkaXIsIHRoZW4gbm90aGluZyBjYW4gbWF0Y2ghXG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm5cblxuICAvLyBJdCB3aWxsIG9ubHkgbWF0Y2ggZG90IGVudHJpZXMgaWYgaXQgc3RhcnRzIHdpdGggYSBkb3QsIG9yIGlmXG4gIC8vIGRvdCBpcyBzZXQuICBTdHVmZiBsaWtlIEAoLmZvb3wuYmFyKSBpc24ndCBhbGxvd2VkLlxuICB2YXIgcG4gPSByZW1haW5bMF1cbiAgdmFyIG5lZ2F0ZSA9ICEhdGhpcy5taW5pbWF0Y2gubmVnYXRlXG4gIHZhciByYXdHbG9iID0gcG4uX2dsb2JcbiAgdmFyIGRvdE9rID0gdGhpcy5kb3QgfHwgcmF3R2xvYi5jaGFyQXQoMCkgPT09ICcuJ1xuXG4gIHZhciBtYXRjaGVkRW50cmllcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gJy4nIHx8IGRvdE9rKSB7XG4gICAgICB2YXIgbVxuICAgICAgaWYgKG5lZ2F0ZSAmJiAhcHJlZml4KSB7XG4gICAgICAgIG0gPSAhZS5tYXRjaChwbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBlLm1hdGNoKHBuKVxuICAgICAgfVxuICAgICAgaWYgKG0pXG4gICAgICAgIG1hdGNoZWRFbnRyaWVzLnB1c2goZSlcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gbWF0Y2hlZEVudHJpZXMubGVuZ3RoXG4gIC8vIElmIHRoZXJlIGFyZSBubyBtYXRjaGVkIGVudHJpZXMsIHRoZW4gbm90aGluZyBtYXRjaGVzLlxuICBpZiAobGVuID09PSAwKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nIHBhdHRlcm4gYml0LCB0aGVuIG5vIG5lZWQgZm9yXG4gIC8vIGFuIGFkZGl0aW9uYWwgc3RhdCAqdW5sZXNzKiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG1hcmsgb3JcbiAgLy8gc3RhdCBleHBsaWNpdGx5LiAgV2Uga25vdyB0aGV5IGV4aXN0LCBzaW5jZSByZWFkZGlyIHJldHVybmVkXG4gIC8vIHRoZW0uXG5cbiAgaWYgKHJlbWFpbi5sZW5ndGggPT09IDEgJiYgIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXguc2xpY2UoLTEpICE9PSAnLycpXG4gICAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy8nICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICAgICAgZSA9IHBhdGguam9pbih0aGlzLnJvb3QsIGUpXG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIGUpXG4gICAgfVxuICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IG9uZSwgYW5kIG5vIHN0YXRzIHdlcmUgbmVlZGVkXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBub3cgdGVzdCBhbGwgbWF0Y2hlZCBlbnRyaWVzIGFzIHN0YW5kLWlucyBmb3IgdGhhdCBwYXJ0XG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICByZW1haW4uc2hpZnQoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICB2YXIgbmV3UGF0dGVyblxuICAgIGlmIChwcmVmaXgpXG4gICAgICBuZXdQYXR0ZXJuID0gW3ByZWZpeCwgZV1cbiAgICBlbHNlXG4gICAgICBuZXdQYXR0ZXJuID0gW2VdXG4gICAgdGhpcy5fcHJvY2VzcyhuZXdQYXR0ZXJuLmNvbmNhdChyZW1haW4pLCBpbmRleCwgaW5HbG9iU3RhcilcbiAgfVxufVxuXG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fZW1pdE1hdGNoID0gZnVuY3Rpb24gKGluZGV4LCBlKSB7XG4gIGlmIChpc0lnbm9yZWQodGhpcywgZSkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZSlcblxuICBpZiAodGhpcy5tYXJrKVxuICAgIGUgPSB0aGlzLl9tYXJrKGUpXG5cbiAgaWYgKHRoaXMuYWJzb2x1dGUpIHtcbiAgICBlID0gYWJzXG4gIH1cblxuICBpZiAodGhpcy5tYXRjaGVzW2luZGV4XVtlXSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5ub2Rpcikge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMubWF0Y2hlc1tpbmRleF1bZV0gPSB0cnVlXG5cbiAgaWYgKHRoaXMuc3RhdClcbiAgICB0aGlzLl9zdGF0KGUpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlySW5HbG9iU3RhciA9IGZ1bmN0aW9uIChhYnMpIHtcbiAgLy8gZm9sbG93IGFsbCBzeW1saW5rZWQgZGlyZWN0b3JpZXMgZm9yZXZlclxuICAvLyBqdXN0IHByb2NlZWQgYXMgaWYgdGhpcyBpcyBhIG5vbi1nbG9ic3RhciBzaXR1YXRpb25cbiAgaWYgKHRoaXMuZm9sbG93KVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyKGFicywgZmFsc2UpXG5cbiAgdmFyIGVudHJpZXNcbiAgdmFyIGxzdGF0XG4gIHZhciBzdGF0XG4gIHRyeSB7XG4gICAgbHN0YXQgPSB0aGlzLmZzLmxzdGF0U3luYyhhYnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAvLyBsc3RhdCBmYWlsZWQsIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgdmFyIGlzU3ltID0gbHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKVxuICB0aGlzLnN5bWxpbmtzW2Fic10gPSBpc1N5bVxuXG4gIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gIC8vIGRvbid0IGJvdGhlciBkb2luZyBhIHJlYWRkaXIgaW4gdGhhdCBjYXNlLlxuICBpZiAoIWlzU3ltICYmIGxzdGF0ICYmICFsc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICBlbHNlXG4gICAgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXIgPSBmdW5jdGlvbiAoYWJzLCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzXG5cbiAgaWYgKGluR2xvYlN0YXIgJiYgIW93blByb3AodGhpcy5zeW1saW5rcywgYWJzKSlcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckluR2xvYlN0YXIoYWJzKVxuXG4gIGlmIChvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmICghYyB8fCBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm4gY1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckVudHJpZXMoYWJzLCB0aGlzLmZzLnJlYWRkaXJTeW5jKGFicykpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgdGhpcy5fcmVhZGRpckVycm9yKGFicywgZXIpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJFbnRyaWVzID0gZnVuY3Rpb24gKGFicywgZW50cmllcykge1xuICAvLyBpZiB3ZSBoYXZlbid0IGFza2VkIHRvIHN0YXQgZXZlcnl0aGluZywgdGhlbiBqdXN0XG4gIC8vIGFzc3VtZSB0aGF0IGV2ZXJ5dGhpbmcgaW4gdGhlcmUgZXhpc3RzLCBzbyB3ZSBjYW4gYXZvaWRcbiAgLy8gaGF2aW5nIHRvIHN0YXQgaXQgYSBzZWNvbmQgdGltZS5cbiAgaWYgKCF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgICAgaWYgKGFicyA9PT0gJy8nKVxuICAgICAgICBlID0gYWJzICsgZVxuICAgICAgZWxzZVxuICAgICAgICBlID0gYWJzICsgJy8nICsgZVxuICAgICAgdGhpcy5jYWNoZVtlXSA9IHRydWVcbiAgICB9XG4gIH1cblxuICB0aGlzLmNhY2hlW2Fic10gPSBlbnRyaWVzXG5cbiAgLy8gbWFyayBhbmQgY2FjaGUgZGlyLW5lc3NcbiAgcmV0dXJuIGVudHJpZXNcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlyRXJyb3IgPSBmdW5jdGlvbiAoZiwgZXIpIHtcbiAgLy8gaGFuZGxlIGVycm9ycywgYW5kIGNhY2hlIHRoZSBpbmZvcm1hdGlvblxuICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICBjYXNlICdFTk9UU1VQJzogLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzIwNVxuICAgIGNhc2UgJ0VOT1RESVInOiAvLyB0b3RhbGx5IG5vcm1hbC4gbWVhbnMgaXQgKmRvZXMqIGV4aXN0LlxuICAgICAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICAgICAgaWYgKGFicyA9PT0gdGhpcy5jd2RBYnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVyLmNvZGUgKyAnIGludmFsaWQgY3dkICcgKyB0aGlzLmN3ZClcbiAgICAgICAgZXJyb3IucGF0aCA9IHRoaXMuY3dkXG4gICAgICAgIGVycm9yLmNvZGUgPSBlci5jb2RlXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnRU5PRU5UJzogLy8gbm90IHRlcnJpYmx5IHVudXN1YWxcbiAgICBjYXNlICdFTE9PUCc6XG4gICAgY2FzZSAnRU5BTUVUT09MT05HJzpcbiAgICBjYXNlICdVTktOT1dOJzpcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6IC8vIHNvbWUgdW51c3VhbCBlcnJvci4gIFRyZWF0IGFzIGZhaWx1cmUuXG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLnN0cmljdClcbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIGlmICghdGhpcy5zaWxlbnQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsb2IgZXJyb3InLCBlcilcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzR2xvYlN0YXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpIHtcblxuICB2YXIgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyKVxuXG4gIC8vIG5vIGVudHJpZXMgbWVhbnMgbm90IGEgZGlyLCBzbyBpdCBjYW4gbmV2ZXIgaGF2ZSBtYXRjaGVzXG4gIC8vIGZvby50eHQvKiogZG9lc24ndCBtYXRjaCBmb28udHh0XG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm5cblxuICAvLyB0ZXN0IHdpdGhvdXQgdGhlIGdsb2JzdGFyLCBhbmQgd2l0aCBldmVyeSBjaGlsZCBib3RoIGJlbG93XG4gIC8vIGFuZCByZXBsYWNpbmcgdGhlIGdsb2JzdGFyLlxuICB2YXIgcmVtYWluV2l0aG91dEdsb2JTdGFyID0gcmVtYWluLnNsaWNlKDEpXG4gIHZhciBnc3ByZWYgPSBwcmVmaXggPyBbIHByZWZpeCBdIDogW11cbiAgdmFyIG5vR2xvYlN0YXIgPSBnc3ByZWYuY29uY2F0KHJlbWFpbldpdGhvdXRHbG9iU3RhcilcblxuICAvLyB0aGUgbm9HbG9iU3RhciBwYXR0ZXJuIGV4aXRzIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gIHRoaXMuX3Byb2Nlc3Mobm9HbG9iU3RhciwgaW5kZXgsIGZhbHNlKVxuXG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aFxuICB2YXIgaXNTeW0gPSB0aGlzLnN5bWxpbmtzW2Fic11cblxuICAvLyBJZiBpdCdzIGEgc3ltbGluaywgYW5kIHdlJ3JlIGluIGEgZ2xvYnN0YXIsIHRoZW4gc3RvcFxuICBpZiAoaXNTeW0gJiYgaW5HbG9iU3RhcilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApID09PSAnLicgJiYgIXRoaXMuZG90KVxuICAgICAgY29udGludWVcblxuICAgIC8vIHRoZXNlIHR3byBjYXNlcyBlbnRlciB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICAgIHZhciBpbnN0ZWFkID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW5XaXRob3V0R2xvYlN0YXIpXG4gICAgdGhpcy5fcHJvY2VzcyhpbnN0ZWFkLCBpbmRleCwgdHJ1ZSlcblxuICAgIHZhciBiZWxvdyA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluKVxuICAgIHRoaXMuX3Byb2Nlc3MoYmVsb3csIGluZGV4LCB0cnVlKVxuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGluZGV4KSB7XG4gIC8vIFhYWCByZXZpZXcgdGhpcy4gIFNob3VsZG4ndCBpdCBiZSBkb2luZyB0aGUgbW91bnRpbmcgZXRjXG4gIC8vIGJlZm9yZSBkb2luZyBzdGF0PyAga2luZGEgd2VpcmQ/XG4gIHZhciBleGlzdHMgPSB0aGlzLl9zdGF0KHByZWZpeClcblxuICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAvLyBJZiBpdCBkb2Vzbid0IGV4aXN0LCB0aGVuIGp1c3QgbWFyayB0aGUgbGFjayBvZiByZXN1bHRzXG4gIGlmICghZXhpc3RzKVxuICAgIHJldHVyblxuXG4gIGlmIChwcmVmaXggJiYgaXNBYnNvbHV0ZShwcmVmaXgpICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICB2YXIgdHJhaWwgPSAvW1xcL1xcXFxdJC8udGVzdChwcmVmaXgpXG4gICAgaWYgKHByZWZpeC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgcHJlZml4ID0gcGF0aC5qb2luKHRoaXMucm9vdCwgcHJlZml4KVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXggPSBwYXRoLnJlc29sdmUodGhpcy5yb290LCBwcmVmaXgpXG4gICAgICBpZiAodHJhaWwpXG4gICAgICAgIHByZWZpeCArPSAnLydcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvXFxcXC9nLCAnLycpXG5cbiAgLy8gTWFyayB0aGlzIGFzIGEgbWF0Y2hcbiAgdGhpcy5fZW1pdE1hdGNoKGluZGV4LCBwcmVmaXgpXG59XG5cbi8vIFJldHVybnMgZWl0aGVyICdESVInLCAnRklMRScsIG9yIGZhbHNlXG5HbG9iU3luYy5wcm90b3R5cGUuX3N0YXQgPSBmdW5jdGlvbiAoZikge1xuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICB2YXIgbmVlZERpciA9IGYuc2xpY2UoLTEpID09PSAnLydcblxuICBpZiAoZi5sZW5ndGggPiB0aGlzLm1heExlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICBpZiAoIXRoaXMuc3RhdCAmJiBvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICBjID0gJ0RJUidcblxuICAgIC8vIEl0IGV4aXN0cywgYnV0IG1heWJlIG5vdCBob3cgd2UgbmVlZCBpdFxuICAgIGlmICghbmVlZERpciB8fCBjID09PSAnRElSJylcbiAgICAgIHJldHVybiBjXG5cbiAgICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHN0YXQsIGJlY2F1c2UgbWF5YmUgYz10cnVlXG4gICAgLy8gaWYgd2Uga25vdyBpdCBleGlzdHMsIGJ1dCBub3Qgd2hhdCBpdCBpcy5cbiAgfVxuXG4gIHZhciBleGlzdHNcbiAgdmFyIHN0YXQgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmICghc3RhdCkge1xuICAgIHZhciBsc3RhdFxuICAgIHRyeSB7XG4gICAgICBsc3RhdCA9IHRoaXMuZnMubHN0YXRTeW5jKGFicylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgICAgIHRoaXMuc3RhdENhY2hlW2Fic10gPSBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdCA9IHRoaXMuZnMuc3RhdFN5bmMoYWJzKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgc3RhdCA9IGxzdGF0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXQgPSBsc3RhdFxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RhdENhY2hlW2Fic10gPSBzdGF0XG5cbiAgdmFyIGMgPSB0cnVlXG4gIGlmIChzdGF0KVxuICAgIGMgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBjXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fbWFyayA9IGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBjb21tb24ubWFyayh0aGlzLCBwKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBNdXRhdGlvbiA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG52YXIgc2NoZWR1bGVEcmFpbjtcblxuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICBpZiAoTXV0YXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gMDtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb24obmV4dFRpY2spO1xuICAgIHZhciBlbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5kYXRhID0gKGNhbGxlZCA9ICsrY2FsbGVkICUgMik7XG4gICAgfTtcbiAgfSBlbHNlIGlmICghZ2xvYmFsLnNldEltbWVkaWF0ZSAmJiB0eXBlb2YgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBjaGFubmVsID0gbmV3IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbmV4dFRpY2s7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgnZG9jdW1lbnQnIGluIGdsb2JhbCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICB2YXIgc2NyaXB0RWwgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKCk7XG5cbiAgICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICAgIHNjcmlwdEVsID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrLCAwKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sobmV4dFRpY2spO1xuICB9O1xufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cbiIsInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxudmFyIHJlcXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShpbmZsaWdodClcblxuZnVuY3Rpb24gaW5mbGlnaHQgKGtleSwgY2IpIHtcbiAgaWYgKHJlcXNba2V5XSkge1xuICAgIHJlcXNba2V5XS5wdXNoKGNiKVxuICAgIHJldHVybiBudWxsXG4gIH0gZWxzZSB7XG4gICAgcmVxc1trZXldID0gW2NiXVxuICAgIHJldHVybiBtYWtlcmVzKGtleSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlcmVzIChrZXkpIHtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gUkVTICgpIHtcbiAgICB2YXIgY2JzID0gcmVxc1trZXldXG4gICAgdmFyIGxlbiA9IGNicy5sZW5ndGhcbiAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cylcblxuICAgIC8vIFhYWCBJdCdzIHNvbWV3aGF0IGFtYmlndW91cyB3aGV0aGVyIGEgbmV3IGNhbGxiYWNrIGFkZGVkIGluIHRoaXNcbiAgICAvLyBwYXNzIHNob3VsZCBiZSBxdWV1ZWQgZm9yIGxhdGVyIGV4ZWN1dGlvbiBpZiBzb21ldGhpbmcgaW4gdGhlXG4gICAgLy8gbGlzdCBvZiBjYWxsYmFja3MgdGhyb3dzLCBvciBpZiBpdCBzaG91bGQganVzdCBiZSBkaXNjYXJkZWQuXG4gICAgLy8gSG93ZXZlciwgaXQncyBzdWNoIGFuIGVkZ2UgY2FzZSB0aGF0IGl0IGhhcmRseSBtYXR0ZXJzLCBhbmQgZWl0aGVyXG4gICAgLy8gY2hvaWNlIGlzIGxpa2VseSBhcyBzdXJwcmlzaW5nIGFzIHRoZSBvdGhlci5cbiAgICAvLyBBcyBpdCBoYXBwZW5zLCB3ZSBkbyBnbyBhaGVhZCBhbmQgc2NoZWR1bGUgaXQgZm9yIGxhdGVyIGV4ZWN1dGlvbi5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYnNbaV0uYXBwbHkobnVsbCwgYXJncylcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGNicy5sZW5ndGggPiBsZW4pIHtcbiAgICAgICAgLy8gYWRkZWQgbW9yZSBpbiB0aGUgaW50ZXJpbS5cbiAgICAgICAgLy8gZGUtemFsZ28sIGp1c3QgaW4gY2FzZSwgYnV0IGRvbid0IGNhbGwgYWdhaW4uXG4gICAgICAgIGNicy5zcGxpY2UoMCwgbGVuKVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBSRVMuYXBwbHkobnVsbCwgYXJncylcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSByZXFzW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNsaWNlIChhcmdzKSB7XG4gIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aFxuICB2YXIgYXJyYXkgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFycmF5W2ldID0gYXJnc1tpXVxuICByZXR1cm4gYXJyYXlcbn1cbiIsInRyeSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIHV0aWwuaW5oZXJpdHMgIT09ICdmdW5jdGlvbicpIHRocm93ICcnO1xuICBtb2R1bGUuZXhwb3J0cyA9IHV0aWwuaW5oZXJpdHM7XG59IGNhdGNoIChlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbmhlcml0c19icm93c2VyLmpzJyk7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05Ky89XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vRGF0YVdvcmtlclwiKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZShcIi4vc3RyZWFtL0NyYzMyUHJvYmVcIik7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZShcIi4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZVwiKTtcblxuLyoqXG4gKiBSZXByZXNlbnQgYSBjb21wcmVzc2VkIG9iamVjdCwgd2l0aCBldmVyeXRoaW5nIG5lZWRlZCB0byBkZWNvbXByZXNzIGl0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgY29tcHJlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1bmNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGFmdGVyIGRlY29tcHJlc3Npb24uXG4gKiBAcGFyYW0ge251bWJlcn0gY3JjMzIgdGhlIGNyYzMyIG9mIHRoZSBkZWNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgdHlwZSBvZiBjb21wcmVzc2lvbiwgc2VlIGxpYi9jb21wcmVzc2lvbnMuanMuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgY29tcHJlc3NlZCBkYXRhLlxuICovXG5mdW5jdGlvbiBDb21wcmVzc2VkT2JqZWN0KGNvbXByZXNzZWRTaXplLCB1bmNvbXByZXNzZWRTaXplLCBjcmMzMiwgY29tcHJlc3Npb24sIGRhdGEpIHtcbiAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gdW5jb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLmNyYzMyID0gY3JjMzI7XG4gICAgdGhpcy5jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgIHRoaXMuY29tcHJlc3NlZENvbnRlbnQgPSBkYXRhO1xufVxuXG5Db21wcmVzc2VkT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2V0IHRoZSB1bmNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbnRlbnRXb3JrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgICAgIC5waXBlKHRoaXMuY29tcHJlc3Npb24udW5jb21wcmVzc1dvcmtlcigpKVxuICAgICAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW1JbmZvW1wiZGF0YV9sZW5ndGhcIl0gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcInVuY29tcHJlc3NlZFNpemVcIiwgdGhpcy51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgdGhpcy5jcmMzMilcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgICAgICAucGlwZShuZXcgQ3JjMzJQcm9iZSgpKVxuICAgICAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwidW5jb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAgICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImNvbXByZXNzZWRTaXplXCIpKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCBjb21wcmVzc2lvbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXByZXNzZWRPYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxuZXhwb3J0cy5TVE9SRSA9IHtcbiAgICBtYWdpYzogXCJcXHgwMFxceDAwXCIsXG4gICAgY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGNvbXByZXNzaW9uXCIpO1xuICAgIH0sXG4gICAgdW5jb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgZGVjb21wcmVzc2lvblwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5ERUZMQVRFID0gcmVxdWlyZShcIi4vZmxhdGVcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgY29tZSBmcm9tIHBha28sIGZyb20gcGFrby9saWIvemxpYi9jcmMzMi5qc1xuICogcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLCBzZWUgcGFrbyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vXG4gKi9cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgICB2YXIgYywgdGFibGUgPSBbXTtcblxuICAgIGZvcih2YXIgbiA9MDsgbiA8IDI1NjsgbisrKXtcbiAgICAgICAgYyA9IG47XG4gICAgICAgIGZvcih2YXIgayA9MDsgayA8IDg7IGsrKyl7XG4gICAgICAgICAgICBjID0gKChjJjEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVtuXSA9IGM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBjcmMzMiBvZiBhIHN0cmluZy5cbiAqIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIHRoZSBmdW5jdGlvbiBjcmMzMiwgYnV0IGZvciBzdHJpbmdzLiBVc2luZyB0aGVcbiAqIHNhbWUgZnVuY3Rpb24gZm9yIHRoZSB0d28gdXNlIGNhc2VzIGxlYWRzIHRvIGhvcnJpYmxlIHBlcmZvcm1hbmNlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjcmMgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIHRoZSBjcmMuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbiB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIHRoZSBzdGFydGluZyBwb3NpdGlvbiBmb3IgdGhlIGNyYzMyIGNvbXB1dGF0aW9uLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgY29tcHV0ZWQgY3JjMzIuXG4gKi9cbmZ1bmN0aW9uIGNyYzMyc3RyKGNyYywgc3RyLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gc3RyLmNoYXJDb2RlQXQoaSkpICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JjMzJ3cmFwcGVyKGlucHV0LCBjcmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuXG4gICAgaWYoaXNBcnJheSkge1xuICAgICAgICByZXR1cm4gY3JjMzIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmMzMnN0cihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBsb2FkIHRoZSBnbG9iYWwgb2JqZWN0IGZpcnN0OlxuLy8gLSBpdCBzaG91bGQgYmUgYmV0dGVyIGludGVncmF0ZWQgaW4gdGhlIHN5c3RlbSAodW5oYW5kbGVkUmVqZWN0aW9uIGluIG5vZGUpXG4vLyAtIHRoZSBlbnZpcm9ubWVudCBtYXkgaGF2ZSBhIGN1c3RvbSBQcm9taXNlIGltcGxlbWVudGF0aW9uIChzZWUgem9uZS5qcylcbnZhciBFUzZQcm9taXNlID0gbnVsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEVTNlByb21pc2UgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBFUzZQcm9taXNlID0gcmVxdWlyZShcImxpZVwiKTtcbn1cblxuLyoqXG4gKiBMZXQgdGhlIHVzZXIgdXNlL2NoYW5nZSBzb21lIGltcGxlbWVudGF0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHJvbWlzZTogRVM2UHJvbWlzZVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIFVpbnQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuLi91dGY4XCIpO1xudmFyIGNyYzMyID0gcmVxdWlyZShcIi4uL2NyYzMyXCIpO1xudmFyIHNpZ25hdHVyZSA9IHJlcXVpcmUoXCIuLi9zaWduYXR1cmVcIik7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zKSB7XG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvW1wiZmlsZVwiXSxcbiAgICAgICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvW1wiY29tcHJlc3Npb25cIl0sXG4gICAgICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICAgICAgZW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoZmlsZS5uYW1lKSksXG4gICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZSA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShmaWxlLm5hbWUpKSxcbiAgICAgICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICAgICAgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSksXG4gICAgICAgIHV0ZkVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGNvbW1lbnQpKSxcbiAgICAgICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICAgICAgdXNlVVRGOEZvckNvbW1lbnQgPSB1dGZFbmNvZGVkQ29tbWVudC5sZW5ndGggIT09IGNvbW1lbnQubGVuZ3RoLFxuICAgICAgICBkb3NUaW1lLFxuICAgICAgICBkb3NEYXRlLFxuICAgICAgICBleHRyYUZpZWxkcyA9IFwiXCIsXG4gICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgICAgIGRpciA9IGZpbGUuZGlyLFxuICAgICAgICBkYXRlID0gZmlsZS5kYXRlO1xuXG5cbiAgICB2YXIgZGF0YUluZm8gPSB7XG4gICAgICAgIGNyYzMyIDogMCxcbiAgICAgICAgY29tcHJlc3NlZFNpemUgOiAwLFxuICAgICAgICB1bmNvbXByZXNzZWRTaXplIDogMFxuICAgIH07XG5cbiAgICAvLyBpZiB0aGUgY29udGVudCBpcyBzdHJlYW1lZCwgdGhlIHNpemVzL2NyYzMyIGFyZSBvbmx5IGF2YWlsYWJsZSBBRlRFUlxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbiAgICBpZiAoIXN0cmVhbWVkQ29udGVudCB8fCBzdHJlYW1pbmdFbmRlZCkge1xuICAgICAgICBkYXRhSW5mby5jcmMzMiA9IHN0cmVhbUluZm9bXCJjcmMzMlwiXTtcbiAgICAgICAgZGF0YUluZm8uY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvW1wiY29tcHJlc3NlZFNpemVcIl07XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvW1widW5jb21wcmVzc2VkU2l6ZVwiXTtcbiAgICB9XG5cbiAgICB2YXIgYml0ZmxhZyA9IDA7XG4gICAgaWYgKHN0cmVhbWVkQ29udGVudCkge1xuICAgICAgICAvLyBCaXQgMzogdGhlIHNpemVzL2NyYzMyIGFyZSBzZXQgdG8gemVybyBpbiB0aGUgbG9jYWwgaGVhZGVyLlxuICAgICAgICAvLyBUaGUgY29ycmVjdCB2YWx1ZXMgYXJlIHB1dCBpbiB0aGUgZGF0YSBkZXNjcmlwdG9yIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIGZvbGxvd2luZyB0aGUgY29tcHJlc3NlZCBkYXRhLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDAwODtcbiAgICB9XG4gICAgaWYgKCF1c2VDdXN0b21FbmNvZGluZyAmJiAodXNlVVRGOEZvckZpbGVOYW1lIHx8IHVzZVVURjhGb3JDb21tZW50KSkge1xuICAgICAgICAvLyBCaXQgMTE6IExhbmd1YWdlIGVuY29kaW5nIGZsYWcgKEVGUykuXG4gICAgICAgIGJpdGZsYWcgfD0gMHgwODAwO1xuICAgIH1cblxuXG4gICAgdmFyIGV4dEZpbGVBdHRyID0gMDtcbiAgICB2YXIgdmVyc2lvbk1hZGVCeSA9IDA7XG4gICAgaWYgKGRpcikge1xuICAgICAgICAvLyBkb3Mgb3IgdW5peCwgd2Ugc2V0IHRoZSBkb3MgZGlyIGZsYWdcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gMHgwMDAxMDtcbiAgICB9XG4gICAgaWYocGxhdGZvcm0gPT09IFwiVU5JWFwiKSB7XG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAzMUU7IC8vIFVOSVgsIHZlcnNpb24gMy4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlVW5peEV4dGVybmFsRmlsZUF0dHIoZmlsZS51bml4UGVybWlzc2lvbnMsIGRpcik7XG4gICAgfSBlbHNlIHsgLy8gRE9TIG9yIG90aGVyLCBmYWxsYmFjayB0byBET1NcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDAxNDsgLy8gRE9TLCB2ZXJzaW9uIDIuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIoZmlsZS5kb3NQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9XG5cbiAgICAvLyBkYXRlXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzUyLzEzLmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjUvMTYuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82Ni8xNi5odG1sXG5cbiAgICBkb3NUaW1lID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDY7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA1O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENTZWNvbmRzKCkgLyAyO1xuXG4gICAgZG9zRGF0ZSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAtIDE5ODA7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA1O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgZGF0ZS5nZXRVVENEYXRlKCk7XG5cbiAgICBpZiAodXNlVVRGOEZvckZpbGVOYW1lKSB7XG4gICAgICAgIC8vIHNldCB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLiB1bnppcCBuZWVkcyBhdCBsZWFzdCBvbmUgZXh0cmFcbiAgICAgICAgLy8gZmllbGQgdG8gY29ycmVjdGx5IGhhbmRsZSB1bmljb2RlIHBhdGgsIHNvIHVzaW5nIHRoZSBwYXRoIGlzIGFzIGdvb2RcbiAgICAgICAgLy8gYXMgYW55IG90aGVyIGluZm9ybWF0aW9uLiBUaGlzIGNvdWxkIGltcHJvdmUgdGhlIHNpdHVhdGlvbiB3aXRoXG4gICAgICAgIC8vIG90aGVyIGFyY2hpdmUgbWFuYWdlcnMgdG9vLlxuICAgICAgICAvLyBUaGlzIGZpZWxkIGlzIHVzdWFsbHkgdXNlZCB3aXRob3V0IHRoZSB1dGY4IGZsYWcsIHdpdGggYSBub25cbiAgICAgICAgLy8gdW5pY29kZSBwYXRoIGluIHRoZSBoZWFkZXIgKHdpbnJhciwgd2luemlwKS4gVGhpcyBoZWxwcyAoYSBiaXQpXG4gICAgICAgIC8vIHdpdGggdGhlIG1lc3N5IFdpbmRvd3MnIGRlZmF1bHQgY29tcHJlc3NlZCBmb2xkZXJzIGZlYXR1cmUgYnV0XG4gICAgICAgIC8vIGJyZWFrcyBvbiBwN3ppcCB3aGljaCBkb2Vzbid0IHNlZWsgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC5cbiAgICAgICAgLy8gU28gZm9yIG5vdywgVVRGLTggZXZlcnl3aGVyZSAhXG4gICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBOYW1lQ1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRGaWxlTmFtZSksIDQpICtcbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lXG4gICAgICAgICAgICB1dGZFbmNvZGVkRmlsZU5hbWU7XG5cbiAgICAgICAgZXh0cmFGaWVsZHMgKz1cbiAgICAgICAgICAgIC8vIEluZm8tWklQIFVuaWNvZGUgUGF0aCBFeHRyYSBGaWVsZFxuICAgICAgICAgICAgXCJcXHg3NVxceDcwXCIgK1xuICAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgICAgICAgZGVjVG9IZXgodW5pY29kZVBhdGhFeHRyYUZpZWxkLmxlbmd0aCwgMikgK1xuICAgICAgICAgICAgLy8gY29udGVudFxuICAgICAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkO1xuICAgIH1cblxuICAgIGlmKHVzZVVURjhGb3JDb21tZW50KSB7XG5cbiAgICAgICAgdW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIENvbW1lbnRDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZENvbW1lbnQpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZENvbW1lbnQ7XG5cbiAgICAgICAgZXh0cmFGaWVsZHMgKz1cbiAgICAgICAgICAgIC8vIEluZm8tWklQIFVuaWNvZGUgUGF0aCBFeHRyYSBGaWVsZFxuICAgICAgICAgICAgXCJcXHg3NVxceDYzXCIgK1xuICAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgICAgICAgZGVjVG9IZXgodW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkLmxlbmd0aCwgMikgK1xuICAgICAgICAgICAgLy8gY29udGVudFxuICAgICAgICAgICAgdW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkO1xuICAgIH1cblxuICAgIHZhciBoZWFkZXIgPSBcIlwiO1xuXG4gICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgIGhlYWRlciArPSBcIlxceDBBXFx4MDBcIjtcbiAgICAvLyBnZW5lcmFsIHB1cnBvc2UgYml0IGZsYWdcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoYml0ZmxhZywgMik7XG4gICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgaGVhZGVyICs9IGNvbXByZXNzaW9uLm1hZ2ljO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgdGltZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NUaW1lLCAyKTtcbiAgICAvLyBsYXN0IG1vZCBmaWxlIGRhdGVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zRGF0ZSwgMik7XG4gICAgLy8gY3JjLTMyXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNyYzMyLCA0KTtcbiAgICAvLyBjb21wcmVzc2VkIHNpemVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8uY29tcHJlc3NlZFNpemUsIDQpO1xuICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUsIDQpO1xuICAgIC8vIGZpbGUgbmFtZSBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZW5jb2RlZEZpbGVOYW1lLmxlbmd0aCwgMik7XG4gICAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGV4dHJhRmllbGRzLmxlbmd0aCwgMik7XG5cblxuICAgIHZhciBmaWxlUmVjb3JkID0gc2lnbmF0dXJlLkxPQ0FMX0ZJTEVfSEVBREVSICsgaGVhZGVyICsgZW5jb2RlZEZpbGVOYW1lICsgZXh0cmFGaWVsZHM7XG5cbiAgICB2YXIgZGlyUmVjb3JkID0gc2lnbmF0dXJlLkNFTlRSQUxfRklMRV9IRUFERVIgK1xuICAgICAgICAvLyB2ZXJzaW9uIG1hZGUgYnkgKDAwOiBET1MpXG4gICAgICAgIGRlY1RvSGV4KHZlcnNpb25NYWRlQnksIDIpICtcbiAgICAgICAgLy8gZmlsZSBoZWFkZXIgKGNvbW1vbiB0byBmaWxlIGFuZCBjZW50cmFsIGRpcmVjdG9yeSlcbiAgICAgICAgaGVhZGVyICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICBkZWNUb0hleChlbmNvZGVkQ29tbWVudC5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gZGlzayBudW1iZXIgc3RhcnRcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgVE9ET1xuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICBkZWNUb0hleChleHRGaWxlQXR0ciwgNCkgK1xuICAgICAgICAvLyByZWxhdGl2ZSBvZmZzZXQgb2YgbG9jYWwgaGVhZGVyXG4gICAgICAgIGRlY1RvSGV4KG9mZnNldCwgNCkgK1xuICAgICAgICAvLyBmaWxlIG5hbWVcbiAgICAgICAgZW5jb2RlZEZpbGVOYW1lICtcbiAgICAgICAgLy8gZXh0cmEgZmllbGRcbiAgICAgICAgZXh0cmFGaWVsZHMgK1xuICAgICAgICAvLyBmaWxlIGNvbW1lbnRcbiAgICAgICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlUmVjb3JkOiBmaWxlUmVjb3JkLFxuICAgICAgICBkaXJSZWNvcmQ6IGRpclJlY29yZFxuICAgIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBFT0NEIHJlY29yZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbnRyaWVzQ291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjZW50cmFsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgY2VudHJhbCBkaXIuXG4gKiBAcGFyYW0ge051bWJlcn0gbG9jYWxEaXJMZW5ndGggdGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBsb2NhbCBkaXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgemlwIGZpbGUgY29tbWVudCBhcyBhIGJpbmFyeSBzdHJpbmcuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBjb21tZW50LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgRU9DRCByZWNvcmQuXG4gKi9cbnZhciBnZW5lcmF0ZUNlbnRyYWxEaXJlY3RvcnlFbmQgPSBmdW5jdGlvbiAoZW50cmllc0NvdW50LCBjZW50cmFsRGlyTGVuZ3RoLCBsb2NhbERpckxlbmd0aCwgY29tbWVudCwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICB2YXIgZGlyRW5kID0gXCJcIjtcbiAgICB2YXIgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSk7XG5cbiAgICAvLyBlbmQgb2YgY2VudHJhbCBkaXIgc2lnbmF0dXJlXG4gICAgZGlyRW5kID0gc2lnbmF0dXJlLkNFTlRSQUxfRElSRUNUT1JZX0VORCArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGlzIGRpc2tcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IG9uIHRoaXMgZGlza1xuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgIGRlY1RvSGV4KGVudHJpZXNDb3VudCwgMikgK1xuICAgICAgICAvLyBzaXplIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeSAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoY2VudHJhbERpckxlbmd0aCwgNCkgK1xuICAgICAgICAvLyBvZmZzZXQgb2Ygc3RhcnQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGFydGluZyBkaXNrIG51bWJlclxuICAgICAgICBkZWNUb0hleChsb2NhbERpckxlbmd0aCwgNCkgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIC5aSVAgZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIGRpckVuZDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgZGF0YSBkZXNjcmlwdG9ycyBmb3IgYSBmaWxlIGVudHJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggZ2VuZXJhdGVkIGJ5IGEgd29ya2VyLCBjb250YWluaW5nIGluZm9ybWF0aW9uXG4gKiBvbiB0aGUgZmlsZSBlbnRyeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRhdGEgZGVzY3JpcHRvcnMuXG4gKi9cbnZhciBnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBcIlwiO1xuICAgIGRlc2NyaXB0b3IgPSBzaWduYXR1cmUuREFUQV9ERVNDUklQVE9SICtcbiAgICAgICAgLy8gY3JjLTMyICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bXCJjcmMzMlwiXSwgNCkgK1xuICAgICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1tcImNvbXByZXNzZWRTaXplXCJdLCA0KSArXG4gICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvW1widW5jb21wcmVzc2VkU2l6ZVwiXSwgNCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cblxuLyoqXG4gKiBBIHdvcmtlciB0byBjb25jYXRlbmF0ZSBvdGhlciB3b3JrZXJzIHRvIGNyZWF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1GaWxlcyBgdHJ1ZWAgdG8gc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyxcbiAqIGBmYWxzZWAgdG8gYWNjdW11bGF0ZSBpdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSB0aGUgcGxhdGZvcm0gdG8gdXNlLCBcIlVOSVhcIiBvciBcIkRPU1wiLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAqL1xuZnVuY3Rpb24gWmlwRmlsZVdvcmtlcihzdHJlYW1GaWxlcywgY29tbWVudCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiWmlwRmlsZVdvcmtlclwiKTtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gc28gZmFyLiBUaGlzIGRvZXNuJ3QgY291bnQgYWNjdW11bGF0ZWQgY2h1bmtzLlxuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICAvLyBUaGUgY29tbWVudCBvZiB0aGUgemlwIGZpbGVcbiAgICB0aGlzLnppcENvbW1lbnQgPSBjb21tZW50O1xuICAgIC8vIFRoZSBwbGF0Zm9ybSBcImdlbmVyYXRpbmdcIiB0aGUgemlwIGZpbGUuXG4gICAgdGhpcy56aXBQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIC8vIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gICAgdGhpcy5lbmNvZGVGaWxlTmFtZSA9IGVuY29kZUZpbGVOYW1lO1xuICAgIC8vIFNob3VsZCB3ZSBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzID9cbiAgICB0aGlzLnN0cmVhbUZpbGVzID0gc3RyZWFtRmlsZXM7XG4gICAgLy8gSWYgYHN0cmVhbUZpbGVzYCBpcyBmYWxzZSwgd2Ugd2lsbCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgLy8gZmlsZXMgdG8gY2FsY3VsYXRlIHNpemVzIC8gY3JjMzIgKGFuZCB3cml0ZSB0aGVtICpiZWZvcmUqIHRoZSBjb250ZW50KS5cbiAgICAvLyBUaGlzIGJvb2xlYW4gaW5kaWNhdGVzIGlmIHdlIGFyZSBhY2N1bXVsYXRpbmcgY2h1bmtzIChpdCB3aWxsIGNoYW5nZSBhIGxvdFxuICAgIC8vIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyB3b3JrZXIpLlxuICAgIHRoaXMuYWNjdW11bGF0ZSA9IGZhbHNlO1xuICAgIC8vIFRoZSBidWZmZXIgcmVjZWl2aW5nIGNodW5rcyB3aGVuIGFjY3VtdWxhdGluZyBjb250ZW50LlxuICAgIHRoaXMuY29udGVudEJ1ZmZlciA9IFtdO1xuICAgIC8vIFRoZSBsaXN0IG9mIGdlbmVyYXRlZCBkaXJlY3RvcnkgcmVjb3Jkcy5cbiAgICB0aGlzLmRpclJlY29yZHMgPSBbXTtcbiAgICAvLyBUaGUgb2Zmc2V0IChpbiBieXRlcykgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB6aXAgZmlsZSBmb3IgdGhlIGN1cnJlbnQgc291cmNlLlxuICAgIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IDA7XG4gICAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgemlwIGZpbGUuXG4gICAgdGhpcy5lbnRyaWVzQ291bnQgPSAwO1xuICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGN1cnJlbnRseSBiZWluZyBhZGRlZCwgbnVsbCB3aGVuIGhhbmRsaW5nIHRoZSBlbmQgb2YgdGhlIHppcCBmaWxlLlxuICAgIC8vIFVzZWQgZm9yIHRoZSBlbWl0dGVkIG1ldGFkYXRhLlxuICAgIHRoaXMuY3VycmVudEZpbGUgPSBudWxsO1xuXG5cblxuICAgIHRoaXMuX3NvdXJjZXMgPSBbXTtcbn1cbnV0aWxzLmluaGVyaXRzKFppcEZpbGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmspIHtcblxuICAgIHZhciBjdXJyZW50RmlsZVBlcmNlbnQgPSBjaHVuay5tZXRhLnBlcmNlbnQgfHwgMDtcbiAgICB2YXIgZW50cmllc0NvdW50ID0gdGhpcy5lbnRyaWVzQ291bnQ7XG4gICAgdmFyIHJlbWFpbmluZ0ZpbGVzID0gdGhpcy5fc291cmNlcy5sZW5ndGg7XG5cbiAgICBpZih0aGlzLmFjY3VtdWxhdGUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50QnVmZmVyLnB1c2goY2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGNodW5rLmRhdGEubGVuZ3RoO1xuXG4gICAgICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBkYXRhIDogY2h1bmsuZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGUgOiB0aGlzLmN1cnJlbnRGaWxlLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiBlbnRyaWVzQ291bnQgPyAoY3VycmVudEZpbGVQZXJjZW50ICsgMTAwICogKGVudHJpZXNDb3VudCAtIHJlbWFpbmluZ0ZpbGVzIC0gMSkpIC8gZW50cmllc0NvdW50IDogMTAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIHdvcmtlciBzdGFydGVkIGEgbmV3IHNvdXJjZSAoYW4gb3RoZXIgd29ya2VyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBzdHJlYW1JbmZvIG9iamVjdCBmcm9tIHRoZSBuZXcgc291cmNlLlxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5vcGVuZWRTb3VyY2UgPSBmdW5jdGlvbiAoc3RyZWFtSW5mbykge1xuICAgIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IHRoaXMuYnl0ZXNXcml0dGVuO1xuICAgIHRoaXMuY3VycmVudEZpbGUgPSBzdHJlYW1JbmZvW1wiZmlsZVwiXS5uYW1lO1xuXG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bXCJmaWxlXCJdLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1tcImZpbGVcIl0uZGlyO1xuICAgIHZhciByZWNvcmQgPSBnZW5lcmF0ZVppcFBhcnRzKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgdHJ1ZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcblxuICAgIHRoaXMuZGlyUmVjb3Jkcy5wdXNoKHJlY29yZC5kaXJSZWNvcmQpO1xuICAgIGlmKHN0cmVhbWVkQ29udGVudCkge1xuICAgICAgICAvLyBhZnRlciB0aGUgc3RyZWFtZWQgZmlsZSwgd2UgcHV0IGRhdGEgZGVzY3JpcHRvcnNcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyhzdHJlYW1JbmZvKSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBjb250ZW50IHdhc24ndCBzdHJlYW1lZCwgd2UgbmVlZCB0byBwdXNoIGV2ZXJ5dGhpbmcgbm93XG4gICAgICAgIC8vIGZpcnN0IHRoZSBmaWxlIHJlY29yZCwgdGhlbiB0aGUgY29udGVudFxuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHJlY29yZC5maWxlUmVjb3JkLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSh0aGlzLmNvbnRlbnRCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jb250ZW50QnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEZpbGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbG9jYWxEaXJMZW5ndGggPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJSZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogdGhpcy5kaXJSZWNvcmRzW2ldLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBjZW50cmFsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW4gLSBsb2NhbERpckxlbmd0aDtcblxuICAgIHZhciBkaXJFbmQgPSBnZW5lcmF0ZUNlbnRyYWxEaXJlY3RvcnlFbmQodGhpcy5kaXJSZWNvcmRzLmxlbmd0aCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIHRoaXMuemlwQ29tbWVudCwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZGlyRW5kLFxuICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBuZXh0IHNvdXJjZSB0byBiZSByZWFkLlxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wcmVwYXJlTmV4dFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXZpb3VzID0gdGhpcy5fc291cmNlcy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbmVkU291cmNlKHRoaXMucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5wYXVzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVnaXN0ZXJQcmV2aW91c1xuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZWdpc3RlclByZXZpb3VzID0gZnVuY3Rpb24gKHByZXZpb3VzKSB7XG4gICAgdGhpcy5fc291cmNlcy5wdXNoKHByZXZpb3VzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBwcmV2aW91cy5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICB9KTtcbiAgICBwcmV2aW91cy5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wcmV2aW91cyAmJiB0aGlzLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgIXRoaXMuX3NvdXJjZXMubGVuZ3RoICYmICF0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmVycm9yXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuX3NvdXJjZXM7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc291cmNlc1tpXS5lcnJvcihlKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyB0aGUgYGVycm9yYCBleHBsb2RlZCwgbm90aGluZyB0byBkb1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIubG9ja1xuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmxvY2suY2FsbCh0aGlzKTtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuX3NvdXJjZXM7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlc1tpXS5sb2NrKCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBaaXBGaWxlV29ya2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKFwiLi4vY29tcHJlc3Npb25zXCIpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKFwiLi9aaXBGaWxlV29ya2VyXCIpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGNvbXByZXNzaW9uIHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGZpbGUgbGV2ZWwsIGlmIGFueS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB6aXBDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgbG9hZCgpIGxldmVsLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY29tcHJlc3Npb24gb2JqZWN0IHRvIHVzZS5cbiAqL1xudmFyIGdldENvbXByZXNzaW9uID0gZnVuY3Rpb24gKGZpbGVDb21wcmVzc2lvbiwgemlwQ29tcHJlc3Npb24pIHtcblxuICAgIHZhciBjb21wcmVzc2lvbk5hbWUgPSBmaWxlQ29tcHJlc3Npb24gfHwgemlwQ29tcHJlc3Npb247XG4gICAgdmFyIGNvbXByZXNzaW9uID0gY29tcHJlc3Npb25zW2NvbXByZXNzaW9uTmFtZV07XG4gICAgaWYgKCFjb21wcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcHJlc3Npb25OYW1lICsgXCIgaXMgbm90IGEgdmFsaWQgY29tcHJlc3Npb24gbWV0aG9kICFcIik7XG4gICAgfVxuICAgIHJldHVybiBjb21wcmVzc2lvbjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRvIGdlbmVyYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0pTWmlwfSB6aXAgdGhlIEpTWmlwIGluc3RhbmNlIGF0IHRoZSByaWdodCByb290IGxldmVsLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICovXG5leHBvcnRzLmdlbmVyYXRlV29ya2VyID0gZnVuY3Rpb24gKHppcCwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgdmFyIHppcEZpbGVXb3JrZXIgPSBuZXcgWmlwRmlsZVdvcmtlcihvcHRpb25zLnN0cmVhbUZpbGVzLCBjb21tZW50LCBvcHRpb25zLnBsYXRmb3JtLCBvcHRpb25zLmVuY29kZUZpbGVOYW1lKTtcbiAgICB2YXIgZW50cmllc0NvdW50ID0gMDtcbiAgICB0cnkge1xuXG4gICAgICAgIHppcC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgIGVudHJpZXNDb3VudCsrO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb24oZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uLCBvcHRpb25zLmNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbk9wdGlvbnMgPSBmaWxlLm9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGRpciA9IGZpbGUuZGlyLCBkYXRlID0gZmlsZS5kYXRlO1xuXG4gICAgICAgICAgICBmaWxlLl9jb21wcmVzc1dvcmtlcihjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKVxuICAgICAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lIDogcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICAgICAgICBkaXIgOiBkaXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50IDogZmlsZS5jb21tZW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHVuaXhQZXJtaXNzaW9ucyA6IGZpbGUudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5waXBlKHppcEZpbGVXb3JrZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lbnRyaWVzQ291bnQgPSBlbnRyaWVzQ291bnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVycm9yKGUpO1xuICAgIH1cblxuICAgIHJldHVybiB6aXBGaWxlV29ya2VyO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKU1ppcCgpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgd2l0aG91dCBgbmV3YCwgaXQgYWRkcyBgbmV3YCBiZWZvcmUgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICAvLyBOT1RFOiB3ZSB1c2UgYSBudWxsIHByb3RvdHlwZSBiZWNhdXNlIHdlIGRvIG5vdFxuICAgIC8vIHdhbnQgZmlsZW5hbWVzIGxpa2UgXCJ0b1N0cmluZ1wiIGNvbWluZyBmcm9tIGEgemlwIGZpbGVcbiAgICAvLyB0byBvdmVyd3JpdGUgbWV0aG9kcyBhbmQgYXR0cmlidXRlcyBpbiBhIG5vcm1hbCBPYmplY3QuXG4gICAgdGhpcy5maWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG5KU1ppcC5wcm90b3R5cGUubG9hZEFzeW5jID0gcmVxdWlyZShcIi4vbG9hZFwiKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcblxuLy8gVE9ETyBmaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcyB2ZXJzaW9uLFxuLy8gYSByZXF1aXJlKCdwYWNrYWdlLmpzb24nKS52ZXJzaW9uIGRvZXNuJ3Qgd29yayB3aXRoIHdlYnBhY2ssIHNlZSAjMzI3XG5KU1ppcC52ZXJzaW9uID0gXCIzLjEwLjFcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuL3V0ZjhcIik7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoXCIuL3ppcEVudHJpZXNcIik7XG52YXIgQ3JjMzJQcm9iZSA9IHJlcXVpcmUoXCIuL3N0cmVhbS9DcmMzMlByb2JlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG5cbi8qKlxuICogQ2hlY2sgdGhlIENSQzMyIG9mIGFuIGVudHJ5LlxuICogQHBhcmFtIHtaaXBFbnRyeX0gemlwRW50cnkgdGhlIHppcCBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW50cnlDUkMzMih6aXBFbnRyeSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IENyYzMyUHJvYmUoKSk7XG4gICAgICAgIHdvcmtlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHppcCA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IGZhbHNlLFxuICAgICAgICBjcmVhdGVGb2xkZXJzOiBmYWxzZSxcbiAgICAgICAgZGVjb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGRlY29kZVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVDb250ZW50KFwidGhlIGxvYWRlZCB6aXAgZmlsZVwiLCBkYXRhLCB0cnVlLCBvcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZywgb3B0aW9ucy5iYXNlNjQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKG9wdGlvbnMpO1xuICAgICAgICAgICAgemlwRW50cmllcy5sb2FkKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gY2hlY2tDUkMzMih6aXBFbnRyaWVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcEVudHJpZXMpXTtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jaGVja0NSQzMyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gYWRkRmlsZXMocmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHppcEVudHJpZXMgPSByZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGZpbGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgdmFyIHVuc2FmZU5hbWUgPSBpbnB1dC5maWxlTmFtZVN0cjtcbiAgICAgICAgICAgICAgICB2YXIgc2FmZU5hbWUgPSB1dGlscy5yZXNvbHZlKGlucHV0LmZpbGVOYW1lU3RyKTtcblxuICAgICAgICAgICAgICAgIHppcC5maWxlKHNhZmVOYW1lLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRpcjogaW5wdXQuZGlyLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50OiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHVuaXhQZXJtaXNzaW9uczogaW5wdXQudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9uczogaW5wdXQuZG9zUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IG9wdGlvbnMuY3JlYXRlRm9sZGVyc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHppcC5maWxlKHNhZmVOYW1lKS51bnNhZmVPcmlnaW5hbE5hbWUgPSB1bnNhZmVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgemlwLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB6aXA7XG4gICAgICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgaXMgcnVubmluZyBpbiBOb2RlanMsIHdpbGwgYmUgdW5kZWZpbmVkIGluIGEgYnJvd3Nlci5cbiAgICAgKiBJbiBhIGJyb3dzZXIsIGJyb3dzZXJpZnkgd29uJ3QgaW5jbHVkZSB0aGlzIGZpbGUgYW5kIHRoZSB3aG9sZSBtb2R1bGVcbiAgICAgKiB3aWxsIGJlIHJlc29sdmVkIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKi9cbiAgICBpc05vZGUgOiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIGZyb20gYW4gZXhpc3RpbmcgY29udGVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgZGF0YSB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBuZXdCdWZmZXJGcm9tOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIC8vIFNhZmVndWFyZCBmb3Igb2xkIE5vZGUuanMgdmVyc2lvbnMuIE9uIG5ld2VyIHZlcnNpb25zLFxuICAgICAgICAgICAgICAgIC8vIEJ1ZmZlci5mcm9tKG51bWJlcikgLyBCdWZmZXIobnVtYmVyLCBlbmNvZGluZykgYWxyZWFkeSB0aHJvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgXFxcImRhdGFcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNpemUgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBhbGxvY0J1ZmZlcjogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5hbGxvYykge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICAgICAgYnVmLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kIG91dCBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGIgdGhlIG9iamVjdCB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEJ1ZmZlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQnVmZmVyIDogZnVuY3Rpb24oYil7XG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYik7XG4gICAgfSxcblxuICAgIGlzU3RyZWFtIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLm9uID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucGF1c2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5yZXN1bWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4uL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgdXNlIGEgbm9kZWpzIHN0cmVhbSBhcyBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBlbnRyeSBmb3IgdGhpcyBzdHJlYW0uXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihmaWxlbmFtZSwgc3RyZWFtKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGZpbGVuYW1lKTtcbiAgICB0aGlzLl91cHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZFN0cmVhbShzdHJlYW0pO1xufVxuXG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN0cmVhbSBhbmQgYmluZCB0aGUgY2FsbGJhY2tzIG9uIGl0LlxuICogRG8gdGhpcyBBU0FQIG9uIG5vZGUgMC4xMCAhIEEgbGF6eSBiaW5kaW5nIGRvZXNuJ3QgYWx3YXlzIHdvcmsuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtIHRvIHVzZS5cbiAqL1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIHN0cmVhbVxuICAgICAgICAub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wYXVzZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fc3RyZWFtLnBhdXNlKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0aGlzLl91cHN0cmVhbUVuZGVkKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKS5SZWFkYWJsZTtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudXRpbHMuaW5oZXJpdHMoTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciwgUmVhZGFibGUpO1xuXG4vKipcbiogQSBub2RlanMgc3RyZWFtIHVzaW5nIGEgd29ya2VyIGFzIHNvdXJjZS5cbiogQHNlZSB0aGUgU291cmNlV3JhcHBlciBpbiBodHRwOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWxcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB3cmFwcGluZyB0aGUgd29ya2VyXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBub2RlanMgc3RyZWFtIG9wdGlvbnNcbiogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiovXG5mdW5jdGlvbiBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyKGhlbHBlciwgb3B0aW9ucywgdXBkYXRlQ2IpIHtcbiAgICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2hlbHBlciA9IGhlbHBlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBoZWxwZXIub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgIGlmICghc2VsZi5wdXNoKGRhdGEpKSB7XG4gICAgICAgICAgICBzZWxmLl9oZWxwZXIucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZih1cGRhdGVDYikge1xuICAgICAgICAgICAgdXBkYXRlQ2IobWV0YSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICAgICAgfSk7XG59XG5cblxuTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9oZWxwZXIucmVzdW1lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGY4ID0gcmVxdWlyZShcIi4vdXRmOFwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vU3RyZWFtSGVscGVyXCIpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoXCIuL2NvbXByZXNzZWRPYmplY3RcIik7XG52YXIgWmlwT2JqZWN0ID0gcmVxdWlyZShcIi4vemlwT2JqZWN0XCIpO1xudmFyIGdlbmVyYXRlID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVcIik7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcbnZhciBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIgPSByZXF1aXJlKFwiLi9ub2RlanMvTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyXCIpO1xuXG5cbi8qKlxuICogQWRkIGEgZmlsZSBpbiB0aGUgY3VycmVudCBmb2xkZXIuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWxPcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZmlsZS5cbiAqL1xudmFyIGZpbGVBZGQgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcmlnaW5hbE9wdGlvbnMpIHtcbiAgICAvLyBiZSBzdXJlIHN1YiBmb2xkZXJzIGV4aXN0XG4gICAgdmFyIGRhdGFUeXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpLFxuICAgICAgICBwYXJlbnQ7XG5cblxuICAgIC8qXG4gICAgICogQ29ycmVjdCBvcHRpb25zLlxuICAgICAqL1xuXG4gICAgdmFyIG8gPSB1dGlscy5leHRlbmQob3JpZ2luYWxPcHRpb25zIHx8IHt9LCBkZWZhdWx0cyk7XG4gICAgby5kYXRlID0gby5kYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgaWYgKG8uY29tcHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgby5jb21wcmVzc2lvbiA9IG8uY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG8udW5peFBlcm1pc3Npb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG8udW5peFBlcm1pc3Npb25zID0gcGFyc2VJbnQoby51bml4UGVybWlzc2lvbnMsIDgpO1xuICAgIH1cblxuICAgIC8vIFVOWF9JRkRJUiAgMDA0MDAwMCBzZWUgemlwaW5mby5jXG4gICAgaWYgKG8udW5peFBlcm1pc3Npb25zICYmIChvLnVuaXhQZXJtaXNzaW9ucyAmIDB4NDAwMCkpIHtcbiAgICAgICAgby5kaXIgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBCaXQgNCAgICBEaXJlY3RvcnlcbiAgICBpZiAoby5kb3NQZXJtaXNzaW9ucyAmJiAoby5kb3NQZXJtaXNzaW9ucyAmIDB4MDAxMCkpIHtcbiAgICAgICAgby5kaXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvLmRpcikge1xuICAgICAgICBuYW1lID0gZm9yY2VUcmFpbGluZ1NsYXNoKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoby5jcmVhdGVGb2xkZXJzICYmIChwYXJlbnQgPSBwYXJlbnRGb2xkZXIobmFtZSkpKSB7XG4gICAgICAgIGZvbGRlckFkZC5jYWxsKHRoaXMsIHBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGlzVW5pY29kZVN0cmluZyA9IGRhdGFUeXBlID09PSBcInN0cmluZ1wiICYmIG8uYmluYXJ5ID09PSBmYWxzZSAmJiBvLmJhc2U2NCA9PT0gZmFsc2U7XG4gICAgaWYgKCFvcmlnaW5hbE9wdGlvbnMgfHwgdHlwZW9mIG9yaWdpbmFsT3B0aW9ucy5iaW5hcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgby5iaW5hcnkgPSAhaXNVbmljb2RlU3RyaW5nO1xuICAgIH1cblxuXG4gICAgdmFyIGlzQ29tcHJlc3NlZEVtcHR5ID0gKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSAmJiBkYXRhLnVuY29tcHJlc3NlZFNpemUgPT09IDA7XG5cbiAgICBpZiAoaXNDb21wcmVzc2VkRW1wdHkgfHwgby5kaXIgfHwgIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgby5iYXNlNjQgPSBmYWxzZTtcbiAgICAgICAgby5iaW5hcnkgPSB0cnVlO1xuICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgby5jb21wcmVzc2lvbiA9IFwiU1RPUkVcIjtcbiAgICAgICAgZGF0YVR5cGUgPSBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29udmVydCBjb250ZW50IHRvIGZpdC5cbiAgICAgKi9cblxuICAgIHZhciB6aXBPYmplY3RDb250ZW50ID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgfHwgZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IGRhdGE7XG4gICAgfSBlbHNlIGlmIChub2RlanNVdGlscy5pc05vZGUgJiYgbm9kZWpzVXRpbHMuaXNTdHJlYW0oZGF0YSkpIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IG5ldyBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIobmFtZSwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IHV0aWxzLnByZXBhcmVDb250ZW50KG5hbWUsIGRhdGEsIG8uYmluYXJ5LCBvLm9wdGltaXplZEJpbmFyeVN0cmluZywgby5iYXNlNjQpO1xuICAgIH1cblxuICAgIHZhciBvYmplY3QgPSBuZXcgWmlwT2JqZWN0KG5hbWUsIHppcE9iamVjdENvbnRlbnQsIG8pO1xuICAgIHRoaXMuZmlsZXNbbmFtZV0gPSBvYmplY3Q7XG4gICAgLypcbiAgICBUT0RPOiB3ZSBjYW4ndCB0aHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSB3ZSBoYXZlIGFzeW5jIHByb21pc2VzXG4gICAgKHdlIGNhbiBoYXZlIGEgcHJvbWlzZSBvZiBhIERhdGUoKSBmb3IgZXhhbXBsZSkgYnV0IHJldHVybmluZyBhXG4gICAgcHJvbWlzZSBpcyB1c2VsZXNzIGJlY2F1c2UgZmlsZShuYW1lLCBkYXRhKSByZXR1cm5zIHRoZSBKU1ppcFxuICAgIG9iamVjdCBmb3IgY2hhaW5pbmcuIFNob3VsZCB3ZSBicmVhayB0aGF0IHRvIGFsbG93IHRoZSB1c2VyXG4gICAgdG8gY2F0Y2ggdGhlIGVycm9yID9cblxuICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwT2JqZWN0Q29udGVudClcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG4gICAgKi9cbn07XG5cbi8qKlxuICogRmluZCB0aGUgcGFyZW50IGZvbGRlciBvZiB0aGUgcGF0aC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB1c2VcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHBhcmVudCBmb2xkZXIsIG9yIFwiXCJcbiAqL1xudmFyIHBhcmVudEZvbGRlciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2xpY2UoLTEpID09PSBcIi9cIikge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCB3aXRoIGEgc2xhc2ggYXQgdGhlIGVuZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHBhdGggd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICovXG52YXIgZm9yY2VUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENoZWNrIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC9cbiAgICBpZiAocGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggKz0gXCIvXCI7IC8vIElFIGRvZXNuJ3QgbGlrZSBzdWJzdHIoLTEpXG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBBZGQgYSAoc3ViKSBmb2xkZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmb2xkZXIncyBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbY3JlYXRlRm9sZGVyc10gSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBjcmVhdGUgc3ViXG4gKiAgZm9sZGVycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZm9sZGVyLlxuICovXG52YXIgZm9sZGVyQWRkID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlRm9sZGVycykge1xuICAgIGNyZWF0ZUZvbGRlcnMgPSAodHlwZW9mIGNyZWF0ZUZvbGRlcnMgIT09IFwidW5kZWZpbmVkXCIpID8gY3JlYXRlRm9sZGVycyA6IGRlZmF1bHRzLmNyZWF0ZUZvbGRlcnM7XG5cbiAgICBuYW1lID0gZm9yY2VUcmFpbGluZ1NsYXNoKG5hbWUpO1xuXG4gICAgLy8gRG9lcyB0aGlzIGZvbGRlciBhbHJlYWR5IGV4aXN0P1xuICAgIGlmICghdGhpcy5maWxlc1tuYW1lXSkge1xuICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgbnVsbCwge1xuICAgICAgICAgICAgZGlyOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogY3JlYXRlRm9sZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmlsZXNbbmFtZV07XG59O1xuXG4vKipcbiogQ3Jvc3Mtd2luZG93LCBjcm9zcy1Ob2RlLWNvbnRleHQgcmVndWxhciBleHByZXNzaW9uIGRldGVjdGlvblxuKiBAcGFyYW0gIHtPYmplY3R9ICBvYmplY3QgQW55dGhpbmdcbiogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbixcbiogZmFsc2Ugb3RoZXJ3aXNlXG4qL1xuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xufVxuXG4vLyByZXR1cm4gdGhlIGFjdHVhbCBwcm90b3R5cGUgb2YgSlNaaXBcbnZhciBvdXQgPSB7XG4gICAgLyoqXG4gICAgICogQHNlZSBsb2FkQXN5bmNcbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGVudHJ5IGF0IHRoaXMgZm9sZGVyIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBjYWxsYmFjayBmdW5jdGlvbjpcbiAgICAgKiBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7Li4ufVxuICAgICAqIEl0IHRha2VzIDIgYXJndW1lbnRzIDogdGhlIHJlbGF0aXZlIHBhdGggYW5kIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSwgcmVsYXRpdmVQYXRoLCBmaWxlO1xuICAgICAgICAvLyBpZ25vcmUgd2FybmluZyBhYm91dCB1bndhbnRlZCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhpcy5maWxlcyBpcyBhIG51bGwgcHJvdG90eXBlIG9iamVjdFxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluICovXG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZmlsZW5hbWUuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgZmlsZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGggJiYgZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCkgeyAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICAgICAgY2IocmVsYXRpdmVQYXRoLCBmaWxlKTsgLy8gVE9ETyByZXZlcnNlIHRoZSBwYXJhbWV0ZXJzID8gbmVlZCB0byBiZSBjbGVhbiBBTkQgY29uc2lzdGVudCB3aXRoIHRoZSBmaWx0ZXIgc2VhcmNoIGZuLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG5lc3RlZCBmaWxlcy9mb2xkZXJzIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2ggdGhlIHByZWRpY2F0ZSB0byB1c2UgOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKHJlbGF0aXZlUGF0aCwgZW50cnkpKSB7IC8vIHRoZSBmaWxlIG1hdGNoZXMgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfFJlZ0V4cH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBhZGQgKGlmIGRhdGEgaXMgZGVmaW5lZCksXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZCAoaWYgbm8gZGF0YSkgb3IgYSByZWdleCB0byBtYXRjaCBmaWxlcy5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhICBUaGUgZmlsZSBkYXRhLCBlaXRoZXIgcmF3IG9yIGJhc2U2NCBlbmNvZGVkXG4gICAgICogQHBhcmFtICAge09iamVjdH0gbyAgICAgRmlsZSBvcHRpb25zXG4gICAgICogQHJldHVybiAge0pTWmlwfE9iamVjdHxBcnJheX0gdGhpcyBKU1ppcCBvYmplY3QgKHdoZW4gYWRkaW5nIGEgZmlsZSksXG4gICAgICogYSBmaWxlICh3aGVuIHNlYXJjaGluZyBieSBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIGZpbGVzICh3aGVuIHNlYXJjaGluZyBieSByZWdleCkuXG4gICAgICovXG4gICAgZmlsZTogZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWZpbGUuZGlyICYmIHJlZ2V4cC50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gdGV4dFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgIW9iai5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWF5YmUgYSBmb2xkZXIsIGRlbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgICAgdmFyIGtpZHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNba2lkc1tpXS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhcyBhbiBpbnRlcm5hbCBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHppcCBmaWxlIDpcbiAgICAgKiAtIGNvbXByZXNzaW9uLCBcIlNUT1JFXCIgYnkgZGVmYXVsdC5cbiAgICAgKiAtIHR5cGUsIFwiYmFzZTY0XCIgYnkgZGVmYXVsdC4gVmFsdWVzIGFyZSA6IHN0cmluZywgYmFzZTY0LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgYmxvYi5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBzdHJlYW1lZCB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUludGVybmFsU3RyZWFtOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciB3b3JrZXIsIG9wdHMgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9wdHMgPSB1dGlscy5leHRlbmQob3B0aW9ucyB8fCB7fSwge1xuICAgICAgICAgICAgICAgIHN0cmVhbUZpbGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgICAgICBjb21tZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiLFxuICAgICAgICAgICAgICAgIGVuY29kZUZpbGVOYW1lOiB1dGY4LnV0ZjhlbmNvZGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBvcHRzLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3Npb24gPSBvcHRzLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIFwiYmluYXJ5c3RyaW5nXCIgaXMgcHJlZmVycmVkIGJ1dCB0aGUgaW50ZXJuYWxzIHVzZSBcInN0cmluZ1wiLlxuICAgICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgb3B0cy50eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQob3B0cy50eXBlKTtcblxuICAgICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09IFwiZGFyd2luXCIgfHxcbiAgICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSBcImZyZWVic2RcIiB8fFxuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09IFwibGludXhcIiB8fFxuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09IFwic3Vub3NcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9IFwiVU5JWFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IG9wdHMuY29tbWVudCB8fCB0aGlzLmNvbW1lbnQgfHwgXCJcIjtcbiAgICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICAgICAgd29ya2VyLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHdvcmtlciwgb3B0cy50eXBlIHx8IFwic3RyaW5nXCIsIG9wdHMubWltZVR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlQXN5bmM6IGZ1bmN0aW9uKG9wdGlvbnMsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHNlZSBnZW5lcmF0ZUludGVybmFsU3RyZWFtXG4gICAgICovXG4gICAgZ2VuZXJhdGVOb2RlU3RyZWFtOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IFwibm9kZWJ1ZmZlclwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IG91dDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKFwiLi9EYXRhUmVhZGVyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gJiAweEZGO1xuICAgIH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBEYXRhUmVhZGVyKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhOyAvLyB0eXBlIDogc2VlIGltcGxlbWVudGF0aW9uXG4gICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnplcm8gPSAwO1xufVxuRGF0YVJlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgb2Zmc2V0IHdpbGwgbm90IGdvIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9mZnNldCB0aGUgYWRkaXRpb25hbCBvZmZzZXQgdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja09mZnNldDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleCh0aGlzLmluZGV4ICsgb2Zmc2V0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHNwZWNpZmllZCBpbmRleCB3aWxsIG5vdCBiZSB0b28gZmFyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrSW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuemVybyArIG5ld0luZGV4IHx8IG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5kIG9mIGRhdGEgcmVhY2hlZCAoZGF0YSBsZW5ndGggPSBcIiArIHRoaXMubGVuZ3RoICsgXCIsIGFza2VkIGluZGV4ID0gXCIgKyAobmV3SW5kZXgpICsgXCIpLiBDb3JydXB0ZWQgemlwID9cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4IFRoZSBuZXcgaW5kZXguXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNldEluZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICB0aGlzLmNoZWNrSW5kZXgobmV3SW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTa2lwIHRoZSBuZXh0IG4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBza2lwLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBza2lwOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgodGhpcy5pbmRleCArIG4pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgdGhlIGluZGV4IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGEgYnl0ZS5cbiAgICAgKi9cbiAgICBieXRlQXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGEgemlwIHNpZ25hdHVyZSAoNCBieXRlcykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgc2lnbmF0dXJlIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSwgLTEgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGxhc3RJbmRleE9mU2lnbmF0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgc2lnbmF0dXJlICg0IGJ5dGVzKSBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgY29tcGFyZSBpdCB3aXRoIHNpZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBleHBlY3RlZCBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzaWduYXR1cmUgbWF0Y2hlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlYWRBbmRDaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBkYXRlLlxuICAgICAqIEByZXR1cm4ge0RhdGV9IHRoZSBkYXRlLlxuICAgICAqL1xuICAgIHJlYWREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvc3RpbWUgPSB0aGlzLnJlYWRJbnQoNCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhcbiAgICAgICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgICAgICgoZG9zdGltZSA+PiAyMSkgJiAweDBmKSAtIDEsIC8vIG1vbnRoXG4gICAgICAgICAgICAoZG9zdGltZSA+PiAxNikgJiAweDFmLCAvLyBkYXlcbiAgICAgICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgICAgIChkb3N0aW1lID4+IDUpICYgMHgzZiwgLy8gbWludXRlXG4gICAgICAgICAgICAoZG9zdGltZSAmIDB4MWYpIDw8IDEpKTsgLy8gc2Vjb25kXG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YVJlYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKFwiLi9VaW50OEFycmF5UmVhZGVyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpIHtcbiAgICBVaW50OEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhOb2RlQnVmZmVyUmVhZGVyLCBVaW50OEFycmF5UmVhZGVyKTtcblxuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuTm9kZUJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVCdWZmZXJSZWFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZShcIi4vRGF0YVJlYWRlclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gU3RyaW5nUmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhTdHJpbmdSZWFkZXIsIERhdGFSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIuYnl0ZUF0XG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnplcm8gKyBpKTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZVxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5sYXN0SW5kZXhPZihzaWcpIC0gdGhpcy56ZXJvO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZVxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMucmVhZERhdGEoNCk7XG4gICAgcmV0dXJuIHNpZyA9PT0gZGF0YTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgLy8gdGhpcyB3aWxsIHdvcmsgYmVjYXVzZSB0aGUgY29uc3RydWN0b3IgYXBwbGllZCB0aGUgXCImIDB4ZmZcIiBtYXNrLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nUmVhZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKFwiLi9BcnJheVJlYWRlclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gVWludDhBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgQXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFVpbnQ4QXJyYXlSZWFkZXIsIEFycmF5UmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblVpbnQ4QXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgaWYoc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBpbiBJRTEwLCB3aGVuIHVzaW5nIHN1YmFycmF5KGlkeCwgaWR4KSwgd2UgZ2V0IHRoZSBhcnJheSBbMHgwMF0gaW5zdGVhZCBvZiBbXS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnN1YmFycmF5KHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXlSZWFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoXCIuL0FycmF5UmVhZGVyXCIpO1xudmFyIFN0cmluZ1JlYWRlciA9IHJlcXVpcmUoXCIuL1N0cmluZ1JlYWRlclwiKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vTm9kZUJ1ZmZlclJlYWRlclwiKTtcbnZhciBVaW50OEFycmF5UmVhZGVyID0gcmVxdWlyZShcIi4vVWludDhBcnJheVJlYWRlclwiKTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWFkZXIgYWRhcHRlZCB0byB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIHRvIHJlYWQuXG4gKiBAcmV0dXJuIHtEYXRhUmVhZGVyfSB0aGUgZGF0YSByZWFkZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1JlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZUJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5XCIsIGRhdGEpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljV29ya2VyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNvbnZlcnQgY2h1bmtzIHRvIGEgc3BlY2lmaWVkIHR5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0VHlwZSB0aGUgZGVzdGluYXRpb24gdHlwZS5cbiAqL1xuZnVuY3Rpb24gQ29udmVydFdvcmtlcihkZXN0VHlwZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBkZXN0VHlwZSk7XG4gICAgdGhpcy5kZXN0VHlwZSA9IGRlc3RUeXBlO1xufVxudXRpbHMuaW5oZXJpdHMoQ29udmVydFdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5Db252ZXJ0V29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogdXRpbHMudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0V29ya2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vR2VuZXJpY1dvcmtlclwiKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoXCIuLi9jcmMzMlwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIGNyYzMyIG9mIHRoZSBkYXRhIGZsb3dpbmcgdGhyb3VnaC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDcmMzMlByb2JlKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNyYzMyUHJvYmVcIik7XG4gICAgdGhpcy53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoQ3JjMzJQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5DcmMzMlByb2JlLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnN0cmVhbUluZm8uY3JjMzIgPSBjcmMzMihjaHVuay5kYXRhLCB0aGlzLnN0cmVhbUluZm8uY3JjMzIgfHwgMCk7XG4gICAgdGhpcy5wdXNoKGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENyYzMyUHJvYmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljV29ya2VyXCIpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBkYXRhIGZsb3dpbmcgdGhyb3VnaC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIHRoZSBuYW1lIHVzZWQgdG8gZXhwb3NlIHRoZSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gRGF0YUxlbmd0aFByb2JlKHByb3BOYW1lKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YUxlbmd0aFByb2JlIGZvciBcIiArIHByb3BOYW1lKTtcbiAgICB0aGlzLnByb3BOYW1lID0gcHJvcE5hbWU7XG4gICAgdGhpcy53aXRoU3RyZWFtSW5mbyhwcm9wTmFtZSwgMCk7XG59XG51dGlscy5pbmhlcml0cyhEYXRhTGVuZ3RoUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuRGF0YUxlbmd0aFByb2JlLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZihjaHVuaykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdIHx8IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSA9IGxlbmd0aCArIGNodW5rLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsuY2FsbCh0aGlzLCBjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhTGVuZ3RoUHJvYmU7XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG5cbi8vIHRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgY2h1bmtzXG4vLyBUT0RPIGV4cG9zZSB0aGlzIGFzIGEgcHVibGljIHZhcmlhYmxlXG52YXIgREVGQVVMVF9CTE9DS19TSVpFID0gMTYgKiAxMDI0O1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgcmVhZHMgYSBjb250ZW50IGFuZCBlbWl0cyBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UHJvbWlzZX0gZGF0YVAgdGhlIHByb21pc2Ugb2YgdGhlIGRhdGEgdG8gc3BsaXRcbiAqL1xuZnVuY3Rpb24gRGF0YVdvcmtlcihkYXRhUCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFXb3JrZXJcIik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZGF0YUlzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLm1heCA9IDA7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuXG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YVAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLmRhdGFJc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5kYXRhID0gZGF0YTtcbiAgICAgICAgc2VsZi5tYXggPSBkYXRhICYmIGRhdGEubGVuZ3RoIHx8IDA7XG4gICAgICAgIHNlbGYudHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICAgICAgaWYoIXNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3RpY2tBbmRSZXBlYXQoKTtcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgfSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKERhdGFXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5jbGVhblVwXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZXN1bWVcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90aWNrU2NoZWR1bGVkICYmIHRoaXMuZGF0YUlzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHV0aWxzLmRlbGF5KHRoaXMuX3RpY2tBbmRSZXBlYXQsIFtdLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYSB0aWNrIGEgc2NoZWR1bGUgYW4gb3RoZXIgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGlja0FuZFJlcGVhdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RpY2soKTtcbiAgICBpZighdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHV0aWxzLmRlbGF5KHRoaXMuX3RpY2tBbmRSZXBlYXQsIFtdLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwdXNoIGEgY2h1bmsuXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSBERUZBVUxUX0JMT0NLX1NJWkU7XG4gICAgdmFyIGRhdGEgPSBudWxsLCBuZXh0SW5kZXggPSBNYXRoLm1pbih0aGlzLm1heCwgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMubWF4KSB7XG4gICAgICAgIC8vIEVPRlxuICAgICAgICByZXR1cm4gdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2godGhpcy50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVpbnQ4YXJyYXlcIjpcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiB0aGlzLm1heCA/IHRoaXMuaW5kZXggLyB0aGlzLm1heCAqIDEwMCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhV29ya2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgIFwiZGF0YVwiOltdLFxuICAgICAgICBcImVuZFwiOltdLFxuICAgICAgICBcImVycm9yXCI6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5leHRyYVN0cmVhbUluZm8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RyZWFtSW5mb1trZXldID0gdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2NrIHRoZSBzdHJlYW0gdG8gcHJldmVudCBmdXJ0aGVyIHVwZGF0ZXMgb24gdGhlIHdvcmtlcnMgY2hhaW4uXG4gICAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCwgYWxsIGNhbGxzIHRvIHBpcGUgd2lsbCBmYWlsLlxuICAgICAqL1xuICAgIGxvY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5sb2NrKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQcmV0dHkgcHJpbnQgdGhlIHdvcmtlcnMgY2hhaW4uXG4gICAgICovXG4gICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZSA9IFwiV29ya2VyIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMgKyBcIiAtPiBcIiArIG1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW5lcmljV29ya2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBDb252ZXJ0V29ya2VyID0gcmVxdWlyZShcIi4vQ29udmVydFdvcmtlclwiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vR2VuZXJpY1dvcmtlclwiKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKFwiLi4vYmFzZTY0XCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9leHRlcm5hbFwiKTtcblxudmFyIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSBudWxsO1xuaWYgKHN1cHBvcnQubm9kZXN0cmVhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJcIik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgZmluYWwgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGRhdGEuIElmIHRoZSB1c2VyIHdhbnRzIGEgQmxvYiBmb3JcbiAqIGV4YW1wbGUsIGl0J3MgZWFzaWVyIHRvIHdvcmsgd2l0aCBhbiBVOGludEFycmF5IGFuZCBmaW5hbGx5IGRvIHRoZVxuICogQXJyYXlCdWZmZXIvQmxvYiBjb252ZXJzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIGZpbmFsIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHR5cGUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwiYmxvYlwiIDpcbiAgICAgICAgcmV0dXJuIHV0aWxzLm5ld0Jsb2IodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLCBjb250ZW50KSwgbWltZVR5cGUpO1xuICAgIGNhc2UgXCJiYXNlNjRcIiA6XG4gICAgICAgIHJldHVybiBiYXNlNjQuZW5jb2RlKGNvbnRlbnQpO1xuICAgIGRlZmF1bHQgOlxuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8odHlwZSwgY29udGVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIGRhdGEgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgY2h1bmtzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBjb25jYXRlbmF0ZWQgZGF0YVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXNrZWQgdHlwZSBpcyB1bnN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjb25jYXQgKHR5cGUsIGRhdGFBcnJheSkge1xuICAgIHZhciBpLCBpbmRleCA9IDAsIHJlcyA9IG51bGwsIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHJldHVybiBkYXRhQXJyYXkuam9pbihcIlwiKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGRhdGFBcnJheSk7XG4gICAgY2FzZSBcInVpbnQ4YXJyYXlcIjpcbiAgICAgICAgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YUFycmF5W2ldLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoZGF0YUFycmF5KTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICdcIiAgKyB0eXBlICsgXCInXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICogY29tcGxldGUgYmxvY2suXG4gKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2FsbGJhY2sgYSBjYWxsYmFjayBjYWxsZWQgb24gZWFjaCB1cGRhdGUuIENhbGxlZFxuICogd2l0aCBvbmUgYXJnIDpcbiAqIC0gdGhlIG1ldGFkYXRhIGxpbmtlZCB0byB0aGUgdXBkYXRlIHJlY2VpdmVkLlxuICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlKGhlbHBlciwgdXBkYXRlQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNodW5rVHlwZSA9IGhlbHBlci5faW50ZXJuYWxUeXBlLFxuICAgICAgICAgICAgcmVzdWx0VHlwZSA9IGhlbHBlci5fb3V0cHV0VHlwZSxcbiAgICAgICAgICAgIG1pbWVUeXBlID0gaGVscGVyLl9taW1lVHlwZTtcbiAgICAgICAgaGVscGVyXG4gICAgICAgICAgICAub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2FsbGJhY2sobWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtWmlwT3V0cHV0KHJlc3VsdFR5cGUsIGNvbmNhdChjaHVua1R5cGUsIGRhdGFBcnJheSksIG1pbWVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgIGNhc2UgXCJibG9iXCI6XG4gICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIGludGVybmFsVHlwZSA9IFwidWludDhhcnJheVwiO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgIGludGVybmFsVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBpbnRlcm5hbFR5cGU7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgdG8gb3V0cHV0IHJlc3VsdHNcbiAgICAgICAgdGhpcy5fb3V0cHV0VHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIC8vIHRoZSBtaW1lIHR5cGVcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KGludGVybmFsVHlwZSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlci5waXBlKG5ldyBDb252ZXJ0V29ya2VyKGludGVybmFsVHlwZSkpO1xuICAgICAgICAvLyB0aGUgbGFzdCB3b3JrZXJzIGNhbiBiZSByZXdpcmVkIHdpdGhvdXQgaXNzdWVzIGJ1dCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgYW55IHVwZGF0ZXMgb24gcHJldmlvdXMgd29ya2Vycy5cbiAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmVycm9yKGUpO1xuICAgIH1cbn1cblxuU3RyZWFtSGVscGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICAgICAqIGNvbXBsZXRlIGJsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICAgICAqL1xuICAgIGFjY3VtdWxhdGUgOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGUodGhpcywgdXBkYXRlQ2IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgb24gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAoZXZ0LCBmbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoZXZ0ID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChzZWxmLCBjaHVuay5kYXRhLCBjaHVuay5tZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGF5KGZuLCBhcmd1bWVudHMsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93b3JrZXIucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBub2RlanMgc3RyZWFtIGZvciB0aGlzIGhlbHBlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJ9IHRoZSBub2RlanMgc3RyZWFtLlxuICAgICAqL1xuICAgIHRvTm9kZWpzU3RyZWFtIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIik7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHN0cmVhbSBjb250YWluaW5nIGJsb2IvYXJyYXlidWZmZXIvdWludDhhcnJheS9zdHJpbmdcbiAgICAgICAgICAgIC8vIGlzIHN0cmFuZ2UgYW5kIEkgZG9uJ3Qga25vdyBpZiBpdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBJIHlvdSBmaW5kIHRoaXMgY29tbWVudCBhbmQgaGF2ZSBhIGdvb2QgdXNlY2FzZSwgcGxlYXNlIG9wZW4gYVxuICAgICAgICAgICAgLy8gYnVnIHJlcG9ydCAhXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIodGhpcywge1xuICAgICAgICAgICAgb2JqZWN0TW9kZSA6IHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiXG4gICAgICAgIH0sIHVwZGF0ZUNiKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtSGVscGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuYmFzZTY0ID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXkgPSB0cnVlO1xuZXhwb3J0cy5zdHJpbmcgPSB0cnVlO1xuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoXCJhcHBsaWNhdGlvbi96aXBcIikuc2l6ZSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnRyeSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gISFyZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpLlJlYWRhYmxlO1xufSBjYXRjaChlKSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gZmFsc2U7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgY29tZSBmcm9tIHBha28sIGZyb20gcGFrby9saWIvdXRpbHMvc3RyaW5nc1xuICogcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLCBzZWUgcGFrbyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vXG4gKi9cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGk9MDsgaTwyNTY7IGkrKykge1xuICAgIF91dGY4bGVuW2ldID0gKGkgPj0gMjUyID8gNiA6IGkgPj0gMjQ4ID8gNSA6IGkgPj0gMjQwID8gNCA6IGkgPj0gMjI0ID8gMyA6IGkgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XT1fdXRmOGxlblsyNTRdPTE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxudmFyIHN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICAgIH1cblxuICAgIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gbmV3IEFycmF5KGJ1Zl9sZW4pO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnRcbiAgICBmb3IgKGk9MCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7XG4gICAgdmFyIHBvcztcblxuICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAgIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICAgIHBvcyA9IG1heC0xO1xuICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gICAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAgIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICAgIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAgIC8vIHJldHVybiBtYXggdG9vLlxuICAgIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gICAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAgIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAgIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbioyKTtcblxuICAgIGZvciAob3V0PTAsIGk9MDsgaTxsZW47KSB7XG4gICAgICAgIGMgPSBidWZbaSsrXTtcbiAgICAgICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgICAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgICAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgICAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICAgICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4tMTsgY29udGludWU7IH1cblxuICAgICAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgICAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICAgICAgICBjX2xlbi0tO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgICAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgICAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjIC09IDB4MTAwMDA7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzaHJpbmtCdWYodXRmMTZidWYsIG91dClcbiAgICBpZiAodXRmMTZidWYubGVuZ3RoICE9PSBvdXQpIHtcbiAgICAgICAgaWYodXRmMTZidWYuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmID0gdXRmMTZidWYuc3ViYXJyYXkoMCwgb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmLmxlbmd0aCA9IG91dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0ZjE2YnVmKTtcbiAgICByZXR1cm4gdXRpbHMuYXBwbHlGcm9tQ2hhckNvZGUodXRmMTZidWYpO1xufTtcblxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBqYXZhc2NyaXB0IHN0cmluZyBpbnRvIGFuIGFycmF5ICh0eXBlZCBpZiBwb3NzaWJsZSkgb2YgYnl0ZXMsXG4gKiBVVEYtOCBlbmNvZGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBVVEYtOCBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZW5jb2RlID0gZnVuY3Rpb24gdXRmOGVuY29kZShzdHIpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKHN0ciwgXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nMmJ1ZihzdHIpO1xufTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGJ5dGVzIGFycmF5IChvciBhIHJlcHJlc2VudGF0aW9uKSByZXByZXNlbnRpbmcgYW4gVVRGLTggZW5jb2RlZFxuICogc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IGJ1ZiB0aGUgZGF0YSBkZSBkZWNvZGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhkZWNvZGUgPSBmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ1Zikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwibm9kZWJ1ZmZlclwiLCBidWYpLnRvU3RyaW5nKFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgYnVmID0gdXRpbHMudHJhbnNmb3JtVG8oc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIGJ1Zik7XG5cbiAgICByZXR1cm4gYnVmMnN0cmluZyhidWYpO1xufTtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBkZWNvZGUgdXRmOCBlbmNvZGVkIGJpbmFyeSBjaHVua3MgaW50byBzdHJpbmcgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhEZWNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZGVjb2RlXCIpO1xuICAgIC8vIHRoZSBsYXN0IGJ5dGVzIGlmIGEgY2h1bmsgZGlkbid0IGVuZCB3aXRoIGEgY29tcGxldGUgY29kZXBvaW50LlxuICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOERlY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcblxuICAgIHZhciBkYXRhID0gdXRpbHMudHJhbnNmb3JtVG8oc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIGNodW5rLmRhdGEpO1xuXG4gICAgLy8gMXN0IHN0ZXAsIHJlLXVzZSB3aGF0J3MgbGVmdCBvZiB0aGUgcHJldmlvdXMgY2h1bmtcbiAgICBpZiAodGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICBpZihzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHByZXZpb3VzRGF0YS5sZW5ndGggKyB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgICAgICBkYXRhLnNldCh0aGlzLmxlZnRPdmVyLCAwKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHByZXZpb3VzRGF0YSwgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMubGVmdE92ZXIuY29uY2F0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBuZXh0Qm91bmRhcnkgPSB1dGY4Ym9yZGVyKGRhdGEpO1xuICAgIHZhciB1c2FibGVEYXRhID0gZGF0YTtcbiAgICBpZiAobmV4dEJvdW5kYXJ5ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB1c2FibGVEYXRhID0gZGF0YS5zdWJhcnJheSgwLCBuZXh0Qm91bmRhcnkpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IGRhdGEuc3ViYXJyYXkobmV4dEJvdW5kYXJ5LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2FibGVEYXRhID0gZGF0YS5zbGljZSgwLCBuZXh0Qm91bmRhcnkpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IGRhdGEuc2xpY2UobmV4dEJvdW5kYXJ5LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHVzYWJsZURhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYodGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh0aGlzLmxlZnRPdmVyKSxcbiAgICAgICAgICAgIG1ldGEgOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxufTtcbmV4cG9ydHMuVXRmOERlY29kZVdvcmtlciA9IFV0ZjhEZWNvZGVXb3JrZXI7XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZW5kY29kZSBzdHJpbmcgY2h1bmtzIGludG8gdXRmOCBlbmNvZGVkIGJpbmFyeSBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOEVuY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBlbmNvZGVcIik7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RW5jb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhFbmNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhlbmNvZGUoY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuZXhwb3J0cy5VdGY4RW5jb2RlV29ya2VyID0gVXRmOEVuY29kZVdvcmtlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG52YXIgYmFzZTY0ID0gcmVxdWlyZShcIi4vYmFzZTY0XCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRoYXQgcGFzcyBhcyBhIFwiYmluYXJ5IHN0cmluZ1wiOiBpdCBzaG91bGQgcmVwcmVzZW50IGEgYnl0ZVxuICogYXJyYXkgYnV0IG1heSBoYXZlID4gMjU1IGNoYXIgY29kZXMuIEJlIHN1cmUgdG8gdGFrZSBvbmx5IHRoZSBmaXJzdCBieXRlXG4gKiBhbmQgcmV0dXJucyB0aGUgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fSB0aGUgc3RyaW5nIGluIGEgYmluYXJ5IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nMmJpbmFyeShzdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9uIGFuZCBmdW5jdGlvbnMgdGhhdFxuICogY2FuIGJlIG9wdGltaXplZCBieSB0aGUgYnJvd3NlciBKSVQgY29tcGlsZXIuXG4gKi9cbnZhciBhcnJheVRvU3RyaW5nSGVscGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBpbnQgaW50byBhIHN0cmluZywgY2h1bmsgYnkgY2h1bmsuXG4gICAgICogU2VlIHRoZSBwZXJmb3JtYW5jZXMgbm90ZXMgb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjaHVuayB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNodW5rIGlzIHRvbyBiaWcgZm9yIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNodW5rOiBmdW5jdGlvbihhcnJheSwgdHlwZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICBpZiAobGVuIDw9IGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnNsaWNlKGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc3ViYXJyYXkoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICogVGhpcyBpcyB0aGUgbmFpdmUgaW1wbGVtZW50YXRpb24sIHdoaWNoIGdlbmVyYXRlIEEgTE9UIG9mIGludGVybWVkaWF0ZSBzdHJpbmcuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBmYWlsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2hhcjogZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9LFxuICAgIGFwcGx5Q2FuQmVVc2VkIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIFVpbnQ4QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHVpbnQ4YXJyYXkgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC51aW50OGFycmF5ICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gbm9kZWpzIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVidWZmZXIgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5ub2RlYnVmZmVyICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoaW5wdXQubGVuZ3RoKSk7XG4gICAgfVxufTtcblxuLy8gYXJyYXkgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfVxufTtcblxuLy8gdWludDhhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJ1aW50OGFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBub2RlYnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBpZGVudGl0eVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW5wdXQgaW50byBhbnkgdHlwZS5cbiAqIFRoZSBzdXBwb3J0ZWQgb3V0cHV0IHR5cGUgYXJlIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIG5vZGVidWZmZXIuXG4gKiBJZiBubyBvdXRwdXQgdHlwZSBpcyBzcGVjaWZpZWQsIHRoZSB1bm1vZGlmaWVkIGlucHV0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgb3V0cHV0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gaW5wdXQgdGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHR5cGUuXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihvdXRwdXRUeXBlLCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkLCBudWxsLCBldGNcbiAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIHdvbid0IGhhcm0uXG4gICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQob3V0cHV0VHlwZSk7XG4gICAgdmFyIGlucHV0VHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGlucHV0KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtW2lucHV0VHlwZV1bb3V0cHV0VHlwZV0oaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgYWxsIHJlbGF0aXZlIHBhdGggY29tcG9uZW50cywgXCIuXCIgYW5kIFwiLi5cIiwgaW4gYSBwYXRoLiBJZiB0aGVzZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gKiB0cmF2ZXJzZSBhYm92ZSB0aGUgcm9vdCB0aGVuIHRoZSByZXN1bHRpbmcgcGF0aCB3aWxsIG9ubHkgY29udGFpbiB0aGUgZmluYWwgcGF0aCBjb21wb25lbnQuXG4gKlxuICogQWxsIGVtcHR5IGNvbXBvbmVudHMsIGUuZy4gXCIvL1wiLCBhcmUgcmVtb3ZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEEgcGF0aCB3aXRoIC8gb3IgXFwgc2VwYXJhdG9yc1xuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggd2l0aCBhbGwgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzIHJlc29sdmVkLlxuICovXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpbmRleF07XG4gICAgICAgIC8vIEFsbG93IHRoZSBmaXJzdCBhbmQgbGFzdCBjb21wb25lbnQgdG8gYmUgZW1wdHkgZm9yIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgICAgIGlmIChwYXJ0ID09PSBcIi5cIiB8fCAocGFydCA9PT0gXCJcIiAmJiBpbmRleCAhPT0gMCAmJiBpbmRleCAhPT0gcGFydHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiL1wiKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIFRoZSB0eXBlIHdpbGwgYmUgaW4gYSBmb3JtYXQgdmFsaWQgZm9yIEpTWmlwLnV0aWxzLnRyYW5zZm9ybVRvIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0IHRvIGlkZW50aWZ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgKGxvd2VyY2FzZSkgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKi9cbmV4cG9ydHMuZ2V0VHlwZU9mID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIgJiYgbm9kZWpzVXRpbHMuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBcIm5vZGVidWZmZXJcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSAmJiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDhhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5hcnJheWJ1ZmZlciAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRvIGNoZWNrLlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIHR5cGUuXG4gKi9cbmV4cG9ydHMuY2hlY2tTdXBwb3J0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0W3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcGxhdGZvcm1cIik7XG4gICAgfVxufTtcblxuZXhwb3J0cy5NQVhfVkFMVUVfMTZCSVRTID0gNjU1MzU7XG5leHBvcnRzLk1BWF9WQUxVRV8zMkJJVFMgPSAtMTsgLy8gd2VsbCwgXCJcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXCIgaXMgcGFyc2VkIGFzIC0xXG5cbi8qKlxuICogUHJldHRpZnkgYSBzdHJpbmcgcmVhZCBhcyBiaW5hcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gcHJldHRpZnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgcHJldHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5wcmV0dHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgcmVzID0gXCJcIixcbiAgICAgICAgY29kZSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgKHN0ciB8fCBcIlwiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJlcyArPSBcIlxcXFx4XCIgKyAoY29kZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIERlZmVyIHRoZSBjYWxsIG9mIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhc3luY2hyb25vdXNseS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBnaXZlIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzLCBzZWxmKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBhIHByb3RvdHlwZSB3aXRoIGFuIG90aGVyLCB3aXRob3V0IGNhbGxpbmcgYSBjb25zdHJ1Y3RvciB3aXRoXG4gKiBzaWRlIGVmZmVjdHMuIEluc3BpcmVkIGJ5IG5vZGVqcycgYHV0aWxzLmluaGVyaXRzYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvciB0aGUgY29uc3RydWN0b3IgdG8gYXVnbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDdG9yIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgdG8gdXNlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgdmFyIE9iaiA9IGZ1bmN0aW9uKCkge307XG4gICAgT2JqLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgT2JqKCk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBvYmplY3RzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIGludG8gYSBuZXcgb25lLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBBbGwgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIGRhdGEgb2YgdGhlIG90aGVycy5cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGksIGF0dHI7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyAvLyBhcmd1bWVudHMgaXMgbm90IGVudW1lcmFibGUgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICBmb3IgKGF0dHIgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwgYXR0cikgJiYgdHlwZW9mIHJlc3VsdFthdHRyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFthdHRyXSA9IGFyZ3VtZW50c1tpXVthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYXJiaXRyYXJ5IGNvbnRlbnQgaW50byBhIFByb21pc2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG5hbWUgZm9yIHRoZSBjb250ZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGEgdGhlIGNvbnRlbnQgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgdHJ1ZSBpZiB0aGUgY29udGVudCBpcyBub3QgYW4gdW5pY29kZSBzdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgb25seSBoYXMgb25lIGJ5dGUgcGVyIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCYXNlNjQgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgaXMgZW5jb2RlZCB3aXRoIGJhc2U2NC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSBpbiBhIGZvcm1hdCB1c2FibGUgYnkgSlNaaXAuXG4gKi9cbmV4cG9ydHMucHJlcGFyZUNvbnRlbnQgPSBmdW5jdGlvbihuYW1lLCBpbnB1dERhdGEsIGlzQmluYXJ5LCBpc09wdGltaXplZEJpbmFyeVN0cmluZywgaXNCYXNlNjQpIHtcblxuICAgIC8vIGlmIGlucHV0RGF0YSBpcyBhbHJlYWR5IGEgcHJvbWlzZSwgdGhpcyBmbGF0dGVuIGl0LlxuICAgIHZhciBwcm9taXNlID0gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKGlucHV0RGF0YSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG5cblxuICAgICAgICB2YXIgaXNCbG9iID0gc3VwcG9ydC5ibG9iICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBbXCJbb2JqZWN0IEZpbGVdXCIsIFwiW29iamVjdCBCbG9iXVwiXS5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkgIT09IC0xKTtcblxuICAgICAgICBpZiAoaXNCbG9iICYmIHR5cGVvZiBGaWxlUmVhZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlLnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoZGF0YSk7XG5cbiAgICAgICAgaWYgKCFkYXRhVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIkNhbid0IHJlYWQgdGhlIGRhdGEgb2YgJ1wiICsgbmFtZSArIFwiJy4gSXMgaXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImluIGEgc3VwcG9ydGVkIEphdmFTY3JpcHQgdHlwZSAoU3RyaW5nLCBCbG9iLCBBcnJheUJ1ZmZlciwgZXRjKSA/XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSA6IGl0J3Mgd2F5IGVhc2llciB0byB3b3JrIHdpdGggVWludDhBcnJheSB0aGFuIHdpdGggQXJyYXlCdWZmZXJcbiAgICAgICAgaWYgKGRhdGFUeXBlID09PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBleHBvcnRzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlzQmFzZTY0KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGJhc2U2NC5kZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZEJpbmFyeVN0cmluZyA9PT0gdHJ1ZSBtZWFucyB0aGF0IHRoZSBmaWxlIGhhcyBhbHJlYWR5IGJlZW4gZmlsdGVyZWQgd2l0aCBhIDB4RkYgbWFza1xuICAgICAgICAgICAgICAgIGlmIChpc09wdGltaXplZEJpbmFyeVN0cmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc3RyaW5nLCBub3QgaW4gYSBiYXNlNjQgZm9ybWF0LlxuICAgICAgICAgICAgICAgICAgICAvLyBCZSBzdXJlIHRoYXQgdGhpcyBpcyBhIGNvcnJlY3QgXCJiaW5hcnkgc3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHN0cmluZzJiaW5hcnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoXCIuL3JlYWRlci9yZWFkZXJGb3JcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBzaWcgPSByZXF1aXJlKFwiLi9zaWduYXR1cmVcIik7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKFwiLi96aXBFbnRyeVwiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcbi8vICBjbGFzcyBaaXBFbnRyaWVzIHt7e1xuLyoqXG4gKiBBbGwgdGhlIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyaWVzKGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJpZXMucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHJlYWRlciBpcyBvbiB0aGUgc3BlY2lmaWVkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgYW4gb3RoZXIgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGNoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShleHBlY3RlZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSBcIiArIFwiKFwiICsgdXRpbHMucHJldHR5KHNpZ25hdHVyZSkgKyBcIiwgZXhwZWN0ZWQgXCIgKyB1dGlscy5wcmV0dHkoZXhwZWN0ZWRTaWduYXR1cmUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGlzIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNrZWRJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gZXhwZWN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBoZXJlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNTaWduYXR1cmU6IGZ1bmN0aW9uKGFza2VkSW5kZXgsIGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnJlYWRlci5pbmRleDtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoYXNrZWRJbmRleCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2lnbmF0dXJlID09PSBleHBlY3RlZFNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoY3VycmVudEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEJsb2NrRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIHRoaXMuemlwQ29tbWVudExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIC8vIHdhcm5pbmcgOiB0aGUgZW5jb2RpbmcgZGVwZW5kcyBvZiB0aGUgc3lzdGVtIGxvY2FsZVxuICAgICAgICAvLyBPbiBhIGxpbnV4IG1hY2hpbmUgd2l0aCBMQU5HPWVuX1VTLnV0ZjgsIHRoaXMgZmllbGQgaXMgdXRmOCBlbmNvZGVkLlxuICAgICAgICAvLyBPbiBhIHdpbmRvd3MgbWFjaGluZSwgdGhpcyBmaWVsZCBpcyBlbmNvZGVkIHdpdGggdGhlIGxvY2FsaXplZCB3aW5kb3dzIGNvZGUgcGFnZS5cbiAgICAgICAgdmFyIHppcENvbW1lbnQgPSB0aGlzLnJlYWRlci5yZWFkRGF0YSh0aGlzLnppcENvbW1lbnRMZW5ndGgpO1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIC8vIFRvIGdldCBjb25zaXN0ZW50IGJlaGF2aW9yIHdpdGggdGhlIGdlbmVyYXRpb24gcGFydCwgd2Ugd2lsbCBhc3N1bWUgdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIHV0ZjggZW5jb2RlZCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIGRlY29kZUNvbnRlbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHppcENvbW1lbnQpO1xuICAgICAgICB0aGlzLnppcENvbW1lbnQgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGRlY29kZUNvbnRlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICogTm90IG1lcmdlZCB3aXRoIHRoZSBtZXRob2QgcmVhZEVuZE9mQ2VudHJhbCA6XG4gICAgICogVGhlIGVuZCBvZiBjZW50cmFsIGNhbiBjb2V4aXN0IHdpdGggaXRzIFppcDY0IGJyb3RoZXIsXG4gICAgICogSSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIHdyb25nIG51bWJlciBvZiBieXRlcyAhXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMucmVhZGVyLnNraXAoNCk7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk1hZGVCeSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcblxuICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGEgPSB7fTtcbiAgICAgICAgdmFyIGV4dHJhRGF0YVNpemUgPSB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSAtIDQ0LFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZXh0cmFEYXRhU2l6ZSkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gdGhpcy5yZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yLlxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuZGlza3NDb3VudCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIGlmICh0aGlzLmRpc2tzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aS12b2x1bWVzIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgZmlsZXMsIGJhc2VkIG9uIHRoZSBvZmZzZXQgcmVhZCBpbiB0aGUgY2VudHJhbCBwYXJ0LlxuICAgICAqL1xuICAgIHJlYWRMb2NhbEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGZpbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGZpbGUubG9jYWxIZWFkZXJPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuICAgICAgICAgICAgZmlsZS5yZWFkTG9jYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlVVRGOCgpO1xuICAgICAgICAgICAgZmlsZS5wcm9jZXNzQXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbERpcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWxlO1xuXG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMuY2VudHJhbERpck9mZnNldCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICBmaWxlID0gbmV3IFppcEVudHJ5KHtcbiAgICAgICAgICAgICAgICB6aXA2NDogdGhpcy56aXA2NFxuICAgICAgICAgICAgfSwgdGhpcy5sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICBmaWxlLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gdGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSAwICYmIHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZXhwZWN0ZWQgc29tZSByZWNvcmRzIGJ1dCBjb3VsZG4ndCBmaW5kIEFOWS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlYWxseSBzdXNwaWNpb3VzLCBhcyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgXCIgKyB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICsgXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiICsgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBzb21lIHJlY29yZHMgYnV0IG5vdCBhbGwuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGlzIHdyb25nIGJ1dCB3ZSBnb3Qgc29tZXRoaW5nIGZvciB0aGUgdXNlcjogbm8gZXJyb3IgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJleHBlY3RlZFwiLCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzLCBcInJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdFwiLCB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnQgaXMgYSB0cnVuY2F0ZWQgemlwIG9yIGNvbXBsZXRlIGdhcmJhZ2UuXG4gICAgICAgICAgICAvLyBBIFwiTE9DQUxfRklMRV9IRUFERVJcIiBpcyBub3QgcmVxdWlyZWQgYXQgdGhlIGJlZ2lubmluZyAoYXV0b1xuICAgICAgICAgICAgLy8gZXh0cmFjdGlibGUgemlwIGZvciBleGFtcGxlKSBidXQgaXQgY2FuIGdpdmUgYSBnb29kIGhpbnQuXG4gICAgICAgICAgICAvLyBJZiBhbiBhamF4IHJlcXVlc3Qgd2FzIHVzZWQgd2l0aG91dCByZXNwb25zZVR5cGUsIHdlIHdpbGwgYWxzb1xuICAgICAgICAgICAgLy8gZ2V0IHVucmVhZGFibGUgZGF0YS5cbiAgICAgICAgICAgIHZhciBpc0dhcmJhZ2UgPSAhdGhpcy5pc1NpZ25hdHVyZSgwLCBzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuXG4gICAgICAgICAgICBpZiAoaXNHYXJiYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgOiBpcyB0aGlzIGEgemlwIGZpbGUgPyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICB2YXIgZW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpO1xuXG5cbiAgICAgICAgLyogZXh0cmFjdCBmcm9tIHRoZSB6aXAgc3BlYyA6XG4gICAgICAgICAgICA0KSAgSWYgb25lIG9mIHRoZSBmaWVsZHMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIHJlY29yZCBpcyB0b28gc21hbGwgdG8gaG9sZCByZXF1aXJlZCBkYXRhLCB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHRvIC0xICgweEZGRkYgb3IgMHhGRkZGRkZGRikgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFpJUDY0IGZvcm1hdCByZWNvcmQgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICA1KSAgVGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yIHJlY29yZCBtdXN0XG4gICAgICAgICAgICAgICAgcmVzaWRlIG9uIHRoZSBzYW1lIGRpc2sgd2hlbiBzcGxpdHRpbmcgb3Igc3Bhbm5pbmdcbiAgICAgICAgICAgICAgICBhbiBhcmNoaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlciA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUyB8fCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuemlwNjQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgV2FybmluZyA6IHRoZSB6aXA2NCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLCBidXQgT05MWSBpZiB0aGUgNjRiaXRzIGludGVnZXIgcmVhZCBmcm9tXG4gICAgICAgICAgICB0aGUgemlwIGZpbGUgY2FuIGZpdCBpbnRvIGEgMzJiaXRzIGludGVnZXIuIFRoaXMgY2Fubm90IGJlIHNvbHZlZCA6IEphdmFTY3JpcHQgcmVwcmVzZW50c1xuICAgICAgICAgICAgYWxsIG51bWJlcnMgYXMgNjQtYml0IGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICAgIFNvLCB3ZSBoYXZlIDUzYml0cyBmb3IgaW50ZWdlcnMgYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucyB0cmVhdCBldmVyeXRoaW5nIGFzIDMyYml0cy5cbiAgICAgICAgICAgIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9yc1xuICAgICAgICAgICAgYW5kIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYgc2VjdGlvbiA4LjVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGZvciBhIHppcDY0IEVPQ0QgbG9jYXRvclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB0aGUgemlwNjQgRU9DRCByZWNvcmRcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NpZ25hdHVyZSh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIsIHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IG5vdCB3aGVyZSBleHBlY3RlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5jZW50cmFsRGlyT2Zmc2V0ICsgdGhpcy5jZW50cmFsRGlyU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuemlwNjQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDIwOyAvLyBlbmQgb2YgY2VudHJhbCBkaXIgNjQgbG9jYXRvclxuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMTIgLyogc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIDEyIGJ5dGVzICovICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGVuZE9mQ2VudHJhbERpck9mZnNldCAtIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0O1xuXG4gICAgICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGV4dHJhQnl0ZXMsIFwiZXh0cmEgYnl0ZXMgYXQgYmVnaW5uaW5nIG9yIHdpdGhpbiB6aXBmaWxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaWduYXR1cmUoZW5kT2ZDZW50cmFsRGlyT2Zmc2V0LCBzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2Zmc2V0cyBzZWVtIHdyb25nLCBidXQgd2UgaGF2ZSBzb21ldGhpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gU2/igKYgd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyB3cm9uZywgdXBkYXRlIHRoZSBcInplcm9cIiBvZiB0aGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIGRhdGEgaGFzIGJlZW4gcHJlcGVuZGVkIChjcnggZmlsZXMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuemVybyA9IGV4dHJhQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIgKyBNYXRoLmFicyhleHRyYUJ5dGVzKSArIFwiIGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlYWRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlckZvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKFwiLi9yZWFkZXIvcmVhZGVyRm9yXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoXCIuL2NvbXByZXNzZWRPYmplY3RcIik7XG52YXIgY3JjMzJmbiA9IHJlcXVpcmUoXCIuL2NyYzMyXCIpO1xudmFyIHV0ZjggPSByZXF1aXJlKFwiLi91dGY4XCIpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uc1wiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcblxudmFyIE1BREVfQllfRE9TID0gMHgwMDtcbnZhciBNQURFX0JZX1VOSVggPSAweDAzO1xuXG4vKipcbiAqIEZpbmQgYSBjb21wcmVzc2lvbiByZWdpc3RlcmVkIGluIEpTWmlwLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXByZXNzaW9uTWV0aG9kIHRoZSBtZXRob2QgbWFnaWMgdG8gZmluZC5cbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSB0aGUgSlNaaXAgY29tcHJlc3Npb24gb2JqZWN0LCBudWxsIGlmIG5vbmUgZm91bmQuXG4gKi9cbnZhciBmaW5kQ29tcHJlc3Npb24gPSBmdW5jdGlvbihjb21wcmVzc2lvbk1ldGhvZCkge1xuICAgIGZvciAodmFyIG1ldGhvZCBpbiBjb21wcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29tcHJlc3Npb25zLCBtZXRob2QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Npb25zW21ldGhvZF0ubWFnaWMgPT09IGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3Npb25zW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBjbGFzcyBaaXBFbnRyeSB7e3tcbi8qKlxuICogQW4gZW50cnkgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9mIHRoZSBjdXJyZW50IGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyeShvcHRpb25zLCBsb2FkT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuY3J5cHRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDAwMSkgPT09IDB4MDAwMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBoYXMgdXRmLTggZmlsZW5hbWUvY29tbWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlbmFtZS9jb21tZW50IGlzIGluIHV0Zi04LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdXNlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoO1xuXG4gICAgICAgIC8vIHdlIGFscmVhZHkga25vdyBldmVyeXRoaW5nIGZyb20gdGhlIGNlbnRyYWwgZGlyICFcbiAgICAgICAgLy8gSWYgdGhlIGNlbnRyYWwgZGlyIGRhdGEgYXJlIGZhbHNlLCB3ZSBhcmUgZG9vbWVkLlxuICAgICAgICAvLyBPbiB0aGUgYnJpZ2h0IHNpZGUsIHRoZSBsb2NhbCBwYXJ0IGlzIHNjYXJ5ICA6IHppcDY0LCBkYXRhIGRlc2NyaXB0b3JzLCBib3RoLCBldGMuXG4gICAgICAgIC8vIFRoZSBsZXNzIGRhdGEgd2UgZ2V0IGhlcmUsIHRoZSBtb3JlIHJlbGlhYmxlIHRoaXMgc2hvdWxkIGJlLlxuICAgICAgICAvLyBMZXQncyBza2lwIHRoZSB3aG9sZSBoZWFkZXIgYW5kIGRhc2ggdG8gdGhlIGRhdGEgIVxuICAgICAgICByZWFkZXIuc2tpcCgyMik7XG4gICAgICAgIC8vIGluIHNvbWUgemlwIGNyZWF0ZWQgb24gd2luZG93cywgdGhlIGZpbGVuYW1lIHN0b3JlZCBpbiB0aGUgY2VudHJhbCBkaXIgY29udGFpbnMgXFwgaW5zdGVhZCBvZiAvLlxuICAgICAgICAvLyBTdHJhbmdlbHksIHRoZSBmaWxlbmFtZSBoZXJlIGlzIE9LLlxuICAgICAgICAvLyBJIHdvdWxkIGxvdmUgdG8gdHJlYXQgdGhlc2UgemlwIGZpbGVzIGFzIGNvcnJ1cHRlZCAoc2VlIGh0dHA6Ly93d3cuaW5mby16aXAub3JnL0ZBUS5odG1sI2JhY2tzbGFzaGVzXG4gICAgICAgIC8vIG9yIEFQUE5PVEUjNC40LjE3LjEsIFwiQWxsIHNsYXNoZXMgTVVTVCBiZSBmb3J3YXJkIHNsYXNoZXMgJy8nXCIpIGJ1dCB0aGVyZSBhcmUgYSBsb3Qgb2YgYmFkIHppcCBnZW5lcmF0b3JzLi4uXG4gICAgICAgIC8vIFNlYXJjaCBcInVuemlwIG1pc21hdGNoaW5nIFwibG9jYWxcIiBmaWxlbmFtZSBjb250aW51aW5nIHdpdGggXCJjZW50cmFsXCIgZmlsZW5hbWUgdmVyc2lvblwiIG9uXG4gICAgICAgIC8vIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSSB0aGluayBJIHNlZSB0aGUgbG9naWMgaGVyZSA6IHRoZSBjZW50cmFsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gY29udGVudCBhbmQgdGhlIGxvY2FsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGV4dHJhY3QgdGhlIGZpbGVzLiBNaXhpbmcgLyBhbmQgXFxcbiAgICAgICAgLy8gbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBcXCB0byB3aW5kb3dzIHVzZXJzIGFuZCB1c2UgLyB3aGVuIGV4dHJhY3RpbmcgdGhlIGZpbGVzLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGxlYWQgYWxzbyB0byBzb21lIGlzc3VlcyA6IGh0dHA6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAwOS9TZXAvMzk0XG4gICAgICAgIHRoaXMuZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpOyAvLyBjYW4ndCBiZSBzdXJlIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgY2VudHJhbCBkaXJcbiAgICAgICAgLy8gdGhlIGZpbGVOYW1lIGlzIHN0b3JlZCBhcyBiaW5hcnkgZGF0YSwgdGhlIGhhbmRsZVVURjggbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSBlbmNvZGluZy5cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgcmVhZGVyLnNraXAobG9jYWxFeHRyYUZpZWxkc0xlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb24gZnJvbSB0aGUgY2VudHJhbCBkaXJlY3RvcnkgXCIgKyBcIihjb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcHJlc3Npb24gPSBmaW5kQ29tcHJlc3Npb24odGhpcy5jb21wcmVzc2lvbk1ldGhvZCk7XG4gICAgICAgIGlmIChjb21wcmVzc2lvbiA9PT0gbnVsbCkgeyAvLyBubyBjb21wcmVzc2lvbiBmb3VuZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNvbXByZXNzaW9uIFwiICsgdXRpbHMucHJldHR5KHRoaXMuY29tcHJlc3Npb25NZXRob2QpICsgXCIgdW5rbm93biAoaW5uZXIgZmlsZSA6IFwiICsgdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5maWxlTmFtZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNvbXByZXNzZWQgPSBuZXcgQ29tcHJlc3NlZE9iamVjdCh0aGlzLmNvbXByZXNzZWRTaXplLCB0aGlzLnVuY29tcHJlc3NlZFNpemUsIHRoaXMuY3JjMzIsIGNvbXByZXNzaW9uLCByZWFkZXIucmVhZERhdGEodGhpcy5jb21wcmVzc2VkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICByZWFkZXIuc2tpcCgyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuYml0RmxhZyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTWV0aG9kID0gcmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHJlYWRlci5yZWFkRGF0ZSgpO1xuICAgICAgICB0aGlzLmNyYzMyID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHZhciBmaWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gcmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGVkIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdpbGwgYmUgcmVhZCBpbiB0aGUgbG9jYWwgcGFydCwgc2VlIHRoZSBjb21tZW50cyB0aGVyZVxuICAgICAgICByZWFkZXIuc2tpcChmaWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVhZEV4dHJhRmllbGRzKHJlYWRlcik7XG4gICAgICAgIHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQocmVhZGVyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudCA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyBhbmQgZ2V0IHRoZSB1bml4L2RvcyBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB2YXIgbWFkZUJ5ID0gdGhpcy52ZXJzaW9uTWFkZUJ5ID4+IDg7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgRE9TIGRpcmVjdG9yeSBmbGFnIHNldC5cbiAgICAgICAgLy8gV2UgbG9vayBmb3IgaXQgaW4gdGhlIERPUyBhbmQgVU5JWCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBidXQgc29tZSB1bmtub3duIHBsYXRmb3JtIGNvdWxkIHNldCBpdCBhcyBhIGNvbXBhdGliaWxpdHkgZmxhZy5cbiAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDAwMTAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX0RPUykge1xuICAgICAgICAgICAgLy8gZmlyc3QgNiBiaXRzICgwIHRvIDUpXG4gICAgICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgzRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9VTklYKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9ICh0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGO1xuICAgICAgICAgICAgLy8gdGhlIG9jdGFsIHBlcm1pc3Npb25zIGFyZSBpbiAodGhpcy51bml4UGVybWlzc2lvbnMgJiAweDAxRkYpLnRvU3RyaW5nKDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFpbCBzYWZlIDogaWYgdGhlIG5hbWUgZW5kcyB3aXRoIGEgLyBpdCBwcm9iYWJseSBtZWFucyBhIGZvbGRlclxuICAgICAgICBpZiAoIXRoaXMuZGlyICYmIHRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpID09PSBcIi9cIikge1xuICAgICAgICAgICAgdGhpcy5kaXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBaSVA2NCBleHRyYSBmaWVsZCBhbmQgbWVyZ2UgdGhlIGluZm8gaW4gdGhlIGN1cnJlbnQgWmlwRW50cnkuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcGFyc2VaSVA2NEV4dHJhRmllbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZywgcHJlcGFyaW5nIHRoZSBleHRyYSByZWFkZXJcbiAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXS52YWx1ZSk7XG5cbiAgICAgICAgLy8gSSByZWFsbHkgaG9wZSB0aGF0IHRoZXNlIDY0Yml0cyBpbnRlZ2VyIGNhbiBmaXQgaW4gMzIgYml0cyBpbnRlZ2VyLCBiZWNhdXNlIGpzXG4gICAgICAgIC8vIHdvbid0IGxldCB1cyBoYXZlIG1vcmUuXG4gICAgICAgIGlmICh0aGlzLnVuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gZXh0cmFSZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkRXh0cmFGaWVsZHM6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmluZGV4ICsgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVhZGVyLmluZGV4ICsgNCA8IGVuZCkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSByZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHNbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZGVyLnNldEluZGV4KGVuZCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhbiBVVEY4IHRyYW5zZm9ybWF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwYXRoID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7XG4gICAgICAgICAgICBpZiAodXBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lQnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZmlsZU5hbWVCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWNvbW1lbnQgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh1Y29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1Y29tbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1cGF0aEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgZmlsZW5hbWUgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZU5hbWUpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1Y29tbWVudEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgY29tbWVudCBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlQ29tbWVudCkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZShcIi4vc3RyZWFtL1N0cmVhbUhlbHBlclwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0RhdGFXb3JrZXJcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuL3V0ZjhcIik7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoXCIuL2NvbXByZXNzZWRPYmplY3RcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgYXNrVW5pY29kZVN0cmluZyA9IG91dHB1dFR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBpZiAob3V0cHV0VHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuXG4gICAgICAgICAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gIXRoaXMuX2RhdGFCaW5hcnk7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhEZWNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcihyZXN1bHQsIG91dHB1dFR5cGUsIFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGluIHRoZSBhc2tlZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSkuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgYXMgYSBub2RlanMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gU3RyZWFtIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgbm9kZVN0cmVhbTogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uIChjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0ICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbXByZXNzaW9uLm1hZ2ljID09PSBjb21wcmVzc2lvbi5tYWdpY1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICBpZighdGhpcy5fZGF0YUJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tKHJlc3VsdCwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGRlY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZGVjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlbW92ZWRNZXRob2RzID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdO1xudmFyIHJlbW92ZWRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbn07XG5cbmZvcih2YXIgaSA9IDA7IGkgPCByZW1vdmVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIFppcE9iamVjdC5wcm90b3R5cGVbcmVtb3ZlZE1ldGhvZHNbaV1dID0gcmVtb3ZlZEZuO1xufVxubW9kdWxlLmV4cG9ydHMgPSBaaXBPYmplY3Q7XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgeyBoYXNVbnBpcGVkOiBmYWxzZSB9KTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cblxuICAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuaWYgKHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3RyZWFtLlJlYWRhYmxlO1xuICBleHBvcnRzLlJlYWRhYmxlID0gU3RyZWFtLlJlYWRhYmxlO1xuICBleHBvcnRzLldyaXRhYmxlID0gU3RyZWFtLldyaXRhYmxlO1xuICBleHBvcnRzLkR1cGxleCA9IFN0cmVhbS5EdXBsZXg7XG4gIGV4cG9ydHMuVHJhbnNmb3JtID0gU3RyZWFtLlRyYW5zZm9ybTtcbiAgZXhwb3J0cy5QYXNzVGhyb3VnaCA9IFN0cmVhbS5QYXNzVGhyb3VnaDtcbiAgZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG59IGVsc2Uge1xuICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG4gIGV4cG9ydHMuU3RyZWFtID0gU3RyZWFtIHx8IGV4cG9ydHM7XG4gIGV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuICBleHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuICBleHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4gIGV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbiAgZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIndXNlIHN0cmljdCc7XG52YXIgaW1tZWRpYXRlID0gcmVxdWlyZSgnaW1tZWRpYXRlJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBJTlRFUk5BTCgpIHt9XG5cbnZhciBoYW5kbGVycyA9IHt9O1xuXG52YXIgUkVKRUNURUQgPSBbJ1JFSkVDVEVEJ107XG52YXIgRlVMRklMTEVEID0gWydGVUxGSUxMRUQnXTtcbnZhciBQRU5ESU5HID0gWydQRU5ESU5HJ107XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgLy8gaW4gd2hpY2ggd2UgYWN0dWFsbHkgdGFrZSBhZHZhbnRhZ2Ugb2YgSlMgc2NvcGluZ1xuICB2YXIgVU5IQU5ETEVEID0gWydVTkhBTkRMRUQnXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghcHJvY2Vzcy5icm93c2VyKSB7XG4gICAgdGhpcy5oYW5kbGVkID0gVU5IQU5ETEVEO1xuICB9XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHRoaXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICBmdW5jdGlvbiB5ZXMgKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcC5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oeWVzKTtcbiAgfVxuICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgZnVuY3Rpb24gbm8gKCkge1xuICAgICAgdGhyb3cgcmVhc29uO1xuICAgIH1cbiAgICByZXR1cm4gcC5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4obm8pO1xuICB9XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgfHxcbiAgICB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSU5URVJOQUwpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIXByb2Nlc3MuYnJvd3Nlcikge1xuICAgIGlmICh0aGlzLmhhbmRsZWQgPT09IFVOSEFORExFRCkge1xuICAgICAgdGhpcy5oYW5kbGVkID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICB2YXIgcmVzb2x2ZXIgPSB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG4gICAgdW53cmFwKHByb21pc2UsIHJlc29sdmVyLCB0aGlzLm91dGNvbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucXVldWUucHVzaChuZXcgUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5mdW5jdGlvbiBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZDtcbiAgICB0aGlzLmNhbGxGdWxmaWxsZWQgPSB0aGlzLm90aGVyQ2FsbEZ1bGZpbGxlZDtcbiAgfVxuICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkO1xuICAgIHRoaXMuY2FsbFJlamVjdGVkID0gdGhpcy5vdGhlckNhbGxSZWplY3RlZDtcbiAgfVxufVxuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlc29sdmUodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vbkZ1bGZpbGxlZCwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlamVjdCh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25SZWplY3RlZCwgdmFsdWUpO1xufTtcblxuZnVuY3Rpb24gdW53cmFwKHByb21pc2UsIGZ1bmMsIHZhbHVlKSB7XG4gIGltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZSk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gcHJvbWlzZSkge1xuICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmhhbmRsZXJzLnJlc29sdmUgPSBmdW5jdGlvbiAoc2VsZiwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKGdldFRoZW4sIHZhbHVlKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHNlbGYsIHJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgdmFyIHRoZW5hYmxlID0gcmVzdWx0LnZhbHVlO1xuXG4gIGlmICh0aGVuYWJsZSkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICBzZWxmLm91dGNvbWUgPSB2YWx1ZTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBzZWxmLnF1ZXVlW2ldLmNhbGxGdWxmaWxsZWQodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5oYW5kbGVycy5yZWplY3QgPSBmdW5jdGlvbiAoc2VsZiwgZXJyb3IpIHtcbiAgc2VsZi5zdGF0ZSA9IFJFSkVDVEVEO1xuICBzZWxmLm91dGNvbWUgPSBlcnJvcjtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICBpZiAoc2VsZi5oYW5kbGVkID09PSBVTkhBTkRMRUQpIHtcbiAgICAgIGltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLmhhbmRsZWQgPT09IFVOSEFORExFRCkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgZXJyb3IsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgc2VsZi5xdWV1ZVtpXS5jYWxsUmVqZWN0ZWQoZXJyb3IpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgYWNjZXNzIHRoZSBhY2Nlc3NvciBvbmNlIGFzIHJlcXVpcmVkIGJ5IHRoZSBzcGVjXG4gIHZhciB0aGVuID0gb2JqICYmIG9iai50aGVuO1xuICBpZiAob2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiBhcHB5VGhlbigpIHtcbiAgICAgIHRoZW4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKSB7XG4gIC8vIEVpdGhlciBmdWxmaWxsLCByZWplY3Qgb3IgcmVqZWN0IHdpdGggZXJyb3JcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbkVycm9yKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlamVjdChzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblN1Y2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlUb1Vud3JhcCgpIHtcbiAgICB0aGVuYWJsZShvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRyeVRvVW53cmFwKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICBvbkVycm9yKHJlc3VsdC52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goZnVuYywgdmFsdWUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB0cnkge1xuICAgIG91dC52YWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIG91dC5zdGF0dXMgPSAnc3VjY2Vzcyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvdXQuc3RhdHVzID0gJ2Vycm9yJztcbiAgICBvdXQudmFsdWUgPSBlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cblByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5mdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRoaXMpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXJzLnJlc29sdmUobmV3IHRoaXMoSU5URVJOQUwpLCB2YWx1ZSk7XG59XG5cblByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcbiAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCByZWFzb24pO1xufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gIHZhciByZXNvbHZlZCA9IDA7XG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhbGxSZXNvbHZlcihpdGVyYWJsZVtpXSwgaSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIGFsbFJlc29sdmVyKHZhbHVlLCBpKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmVGcm9tQWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZyb21BbGwob3V0VmFsdWUpIHtcbiAgICAgIHZhbHVlc1tpXSA9IG91dFZhbHVlO1xuICAgICAgaWYgKCsrcmVzb2x2ZWQgPT09IGxlbiAmJiAhY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUHJvbWlzZS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHJlc29sdmVyKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gcmVzb2x2ZXIodmFsdWUpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbWluaW1hdGNoXG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoXG5cbnZhciBwYXRoID0gKGZ1bmN0aW9uICgpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ3BhdGgnKSB9IGNhdGNoIChlKSB7fX0oKSkgfHwge1xuICBzZXA6ICcvJ1xufVxubWluaW1hdGNoLnNlcCA9IHBhdGguc2VwXG5cbnZhciBHTE9CU1RBUiA9IG1pbmltYXRjaC5HTE9CU1RBUiA9IE1pbmltYXRjaC5HTE9CU1RBUiA9IHt9XG52YXIgZXhwYW5kID0gcmVxdWlyZSgnYnJhY2UtZXhwYW5zaW9uJylcblxudmFyIHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbnZhciBxbWFyayA9ICdbXi9dJ1xuXG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xudmFyIHN0YXIgPSBxbWFyayArICcqPydcblxuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XilcXFxcLikuKSo/J1xuXG4vLyBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGluIFJlZ0V4cC5cbnZhciByZVNwZWNpYWxzID0gY2hhclNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKVxuXG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5mdW5jdGlvbiBjaGFyU2V0IChzKSB7XG4gIHJldHVybiBzLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHNldCwgYykge1xuICAgIHNldFtjXSA9IHRydWVcbiAgICByZXR1cm4gc2V0XG4gIH0sIHt9KVxufVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG52YXIgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyXG5mdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIChwLCBpLCBsaXN0KSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dCAoYSwgYikge1xuICBiID0gYiB8fCB7fVxuICB2YXIgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYVtrXVxuICB9KVxuICBPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGJba11cbiAgfSlcbiAgcmV0dXJuIHRcbn1cblxubWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoXG4gIH1cblxuICB2YXIgb3JpZyA9IG1pbmltYXRjaFxuXG4gIHZhciBtID0gZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLk1pbmltYXRjaCA9IGZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgb3JpZy5NaW5pbWF0Y2gocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cbiAgbS5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2hcbiAgfVxuXG4gIG0uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZmlsdGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLm1ha2VSZSA9IGZ1bmN0aW9uIG1ha2VSZSAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1ha2VSZShwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmJyYWNlRXhwYW5kKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcubWF0Y2gobGlzdCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICByZXR1cm4gbVxufVxuXG5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbn1cblxuZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocClcbn1cblxuZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpKSB7XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpXG5cbiAgLy8gd2luZG93cyBzdXBwb3J0OiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKCFvcHRpb25zLmFsbG93V2luZG93c0VzY2FwZSAmJiBwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLnNldCA9IFtdXG4gIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgdGhpcy5yZWdleHAgPSBudWxsXG4gIHRoaXMubmVnYXRlID0gZmFsc2VcbiAgdGhpcy5jb21tZW50ID0gZmFsc2VcbiAgdGhpcy5lbXB0eSA9IGZhbHNlXG4gIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsXG5cbiAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICB0aGlzLm1ha2UoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge31cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlID0gbWFrZVxuZnVuY3Rpb24gbWFrZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHRoaXMuY29tbWVudCA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXBhdHRlcm4pIHtcbiAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gIHRoaXMucGFyc2VOZWdhdGUoKVxuXG4gIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICB2YXIgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgaWYgKG9wdGlvbnMuZGVidWcpIHRoaXMuZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHsgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpIH1cblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZiBwYXRoLXBvcnRpb25cbiAgLy8gbWF0Y2hpbmcgcGF0dGVybnMuXG4gIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnNwbGl0KHNsYXNoU3BsaXQpXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBnbG9iIC0tPiByZWdleHBzXG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKHMsIHNpLCBzZXQpIHtcbiAgICByZXR1cm4gcy5tYXAodGhpcy5wYXJzZSwgdGhpcylcbiAgfSwgdGhpcylcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuaW5kZXhPZihmYWxzZSkgPT09IC0xXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICB0aGlzLnNldCA9IHNldFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlTmVnYXRlID0gcGFyc2VOZWdhdGVcbmZ1bmN0aW9uIHBhcnNlTmVnYXRlICgpIHtcbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIHZhciBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgaWYgKG9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0dGVybi5sZW5ndGhcbiAgICA7IGkgPCBsICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISdcbiAgICA7IGkrKykge1xuICAgIG5lZ2F0ZSA9ICFuZWdhdGVcbiAgICBuZWdhdGVPZmZzZXQrK1xuICB9XG5cbiAgaWYgKG5lZ2F0ZU9mZnNldCkgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIobmVnYXRlT2Zmc2V0KVxuICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxufVxuXG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmRcblxuZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICB9XG5cbiAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJ1xuICAgID8gdGhpcy5wYXR0ZXJuIDogcGF0dGVyblxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIC8vIFRoYW5rcyB0byBZZXRpbmcgTGkgPGh0dHBzOi8vZ2l0aHViLmNvbS95ZXRpbmdsaT4gZm9yXG4gIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHwgIS9cXHsoPzooPyFcXHspLikqXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgIHJldHVybiBbcGF0dGVybl1cbiAgfVxuXG4gIHJldHVybiBleHBhbmQocGF0dGVybilcbn1cblxudmFyIE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NFxudmFyIGFzc2VydFZhbGlkUGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlID0gcGFyc2VcbnZhciBTVUJQQVJTRSA9IHt9XG5mdW5jdGlvbiBwYXJzZSAocGF0dGVybiwgaXNTdWIpIHtcbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBzaG9ydGN1dHNcbiAgaWYgKHBhdHRlcm4gPT09ICcqKicpIHtcbiAgICBpZiAoIW9wdGlvbnMubm9nbG9ic3RhcilcbiAgICAgIHJldHVybiBHTE9CU1RBUlxuICAgIGVsc2VcbiAgICAgIHBhdHRlcm4gPSAnKidcbiAgfVxuICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gIHZhciByZSA9ICcnXG4gIHZhciBoYXNNYWdpYyA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgdmFyIGVzY2FwaW5nID0gZmFsc2VcbiAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICB2YXIgcGF0dGVybkxpc3RTdGFjayA9IFtdXG4gIHZhciBuZWdhdGl2ZUxpc3RzID0gW11cbiAgdmFyIHN0YXRlQ2hhclxuICB2YXIgaW5DbGFzcyA9IGZhbHNlXG4gIHZhciByZUNsYXNzU3RhcnQgPSAtMVxuICB2YXIgY2xhc3NTdGFydCA9IC0xXG4gIC8vIC4gYW5kIC4uIG5ldmVyIG1hdGNoIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzdGFydCB3aXRoIC4sXG4gIC8vIGV2ZW4gd2hlbiBvcHRpb25zLmRvdCBpcyBzZXQuXG4gIHZhciBwYXR0ZXJuU3RhcnQgPSBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy4nID8gJycgLy8gYW55dGhpbmdcbiAgLy8gbm90IChzdGFydCBvciAvIGZvbGxvd2VkIGJ5IC4gb3IgLi4gZm9sbG93ZWQgYnkgLyBvciBlbmQpXG4gIDogb3B0aW9ucy5kb3QgPyAnKD8hKD86XnxcXFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFxcXC8pKSdcbiAgOiAnKD8hXFxcXC4pJ1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBjbGVhclN0YXRlQ2hhciAoKSB7XG4gICAgaWYgKHN0YXRlQ2hhcikge1xuICAgICAgLy8gd2UgaGFkIHNvbWUgc3RhdGUtdHJhY2tpbmcgY2hhcmFjdGVyXG4gICAgICAvLyB0aGF0IHdhc24ndCBjb25zdW1lZCBieSB0aGlzIHBhc3MuXG4gICAgICBzd2l0Y2ggKHN0YXRlQ2hhcikge1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICByZSArPSBzdGFyXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJlICs9IHFtYXJrXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgc3RhdGVDaGFyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzZWxmLmRlYnVnKCdjbGVhclN0YXRlQ2hhciAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aCwgY1xuICAgIDsgKGkgPCBsZW4pICYmIChjID0gcGF0dGVybi5jaGFyQXQoaSkpXG4gICAgOyBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAvLyBza2lwIG92ZXIgYW55IHRoYXQgYXJlIGVzY2FwZWQuXG4gICAgaWYgKGVzY2FwaW5nICYmIHJlU3BlY2lhbHNbY10pIHtcbiAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgc3dpdGNoIChjKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgY2FzZSAnLyc6IHtcbiAgICAgICAgLy8gY29tcGxldGVseSBub3QgYWxsb3dlZCwgZXZlbiBlc2NhcGVkLlxuICAgICAgICAvLyBTaG91bGQgYWxyZWFkeSBiZSBwYXRoLXNwbGl0IGJ5IG5vdy5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgLy8gZm9yIHRoZSBcImV4dGdsb2JcIiBzdHVmZi5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWogPC0tIHN0YXRlQ2hhcicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAgIC8vIGFsbCBvZiB0aG9zZSBhcmUgbGl0ZXJhbHMgaW5zaWRlIGEgY2xhc3MsIGV4Y2VwdCB0aGF0XG4gICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCcgIGluIGNsYXNzJylcbiAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0ZUNoYXIsIHRoZW4gaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgc29tZXRoaW5nIGxpa2UgKiogb3IgKz8gaW4gdGhlcmUuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgc2VsZi5kZWJ1ZygnY2FsbCBjbGVhclN0YXRlQ2hhciAlaicsIHN0YXRlQ2hhcilcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgIC8vIGlmIGV4dGdsb2IgaXMgZGlzYWJsZWQsIHRoZW4gKyhhc2RmfGZvbykgaXNuJ3QgYSB0aGluZy5cbiAgICAgICAgLy8ganVzdCBjbGVhciB0aGUgc3RhdGVjaGFyICpub3cqLCByYXRoZXIgdGhhbiBldmVuIGRpdmluZyBpbnRvXG4gICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9leHQpIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgIHJlICs9ICdcXFxcKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBzdGF0ZUNoYXIsXG4gICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICBvcGVuOiBwbFR5cGVzW3N0YXRlQ2hhcl0ub3BlbixcbiAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlXG4gICAgICAgIH0pXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICByZSArPSBzdGF0ZUNoYXIgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/OidcbiAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCknXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIHZhciBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKClcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgcmUgKz0gcGwuY2xvc2VcbiAgICAgICAgaWYgKHBsLnR5cGUgPT09ICchJykge1xuICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChwbClcbiAgICAgICAgfVxuICAgICAgICBwbC5yZUVuZCA9IHJlLmxlbmd0aFxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCB8fCBlc2NhcGluZykge1xuICAgICAgICAgIHJlICs9ICdcXFxcfCdcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgcmUgKz0gJ3wnXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGVzZSBhcmUgbW9zdGx5IHRoZSBzYW1lIGluIHJlZ2V4cCBhbmQgZ2xvYlxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgY2xhc3NTdGFydCA9IGlcbiAgICAgICAgcmVDbGFzc1N0YXJ0ID0gcmUubGVuZ3RoXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgLy8gIG1lYW5pbmcgYW5kIHJlcHJlc2VudCBpdHNlbGYgaW5cbiAgICAgICAgLy8gIGEgYnJhY2tldCBleHByZXNzaW9uIGlmIGl0IG9jY3Vyc1xuICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgaWYgKGkgPT09IGNsYXNzU3RhcnQgKyAxIHx8ICFpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAgICAgICAvLyBcIlt6LWFdXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFt6LWFcXF1cIlxuICAgICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAvLyB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGUgYW55IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAvLyB3aXRob3V0IGEgdHJ5L2NhdGNoIGFuZCBhIG5ldyBSZWdFeHAsIGJ1dCBpdCdzIHRyaWNreVxuICAgICAgICAvLyB0byBkbyBzYWZlbHkuICBGb3Igbm93LCB0aGlzIGlzIHNhZmUgYW5kIHdvcmtzLlxuICAgICAgICB2YXIgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWdFeHAoJ1snICsgY3MgKyAnXScpXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgY2xhc3MhXG4gICAgICAgICAgdmFyIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICAgICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXSArICdcXFxcXSdcbiAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmlzaCB1cCB0aGUgY2xhc3MuXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUgY2hhciB0aGF0IHdhc24ndCBjb25zdW1lZFxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZFxuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChyZVNwZWNpYWxzW2NdXG4gICAgICAgICAgJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuXG4gICAgICAgIHJlICs9IGNcblxuICAgIH0gLy8gc3dpdGNoXG4gIH0gLy8gZm9yXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAvLyBcIlthYmNcIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW2FiY1wiXG4gIGlmIChpbkNsYXNzKSB7XG4gICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIGFuZCBlc2NhcGUgaXRcbiAgICAvLyB0aGlzIGlzIGEgaHVnZSBwaXRhLiAgV2Ugbm93IGhhdmUgdG8gcmUtd2Fsa1xuICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgLy8gYW55IGNoYXJhY3RlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgY3MgPSBwYXR0ZXJuLnN1YnN0cihjbGFzc1N0YXJ0ICsgMSlcbiAgICBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF1cbiAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGFkIGEgKyggdGhpbmcgYXQgdGhlICplbmQqXG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgLy8gYW5kIGVzY2FwZSBhbnkgfCBjaGFycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXMgZm9yIHRoZSByZWdleHAuXG4gIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICBmb3IgKHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKTsgcGw7IHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKSkge1xuICAgIHZhciB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgIHRoaXMuZGVidWcoJ3NldHRpbmcgdGFpbCcsIHJlLCBwbClcbiAgICAvLyBtYXliZSBzb21lIGV2ZW4gbnVtYmVyIG9mIFxcLCB0aGVuIG1heWJlIDEgXFwsIGZvbGxvd2VkIGJ5IGEgfFxuICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgIGlmICghJDIpIHtcbiAgICAgICAgLy8gdGhlIHwgaXNuJ3QgYWxyZWFkeSBlc2NhcGVkLCBzbyBlc2NhcGUgaXQuXG4gICAgICAgICQyID0gJ1xcXFwnXG4gICAgICB9XG5cbiAgICAgIC8vIG5lZWQgdG8gZXNjYXBlIGFsbCB0aG9zZSBzbGFzaGVzICphZ2FpbiosIHdpdGhvdXQgZXNjYXBpbmcgdGhlXG4gICAgICAvLyBvbmUgdGhhdCB3ZSBuZWVkIGZvciBlc2NhcGluZyB0aGUgfCBjaGFyYWN0ZXIuICBBcyBpdCB3b3JrcyBvdXQsXG4gICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgIC8vIGl0IGV4YWN0bHkgYWZ0ZXIgaXRzZWxmLiAgVGhhdCdzIHdoeSB0aGlzIHRyaWNrIHdvcmtzLlxuICAgICAgLy9cbiAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgIHJldHVybiAkMSArICQxICsgJDIgKyAnfCdcbiAgICB9KVxuXG4gICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgIHZhciB0ID0gcGwudHlwZSA9PT0gJyonID8gc3RhclxuICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgOiAnXFxcXCcgKyBwbC50eXBlXG5cbiAgICBoYXNNYWdpYyA9IHRydWVcbiAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gIH1cblxuICAvLyBoYW5kbGUgdHJhaWxpbmcgdGhpbmdzIHRoYXQgb25seSBtYXR0ZXIgYXQgdGhlIHZlcnkgZW5kLlxuICBjbGVhclN0YXRlQ2hhcigpXG4gIGlmIChlc2NhcGluZykge1xuICAgIC8vIHRyYWlsaW5nIFxcXFxcbiAgICByZSArPSAnXFxcXFxcXFwnXG4gIH1cblxuICAvLyBvbmx5IG5lZWQgdG8gYXBwbHkgdGhlIG5vZG90IHN0YXJ0IGlmIHRoZSByZSBzdGFydHMgd2l0aFxuICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gIHZhciBhZGRQYXR0ZXJuU3RhcnQgPSBmYWxzZVxuICBzd2l0Y2ggKHJlLmNoYXJBdCgwKSkge1xuICAgIGNhc2UgJ1snOiBjYXNlICcuJzogY2FzZSAnKCc6IGFkZFBhdHRlcm5TdGFydCA9IHRydWVcbiAgfVxuXG4gIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gIC8vIEEgcGF0dGVybiBsaWtlOiAqLiEoeCkuISh5fHopIG5lZWRzIHRvIGVuc3VyZSB0aGF0IGEgbmFtZVxuICAvLyBsaWtlICdhLnh5ei55eicgZG9lc24ndCBtYXRjaC4gIFNvLCB0aGUgZmlyc3QgbmVnYXRpdmVcbiAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAvLyB0aGUgcGF0dGVybi5cbiAgZm9yICh2YXIgbiA9IG5lZ2F0aXZlTGlzdHMubGVuZ3RoIC0gMTsgbiA+IC0xOyBuLS0pIHtcbiAgICB2YXIgbmwgPSBuZWdhdGl2ZUxpc3RzW25dXG5cbiAgICB2YXIgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgIHZhciBubEZpcnN0ID0gcmUuc2xpY2UobmwucmVTdGFydCwgbmwucmVFbmQgLSA4KVxuICAgIHZhciBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKVxuICAgIHZhciBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG5cbiAgICBubExhc3QgKz0gbmxBZnRlclxuXG4gICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgIC8vIG1lYW4gdGhhdCB3ZSBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGUgKSBpbiB0aGUgYml0IHRoYXQgaXMgY29uc2lkZXJlZFxuICAgIC8vIFwiYWZ0ZXJcIiB0aGUgbmVnYXRlZCBzZWN0aW9uLlxuICAgIHZhciBvcGVuUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJygnKS5sZW5ndGggLSAxXG4gICAgdmFyIGNsZWFuQWZ0ZXIgPSBubEFmdGVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wZW5QYXJlbnNCZWZvcmU7IGkrKykge1xuICAgICAgY2xlYW5BZnRlciA9IGNsZWFuQWZ0ZXIucmVwbGFjZSgvXFwpWysqP10/LywgJycpXG4gICAgfVxuICAgIG5sQWZ0ZXIgPSBjbGVhbkFmdGVyXG5cbiAgICB2YXIgZG9sbGFyID0gJydcbiAgICBpZiAobmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFKSB7XG4gICAgICBkb2xsYXIgPSAnJCdcbiAgICB9XG4gICAgdmFyIG5ld1JlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIHJlID0gbmV3UmVcbiAgfVxuXG4gIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gIC8vIE90aGVyd2lzZSBhLyogd2lsbCBtYXRjaCBhLywgd2hpY2ggaXQgc2hvdWxkIG5vdC5cbiAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgIHJlID0gJyg/PS4pJyArIHJlXG4gIH1cblxuICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgcmUgPSBwYXR0ZXJuU3RhcnQgKyByZVxuICB9XG5cbiAgLy8gcGFyc2luZyBqdXN0IGEgcGllY2Ugb2YgYSBsYXJnZXIgcGF0dGVybi5cbiAgaWYgKGlzU3ViID09PSBTVUJQQVJTRSkge1xuICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICB9XG5cbiAgLy8gc2tpcCB0aGUgcmVnZXhwIGZvciBub24tbWFnaWNhbCBwYXR0ZXJuc1xuICAvLyB1bmVzY2FwZSBhbnl0aGluZyBpbiBpdCwgdGhvdWdoLCBzbyB0aGF0IGl0J2xsIGJlXG4gIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgaWYgKCFoYXNNYWdpYykge1xuICAgIHJldHVybiBnbG9iVW5lc2NhcGUocGF0dGVybilcbiAgfVxuXG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcbiAgdHJ5IHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnXicgKyByZSArICckJywgZmxhZ3MpXG4gIH0gY2F0Y2ggKGVyKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwXG59XG5cbm1pbmltYXRjaC5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIG1tLm1hdGNoKGYpXG4gIH0pXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKGYsIHBhcnRpYWwpIHtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykgcGFydGlhbCA9IHRoaXMucGFydGlhbFxuICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAvLyBjb21tZW50cywgZXRjLlxuICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkgcmV0dXJuIHRydWVcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZilcblxuICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICB2YXIgZmlsZW5hbWVcbiAgdmFyIGlcbiAgZm9yIChpID0gZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZpbGVuYW1lID0gZltpXVxuICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0dGVybiA9IHNldFtpXVxuICAgIHZhciBmaWxlID0gZlxuICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICB9XG4gICAgdmFyIGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRoaXMubmVnYXRlXG59XG5cbi8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4vLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbi8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbi8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuLy8gdGhlIHBhcnRzIG1hdGNoLlxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaE9uZSA9IGZ1bmN0aW9uIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpXG5cbiAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgcGkgPSAwLFxuICAgICAgZmwgPSBmaWxlLmxlbmd0aCxcbiAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgOyBmaSsrLCBwaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgIHZhciBmID0gZmlsZVtmaV1cblxuICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgLy8gXCIqKlwiXG4gICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgLy8gYS9iL2NcbiAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgIC8vXG4gICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgdmFyIGZyID0gZmlcbiAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJylcbiAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdXG5cbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICBmcisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICBpZiAoZnIgPT09IGZsKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgIHZhciBoaXRcbiAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoaXQgPSBmID09PSBwXG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgcmV0dXJuIChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICB9XG5cbiAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuZnVuY3Rpb24gZ2xvYlVuZXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbn1cblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylcbn1cbiIsInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkob25jZSlcbm1vZHVsZS5leHBvcnRzLnN0cmljdCA9IHdyYXBweShvbmNlU3RyaWN0KVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2VTdHJpY3QnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlU3RyaWN0KHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZCkgcmV0dXJuIGYudmFsdWVcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG5cbmZ1bmN0aW9uIG9uY2VTdHJpY3QgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihmLm9uY2VFcnJvcilcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICB2YXIgbmFtZSA9IGZuLm5hbWUgfHwgJ0Z1bmN0aW9uIHdyYXBwZWQgd2l0aCBgb25jZWAnXG4gIGYub25jZUVycm9yID0gbmFtZSArIFwiIHNob3VsZG4ndCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcIlxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG4iLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3Rpb25hcnkpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gYmluYXJ5IHN0cmluZ1xuZXhwb3J0cy5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgcG9zO1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBwb3NpeChwYXRoKSB7XG5cdHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG5mdW5jdGlvbiB3aW4zMihwYXRoKSB7XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG5cdHZhciBzcGxpdERldmljZVJlID0gL14oW2EtekEtWl06fFtcXFxcXFwvXXsyfVteXFxcXFxcL10rW1xcXFxcXC9dK1teXFxcXFxcL10rKT8oW1xcXFxcXC9dKT8oW1xcc1xcU10qPykkLztcblx0dmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcblx0dmFyIGRldmljZSA9IHJlc3VsdFsxXSB8fCAnJztcblx0dmFyIGlzVW5jID0gQm9vbGVhbihkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gJzonKTtcblxuXHQvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuXHRyZXR1cm4gQm9vbGVhbihyZXN1bHRbMl0gfHwgaXNVbmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMiA6IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMucG9zaXggPSBwb3NpeDtcbm1vZHVsZS5leHBvcnRzLndpbjMyID0gd2luMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKVxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIilcbmxldCBnbG9iID0gdW5kZWZpbmVkXG50cnkge1xuICBnbG9iID0gcmVxdWlyZShcImdsb2JcIilcbn0gY2F0Y2ggKF9lcnIpIHtcbiAgLy8gdHJlYXQgZ2xvYiBhcyBvcHRpb25hbC5cbn1cblxuY29uc3QgZGVmYXVsdEdsb2JPcHRzID0ge1xuICBub3NvcnQ6IHRydWUsXG4gIHNpbGVudDogdHJ1ZVxufVxuXG4vLyBmb3IgRU1GSUxFIGhhbmRsaW5nXG5sZXQgdGltZW91dCA9IDBcblxuY29uc3QgaXNXaW5kb3dzID0gKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIilcblxuY29uc3QgZGVmYXVsdHMgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAndW5saW5rJyxcbiAgICAnY2htb2QnLFxuICAgICdzdGF0JyxcbiAgICAnbHN0YXQnLFxuICAgICdybWRpcicsXG4gICAgJ3JlYWRkaXInXG4gIF1cbiAgbWV0aG9kcy5mb3JFYWNoKG0gPT4ge1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gICAgbSA9IG0gKyAnU3luYydcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICB9KVxuXG4gIG9wdGlvbnMubWF4QnVzeVRyaWVzID0gb3B0aW9ucy5tYXhCdXN5VHJpZXMgfHwgM1xuICBvcHRpb25zLmVtZmlsZVdhaXQgPSBvcHRpb25zLmVtZmlsZVdhaXQgfHwgMTAwMFxuICBpZiAob3B0aW9ucy5nbG9iID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMuZGlzYWJsZUdsb2IgPSB0cnVlXG4gIH1cbiAgaWYgKG9wdGlvbnMuZGlzYWJsZUdsb2IgIT09IHRydWUgJiYgZ2xvYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2dsb2IgZGVwZW5kZW5jeSBub3QgZm91bmQsIHNldCBgb3B0aW9ucy5kaXNhYmxlR2xvYiA9IHRydWVgIGlmIGludGVudGlvbmFsJylcbiAgfVxuICBvcHRpb25zLmRpc2FibGVHbG9iID0gb3B0aW9ucy5kaXNhYmxlR2xvYiB8fCBmYWxzZVxuICBvcHRpb25zLmdsb2IgPSBvcHRpb25zLmdsb2IgfHwgZGVmYXVsdEdsb2JPcHRzXG59XG5cbmNvbnN0IHJpbXJhZiA9IChwLCBvcHRpb25zLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdyaW1yYWY6IGNhbGxiYWNrIGZ1bmN0aW9uIHJlcXVpcmVkJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IGludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBwcm92aWRlZCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICBsZXQgYnVzeVRyaWVzID0gMFxuICBsZXQgZXJyU3RhdGUgPSBudWxsXG4gIGxldCBuID0gMFxuXG4gIGNvbnN0IG5leHQgPSAoZXIpID0+IHtcbiAgICBlcnJTdGF0ZSA9IGVyclN0YXRlIHx8IGVyXG4gICAgaWYgKC0tbiA9PT0gMClcbiAgICAgIGNiKGVyclN0YXRlKVxuICB9XG5cbiAgY29uc3QgYWZ0ZXJHbG9iID0gKGVyLCByZXN1bHRzKSA9PiB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIGNiKGVyKVxuXG4gICAgbiA9IHJlc3VsdHMubGVuZ3RoXG4gICAgaWYgKG4gPT09IDApXG4gICAgICByZXR1cm4gY2IoKVxuXG4gICAgcmVzdWx0cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgY29uc3QgQ0IgPSAoZXIpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgaWYgKChlci5jb2RlID09PSBcIkVCVVNZXCIgfHwgZXIuY29kZSA9PT0gXCJFTk9URU1QVFlcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpICYmXG4gICAgICAgICAgICAgIGJ1c3lUcmllcyA8IG9wdGlvbnMubWF4QnVzeVRyaWVzKSB7XG4gICAgICAgICAgICBidXN5VHJpZXMgKytcbiAgICAgICAgICAgIC8vIHRyeSBhZ2Fpbiwgd2l0aCB0aGUgc2FtZSBleGFjdCBjYWxsYmFjayBhcyB0aGlzIG9uZS5cbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHJpbXJhZl8ocCwgb3B0aW9ucywgQ0IpLCBidXN5VHJpZXMgKiAxMDApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGhpcyBvbmUgd29uJ3QgaGFwcGVuIGlmIGdyYWNlZnVsLWZzIGlzIHVzZWQuXG4gICAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU1GSUxFXCIgJiYgdGltZW91dCA8IG9wdGlvbnMuZW1maWxlV2FpdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gcmltcmFmXyhwLCBvcHRpb25zLCBDQiksIHRpbWVvdXQgKyspXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWxyZWFkeSBnb25lXG4gICAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpIGVyID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgdGltZW91dCA9IDBcbiAgICAgICAgbmV4dChlcilcbiAgICAgIH1cbiAgICAgIHJpbXJhZl8ocCwgb3B0aW9ucywgQ0IpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmRpc2FibGVHbG9iIHx8ICFnbG9iLmhhc01hZ2ljKHApKVxuICAgIHJldHVybiBhZnRlckdsb2IobnVsbCwgW3BdKVxuXG4gIG9wdGlvbnMubHN0YXQocCwgKGVyLCBzdGF0KSA9PiB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiBhZnRlckdsb2IobnVsbCwgW3BdKVxuXG4gICAgZ2xvYihwLCBvcHRpb25zLmdsb2IsIGFmdGVyR2xvYilcbiAgfSlcblxufVxuXG4vLyBUd28gcG9zc2libGUgc3RyYXRlZ2llcy5cbi8vIDEuIEFzc3VtZSBpdCdzIGEgZmlsZS4gIHVubGluayBpdCwgdGhlbiBkbyB0aGUgZGlyIHN0dWZmIG9uIEVQRVJNIG9yIEVJU0RJUlxuLy8gMi4gQXNzdW1lIGl0J3MgYSBkaXJlY3RvcnkuICByZWFkZGlyLCB0aGVuIGRvIHRoZSBmaWxlIHN0dWZmIG9uIEVOT1RESVJcbi8vXG4vLyBCb3RoIHJlc3VsdCBpbiBhbiBleHRyYSBzeXNjYWxsIHdoZW4geW91IGd1ZXNzIHdyb25nLiAgSG93ZXZlciwgdGhlcmVcbi8vIGFyZSBsaWtlbHkgZmFyIG1vcmUgbm9ybWFsIGZpbGVzIGluIHRoZSB3b3JsZCB0aGFuIGRpcmVjdG9yaWVzLiAgVGhpc1xuLy8gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRoZSBhdmVyYWdlIG51bWJlciBvZiBmaWxlcyBwZXJcbi8vIGRpcmVjdG9yeSBpcyA+PSAxLlxuLy9cbi8vIElmIGFueW9uZSBldmVyIGNvbXBsYWlucyBhYm91dCB0aGlzLCB0aGVuIEkgZ3Vlc3MgdGhlIHN0cmF0ZWd5IGNvdWxkXG4vLyBiZSBtYWRlIGNvbmZpZ3VyYWJsZSBzb21laG93LiAgQnV0IHVudGlsIHRoZW4sIFlBR05JLlxuY29uc3QgcmltcmFmXyA9IChwLCBvcHRpb25zLCBjYikgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgLy8gc3Vub3MgbGV0cyB0aGUgcm9vdCB1c2VyIHVubGluayBkaXJlY3Rvcmllcywgd2hpY2ggaXMuLi4gd2VpcmQuXG4gIC8vIHNvIHdlIGhhdmUgdG8gbHN0YXQgaGVyZSBhbmQgbWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlyLlxuICBvcHRpb25zLmxzdGF0KHAsIChlciwgc3QpID0+IHtcbiAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgIHJldHVybiBjYihudWxsKVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlciAmJiBlci5jb2RlID09PSBcIkVQRVJNXCIgJiYgaXNXaW5kb3dzKVxuICAgICAgZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuXG4gICAgaWYgKHN0ICYmIHN0LmlzRGlyZWN0b3J5KCkpXG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuXG4gICAgb3B0aW9ucy51bmxpbmsocCwgZXIgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgIHJldHVybiBjYihudWxsKVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgIHJldHVybiAoaXNXaW5kb3dzKVxuICAgICAgICAgICAgPyBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgICAgICA6IHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRUlTRElSXCIpXG4gICAgICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYihlcilcbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCBmaXhXaW5FUEVSTSA9IChwLCBvcHRpb25zLCBlciwgY2IpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMuY2htb2QocCwgMG82NjYsIGVyMiA9PiB7XG4gICAgaWYgKGVyMilcbiAgICAgIGNiKGVyMi5jb2RlID09PSBcIkVOT0VOVFwiID8gbnVsbCA6IGVyKVxuICAgIGVsc2VcbiAgICAgIG9wdGlvbnMuc3RhdChwLCAoZXIzLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXIzKVxuICAgICAgICAgIGNiKGVyMy5jb2RlID09PSBcIkVOT0VOVFwiID8gbnVsbCA6IGVyKVxuICAgICAgICBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9wdGlvbnMudW5saW5rKHAsIGNiKVxuICAgICAgfSlcbiAgfSlcbn1cblxuY29uc3QgZml4V2luRVBFUk1TeW5jID0gKHAsIG9wdGlvbnMsIGVyKSA9PiB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIDBvNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICByZXR1cm5cbiAgICBlbHNlXG4gICAgICB0aHJvdyBlclxuICB9XG5cbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBvcHRpb25zLnN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyMykge1xuICAgIGlmIChlcjMuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgIHJldHVyblxuICAgIGVsc2VcbiAgICAgIHRocm93IGVyXG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSlcbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIGVsc2VcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbn1cblxuY29uc3Qgcm1kaXIgPSAocCwgb3B0aW9ucywgb3JpZ2luYWxFciwgY2IpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHRyeSB0byBybWRpciBmaXJzdCwgYW5kIG9ubHkgcmVhZGRpciBvbiBFTk9URU1QVFkgb3IgRUVYSVNUIChTdW5PUylcbiAgLy8gaWYgd2UgZ3Vlc3NlZCB3cm9uZywgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LCB0aGVuXG4gIC8vIHJhaXNlIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgb3B0aW9ucy5ybWRpcihwLCBlciA9PiB7XG4gICAgaWYgKGVyICYmIChlci5jb2RlID09PSBcIkVOT1RFTVBUWVwiIHx8IGVyLmNvZGUgPT09IFwiRUVYSVNUXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKSlcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICBlbHNlIGlmIChlciAmJiBlci5jb2RlID09PSBcIkVOT1RESVJcIilcbiAgICAgIGNiKG9yaWdpbmFsRXIpXG4gICAgZWxzZVxuICAgICAgY2IoZXIpXG4gIH0pXG59XG5cbmNvbnN0IHJta2lkcyA9IChwLCBvcHRpb25zLCBjYikgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgb3B0aW9ucy5yZWFkZGlyKHAsIChlciwgZmlsZXMpID0+IHtcbiAgICBpZiAoZXIpXG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBpZiAobiA9PT0gMClcbiAgICAgIHJldHVybiBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgIGxldCBlcnJTdGF0ZVxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgIHJldHVybiBjYihlcnJTdGF0ZSA9IGVyKVxuICAgICAgICBpZiAoLS1uID09PSAwKVxuICAgICAgICAgIG9wdGlvbnMucm1kaXIocCwgY2IpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5jb25zdCByaW1yYWZTeW5jID0gKHAsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogbWlzc2luZyBvcHRpb25zJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICBsZXQgcmVzdWx0c1xuXG4gIGlmIChvcHRpb25zLmRpc2FibGVHbG9iIHx8ICFnbG9iLmhhc01hZ2ljKHApKSB7XG4gICAgcmVzdWx0cyA9IFtwXVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLmxzdGF0U3luYyhwKVxuICAgICAgcmVzdWx0cyA9IFtwXVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXN1bHRzID0gZ2xvYi5zeW5jKHAsIG9wdGlvbnMuZ2xvYilcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdHMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAgPSByZXN1bHRzW2ldXG5cbiAgICBsZXQgc3RcbiAgICB0cnkge1xuICAgICAgc3QgPSBvcHRpb25zLmxzdGF0U3luYyhwKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIC8vIFdpbmRvd3MgY2FuIEVQRVJNIG9uIHN0YXQuICBMaWZlIGlzIHN1ZmZlcmluZy5cbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVQRVJNXCIgJiYgaXNXaW5kb3dzKVxuICAgICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAgICAgaWYgKHN0ICYmIHN0LmlzRGlyZWN0b3J5KCkpXG4gICAgICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBudWxsKVxuICAgICAgZWxzZVxuICAgICAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgIHJldHVyblxuICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgICBpZiAoZXIuY29kZSAhPT0gXCJFSVNESVJcIilcbiAgICAgICAgdGhyb3cgZXJcblxuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBybWRpclN5bmMgPSAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLnJtZGlyU3luYyhwKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgcmV0dXJuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PVERJUlwiKVxuICAgICAgdGhyb3cgb3JpZ2luYWxFclxuICAgIGlmIChlci5jb2RlID09PSBcIkVOT1RFTVBUWVwiIHx8IGVyLmNvZGUgPT09IFwiRUVYSVNUXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgcm1raWRzU3luYyhwLCBvcHRpb25zKVxuICB9XG59XG5cbmNvbnN0IHJta2lkc1N5bmMgPSAocCwgb3B0aW9ucykgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIG9wdGlvbnMucmVhZGRpclN5bmMocCkuZm9yRWFjaChmID0+IHJpbXJhZlN5bmMocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zKSlcblxuICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgLy8gYXQgdGhpcyBwb2ludCwgd2UgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZW1vdmVkIGFsbCB0aGUga2lkcy5cbiAgLy8gU28sIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSBFTk9FTlQgb3IgRU5PVERJUiBvciBhbnl0aGluZyBlbHNlLlxuICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgLy8gUFJPRk9VTkRMWSBhbm5veWluZyBoYWJpdCBvZiBub3QgY2xvc2luZyBoYW5kbGVzIHByb21wdGx5IHdoZW5cbiAgLy8gZmlsZXMgYXJlIGRlbGV0ZWQsIHJlc3VsdGluZyBpbiBzcHVyaW91cyBFTk9URU1QVFkgZXJyb3JzLlxuICBjb25zdCByZXRyaWVzID0gaXNXaW5kb3dzID8gMTAwIDogMVxuICBsZXQgaSA9IDBcbiAgZG8ge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgIHJldHVybiByZXRcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCsraSA8IHJldHJpZXMgJiYgdGhyZXcpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9IHdoaWxlICh0cnVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbXJhZlxucmltcmFmLnN5bmMgPSByaW1yYWZTeW5jXG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5jb25zdCB7IEJyb3dzaW5nQ29udGV4dEluZm8gfSA9IHJlcXVpcmUoJy4vYnJvd3NpbmdDb250ZXh0VHlwZXMnKVxuY2xhc3MgQnJvd3NpbmdDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoZHJpdmVyKSB7XG4gICAgdGhpcy5fZHJpdmVyID0gZHJpdmVyXG4gIH1cblxuICBhc3luYyBpbml0KHsgYnJvd3NpbmdDb250ZXh0SWQsIHR5cGUsIHJlZmVyZW5jZUNvbnRleHQgfSkge1xuICAgIGlmICghKGF3YWl0IHRoaXMuX2RyaXZlci5nZXRDYXBhYmlsaXRpZXMoKSkuZ2V0KCd3ZWJTb2NrZXRVcmwnKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1dlYkRyaXZlciBpbnN0YW5jZSBtdXN0IHN1cHBvcnQgQmlEaSBwcm90b2NvbCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT0gdW5kZWZpbmVkICYmICFbJ3dpbmRvdycsICd0YWInXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFZhbGlkIHR5cGVzIGFyZSAnd2luZG93JyAmICd0YWInLiBSZWNlaXZlZDogJHt0eXBlfWApXG4gICAgfVxuXG4gICAgdGhpcy5iaWRpID0gYXdhaXQgdGhpcy5fZHJpdmVyLmdldEJpZGkoKVxuICAgIHRoaXMuX2lkID1cbiAgICAgIGJyb3dzaW5nQ29udGV4dElkID09IHVuZGVmaW5lZFxuICAgICAgICA/IChhd2FpdCB0aGlzLmNyZWF0ZSh0eXBlLCByZWZlcmVuY2VDb250ZXh0KSlbJ3Jlc3VsdCddWydjb250ZXh0J11cbiAgICAgICAgOiBicm93c2luZ0NvbnRleHRJZFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBicm93c2luZyBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgcmVmZXJlbmNlQ29udGV4dFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHR5cGUsIHJlZmVyZW5jZUNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBtZXRob2Q6ICdicm93c2luZ0NvbnRleHQuY3JlYXRlJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICByZWZlcmVuY2VDb250ZXh0OiByZWZlcmVuY2VDb250ZXh0LFxuICAgICAgfSxcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYmlkaS5zZW5kKHBhcmFtcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBpZFxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB1cmwgdGhlIHVybCB0byBuYXZpZ2F0ZSB0b1xuICAgKiBAcGFyYW0gcmVhZGluZXNzU3RhdGUgdHlwZSBvZiByZWFkaW5lc3Mgc3RhdGU6IFwibm9uZVwiIC8gXCJpbnRlcmFjdGl2ZVwiIC8gXCJjb21wbGV0ZVwiXG4gICAqIEByZXR1cm5zIE5hdmlnYXRlUmVzdWx0IG9iamVjdFxuICAgKi9cbiAgYXN5bmMgbmF2aWdhdGUodXJsLCByZWFkaW5lc3NTdGF0ZSA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChcbiAgICAgIHJlYWRpbmVzc1N0YXRlICE9IHVuZGVmaW5lZCAmJlxuICAgICAgIVsnbm9uZScsICdpbnRlcmFjdGl2ZScsICdjb21wbGV0ZSddLmluY2x1ZGVzKHJlYWRpbmVzc1N0YXRlKVxuICAgICkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBWYWxpZCByZWFkaW5lc3Mgc3RhdGVzIGFyZSAnbm9uZScsICdpbnRlcmFjdGl2ZScgJiAnY29tcGxldGUnLiBSZWNlaXZlZDogJHtyZWFkaW5lc3NTdGF0ZX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgbWV0aG9kOiAnYnJvd3NpbmdDb250ZXh0Lm5hdmlnYXRlJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjb250ZXh0OiB0aGlzLl9pZCxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHdhaXQ6IHJlYWRpbmVzc1N0YXRlLFxuICAgICAgfSxcbiAgICB9XG4gICAgY29uc3QgbmF2aWdhdGVSZXN1bHQgPSAoYXdhaXQgdGhpcy5iaWRpLnNlbmQocGFyYW1zKSlbJ3Jlc3VsdCddXG5cbiAgICByZXR1cm4gbmV3IE5hdmlnYXRlUmVzdWx0KFxuICAgICAgbmF2aWdhdGVSZXN1bHRbJ3VybCddLFxuICAgICAgbmF2aWdhdGVSZXN1bHRbJ25hdmlnYXRpb24nXVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gbWF4RGVwdGggdGhlIG1heCBkZXB0aCBvZiB0aGUgZGVzY2VuZGVudHMgb2YgYnJvd3NpbmcgY29udGV4dCB0cmVlXG4gICAqIEByZXR1cm5zIEJyb3dzaW5nQ29udGV4dEluZm8gb2JqZWN0XG4gICAqL1xuICBhc3luYyBnZXRUcmVlKG1heERlcHRoID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgbWV0aG9kOiAnYnJvd3NpbmdDb250ZXh0LmdldFRyZWUnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHJvb3Q6IHRoaXMuX2lkLFxuICAgICAgICBtYXhEZXB0aDogbWF4RGVwdGgsXG4gICAgICB9LFxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChwYXJhbXMpXG4gICAgaWYgKCdlcnJvcicgaW4gcmVzdWx0KSB7XG4gICAgICB0aHJvdyBFcnJvcihyZXN1bHRbJ2Vycm9yJ10pXG4gICAgfVxuXG4gICAgcmVzdWx0ID0gcmVzdWx0WydyZXN1bHQnXVsnY29udGV4dHMnXVswXVxuICAgIHJldHVybiBuZXcgQnJvd3NpbmdDb250ZXh0SW5mbyhcbiAgICAgIHJlc3VsdFsnY29udGV4dCddLFxuICAgICAgcmVzdWx0Wyd1cmwnXSxcbiAgICAgIHJlc3VsdFsnY2hpbGRyZW4nXSxcbiAgICAgIHJlc3VsdFsncGFyZW50J11cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBicm93aW5nIGNvbnRleHRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBjbG9zZSgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBtZXRob2Q6ICdicm93c2luZ0NvbnRleHQuY2xvc2UnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNvbnRleHQ6IHRoaXMuX2lkLFxuICAgICAgfSxcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5iaWRpLnNlbmQocGFyYW1zKVxuICB9XG5cbiAgLyoqXG4gICAqIFByaW50cyBQREYgb2YgdGhlIHdlYnBhZ2VcbiAgICogQHBhcmFtIG9wdGlvbnMgcHJpbnQgb3B0aW9ucyBnaXZlbiBieSB0aGUgdXNlclxuICAgKiBAcmV0dXJucyBQcmludFJlc3VsdCBvYmplY3RcbiAgICovXG4gIGFzeW5jIHByaW50UGFnZShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcGFyYW1zID0ge1xuICAgICAgbWV0aG9kOiAnYnJvd3NpbmdDb250ZXh0LnByaW50JyxcbiAgICAgIC8vIFNldHRpbmcgZGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjb250ZXh0OiB0aGlzLl9pZCxcbiAgICAgICAgYmFja2dyb3VuZDogZmFsc2UsXG4gICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgIGJvdHRvbTogMS4wLFxuICAgICAgICAgIGxlZnQ6IDEuMCxcbiAgICAgICAgICByaWdodDogMS4wLFxuICAgICAgICAgIHRvcDogMS4wLFxuICAgICAgICB9LFxuICAgICAgICBvcmllbnRhdGlvbjogJ3BvcnRyYWl0JyxcbiAgICAgICAgcGFnZToge1xuICAgICAgICAgIGhlaWdodDogMjcuOTQsXG4gICAgICAgICAgd2lkdGg6IDIxLjU5LFxuICAgICAgICB9LFxuICAgICAgICBwYWdlUmFuZ2VzOiBbXSxcbiAgICAgICAgc2NhbGU6IDEuMCxcbiAgICAgICAgc2hyaW5rVG9GaXQ6IHRydWUsXG4gICAgICB9LFxuICAgIH1cblxuICAgIC8vIFVwZGF0aW5nIHBhcmFtZXRlciB2YWx1ZXMgYmFzZWQgb24gdGhlIG9wdGlvbnMgcGFzc2VkXG4gICAgcGFyYW1zLnBhcmFtcyA9IHRoaXMuX2RyaXZlci52YWxpZGF0ZVByaW50UGFnZVBhcmFtcyhvcHRpb25zLCBwYXJhbXMucGFyYW1zKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChwYXJhbXMpXG4gICAgcmV0dXJuIG5ldyBQcmludFJlc3VsdChyZXNwb25zZS5yZXN1bHQuZGF0YSlcbiAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0ZVJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgbmF2aWdhdGlvbklkKSB7XG4gICAgdGhpcy5fdXJsID0gdXJsXG4gICAgdGhpcy5fbmF2aWdhdGlvbklkID0gbmF2aWdhdGlvbklkXG4gIH1cblxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmxcbiAgfVxuXG4gIGdldCBuYXZpZ2F0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hdmlnYXRpb25JZFxuICB9XG59XG5cbmNsYXNzIFByaW50UmVzdWx0IHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG59XG5cbi8qKlxuICogaW5pdGlhdGUgYnJvd3NpbmcgY29udGV4dCBpbnN0YW5jZSBhbmQgcmV0dXJuXG4gKiBAcGFyYW0gZHJpdmVyXG4gKiBAcGFyYW0gYnJvd3NpbmdDb250ZXh0SWQgVGhlIGJyb3dzaW5nIGNvbnRleHQgb2YgY3VycmVudCB3aW5kb3cvdGFiXG4gKiBAcGFyYW0gdHlwZSBcIndpbmRvd1wiIG9yIFwidGFiXCJcbiAqIEBwYXJhbSByZWZlcmVuY2VDb250ZXh0IFRvIGdldCBhIGJyb3dzaW5nIGNvbnRleHQgZm9yIHRoaXMgcmVmZXJlbmNlIGlmIHBhc3NlZFxuICogQHJldHVybnMge1Byb21pc2U8QnJvd3NpbmdDb250ZXh0Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0QnJvd3NpbmdDb250ZXh0SW5zdGFuY2UoXG4gIGRyaXZlcixcbiAgeyBicm93c2luZ0NvbnRleHRJZCwgdHlwZSwgcmVmZXJlbmNlQ29udGV4dCB9XG4pIHtcbiAgbGV0IGluc3RhbmNlID0gbmV3IEJyb3dzaW5nQ29udGV4dChkcml2ZXIpXG4gIGF3YWl0IGluc3RhbmNlLmluaXQoeyBicm93c2luZ0NvbnRleHRJZCwgdHlwZSwgcmVmZXJlbmNlQ29udGV4dCB9KVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuLyoqXG4gKiBBUElcbiAqIEB0eXBlIHtmdW5jdGlvbigqLCB7KiwqLCp9KTogUHJvbWlzZTxCcm93c2luZ0NvbnRleHQ+fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJyb3dzaW5nQ29udGV4dEluc3RhbmNlXG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5jb25zdCB7XG4gIEJyb3dzaW5nQ29udGV4dEluZm8sXG4gIE5hdmlnYXRpb25JbmZvLFxufSA9IHJlcXVpcmUoJy4vYnJvd3NpbmdDb250ZXh0VHlwZXMnKVxuXG5jbGFzcyBCcm93c2luZ0NvbnRleHRJbnNwZWN0b3Ige1xuICBjb25zdHJ1Y3Rvcihkcml2ZXIsIGJyb3dzaW5nQ29udGV4dElkcykge1xuICAgIHRoaXMuX2RyaXZlciA9IGRyaXZlclxuICAgIHRoaXMuX2Jyb3dzaW5nQ29udGV4dElkcyA9IGJyb3dzaW5nQ29udGV4dElkc1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB0aGlzLmJpZGkgPSBhd2FpdCB0aGlzLl9kcml2ZXIuZ2V0QmlkaSgpXG4gIH1cblxuICBhc3luYyBvbkJyb3dzaW5nQ29udGV4dENyZWF0ZWQoY2FsbGJhY2spIHtcbiAgICBhd2FpdCB0aGlzLnN1YnNjcmliZUFuZEhhbmRsZUV2ZW50KFxuICAgICAgJ2Jyb3dzaW5nQ29udGV4dC5jb250ZXh0Q3JlYXRlZCcsXG4gICAgICBjYWxsYmFja1xuICAgIClcbiAgfVxuXG4gIGFzeW5jIG9uRG9tQ29udGVudExvYWRlZChjYWxsYmFjaykge1xuICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlQW5kSGFuZGxlRXZlbnQoXG4gICAgICAnYnJvd3NpbmdDb250ZXh0LmRvbUNvbnRlbnRMb2FkZWQnLFxuICAgICAgY2FsbGJhY2tcbiAgICApXG4gIH1cblxuICBhc3luYyBvbkJyb3dzaW5nQ29udGV4dExvYWRlZChjYWxsYmFjaykge1xuICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlQW5kSGFuZGxlRXZlbnQoJ2Jyb3dzaW5nQ29udGV4dC5sb2FkJywgY2FsbGJhY2spXG4gIH1cblxuICBhc3luYyBzdWJzY3JpYmVBbmRIYW5kbGVFdmVudChldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2Jyb3dzaW5nQ29udGV4dElkcyAhPSBudWxsKSB7XG4gICAgICBhd2FpdCB0aGlzLmJpZGkuc3Vic2NyaWJlKGV2ZW50VHlwZSwgdGhpcy5fYnJvd3NpbmdDb250ZXh0SWRzKVxuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLmJpZGkuc3Vic2NyaWJlKGV2ZW50VHlwZSlcbiAgICB9XG4gICAgdGhpcy5fb24oY2FsbGJhY2spXG4gIH1cblxuICBhc3luYyBfb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLndzID0gYXdhaXQgdGhpcy5iaWRpLnNvY2tldFxuICAgIHRoaXMud3Mub24oJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zIH0gPSBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGV2ZW50LnRvU3RyaW5nKCkpKVxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBudWxsXG4gICAgICAgIGlmICgnbmF2aWdhdGlvbicgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBuZXcgTmF2aWdhdGlvbkluZm8oXG4gICAgICAgICAgICBwYXJhbXMuY29udGV4dCxcbiAgICAgICAgICAgIHBhcmFtcy5uYXZpZ2F0aW9uLFxuICAgICAgICAgICAgcGFyYW1zLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmFtcy51cmxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoJ2FjY2VwdGVkJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAvKiBOZWVkcyB0byBiZSB1cGRhdGVkIHdoZW4gYnJvd3NlcnMgaW1wbGVtZW50IG90aGVyIGV2ZW50cyAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlID0gbmV3IEJyb3dzaW5nQ29udGV4dEluZm8oXG4gICAgICAgICAgICBwYXJhbXMuY29udGV4dCxcbiAgICAgICAgICAgIHBhcmFtcy51cmwsXG4gICAgICAgICAgICBwYXJhbXMuY2hpbGRyZW4sXG4gICAgICAgICAgICBwYXJhbXMucGFyZW50XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0QnJvd3NpbmdDb250ZXh0SW5zdGFuY2UoZHJpdmVyLCBicm93c2luZ0NvbnRleHRJZHMgPSBudWxsKSB7XG4gIGxldCBpbnN0YW5jZSA9IG5ldyBCcm93c2luZ0NvbnRleHRJbnNwZWN0b3IoZHJpdmVyLCBicm93c2luZ0NvbnRleHRJZHMpXG4gIGF3YWl0IGluc3RhbmNlLmluaXQoKVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCcm93c2luZ0NvbnRleHRJbnN0YW5jZVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuY2xhc3MgQnJvd3NpbmdDb250ZXh0SW5mbyB7XG4gIGNvbnN0cnVjdG9yKGlkLCB1cmwsIGNoaWxkcmVuLCBwYXJlbnRCcm93c2luZ0NvbnRleHQpIHtcbiAgICB0aGlzLl9pZCA9IGlkXG4gICAgdGhpcy5fdXJsID0gdXJsXG4gICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlblxuICAgIHRoaXMuX3BhcmVudEJyb3dzaW5nQ29udGV4dCA9IHBhcmVudEJyb3dzaW5nQ29udGV4dFxuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZFxuICB9XG5cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsXG4gIH1cblxuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuXG4gIH1cblxuICBnZXQgcGFyZW50QnJvd3NpbmdDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRCcm93c2luZ0NvbnRleHRcbiAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0aW9uSW5mbyB7XG4gIGNvbnN0cnVjdG9yKGJyb3dzaW5nQ29udGV4dElkLCBuYXZpZ2F0aW9uSWQsIHRpbWVzdGFtcCwgdXJsKSB7XG4gICAgdGhpcy5icm93c2luZ0NvbnRleHRJZCA9IGJyb3dzaW5nQ29udGV4dElkXG4gICAgdGhpcy5uYXZpZ2F0aW9uSWQgPSBuYXZpZ2F0aW9uSWRcbiAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcFxuICAgIHRoaXMudXJsID0gdXJsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEJyb3dzaW5nQ29udGV4dEluZm8sIE5hdmlnYXRpb25JbmZvIH1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmNvbnN0IEV2YWx1YXRlUmVzdWx0VHlwZSA9IHtcbiAgU1VDQ0VTUzogJ3N1Y2Nlc3MnLFxuICBFWENFUFRJT046ICdleGNlcHRpb24nLFxufVxuXG5jbGFzcyBFdmFsdWF0ZVJlc3VsdFN1Y2Nlc3Mge1xuICBjb25zdHJ1Y3RvcihyZWFsbUlkLCB2YWx1ZSkge1xuICAgIHRoaXMucmVzdWx0VHlwZSA9IEV2YWx1YXRlUmVzdWx0VHlwZS5TVUNDRVNTXG4gICAgdGhpcy5yZWFsbUlkID0gcmVhbG1JZFxuICAgIHRoaXMucmVzdWx0ID0gdmFsdWVcbiAgfVxufVxuXG5jbGFzcyBFdmFsdWF0ZVJlc3VsdEV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHJlYWxtSWQsIGV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICB0aGlzLnJlc3VsdFR5cGUgPSBFdmFsdWF0ZVJlc3VsdFR5cGUuRVhDRVBUSU9OXG4gICAgdGhpcy5yZWFsbUlkID0gcmVhbG1JZFxuICAgIHRoaXMuZXhjZXB0aW9uRGV0YWlscyA9IGV4Y2VwdGlvbkRldGFpbHNcbiAgfVxufVxuXG5jbGFzcyBFeGNlcHRpb25EZXRhaWxzIHtcbiAgY29uc3RydWN0b3IoZXhjZXB0aW9uRGV0YWlscykge1xuICAgIHRoaXMuY29sdW1uTnVtYmVyID1cbiAgICAgICdjb2x1bW5OdW1iZXInIGluIGV4Y2VwdGlvbkRldGFpbHNcbiAgICAgICAgPyBleGNlcHRpb25EZXRhaWxzWydjb2x1bW5OdW1iZXInXVxuICAgICAgICA6IG51bGxcbiAgICB0aGlzLmV4Y2VwdGlvbiA9XG4gICAgICAnZXhjZXB0aW9uJyBpbiBleGNlcHRpb25EZXRhaWxzID8gZXhjZXB0aW9uRGV0YWlsc1snZXhjZXB0aW9uJ10gOiBudWxsXG4gICAgdGhpcy5saW5lTnVtYmVyID1cbiAgICAgICdsaW5lTnVtYmVyJyBpbiBleGNlcHRpb25EZXRhaWxzID8gZXhjZXB0aW9uRGV0YWlsc1snbGluZU51bWJlciddIDogbnVsbFxuICAgIHRoaXMuc3RhY2tUcmFjZSA9XG4gICAgICAnc3RhY2tUcmFjZScgaW4gZXhjZXB0aW9uRGV0YWlscyA/IGV4Y2VwdGlvbkRldGFpbHNbJ3N0YWNrVHJhY2UnXSA6IG51bGxcbiAgICB0aGlzLnRleHQgPSAndGV4dCcgaW4gZXhjZXB0aW9uRGV0YWlscyA/IGV4Y2VwdGlvbkRldGFpbHNbJ3RleHQnXSA6IG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRXZhbHVhdGVSZXN1bHRUeXBlLFxuICBFdmFsdWF0ZVJlc3VsdFN1Y2Nlc3MsXG4gIEV2YWx1YXRlUmVzdWx0RXhjZXB0aW9uLFxuICBFeGNlcHRpb25EZXRhaWxzLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuY2xhc3MgRmlsdGVyQnkge1xuICBjb25zdHJ1Y3RvcihsZXZlbCkge1xuICAgIHRoaXMubGV2ZWxfID0gbGV2ZWxcbiAgfVxuXG4gIHN0YXRpYyBsb2dMZXZlbChsZXZlbCkge1xuICAgIGlmIChcbiAgICAgIGxldmVsID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChsZXZlbCAhPSB1bmRlZmluZWQgJiZcbiAgICAgICAgIVsnZGVidWcnLCAnZXJyb3InLCAnaW5mbycsICd3YXJuaW5nJ10uaW5jbHVkZXMobGV2ZWwpKVxuICAgICkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBQbGVhc2UgcGFzcyB2YWxpZCBsb2cgbGV2ZWwuIFZhbGlkIGxvZyBsZXZlbHMgYXJlICdkZWJ1ZycsICdlcnJvcicsICdpbmZvJyBhbmQgJ3dhcm5pbmcnLiBSZWNlaXZlZDogJHtsZXZlbH1gXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJCeShsZXZlbClcbiAgfVxuXG4gIGdldExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsX1xuICB9XG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZpbHRlckJ5LFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJylcblxuY29uc3QgUkVTUE9OU0VfVElNRU9VVCA9IDEwMDAgKiAzMFxuXG5jbGFzcyBJbmRleCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGlkID0gMFxuICBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gIGV2ZW50cyA9IFtdXG4gIGJyb3dzaW5nQ29udGV4dHMgPSBbXVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgd2Vic29ja2V0IGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIF93ZWJTb2NrZXRVcmxcbiAgICovXG4gIGNvbnN0cnVjdG9yIChfd2ViU29ja2V0VXJsKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldChfd2ViU29ja2V0VXJsKVxuICAgIHRoaXMuX3dzLm9uKCdvcGVuJywgKCkgPT4ge1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWVcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgY29ubmVjdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAgICovXG4gIGFzeW5jIHdhaXRGb3JDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd3Mub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtXZWJTb2NrZXR9XG4gICAqL1xuICBnZXQgc29ja2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3NcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxuICAgKi9cbiAgZ2V0IGlzQ29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZFxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgYmlkaSByZXF1ZXN0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gICAqL1xuICBhc3luYyBzZW5kIChwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvckNvbm5lY3Rpb24oKVxuICAgIH1cblxuICAgIGNvbnN0IGlkID0gKyt0aGlzLmlkXG5cbiAgICB0aGlzLl93cy5zZW5kKEpTT04uc3RyaW5naWZ5KHsgaWQsIC4uLnBhcmFtcyB9KSlcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUmVxdWVzdCB3aXRoIGlkICR7aWR9IHRpbWVkIG91dGApKVxuICAgICAgICBoYW5kbGVyLm9mZignbWVzc2FnZScsIGxpc3RlbmVyKVxuICAgICAgfSwgUkVTUE9OU0VfVElNRU9VVClcblxuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZGF0YSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSlcbiAgICAgICAgICBpZiAocGF5bG9hZC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICAgICAgICBoYW5kbGVyLm9mZignbWVzc2FnZScsIGxpc3RlbmVyKVxuICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGBGYWlsZWQgcGFyc2UgbWVzc2FnZTogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl93cy5vbignbWVzc2FnZScsIGxpc3RlbmVyKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgKiBAcGFyYW0gZXZlbnRzXG4gICAqIEBwYXJhbSBicm93c2luZ0NvbnRleHRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgc3Vic2NyaWJlIChldmVudHMsIGJyb3dzaW5nQ29udGV4dHMpIHtcbiAgICBmdW5jdGlvbiB0b0FycmF5IChhcmcpIHtcbiAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSA/IFsuLi5hcmddIDogW2FyZ11cbiAgICB9XG5cbiAgICBjb25zdCBldmVudHNBcnJheSA9IHRvQXJyYXkoZXZlbnRzKVxuICAgIGNvbnN0IGNvbnRleHRzQXJyYXkgPSB0b0FycmF5KGJyb3dzaW5nQ29udGV4dHMpXG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBtZXRob2Q6ICdzZXNzaW9uLnN1YnNjcmliZScsIHBhcmFtczoge30sXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50c0FycmF5Lmxlbmd0aCAmJiBldmVudHNBcnJheS5zb21lKFxuICAgICAgZXZlbnQgPT4gdHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V2ZW50cyBzaG91bGQgYmUgc3RyaW5nIG9yIHN0cmluZyBhcnJheScpXG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHRzQXJyYXkubGVuZ3RoICYmIGNvbnRleHRzQXJyYXkuc29tZShcbiAgICAgIGNvbnRleHQgPT4gdHlwZW9mIGNvbnRleHQgIT09ICdzdHJpbmcnKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnJvd3NpbmdDb250ZXh0cyBzaG91bGQgYmUgc3RyaW5nIG9yIHN0cmluZyBhcnJheScpXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgcGFyYW1zLnBhcmFtcy5ldmVudHMgPSBldmVudHNBcnJheVxuICAgIH1cblxuICAgIGlmIChjb250ZXh0c0FycmF5Lmxlbmd0aCkge1xuICAgICAgcGFyYW1zLnBhcmFtcy5jb250ZXh0cyA9IGNvbnRleHRzQXJyYXlcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnNlbmQocGFyYW1zKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgKiBAcGFyYW0gZXZlbnRzXG4gICAqIEBwYXJhbSBicm93c2luZ0NvbnRleHRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgdW5zdWJzY3JpYmUgKGV2ZW50cywgYnJvd3NpbmdDb250ZXh0cykge1xuICAgIGlmICh0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5maWx0ZXIoZXZlbnQgPT4gZXZlbnQgIT09IGV2ZW50cylcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5maWx0ZXIoZXZlbnQgPT4gIWV2ZW50cy5pbmNsdWRlcyhldmVudCkpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBicm93c2luZ0NvbnRleHRzID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5icm93c2luZ0NvbnRleHRzLnBvcCgpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJyb3dzaW5nQ29udGV4dHMpKSB7XG4gICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dHMgPVxuICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dHMuZmlsdGVyKGlkID0+ICFicm93c2luZ0NvbnRleHRzLmluY2x1ZGVzKGlkKSlcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBtZXRob2Q6ICdzZXNzaW9uLnVuc3Vic2NyaWJlJywgcGFyYW1zOiB7XG4gICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnJvd3NpbmdDb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJhbXMucGFyYW1zLmNvbnRleHRzID0gdGhpcy5icm93c2luZ0NvbnRleHRzXG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5zZW5kKHBhcmFtcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQmlkaSBTdGF0dXNcbiAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAqL1xuICBnZXQgc3RhdHVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kKHtcbiAgICAgIG1ldGhvZDogJ3Nlc3Npb24uc3RhdHVzJywgcGFyYW1zOiB7fVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2Ugd3MgY29ubmVjdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgY29uc3QgY2xvc2VXZWJTb2NrZXQgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgIC8vIGRvbid0IGNsb3NlIGlmIGl0J3MgYWxyZWFkeSBjbG9zZWRcbiAgICAgIGlmICh0aGlzLl93cy5yZWFkeVN0YXRlID09PSAzKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvbid0IG5vdGlmeSBvbiB1c2VyLWluaXRpYXRlZCBzaHV0ZG93biAoJ2Rpc2Nvbm5lY3QnIGV2ZW50KVxuICAgICAgICB0aGlzLl93cy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJylcbiAgICAgICAgdGhpcy5fd3Mub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fd3MucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuX3dzLmNsb3NlKClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICAgIGNsb3NlV2ViU29ja2V0KGZ1bGZpbGwpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEFQSVxuICogQHR5cGUge2Z1bmN0aW9uKCopOiBQcm9taXNlPEluZGV4Pn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBJbmRleFxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIEJhc2VMb2dFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGxldmVsLCB0ZXh0LCB0aW1lU3RhbXAsIHN0YWNrVHJhY2UpIHtcbiAgICB0aGlzLl9sZXZlbCA9IGxldmVsXG4gICAgdGhpcy5fdGV4dCA9IHRleHRcbiAgICB0aGlzLl90aW1lU3RhbXAgPSB0aW1lU3RhbXBcbiAgICB0aGlzLl9zdGFja1RyYWNlID0gc3RhY2tUcmFjZVxuICB9XG5cbiAgZ2V0IGxldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbFxuICB9XG5cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRcbiAgfVxuXG4gIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVTdGFtcFxuICB9XG5cbiAgZ2V0IHN0YWNrVHJhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrVHJhY2VcbiAgfVxufVxuXG5jbGFzcyBHZW5lcmljTG9nRW50cnkgZXh0ZW5kcyBCYXNlTG9nRW50cnkge1xuICBjb25zdHJ1Y3RvcihsZXZlbCwgdGV4dCwgdGltZVN0YW1wLCB0eXBlLCBzdGFja1RyYWNlKSB7XG4gICAgc3VwZXIobGV2ZWwsIHRleHQsIHRpbWVTdGFtcCwgc3RhY2tUcmFjZSlcbiAgICB0aGlzLl90eXBlID0gdHlwZVxuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVcbiAgfVxufVxuXG5jbGFzcyBDb25zb2xlTG9nRW50cnkgZXh0ZW5kcyBHZW5lcmljTG9nRW50cnkge1xuICBjb25zdHJ1Y3RvcihsZXZlbCwgdGV4dCwgdGltZVN0YW1wLCB0eXBlLCBtZXRob2QsIHJlYWxtLCBhcmdzLCBzdGFja1RyYWNlKSB7XG4gICAgc3VwZXIobGV2ZWwsIHRleHQsIHRpbWVTdGFtcCwgdHlwZSwgc3RhY2tUcmFjZSlcbiAgICB0aGlzLl9tZXRob2QgPSBtZXRob2RcbiAgICB0aGlzLl9yZWFsbSA9IHJlYWxtXG4gICAgdGhpcy5fYXJncyA9IGFyZ3NcbiAgfVxuXG4gIGdldCBtZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZFxuICB9XG5cbiAgZ2V0IHJlYWxtKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFsbVxuICB9XG5cbiAgZ2V0IGFyZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FyZ3NcbiAgfVxufVxuXG5jbGFzcyBKYXZhc2NyaXB0TG9nRW50cnkgZXh0ZW5kcyBHZW5lcmljTG9nRW50cnkge1xuICBjb25zdHJ1Y3RvcihsZXZlbCwgdGV4dCwgdGltZVN0YW1wLCB0eXBlLCBzdGFja1RyYWNlKSB7XG4gICAgc3VwZXIobGV2ZWwsIHRleHQsIHRpbWVTdGFtcCwgdHlwZSwgc3RhY2tUcmFjZSlcbiAgfVxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCYXNlTG9nRW50cnksXG4gIEdlbmVyaWNMb2dFbnRyeSxcbiAgQ29uc29sZUxvZ0VudHJ5LFxuICBKYXZhc2NyaXB0TG9nRW50cnksXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5jb25zdCB7IEZpbHRlckJ5IH0gPSByZXF1aXJlKCcuL2ZpbHRlckJ5JylcbmNvbnN0IHsgQ29uc29sZUxvZ0VudHJ5LCBKYXZhc2NyaXB0TG9nRW50cnksIEdlbmVyaWNMb2dFbnRyeSB9ID0gcmVxdWlyZSgnLi9sb2dFbnRyaWVzJylcblxuY29uc3QgTE9HID0ge1xuICBUWVBFX0NPTlNPTEUgOiAnY29uc29sZScsXG4gIFRZUEVfSlNfTE9HUyA6ICdqYXZhc2NyaXB0Jyxcbn1cblxuY2xhc3MgTG9nSW5zcGVjdG9yIHtcbiAgYmlkaVxuICB3c1xuXG4gIGNvbnN0cnVjdG9yIChkcml2ZXIsIGJyb3dzaW5nQ29udGV4dElkcykge1xuICAgIHRoaXMuX2RyaXZlciA9IGRyaXZlclxuICAgIHRoaXMuX2Jyb3dzaW5nQ29udGV4dElkcyA9IGJyb3dzaW5nQ29udGV4dElkc1xuICAgIHRoaXMubGlzdGVuZXIgPSB7fVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBsb2cgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBpbml0ICgpIHtcbiAgICB0aGlzLmJpZGkgPSBhd2FpdCB0aGlzLl9kcml2ZXIuZ2V0QmlkaSgpXG4gICAgYXdhaXQgdGhpcy5iaWRpLnN1YnNjcmliZSgnbG9nLmVudHJ5QWRkZWQnLCB0aGlzLl9icm93c2luZ0NvbnRleHRJZHMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGtpbmRcbiAgICovXG4gIGxvZ0xpc3RlbmVyIChraW5kKSB7XG4gICAgaWYgKCEoa2luZCBpbiB0aGlzLmxpc3RlbmVyKSkge1xuICAgICAgdGhpcy5saXN0ZW5lcltraW5kXSA9IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBDb25zb2xlIGxvZ3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgb25Db25zb2xlRW50cnkoY2FsbGJhY2ssIGZpbHRlckJ5ID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGZpbHRlckJ5ICE9IHVuZGVmaW5lZCAmJiAhKGZpbHRlckJ5IGluc3RhbmNlb2YgRmlsdGVyQnkpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgUGFzcyB2YWxpZCBGaWx0ZXJCeSBvYmplY3QuIFJlY2VpdmVkOiAke2ZpbHRlckJ5fWApXG4gICAgfVxuXG4gICAgdGhpcy53cyA9IGF3YWl0IHRoaXMuYmlkaS5zb2NrZXRcblxuICAgIHRoaXMud3Mub24oJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zIH0gPSBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGV2ZW50LnRvU3RyaW5nKCkpKVxuXG4gICAgICBpZiAocGFyYW1zPy50eXBlID09PSBMT0cuVFlQRV9DT05TT0xFKSB7XG4gICAgICAgIGxldCBjb25zb2xlRW50cnkgPSBuZXcgQ29uc29sZUxvZ0VudHJ5KFxuICAgICAgICAgIHBhcmFtcy5sZXZlbCxcbiAgICAgICAgICBwYXJhbXMudGV4dCxcbiAgICAgICAgICBwYXJhbXMudGltZXN0YW1wLFxuICAgICAgICAgIHBhcmFtcy50eXBlLFxuICAgICAgICAgIHBhcmFtcy5tZXRob2QsXG4gICAgICAgICAgcGFyYW1zLnJlYWxtLFxuICAgICAgICAgIHBhcmFtcy5hcmdzLFxuICAgICAgICAgIHBhcmFtcy5zdGFja1RyYWNlXG4gICAgICAgIClcblxuICAgICAgICBpZiAoZmlsdGVyQnkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcz8ubGV2ZWwgPT09IGZpbHRlckJ5LmdldExldmVsKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNvbnNvbGVFbnRyeSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhjb25zb2xlRW50cnkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gSlMgbG9nc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBvbkphdmFzY3JpcHRMb2coY2FsbGJhY2ssIGZpbHRlckJ5ID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGZpbHRlckJ5ICE9IHVuZGVmaW5lZCAmJiAhKGZpbHRlckJ5IGluc3RhbmNlb2YgRmlsdGVyQnkpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgUGFzcyB2YWxpZCBGaWx0ZXJCeSBvYmplY3QuIFJlY2VpdmVkOiAke2ZpbHRlckJ5fWApXG4gICAgfVxuXG4gICAgdGhpcy53cyA9IGF3YWl0IHRoaXMuYmlkaS5zb2NrZXRcblxuICAgIHRoaXMud3Mub24oJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zIH0gPSBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGV2ZW50LnRvU3RyaW5nKCkpKVxuXG4gICAgICBpZiAocGFyYW1zPy50eXBlID09PSBMT0cuVFlQRV9KU19MT0dTKSB7XG4gICAgICAgIGxldCBqc0VudHJ5ID0gbmV3IEphdmFzY3JpcHRMb2dFbnRyeShcbiAgICAgICAgICBwYXJhbXMubGV2ZWwsXG4gICAgICAgICAgcGFyYW1zLnRleHQsXG4gICAgICAgICAgcGFyYW1zLnRpbWVzdGFtcCxcbiAgICAgICAgICBwYXJhbXMudHlwZSxcbiAgICAgICAgICBwYXJhbXMuc3RhY2tUcmFjZVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGZpbHRlckJ5ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChwYXJhbXM/LmxldmVsID09PSBmaWx0ZXJCeS5nZXRMZXZlbCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhqc0VudHJ5KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGpzRW50cnkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gSlMgRXhjZXB0aW9uc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBvbkphdmFzY3JpcHRFeGNlcHRpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLndzID0gYXdhaXQgdGhpcy5iaWRpLnNvY2tldFxuICAgIGxldCBlbmFibGVkID1cbiAgICAgIExPRy5UWVBFX0pTX0VYQ0VQVElPTiBpbiB0aGlzLmxpc3RlbmVyIHx8XG4gICAgICB0aGlzLmxvZ0xpc3RlbmVyKExPRy5UWVBFX0pTX0VYQ0VQVElPTilcbiAgICB0aGlzLmxpc3RlbmVyW0xPRy5UWVBFX0pTX0VYQ0VQVElPTl0ucHVzaChjYWxsYmFjaylcblxuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLndzLm9uKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7IHBhcmFtcyB9ID0gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShldmVudC50b1N0cmluZygpKSlcbiAgICAgIGlmIChwYXJhbXM/LnR5cGUgPT09ICdqYXZhc2NyaXB0JyAmJiBwYXJhbXM/LmxldmVsID09PSAnZXJyb3InKSB7XG4gICAgICAgIGxldCBqc0Vycm9yRW50cnkgPSBuZXcgSmF2YXNjcmlwdExvZ0VudHJ5KFxuICAgICAgICAgIHBhcmFtcy5sZXZlbCxcbiAgICAgICAgICBwYXJhbXMudGV4dCxcbiAgICAgICAgICBwYXJhbXMudGltZXN0YW1wLFxuICAgICAgICAgIHBhcmFtcy50eXBlLFxuICAgICAgICAgIHBhcmFtcy5zdGFja1RyYWNlXG4gICAgICAgIClcblxuICAgICAgICB0aGlzLmxpc3RlbmVyW0xPRy5UWVBFX0pTX0VYQ0VQVElPTl0uZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lcihqc0Vycm9yRW50cnkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gYW55IGxvZ3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgb25Mb2coY2FsbGJhY2ssIGZpbHRlckJ5ID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGZpbHRlckJ5ICE9IHVuZGVmaW5lZCAmJiAhKGZpbHRlckJ5IGluc3RhbmNlb2YgRmlsdGVyQnkpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgUGFzcyB2YWxpZCBGaWx0ZXJCeSBvYmplY3QuIFJlY2VpdmVkOiAke2ZpbHRlckJ5fWApXG4gICAgfVxuXG4gICAgdGhpcy53cyA9IGF3YWl0IHRoaXMuYmlkaS5zb2NrZXRcblxuICAgIHRoaXMud3Mub24oJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zIH0gPSBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGV2ZW50LnRvU3RyaW5nKCkpKVxuICAgICAgaWYgKHBhcmFtcz8udHlwZSA9PT0gJ2phdmFzY3JpcHQnKSB7XG4gICAgICAgIGxldCBqc0VudHJ5ID0gbmV3IEphdmFzY3JpcHRMb2dFbnRyeShcbiAgICAgICAgICBwYXJhbXMubGV2ZWwsXG4gICAgICAgICAgcGFyYW1zLnRleHQsXG4gICAgICAgICAgcGFyYW1zLnRpbWVzdGFtcCxcbiAgICAgICAgICBwYXJhbXMudHlwZSxcbiAgICAgICAgICBwYXJhbXMuc3RhY2tUcmFjZVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGZpbHRlckJ5ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChwYXJhbXM/LmxldmVsID09PSBmaWx0ZXJCeS5nZXRMZXZlbCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhqc0VudHJ5KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGpzRW50cnkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICBcbiAgICAgIGlmIChwYXJhbXM/LnR5cGUgPT09ICdjb25zb2xlJykge1xuICAgICAgICBsZXQgY29uc29sZUVudHJ5ID0gbmV3IENvbnNvbGVMb2dFbnRyeShcbiAgICAgICAgICBwYXJhbXMubGV2ZWwsXG4gICAgICAgICAgcGFyYW1zLnRleHQsXG4gICAgICAgICAgcGFyYW1zLnRpbWVzdGFtcCxcbiAgICAgICAgICBwYXJhbXMudHlwZSxcbiAgICAgICAgICBwYXJhbXMubWV0aG9kLFxuICAgICAgICAgIHBhcmFtcy5yZWFsbSxcbiAgICAgICAgICBwYXJhbXMuYXJncyxcbiAgICAgICAgICBwYXJhbXMuc3RhY2tUcmFjZVxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBpZiAoZmlsdGVyQnkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcz8ubGV2ZWwgPT09IGZpbHRlckJ5LmdldExldmVsKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNvbnNvbGVFbnRyeSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhjb25zb2xlRW50cnkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHBhcmFtcyAhPSB1bmRlZmluZWQgJiZcbiAgICAgICAgIVsnY29uc29sZScsICdqYXZhc2NyaXB0J10uaW5jbHVkZXMocGFyYW1zPy50eXBlKVxuICAgICAgKSB7XG4gICAgICAgIGxldCBnZW5lcmljRW50cnkgPSBuZXcgR2VuZXJpY0xvZ0VudHJ5KFxuICAgICAgICAgIHBhcmFtcy5sZXZlbCxcbiAgICAgICAgICBwYXJhbXMudGV4dCxcbiAgICAgICAgICBwYXJhbXMudGltZXN0YW1wLFxuICAgICAgICAgIHBhcmFtcy50eXBlLFxuICAgICAgICAgIHBhcmFtcy5zdGFja1RyYWNlXG4gICAgICAgIClcblxuICAgICAgICBpZiAoZmlsdGVyQnkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcz8ubGV2ZWwgPT09IGZpbHRlckJ5LmdldExldmVsKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGdlbmVyaWNFbnRyeSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhnZW5lcmljRW50cnkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSB0byBsb2cgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBjbG9zZSAoKSB7XG4gICAgYXdhaXQgdGhpcy5iaWRpLnVuc3Vic2NyaWJlKCdsb2cuZW50cnlBZGRlZCcsIHRoaXMuX2Jyb3dzaW5nQ29udGV4dElkcylcbiAgfVxufVxuXG4vKipcbiAqIGluaXRpYXRlIGluc3BlY3RvciBpbnN0YW5jZSBhbmQgcmV0dXJuXG4gKiBAcGFyYW0gZHJpdmVyXG4gKiBAcGFyYW0gYnJvd3NpbmdDb250ZXh0SWRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxMb2dJbnNwZWN0b3I+fVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2dJbnNwZWN0b3JJbnN0YW5jZSAoZHJpdmVyLCBicm93c2luZ0NvbnRleHRJZHMpIHtcbiAgbGV0IGluc3RhbmNlID0gbmV3IExvZ0luc3BlY3Rvcihkcml2ZXIsIGJyb3dzaW5nQ29udGV4dElkcylcbiAgYXdhaXQgaW5zdGFuY2UuaW5pdCgpXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG4vKipcbiAqIEFQSVxuICogQHR5cGUge2Z1bmN0aW9uKCosICopOiBQcm9taXNlPExvZ0luc3BlY3Rvcj59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZ2V0TG9nSW5zcGVjdG9ySW5zdGFuY2VcbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmNvbnN0IFByaW1pdGl2ZVR5cGUgPSB7XG4gIFVOREVGSU5FRDogJ3VuZGVmaW5lZCcsXG4gIE5VTEw6ICdudWxsJyxcbiAgU1RSSU5HOiAnc3RyaW5nJyxcbiAgTlVNQkVSOiAnbnVtYmVyJyxcbiAgU1BFQ0lBTF9OVU1CRVI6ICdudW1iZXInLFxuICBCT09MRUFOOiAnYm9vbGVhbicsXG4gIEJJR0lOVDogJ2JpZ2ludCcsXG5cbiAgZmluZEJ5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcykuZmluZCgodHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUudG9Mb3dlckNhc2UoKVxuICAgICAgICApXG4gICAgICB9KSB8fCBudWxsXG4gICAgKVxuICB9LFxufVxuXG5jb25zdCBOb25QcmltaXRpdmVUeXBlID0ge1xuICBBUlJBWTogJ2FycmF5JyxcbiAgREFURTogJ2RhdGUnLFxuICBNQVA6ICdtYXAnLFxuICBPQkpFQ1Q6ICdvYmplY3QnLFxuICBSRUdVTEFSX0VYUFJFU1NJT046ICdyZWdleHAnLFxuICBTRVQ6ICdzZXQnLFxuXG4gIGZpbmRCeU5hbWUobmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3QudmFsdWVzKHRoaXMpLmZpbmQoKHR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgbmFtZS50b0xvd2VyQ2FzZSgpID09PSB0eXBlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgfSkgfHwgbnVsbFxuICAgIClcbiAgfSxcbn1cblxuY29uc3QgUmVtb3RlVHlwZSA9IHtcbiAgU1lNQk9MOiAnc3ltYm9sJyxcbiAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gIFdFQUtfTUFQOiAnd2Vha21hcCcsXG4gIFdFQUtfU0VUOiAnd2Vha3NldCcsXG4gIElURVJBVE9SOiAnaXRlcmF0b3InLFxuICBHRU5FUkFUT1I6ICdnZW5lcmF0b3InLFxuICBFUlJPUjogJ2Vycm9yJyxcbiAgUFJPWFk6ICdwcm94eScsXG4gIFBST01JU0U6ICdwcm9taXNlJyxcbiAgVFlQRURfQVJSQVk6ICd0eXBlZGFycmF5JyxcbiAgQVJSQVlfQlVGRkVSOiAnYXJyYXlidWZmZXInLFxuICBOT0RFX0xJU1Q6ICdub2RlbGlzdCcsXG4gIEhUTUxfQ09MTEVDVElPTjogJ2h0bWxjb2xsZWN0aW9uJyxcbiAgTk9ERTogJ25vZGUnLFxuICBXSU5ET1c6ICd3aW5kb3cnLFxuXG4gIGZpbmRCeU5hbWUobmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3QudmFsdWVzKHRoaXMpLmZpbmQoKHR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgbmFtZS50b0xvd2VyQ2FzZSgpID09PSB0eXBlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgfSkgfHwgbnVsbFxuICAgIClcbiAgfSxcbn1cblxuY29uc3QgU3BlY2lhbE51bWJlclR5cGUgPSB7XG4gIE5BTjogJ05hTicsXG4gIE1JTlVTX1pFUk86ICctMCcsXG4gIElORklOSVRZOiAnSW5maW5pdHknLFxuICBNSU5VU19JTkZJTklUWTogJy1JbmZpbml0eScsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQcmltaXRpdmVUeXBlLFxuICBOb25QcmltaXRpdmVUeXBlLFxuICBSZW1vdGVUeXBlLFxuICBTcGVjaWFsTnVtYmVyVHlwZSxcbn1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmNvbnN0IHtcbiAgUHJpbWl0aXZlVHlwZSxcbiAgTm9uUHJpbWl0aXZlVHlwZSxcbiAgUmVtb3RlVHlwZSxcbn0gPSByZXF1aXJlKCcuL3Byb3RvY29sVHlwZScpXG5cbmNvbnN0IFRZUEVfQ09OU1RBTlQgPSAndHlwZSdcbmNvbnN0IFZBTFVFX0NPTlNUQU5UID0gJ3ZhbHVlJ1xuY29uc3QgUmVtb3RlUmVmZXJlbmNlVHlwZSA9IHtcbiAgSEFORExFOiAnaGFuZGxlJyxcbiAgU0hBUkVEX0lEOiAnc2hhcmVJZCcsXG59XG5cbmNsYXNzIExvY2FsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSA9IG51bGwpIHtcbiAgICBpZiAodHlwZSA9PT0gUHJpbWl0aXZlVHlwZS5VTkRFRklORUQgfHwgdHlwZSA9PT0gUHJpbWl0aXZlVHlwZS5OVUxMKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgTG9jYWxWYWx1ZShQcmltaXRpdmVUeXBlLlNUUklORywgdmFsdWUpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlTnVtYmVyVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IExvY2FsVmFsdWUoUHJpbWl0aXZlVHlwZS5OVU1CRVIsIHZhbHVlKVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVNwZWNpYWxOdW1iZXJWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgTG9jYWxWYWx1ZShQcmltaXRpdmVUeXBlLlNQRUNJQUxfTlVNQkVSLCB2YWx1ZSlcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVVbmRlZmluZWRWYWx1ZSgpIHtcbiAgICByZXR1cm4gbmV3IExvY2FsVmFsdWUoUHJpbWl0aXZlVHlwZS5VTkRFRklORUQpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlTnVsbFZhbHVlKCkge1xuICAgIHJldHVybiBuZXcgTG9jYWxWYWx1ZShQcmltaXRpdmVUeXBlLk5VTEwpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlQm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFZhbHVlKFByaW1pdGl2ZVR5cGUuQk9PTEVBTiwgdmFsdWUpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlQmlnSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IExvY2FsVmFsdWUoUHJpbWl0aXZlVHlwZS5CSUdJTlQsIHZhbHVlKVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUFycmF5VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IExvY2FsVmFsdWUoTm9uUHJpbWl0aXZlVHlwZS5BUlJBWSwgdmFsdWUpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlRGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFZhbHVlKE5vblByaW1pdGl2ZVR5cGUuREFURSwgdmFsdWUpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlTWFwVmFsdWUobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gW11cbiAgICBPYmplY3QuZW50cmllcyhtYXApLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICB2YWx1ZS5wdXNoKGVudHJ5KVxuICAgIH0pXG4gICAgcmV0dXJuIG5ldyBMb2NhbFZhbHVlKE5vblByaW1pdGl2ZVR5cGUuTUFQLCB2YWx1ZSlcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVPYmplY3RWYWx1ZShtYXApIHtcbiAgICBsZXQgdmFsdWUgPSBbXVxuICAgIE9iamVjdC5lbnRyaWVzKG1hcCkuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIHZhbHVlLnB1c2goZW50cnkpXG4gICAgfSlcbiAgICByZXR1cm4gbmV3IExvY2FsVmFsdWUoTm9uUHJpbWl0aXZlVHlwZS5PQkpFQ1QsIHZhbHVlKVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVJlZ3VsYXJFeHByZXNzaW9uVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IExvY2FsVmFsdWUoTm9uUHJpbWl0aXZlVHlwZS5SRUdVTEFSX0VYUFJFU1NJT04sIHZhbHVlKVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVNldFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFZhbHVlKE5vblByaW1pdGl2ZVR5cGUuU0VULCB2YWx1ZSlcbiAgfVxuXG4gIHRvSnNvbigpIHtcbiAgICBsZXQgdG9SZXR1cm4gPSB7fVxuICAgIHRvUmV0dXJuW1RZUEVfQ09OU1RBTlRdID0gdGhpcy50eXBlXG5cbiAgICBpZiAoXG4gICAgICAhKFxuICAgICAgICB0aGlzLnR5cGUgPT09IFByaW1pdGl2ZVR5cGUuTlVMTCB8fFxuICAgICAgICB0aGlzLnR5cGUgPT09IFByaW1pdGl2ZVR5cGUuVU5ERUZJTkVEXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0b1JldHVybltWQUxVRV9DT05TVEFOVF0gPSB0aGlzLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiB0b1JldHVyblxuICB9XG59XG5cbmNsYXNzIFJlbW90ZVZhbHVlIHtcbiAgY29uc3RydWN0b3IocmVtb3RlVmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSBudWxsXG4gICAgdGhpcy5oYW5kbGUgPSBudWxsXG4gICAgdGhpcy5pbnRlcm5hbElkID0gbnVsbFxuICAgIHRoaXMudmFsdWUgPSBudWxsXG4gICAgdGhpcy5zaGFyZWRJZCA9IG51bGxcblxuICAgIGlmICgndHlwZScgaW4gcmVtb3RlVmFsdWUpIHtcbiAgICAgIHZhciB0eXBlU3RyaW5nID0gcmVtb3RlVmFsdWVbJ3R5cGUnXVxuICAgICAgaWYgKFByaW1pdGl2ZVR5cGUuZmluZEJ5TmFtZSh0eXBlU3RyaW5nKSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFByaW1pdGl2ZVR5cGUuZmluZEJ5TmFtZSh0eXBlU3RyaW5nKVxuICAgICAgfSBlbHNlIGlmIChOb25QcmltaXRpdmVUeXBlLmZpbmRCeU5hbWUodHlwZVN0cmluZykgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnR5cGUgPSBOb25QcmltaXRpdmVUeXBlLmZpbmRCeU5hbWUodHlwZVN0cmluZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFJlbW90ZVR5cGUuZmluZEJ5TmFtZSh0eXBlU3RyaW5nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnaGFuZGxlJyBpbiByZW1vdGVWYWx1ZSkge1xuICAgICAgdGhpcy5oYW5kbGUgPSByZW1vdGVWYWx1ZVsnaGFuZGxlJ11cbiAgICB9XG5cbiAgICBpZiAoJ2ludGVybmFsSWQnIGluIHJlbW90ZVZhbHVlKSB7XG4gICAgICB0aGlzLmludGVybmFsSWQgPSByZW1vdGVWYWx1ZVsnaW50ZXJuYWxJZCddXG4gICAgfVxuXG4gICAgaWYgKCd2YWx1ZScgaW4gcmVtb3RlVmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSByZW1vdGVWYWx1ZVsndmFsdWUnXVxuICAgIH1cblxuICAgIGlmICgnc2hhcmVkSWQnIGluIHJlbW90ZVZhbHVlKSB7XG4gICAgICB0aGlzLnNoYXJlZElkID0gcmVtb3RlVmFsdWVbJ3NoYXJlZElkJ11cbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5kZXNlcmlhbGl6ZVZhbHVlKHRoaXMudmFsdWUsIHRoaXMudHlwZSlcbiAgICB9XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKFtOb25QcmltaXRpdmVUeXBlLk1BUCwgTm9uUHJpbWl0aXZlVHlwZS5PQkpFQ1RdLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHZhbHVlKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTm9uUHJpbWl0aXZlVHlwZS5SRUdVTEFSX0VYUFJFU1NJT04pIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwVmFsdWUodmFsdWUucGF0dGVybiwgdmFsdWUuZmxhZ3MpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbmNsYXNzIFJlZmVyZW5jZVZhbHVlIHtcbiAgY29uc3RydWN0b3IoaGFuZGxlLCBzaGFyZUlkKSB7XG4gICAgaWYgKGhhbmRsZSA9PT0gUmVtb3RlUmVmZXJlbmNlVHlwZS5IQU5ETEUpIHtcbiAgICAgIHRoaXMuaGFuZGxlID0gc2hhcmVJZFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZSA9IGhhbmRsZVxuICAgICAgdGhpcy5zaGFyZUlkID0gc2hhcmVJZFxuICAgIH1cbiAgfVxuXG4gIGFzTWFwKCkge1xuICAgIGNvbnN0IHRvUmV0dXJuID0ge31cbiAgICBpZiAodGhpcy5oYW5kbGUgIT0gbnVsbCkge1xuICAgICAgdG9SZXR1cm5bUmVtb3RlUmVmZXJlbmNlVHlwZS5IQU5ETEVdID0gdGhpcy5oYW5kbGVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaGFyZUlkICE9IG51bGwpIHtcbiAgICAgIHRvUmV0dXJuW1JlbW90ZVJlZmVyZW5jZVR5cGUuU0hBUkVEX0lEXSA9IHRoaXMuc2hhcmVJZFxuICAgIH1cblxuICAgIHJldHVybiB0b1JldHVyblxuICB9XG59XG5cbmNsYXNzIFJlZ0V4cFZhbHVlIHtcbiAgY29uc3RydWN0b3IocGF0dGVybiwgZmxhZ3MgPSBudWxsKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuICAgIHRoaXMuZmxhZ3MgPSBmbGFnc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBMb2NhbFZhbHVlLFxuICBSZW1vdGVWYWx1ZSxcbiAgUmVmZXJlbmNlVmFsdWUsXG4gIFJlbW90ZVJlZmVyZW5jZVR5cGUsXG4gIFJlZ0V4cFZhbHVlLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuY29uc3QgUmVhbG1UeXBlID0ge1xuICBBVURJT19XT1JLTEVUOiAnYXVkaW8td29ya2xldCcsXG4gIERFRElDQVRFRF9XT1JLRVI6ICdkZWRpY2F0ZWQtd29ya2VyJyxcbiAgUEFJTlRfV09SS0xFVDogJ3BhaW50LXdvcmtsZXQnLFxuICBTRVJWSUNFX1dPUktFRDogJ3NlcnZpY2Utd29ya2VyJyxcbiAgU0hBUkVEX1dPUktFRDogJ3NoYXJlZC13b3JrZXInLFxuICBXSU5ET1c6ICd3aW5kb3cnLFxuICBXT1JLRVI6ICd3b3JrZXInLFxuICBXT1JLTEVUOiAnd29ya2xldCcsXG5cbiAgZmluZEJ5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcykuZmluZCgodHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUudG9Mb3dlckNhc2UoKVxuICAgICAgICApXG4gICAgICB9KSB8fCBudWxsXG4gICAgKVxuICB9LFxufVxuXG5jbGFzcyBSZWFsbUluZm8ge1xuICBjb25zdHJ1Y3RvcihyZWFsbUlkLCBvcmlnaW4sIHJlYWxtVHlwZSkge1xuICAgIHRoaXMucmVhbG1JZCA9IHJlYWxtSWRcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblxuICAgIHRoaXMucmVhbG1UeXBlID0gcmVhbG1UeXBlXG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oaW5wdXQpIHtcbiAgICBsZXQgcmVhbG1JZCA9IG51bGxcbiAgICBsZXQgb3JpZ2luID0gbnVsbFxuICAgIGxldCByZWFsbVR5cGUgPSBudWxsXG4gICAgbGV0IGJyb3dzaW5nQ29udGV4dCA9IG51bGxcbiAgICBsZXQgc2FuZGJveCA9IG51bGxcblxuICAgIGlmICgndHlwZScgaW4gaW5wdXQpIHtcbiAgICAgIGxldCB0eXBlU3RyaW5nID0gaW5wdXRbJ3R5cGUnXVxuICAgICAgcmVhbG1UeXBlID0gUmVhbG1UeXBlLmZpbmRCeU5hbWUodHlwZVN0cmluZylcbiAgICB9XG5cbiAgICBpZiAoJ3JlYWxtJyBpbiBpbnB1dCkge1xuICAgICAgcmVhbG1JZCA9IGlucHV0WydyZWFsbSddXG4gICAgfVxuXG4gICAgaWYgKCdvcmlnaW4nIGluIGlucHV0KSB7XG4gICAgICBvcmlnaW4gPSBpbnB1dFsnb3JpZ2luJ11cbiAgICB9XG5cbiAgICBpZiAoJ2NvbnRleHQnIGluIGlucHV0KSB7XG4gICAgICBicm93c2luZ0NvbnRleHQgPSBpbnB1dFsnY29udGV4dCddXG4gICAgfVxuXG4gICAgaWYgKCdzYW5kYm94JyBpbiBpbnB1dCkge1xuICAgICAgc2FuZGJveCA9IGlucHV0WydzYW5kYm94J11cbiAgICB9XG5cbiAgICBpZiAocmVhbG1UeXBlID09PSBSZWFsbVR5cGUuV0lORE9XKSB7XG4gICAgICByZXR1cm4gbmV3IFdpbmRvd1JlYWxtSW5mbyhcbiAgICAgICAgcmVhbG1JZCxcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICByZWFsbVR5cGUsXG4gICAgICAgIGJyb3dzaW5nQ29udGV4dCxcbiAgICAgICAgc2FuZGJveFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVhbG1JbmZvKHJlYWxtSWQsIG9yaWdpbiwgcmVhbG1UeXBlKVxuICB9XG59XG5cbmNsYXNzIFdpbmRvd1JlYWxtSW5mbyBleHRlbmRzIFJlYWxtSW5mbyB7XG4gIGNvbnN0cnVjdG9yKHJlYWxtSWQsIG9yaWdpbiwgcmVhbG1UeXBlLCBicm93c2luZ0NvbnRleHQsIHNhbmRib3ggPSBudWxsKSB7XG4gICAgc3VwZXIocmVhbG1JZCwgb3JpZ2luLCByZWFsbVR5cGUpXG4gICAgdGhpcy5icm93c2luZ0NvbnRleHQgPSBicm93c2luZ0NvbnRleHRcbiAgICB0aGlzLnNhbmRib3ggPSBzYW5kYm94XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlYWxtSW5mbyxcbiAgUmVhbG1UeXBlLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuY29uc3Qge1xuICBFdmFsdWF0ZVJlc3VsdFR5cGUsXG4gIEV2YWx1YXRlUmVzdWx0U3VjY2VzcyxcbiAgRXZhbHVhdGVSZXN1bHRFeGNlcHRpb24sXG4gIEV4Y2VwdGlvbkRldGFpbHMsXG59ID0gcmVxdWlyZSgnLi9ldmFsdWF0ZVJlc3VsdCcpXG5jb25zdCB7IFJlYWxtSW5mbyB9ID0gcmVxdWlyZSgnLi9yZWFsbUluZm8nKVxuY29uc3QgeyBSZW1vdGVWYWx1ZSB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbFZhbHVlJylcbmNvbnN0IHsgV2ViRHJpdmVyRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2xpYi9lcnJvcicpXG5cbmNsYXNzIFNjcmlwdE1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihkcml2ZXIpIHtcbiAgICB0aGlzLl9kcml2ZXIgPSBkcml2ZXJcbiAgfVxuXG4gIGFzeW5jIGluaXQoYnJvd3NpbmdDb250ZXh0SWQpIHtcbiAgICBpZiAoIShhd2FpdCB0aGlzLl9kcml2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCkpLmdldCgnd2ViU29ja2V0VXJsJykpIHtcbiAgICAgIHRocm93IEVycm9yKCdXZWJEcml2ZXIgaW5zdGFuY2UgbXVzdCBzdXBwb3J0IEJpRGkgcHJvdG9jb2wnKVxuICAgIH1cblxuICAgIHRoaXMuYmlkaSA9IGF3YWl0IHRoaXMuX2RyaXZlci5nZXRCaWRpKClcbiAgICB0aGlzLl9icm93c2luZ0NvbnRleHRJZCA9IGJyb3dzaW5nQ29udGV4dElkXG4gIH1cblxuICBhc3luYyBkaXNvd25SZWFsbVNjcmlwdChyZWFsbUlkLCBoYW5kbGVzKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgbWV0aG9kOiAnc2NyaXB0LmRpc293bicsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgaGFuZGxlczogaGFuZGxlcyxcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgcmVhbG06IHJlYWxtSWQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuYmlkaS5zZW5kKHBhcmFtcylcbiAgfVxuXG4gIGFzeW5jIGRpc293bkJyb3dzaW5nQ29udGV4dFNjcmlwdChcbiAgICBicm93c2luZ0NvbnRleHRJZCxcbiAgICBoYW5kbGVzLFxuICAgIHNhbmRib3ggPSBudWxsXG4gICkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIG1ldGhvZDogJ3NjcmlwdC5kaXNvd24nLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGhhbmRsZXM6IGhhbmRsZXMsXG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIGNvbnRleHQ6IGJyb3dzaW5nQ29udGV4dElkLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBpZiAoc2FuZGJveCAhPSBudWxsKSB7XG4gICAgICBwYXJhbXMucGFyYW1zLnRhcmdldFsnc2FuZGJveCddID0gc2FuZGJveFxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuYmlkaS5zZW5kKHBhcmFtcylcbiAgfVxuXG4gIGFzeW5jIGNhbGxGdW5jdGlvbkluUmVhbG0oXG4gICAgcmVhbG1JZCxcbiAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgIGF3YWl0UHJvbWlzZSxcbiAgICBhcmd1bWVudFZhbHVlTGlzdCA9IG51bGwsXG4gICAgdGhpc1BhcmFtZXRlciA9IG51bGwsXG4gICAgcmVzdWx0T3duZXJzaGlwID0gbnVsbFxuICApIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldENhbGxGdW5jdGlvblBhcmFtcyhcbiAgICAgICdyZWFsbScsXG4gICAgICByZWFsbUlkLFxuICAgICAgbnVsbCxcbiAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICBhd2FpdFByb21pc2UsXG4gICAgICBhcmd1bWVudFZhbHVlTGlzdCxcbiAgICAgIHRoaXNQYXJhbWV0ZXIsXG4gICAgICByZXN1bHRPd25lcnNoaXBcbiAgICApXG5cbiAgICBjb25zdCBjb21tYW5kID0ge1xuICAgICAgbWV0aG9kOiAnc2NyaXB0LmNhbGxGdW5jdGlvbicsXG4gICAgICBwYXJhbXMsXG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iaWRpLnNlbmQoY29tbWFuZClcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFdmFsdWF0ZVJlc3VsdChyZXNwb25zZSlcbiAgfVxuXG4gIGFzeW5jIGNhbGxGdW5jdGlvbkluQnJvd3NpbmdDb250ZXh0KFxuICAgIGJyb3dzaW5nQ29udGV4dElkLFxuICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgYXdhaXRQcm9taXNlLFxuICAgIGFyZ3VtZW50VmFsdWVMaXN0ID0gbnVsbCxcbiAgICB0aGlzUGFyYW1ldGVyID0gbnVsbCxcbiAgICByZXN1bHRPd25lcnNoaXAgPSBudWxsLFxuICAgIHNhbmRib3ggPSBudWxsXG4gICkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0Q2FsbEZ1bmN0aW9uUGFyYW1zKFxuICAgICAgJ2NvbnRleHRUYXJnZXQnLFxuICAgICAgYnJvd3NpbmdDb250ZXh0SWQsXG4gICAgICBzYW5kYm94LFxuICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgIGF3YWl0UHJvbWlzZSxcbiAgICAgIGFyZ3VtZW50VmFsdWVMaXN0LFxuICAgICAgdGhpc1BhcmFtZXRlcixcbiAgICAgIHJlc3VsdE93bmVyc2hpcFxuICAgIClcblxuICAgIGNvbnN0IGNvbW1hbmQgPSB7XG4gICAgICBtZXRob2Q6ICdzY3JpcHQuY2FsbEZ1bmN0aW9uJyxcbiAgICAgIHBhcmFtcyxcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChjb21tYW5kKVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUV2YWx1YXRlUmVzdWx0KHJlc3BvbnNlKVxuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGVGdW5jdGlvbkluUmVhbG0oXG4gICAgcmVhbG1JZCxcbiAgICBleHByZXNzaW9uLFxuICAgIGF3YWl0UHJvbWlzZSxcbiAgICByZXN1bHRPd25lcnNoaXAgPSBudWxsXG4gICkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0RXZhbHVhdGVQYXJhbXMoXG4gICAgICAncmVhbG0nLFxuICAgICAgcmVhbG1JZCxcbiAgICAgIG51bGwsXG4gICAgICBleHByZXNzaW9uLFxuICAgICAgYXdhaXRQcm9taXNlLFxuICAgICAgcmVzdWx0T3duZXJzaGlwXG4gICAgKVxuXG4gICAgY29uc3QgY29tbWFuZCA9IHtcbiAgICAgIG1ldGhvZDogJ3NjcmlwdC5ldmFsdWF0ZScsXG4gICAgICBwYXJhbXMsXG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iaWRpLnNlbmQoY29tbWFuZClcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFdmFsdWF0ZVJlc3VsdChyZXNwb25zZSlcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlRnVuY3Rpb25JbkJyb3dzaW5nQ29udGV4dChcbiAgICBicm93c2luZ0NvbnRleHRJZCxcbiAgICBleHByZXNzaW9uLFxuICAgIGF3YWl0UHJvbWlzZSxcbiAgICByZXN1bHRPd25lcnNoaXAgPSBudWxsLFxuICAgIHNhbmRib3ggPSBudWxsXG4gICkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0RXZhbHVhdGVQYXJhbXMoXG4gICAgICAnY29udGV4dFRhcmdldCcsXG4gICAgICBicm93c2luZ0NvbnRleHRJZCxcbiAgICAgIHNhbmRib3gsXG4gICAgICBleHByZXNzaW9uLFxuICAgICAgYXdhaXRQcm9taXNlLFxuICAgICAgcmVzdWx0T3duZXJzaGlwXG4gICAgKVxuXG4gICAgY29uc3QgY29tbWFuZCA9IHtcbiAgICAgIG1ldGhvZDogJ3NjcmlwdC5ldmFsdWF0ZScsXG4gICAgICBwYXJhbXMsXG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iaWRpLnNlbmQoY29tbWFuZClcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFdmFsdWF0ZVJlc3VsdChyZXNwb25zZSlcbiAgfVxuXG4gIGFzeW5jIGFkZFByZWxvYWRTY3JpcHQoXG4gICAgZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICBhcmd1bWVudFZhbHVlTGlzdCA9IG51bGwsXG4gICAgc2FuZGJveCA9IG51bGxcbiAgKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgIGFyZ3VtZW50czogYXJndW1lbnRWYWx1ZUxpc3QsXG4gICAgICBzYW5kYm94OiBzYW5kYm94LFxuICAgIH1cblxuICAgIGNvbnN0IGNvbW1hbmQgPSB7XG4gICAgICBtZXRob2Q6ICdzY3JpcHQuYWRkUHJlbG9hZFNjcmlwdCcsXG4gICAgICBwYXJhbXMsXG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iaWRpLnNlbmQoY29tbWFuZClcbiAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0LnNjcmlwdFxuICB9XG5cbiAgYXN5bmMgcmVtb3ZlUHJlbG9hZFNjcmlwdChzY3JpcHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IHNjcmlwdDogc2NyaXB0IH1cbiAgICBjb25zdCBjb21tYW5kID0ge1xuICAgICAgbWV0aG9kOiAnc2NyaXB0LnJlbW92ZVByZWxvYWRTY3JpcHQnLFxuICAgICAgcGFyYW1zLFxuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChjb21tYW5kKVxuICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgV2ViRHJpdmVyRXJyb3IocmVzcG9uc2UuZXJyb3IpXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5yZXN1bHRcbiAgfVxuXG4gIGdldENhbGxGdW5jdGlvblBhcmFtcyhcbiAgICB0YXJnZXRUeXBlLFxuICAgIGlkLFxuICAgIHNhbmRib3gsXG4gICAgZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICBhd2FpdFByb21pc2UsXG4gICAgYXJndW1lbnRWYWx1ZUxpc3QgPSBudWxsLFxuICAgIHRoaXNQYXJhbWV0ZXIgPSBudWxsLFxuICAgIHJlc3VsdE93bmVyc2hpcCA9IG51bGxcbiAgKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgIGF3YWl0UHJvbWlzZTogYXdhaXRQcm9taXNlLFxuICAgIH1cbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ2NvbnRleHRUYXJnZXQnKSB7XG4gICAgICBpZiAoc2FuZGJveCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtc1sndGFyZ2V0J10gPSB7IGNvbnRleHQ6IGlkLCBzYW5kYm94OiBzYW5kYm94IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtc1sndGFyZ2V0J10gPSB7IGNvbnRleHQ6IGlkIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zWyd0YXJnZXQnXSA9IHsgcmVhbG06IGlkIH1cbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRWYWx1ZUxpc3QgIT0gbnVsbCkge1xuICAgICAgbGV0IGFyZ3VtZW50UGFyYW1zID0gW11cbiAgICAgIGFyZ3VtZW50VmFsdWVMaXN0LmZvckVhY2goKGFyZ3VtZW50VmFsdWUpID0+IHtcbiAgICAgICAgYXJndW1lbnRQYXJhbXMucHVzaChhcmd1bWVudFZhbHVlLmFzTWFwKCkpXG4gICAgICB9KVxuICAgICAgcGFyYW1zWydhcmd1bWVudHMnXSA9IGFyZ3VtZW50UGFyYW1zXG4gICAgfVxuXG4gICAgaWYgKHRoaXNQYXJhbWV0ZXIgIT0gbnVsbCkge1xuICAgICAgcGFyYW1zWyd0aGlzJ10gPSB0aGlzUGFyYW1ldGVyXG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdE93bmVyc2hpcCAhPSBudWxsKSB7XG4gICAgICBwYXJhbXNbJ3Jlc3VsdE93bmVyc2hpcCddID0gcmVzdWx0T3duZXJzaGlwXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgZ2V0RXZhbHVhdGVQYXJhbXMoXG4gICAgdGFyZ2V0VHlwZSxcbiAgICBpZCxcbiAgICBzYW5kYm94LFxuICAgIGV4cHJlc3Npb24sXG4gICAgYXdhaXRQcm9taXNlLFxuICAgIHJlc3VsdE93bmVyc2hpcCA9IG51bGxcbiAgKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgIGF3YWl0UHJvbWlzZTogYXdhaXRQcm9taXNlLFxuICAgIH1cbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ2NvbnRleHRUYXJnZXQnKSB7XG4gICAgICBpZiAoc2FuZGJveCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtc1sndGFyZ2V0J10gPSB7IGNvbnRleHQ6IGlkLCBzYW5kYm94OiBzYW5kYm94IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtc1sndGFyZ2V0J10gPSB7IGNvbnRleHQ6IGlkIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zWyd0YXJnZXQnXSA9IHsgcmVhbG06IGlkIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdE93bmVyc2hpcCAhPSBudWxsKSB7XG4gICAgICBwYXJhbXNbJ3Jlc3VsdE93bmVyc2hpcCddID0gcmVzdWx0T3duZXJzaGlwXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgY3JlYXRlRXZhbHVhdGVSZXN1bHQocmVzcG9uc2UpIHtcbiAgICB2YXIgdHlwZSA9IHJlc3BvbnNlLnJlc3VsdC50eXBlXG4gICAgdmFyIHJlYWxtSWQgPSByZXNwb25zZS5yZXN1bHQucmVhbG1cbiAgICB2YXIgZXZhbHVhdGVSZXN1bHRcblxuICAgIGlmICh0eXBlID09PSBFdmFsdWF0ZVJlc3VsdFR5cGUuU1VDQ0VTUykge1xuICAgICAgdmFyIHJlc3VsdCA9IHJlc3BvbnNlLnJlc3VsdC5yZXN1bHRcbiAgICAgIGV2YWx1YXRlUmVzdWx0ID0gbmV3IEV2YWx1YXRlUmVzdWx0U3VjY2VzcyhcbiAgICAgICAgcmVhbG1JZCxcbiAgICAgICAgbmV3IFJlbW90ZVZhbHVlKHJlc3VsdClcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4Y2VwdGlvbkRldGFpbHMgPSByZXNwb25zZS5yZXN1bHQuZXhjZXB0aW9uRGV0YWlsc1xuICAgICAgZXZhbHVhdGVSZXN1bHQgPSBuZXcgRXZhbHVhdGVSZXN1bHRFeGNlcHRpb24oXG4gICAgICAgIHJlYWxtSWQsXG4gICAgICAgIG5ldyBFeGNlcHRpb25EZXRhaWxzKGV4Y2VwdGlvbkRldGFpbHMpXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0ZVJlc3VsdFxuICB9XG5cbiAgcmVhbG1JbmZvTWFwcGVyKHJlYWxtcykge1xuICAgIHZhciByZWFsbXNMaXN0ID0gW11cbiAgICByZWFsbXMuZm9yRWFjaCgocmVhbG0pID0+IHtcbiAgICAgIHJlYWxtc0xpc3QucHVzaChSZWFsbUluZm8uZnJvbUpzb24ocmVhbG0pKVxuICAgIH0pXG4gICAgcmV0dXJuIHJlYWxtc0xpc3RcbiAgfVxuXG4gIGFzeW5jIGdldEFsbFJlYWxtcygpIHtcbiAgICBjb25zdCBjb21tYW5kID0ge1xuICAgICAgbWV0aG9kOiAnc2NyaXB0LmdldFJlYWxtcycsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChjb21tYW5kKVxuICAgIHJldHVybiB0aGlzLnJlYWxtSW5mb01hcHBlcihyZXNwb25zZS5yZXN1bHQucmVhbG1zKVxuICB9XG5cbiAgYXN5bmMgZ2V0UmVhbG1zQnlUeXBlKHR5cGUpIHtcbiAgICBjb25zdCBjb21tYW5kID0ge1xuICAgICAgbWV0aG9kOiAnc2NyaXB0LmdldFJlYWxtcycsXG4gICAgICBwYXJhbXM6IHsgdHlwZTogdHlwZSB9LFxuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChjb21tYW5kKVxuICAgIHJldHVybiB0aGlzLnJlYWxtSW5mb01hcHBlcihyZXNwb25zZS5yZXN1bHQucmVhbG1zKVxuICB9XG5cbiAgYXN5bmMgZ2V0UmVhbG1zSW5Ccm93c2luZ0NvbnRleHQoYnJvd3NpbmdDb250ZXh0KSB7XG4gICAgY29uc3QgY29tbWFuZCA9IHtcbiAgICAgIG1ldGhvZDogJ3NjcmlwdC5nZXRSZWFsbXMnLFxuICAgICAgcGFyYW1zOiB7IGNvbnRleHQ6IGJyb3dzaW5nQ29udGV4dCB9LFxuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChjb21tYW5kKVxuICAgIHJldHVybiB0aGlzLnJlYWxtSW5mb01hcHBlcihyZXNwb25zZS5yZXN1bHQucmVhbG1zKVxuICB9XG5cbiAgYXN5bmMgZ2V0UmVhbG1zSW5Ccm93c2luZ0NvbnRleHRCeVR5cGUoYnJvd3NpbmdDb250ZXh0LCB0eXBlKSB7XG4gICAgY29uc3QgY29tbWFuZCA9IHtcbiAgICAgIG1ldGhvZDogJ3NjcmlwdC5nZXRSZWFsbXMnLFxuICAgICAgcGFyYW1zOiB7IGNvbnRleHQ6IGJyb3dzaW5nQ29udGV4dCwgdHlwZTogdHlwZSB9LFxuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpZGkuc2VuZChjb21tYW5kKVxuICAgIHJldHVybiB0aGlzLnJlYWxtSW5mb01hcHBlcihyZXNwb25zZS5yZXN1bHQucmVhbG1zKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFNjcmlwdE1hbmFnZXJJbnN0YW5jZShicm93c2luZ0NvbnRleHRJZCwgZHJpdmVyKSB7XG4gIGxldCBpbnN0YW5jZSA9IG5ldyBTY3JpcHRNYW5hZ2VyKGRyaXZlcilcbiAgYXdhaXQgaW5zdGFuY2UuaW5pdChicm93c2luZ0NvbnRleHRJZClcbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U2NyaXB0TWFuYWdlckluc3RhbmNlXG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBhIHtAbGlua3BsYWluIERyaXZlciBXZWJEcml2ZXJ9IGNsaWVudCBmb3IgdGhlIENocm9tZVxuICogd2ViIGJyb3dzZXIuIEJlZm9yZSB1c2luZyB0aGlzIG1vZHVsZSwgeW91IG11c3QgZG93bmxvYWQgdGhlIGxhdGVzdFxuICogW0Nocm9tZURyaXZlciByZWxlYXNlXSBhbmQgZW5zdXJlIGl0IGNhbiBiZSBmb3VuZCBvbiB5b3VyIHN5c3RlbSBbUEFUSF0uXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHByaW1hcnkgY2xhc3NlcyBleHBvcnRlZCBieSB0aGlzIG1vZHVsZTpcbiAqXG4gKiAxLiB7QGxpbmtwbGFpbiBTZXJ2aWNlQnVpbGRlcn06IGNvbmZpZ3VyZXMgdGhlXG4gKiAgICAge0BsaW5rIHNlbGVuaXVtLXdlYmRyaXZlci9yZW1vdGUuRHJpdmVyU2VydmljZSByZW1vdGUuRHJpdmVyU2VydmljZX1cbiAqICAgICB0aGF0IG1hbmFnZXMgdGhlIFtDaHJvbWVEcml2ZXJdIGNoaWxkIHByb2Nlc3MuXG4gKlxuICogMi4ge0BsaW5rcGxhaW4gT3B0aW9uc306IGRlZmluZXMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBlYWNoIG5ldyBDaHJvbWVcbiAqICAgICBzZXNzaW9uLCBzdWNoIGFzIHdoaWNoIHtAbGlua3BsYWluIE9wdGlvbnMjc2V0UHJveHkgcHJveHl9IHRvIHVzZSxcbiAqICAgICB3aGF0IHtAbGlua3BsYWluIE9wdGlvbnMjYWRkRXh0ZW5zaW9ucyBleHRlbnNpb25zfSB0byBpbnN0YWxsLCBvclxuICogICAgIHdoYXQge0BsaW5rcGxhaW4gT3B0aW9ucyNhZGRBcmd1bWVudHMgY29tbWFuZC1saW5lIHN3aXRjaGVzfSB0byB1c2Ugd2hlblxuICogICAgIHN0YXJ0aW5nIHRoZSBicm93c2VyLlxuICpcbiAqIDMuIHtAbGlua3BsYWluIERyaXZlcn06IHRoZSBXZWJEcml2ZXIgY2xpZW50OyBlYWNoIG5ldyBpbnN0YW5jZSB3aWxsIGNvbnRyb2xcbiAqICAgICBhIHVuaXF1ZSBicm93c2VyIHNlc3Npb24gd2l0aCBhIGNsZWFuIHVzZXIgcHJvZmlsZSAodW5sZXNzIG90aGVyd2lzZVxuICogICAgIGNvbmZpZ3VyZWQgdGhyb3VnaCB0aGUge0BsaW5rIE9wdGlvbnN9IGNsYXNzKS5cbiAqXG4gKiBfX0hlYWRsZXNzIENocm9tZV9fIDxhIGlkPVwiaGVhZGxlc3NcIj48L2E+XG4gKlxuICogVG8gc3RhcnQgQ2hyb21lIGluIGhlYWRsZXNzIG1vZGUsIHNpbXBseSBjYWxsXG4gKiB7QGxpbmtwbGFpbiBPcHRpb25zI2hlYWRsZXNzIE9wdGlvbnMuaGVhZGxlc3MoKX0uXG4gKlxuICogICAgIGxldCBjaHJvbWUgPSByZXF1aXJlKCdzZWxlbml1bS13ZWJkcml2ZXIvY2hyb21lJyk7XG4gKiAgICAgbGV0IHtCdWlsZGVyfSA9IHJlcXVpcmUoJ3NlbGVuaXVtLXdlYmRyaXZlcicpO1xuICpcbiAqICAgICBsZXQgZHJpdmVyID0gbmV3IEJ1aWxkZXIoKVxuICogICAgICAgICAuZm9yQnJvd3NlcignY2hyb21lJylcbiAqICAgICAgICAgLnNldENocm9tZU9wdGlvbnMobmV3IGNocm9tZS5PcHRpb25zKCkuaGVhZGxlc3MoKSlcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogX19DdXN0b21pemluZyB0aGUgQ2hyb21lRHJpdmVyIFNlcnZlcl9fIDxhIGlkPVwiY3VzdG9tLXNlcnZlclwiPjwvYT5cbiAqXG4gKiBCeSBkZWZhdWx0LCBldmVyeSBDaHJvbWUgc2Vzc2lvbiB3aWxsIHVzZSBhIHNpbmdsZSBkcml2ZXIgc2VydmljZSwgd2hpY2ggaXNcbiAqIHN0YXJ0ZWQgdGhlIGZpcnN0IHRpbWUgYSB7QGxpbmsgRHJpdmVyfSBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCB0ZXJtaW5hdGVkXG4gKiB3aGVuIHRoaXMgcHJvY2VzcyBleGl0cy4gVGhlIGRlZmF1bHQgc2VydmljZSB3aWxsIGluaGVyaXQgaXRzIGVudmlyb25tZW50XG4gKiBmcm9tIHRoZSBjdXJyZW50IHByb2Nlc3MgYW5kIGRpcmVjdCBhbGwgb3V0cHV0IHRvIC9kZXYvbnVsbC4gWW91IG1heSBvYnRhaW5cbiAqIGEgaGFuZGxlIHRvIHRoaXMgZGVmYXVsdCBzZXJ2aWNlIHVzaW5nXG4gKiB7QGxpbmsgI2dldERlZmF1bHRTZXJ2aWNlIGdldERlZmF1bHRTZXJ2aWNlKCl9IGFuZCBjaGFuZ2UgaXRzIGNvbmZpZ3VyYXRpb25cbiAqIHdpdGgge0BsaW5rICNzZXREZWZhdWx0U2VydmljZSBzZXREZWZhdWx0U2VydmljZSgpfS5cbiAqXG4gKiBZb3UgbWF5IGFsc28gY3JlYXRlIGEge0BsaW5rIERyaXZlcn0gd2l0aCBpdHMgb3duIGRyaXZlciBzZXJ2aWNlLiBUaGlzIGlzXG4gKiB1c2VmdWwgaWYgeW91IG5lZWQgdG8gY2FwdHVyZSB0aGUgc2VydmVyJ3MgbG9nIG91dHB1dCBmb3IgYSBzcGVjaWZpYyBzZXNzaW9uOlxuICpcbiAqICAgICBsZXQgY2hyb21lID0gcmVxdWlyZSgnc2VsZW5pdW0td2ViZHJpdmVyL2Nocm9tZScpO1xuICpcbiAqICAgICBsZXQgc2VydmljZSA9IG5ldyBjaHJvbWUuU2VydmljZUJ1aWxkZXIoKVxuICogICAgICAgICAubG9nZ2luZ1RvKCcvbXkvbG9nL2ZpbGUudHh0JylcbiAqICAgICAgICAgLmVuYWJsZVZlcmJvc2VMb2dnaW5nKClcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogICAgIGxldCBvcHRpb25zID0gbmV3IGNocm9tZS5PcHRpb25zKCk7XG4gKiAgICAgLy8gY29uZmlndXJlIGJyb3dzZXIgb3B0aW9ucyAuLi5cbiAqXG4gKiAgICAgbGV0IGRyaXZlciA9IGNocm9tZS5Ecml2ZXIuY3JlYXRlU2Vzc2lvbihvcHRpb25zLCBzZXJ2aWNlKTtcbiAqXG4gKiBVc2VycyBzaG91bGQgb25seSBpbnN0YW50aWF0ZSB0aGUge0BsaW5rIERyaXZlcn0gY2xhc3MgZGlyZWN0bHkgd2hlbiB0aGV5XG4gKiBuZWVkIGEgY3VzdG9tIGRyaXZlciBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gKGFzIHNob3duIGFib3ZlKS4gRm9yIG5vcm1hbFxuICogb3BlcmF0aW9uLCB1c2VycyBzaG91bGQgc3RhcnQgQ2hyb21lIHVzaW5nIHRoZVxuICoge0BsaW5rIHNlbGVuaXVtLXdlYmRyaXZlci5CdWlsZGVyfS5cbiAqXG4gKiBfX1dvcmtpbmcgd2l0aCBBbmRyb2lkX18gPGEgaWQ9XCJhbmRyb2lkXCI+PC9hPlxuICpcbiAqIFRoZSBbQ2hyb21lRHJpdmVyXVthbmRyb2lkXSBzdXBwb3J0cyBydW5uaW5nIHRlc3RzIG9uIHRoZSBDaHJvbWUgYnJvd3NlciBhc1xuICogd2VsbCBhcyBbV2ViVmlldyBhcHBzXVt3ZWJ2aWV3XSBzdGFydGluZyBpbiBBbmRyb2lkIDQuNCAoS2l0S2F0KS4gSW4gb3JkZXIgdG9cbiAqIHdvcmsgd2l0aCBBbmRyb2lkLCB5b3UgbXVzdCBmaXJzdCBzdGFydCB0aGUgYWRiXG4gKlxuICogICAgIGFkYiBzdGFydC1zZXJ2ZXJcbiAqXG4gKiBCeSBkZWZhdWx0LCBhZGIgd2lsbCBzdGFydCBvbiBwb3J0IDUwMzcuIFlvdSBtYXkgY2hhbmdlIHRoaXMgcG9ydCwgYnV0IHRoaXNcbiAqIHdpbGwgcmVxdWlyZSBjb25maWd1cmluZyBhIFtjdXN0b20gc2VydmVyXSgjY3VzdG9tLXNlcnZlcikgdGhhdCB3aWxsIGNvbm5lY3RcbiAqIHRvIGFkYiBvbiB0aGUge0BsaW5rcGxhaW4gU2VydmljZUJ1aWxkZXIjc2V0QWRiUG9ydCBjb3JyZWN0IHBvcnR9OlxuICpcbiAqICAgICBsZXQgc2VydmljZSA9IG5ldyBjaHJvbWUuU2VydmljZUJ1aWxkZXIoKVxuICogICAgICAgICAuc2V0QWRiUG9ydCgxMjM0KVxuICogICAgICAgICBidWlsZCgpO1xuICogICAgIC8vIGV0Yy5cbiAqXG4gKiBUaGUgQ2hyb21lRHJpdmVyIG1heSBiZSBjb25maWd1cmVkIHRvIGxhdW5jaCBDaHJvbWUgb24gQW5kcm9pZCB1c2luZ1xuICoge0BsaW5rIE9wdGlvbnMjYW5kcm9pZENocm9tZSgpfTpcbiAqXG4gKiAgICAgbGV0IGRyaXZlciA9IG5ldyBCdWlsZGVyKClcbiAqICAgICAgICAgLmZvckJyb3dzZXIoJ2Nocm9tZScpXG4gKiAgICAgICAgIC5zZXRDaHJvbWVPcHRpb25zKG5ldyBjaHJvbWUuT3B0aW9ucygpLmFuZHJvaWRDaHJvbWUoKSlcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBjb25maWd1cmUgdGhlIENocm9tZURyaXZlciB0byBsYXVuY2ggYW4gYXBwIHdpdGggYVxuICogQ2hyb21lLVdlYlZpZXcgYnkgc2V0dGluZyB0aGUge0BsaW5rcGxhaW4gT3B0aW9ucyNhbmRyb2lkQWN0aXZpdHlcbiAqIGFuZHJvaWRBY3Rpdml0eX0gb3B0aW9uOlxuICpcbiAqICAgICBsZXQgZHJpdmVyID0gbmV3IEJ1aWxkZXIoKVxuICogICAgICAgICAuZm9yQnJvd3NlcignY2hyb21lJylcbiAqICAgICAgICAgLnNldENocm9tZU9wdGlvbnMobmV3IGNocm9tZS5PcHRpb25zKClcbiAqICAgICAgICAgICAgIC5hbmRyb2lkUGFja2FnZSgnY29tLmV4YW1wbGUnKVxuICogICAgICAgICAgICAgLmFuZHJvaWRBY3Rpdml0eSgnY29tLmV4YW1wbGUuQWN0aXZpdHknKSlcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogW1JlZmVyIHRvIHRoZSBDaHJvbWVEcml2ZXIgc2l0ZV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdXNpbmcgdGhlXG4gKiBbQ2hyb21lRHJpdmVyIHdpdGggQW5kcm9pZF1bYW5kcm9pZF0uXG4gKlxuICogW0Nocm9tZURyaXZlcl06IGh0dHBzOi8vY2hyb21lZHJpdmVyLmNocm9taXVtLm9yZy9cbiAqIFtDaHJvbWVEcml2ZXIgcmVsZWFzZV06IGh0dHA6Ly9jaHJvbWVkcml2ZXIuc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9pbmRleC5odG1sXG4gKiBbUEFUSF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUEFUSF8lMjh2YXJpYWJsZSUyOVxuICogW2FuZHJvaWRdOiBodHRwczovL2Nocm9tZWRyaXZlci5jaHJvbWl1bS5vcmcvZ2V0dGluZy1zdGFydGVkL2dldHRpbmctc3RhcnRlZC0tLWFuZHJvaWRcbiAqIFt3ZWJ2aWV3XTogaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9tdWx0aWRldmljZS93ZWJ2aWV3L292ZXJ2aWV3XG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlvID0gcmVxdWlyZSgnLi9pbycpXG5jb25zdCB7IEJyb3dzZXIgfSA9IHJlcXVpcmUoJy4vbGliL2NhcGFiaWxpdGllcycpXG5jb25zdCBjaHJvbWl1bSA9IHJlcXVpcmUoJy4vY2hyb21pdW0nKVxuXG4vKipcbiAqIE5hbWUgb2YgdGhlIENocm9tZURyaXZlciBleGVjdXRhYmxlLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5jb25zdCBDSFJPTUVEUklWRVJfRVhFID1cbiAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdjaHJvbWVkcml2ZXIuZXhlJyA6ICdjaHJvbWVkcml2ZXInXG5cbi8qKiBAdHlwZSB7cmVtb3RlLkRyaXZlclNlcnZpY2V9ICovXG5cbi8qKlxuICogQ3JlYXRlcyB7QGxpbmsgc2VsZW5pdW0td2ViZHJpdmVyL3JlbW90ZS5Ecml2ZXJTZXJ2aWNlfSBpbnN0YW5jZXMgdGhhdCBtYW5hZ2VcbiAqIGEgW0Nocm9tZURyaXZlcl0oaHR0cHM6Ly9jaHJvbWVkcml2ZXIuY2hyb21pdW0ub3JnLylcbiAqIHNlcnZlciBpbiBhIGNoaWxkIHByb2Nlc3MuXG4gKi9cbmNsYXNzIFNlcnZpY2VCdWlsZGVyIGV4dGVuZHMgY2hyb21pdW0uU2VydmljZUJ1aWxkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZXhlIFBhdGggdG8gdGhlIHNlcnZlciBleGVjdXRhYmxlIHRvIHVzZS4gSWYgb21pdHRlZCxcbiAgICogICAgIHRoZSBidWlsZGVyIHdpbGwgYXR0ZW1wdCB0byBsb2NhdGUgdGhlIGNocm9tZWRyaXZlciBvbiB0aGUgY3VycmVudFxuICAgKiAgICAgUEFUSC4gSWYgdGhlIGNocm9tZWRyaXZlciBpcyBub3QgYXZhaWxhYmxlIGluIHBhdGgsIHNlbGVuaXVtLW1hbmFnZXIgd2lsbFxuICAgKiAgICAgZG93bmxvYWQgdGhlIGNocm9tZWRyaXZlclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcHJvdmlkZWQgZXhlY3V0YWJsZSBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGNocm9tZWRyaXZlclxuICAgKiAgICAgY2Fubm90IGJlIGZvdW5kIG9uIHRoZSBQQVRILlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X2V4ZSkge1xuICAgIGxldCBleGUgPSBvcHRfZXhlIHx8IGxvY2F0ZVN5bmNocm9ub3VzbHkoKVxuICAgIHN1cGVyKGV4ZSlcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIGZvciBtYW5hZ2luZyBDaHJvbWVEcml2ZXIgc3BlY2lmaWMgb3B0aW9ucy5cbiAqL1xuY2xhc3MgT3B0aW9ucyBleHRlbmRzIGNocm9taXVtLk9wdGlvbnMge1xuICAvKipcbiAgICogU2V0cyB0aGUgcGF0aCB0byB0aGUgQ2hyb21lIGJpbmFyeSB0byB1c2UuIE9uIE1hYyBPUyBYLCB0aGlzIHBhdGggc2hvdWxkXG4gICAqIHJlZmVyZW5jZSB0aGUgYWN0dWFsIENocm9tZSBleGVjdXRhYmxlLCBub3QganVzdCB0aGUgYXBwbGljYXRpb24gYmluYXJ5XG4gICAqIChlLmcuIFwiL0FwcGxpY2F0aW9ucy9Hb29nbGUgQ2hyb21lLmFwcC9Db250ZW50cy9NYWNPUy9Hb29nbGUgQ2hyb21lXCIpLlxuICAgKlxuICAgKiBUaGUgYmluYXJ5IHBhdGggYmUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8gdGhlIGNocm9tZWRyaXZlciBzZXJ2ZXJcbiAgICogZXhlY3V0YWJsZSwgYnV0IGl0IG11c3QgZXhpc3Qgb24gdGhlIG1hY2hpbmUgdGhhdCB3aWxsIGxhdW5jaCBDaHJvbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBDaHJvbWUgYmluYXJ5IHRvIHVzZS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRDaHJvbWVCaW5hcnlQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRCaW5hcnlQYXRoKHBhdGgpXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgQ2hyb21lRHJpdmVyIHRvIGxhdW5jaCBDaHJvbWUgb24gQW5kcm9pZCB2aWEgYWRiLiBUaGlzXG4gICAqIGZ1bmN0aW9uIGlzIHNob3J0aGFuZCBmb3JcbiAgICoge0BsaW5rICNhbmRyb2lkUGFja2FnZSBvcHRpb25zLmFuZHJvaWRQYWNrYWdlKCdjb20uYW5kcm9pZC5jaHJvbWUnKX0uXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgYW5kcm9pZENocm9tZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmRyb2lkUGFja2FnZSgnY29tLmFuZHJvaWQuY2hyb21lJylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYXRoIHRvIENocm9tZSdzIGxvZyBmaWxlLiBUaGlzIHBhdGggc2hvdWxkIGV4aXN0IG9uIHRoZSBtYWNoaW5lXG4gICAqIHRoYXQgd2lsbCBsYXVuY2ggQ2hyb21lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIHRoZSBsb2cgZmlsZSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0Q2hyb21lTG9nRmlsZShwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QnJvd3NlckxvZ0ZpbGUocGF0aClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJlY3RvcnkgdG8gc3RvcmUgQ2hyb21lIG1pbmlkdW1wcyBpbi4gVGhpcyBvcHRpb24gaXMgb25seVxuICAgKiBzdXBwb3J0ZWQgd2hlbiBDaHJvbWVEcml2ZXIgaXMgcnVubmluZyBvbiBMaW51eC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIGRpcmVjdG9yeSBwYXRoLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNldENocm9tZU1pbmlkdW1wUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QnJvd3Nlck1pbmlkdW1wUGF0aChwYXRoKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBXZWJEcml2ZXIgY2xpZW50IGZvciBDaHJvbWUuXG4gKi9cbmNsYXNzIERyaXZlciBleHRlbmRzIGNocm9taXVtLkRyaXZlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHNlc3Npb24gd2l0aCB0aGUgQ2hyb21lRHJpdmVyLlxuICAgKlxuICAgKiBAcGFyYW0geyhDYXBhYmlsaXRpZXN8T3B0aW9ucyk9fSBvcHRfY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7KHJlbW90ZS5Ecml2ZXJTZXJ2aWNlfGh0dHAuRXhlY3V0b3IpPX0gb3B0X3NlcnZpY2VFeGVjdXRvciBFaXRoZXJcbiAgICogICAgIGEgIERyaXZlclNlcnZpY2UgdG8gdXNlIGZvciB0aGUgcmVtb3RlIGVuZCwgb3IgYSBwcmVjb25maWd1cmVkIGV4ZWN1dG9yXG4gICAqICAgICBmb3IgYW4gZXh0ZXJuYWxseSBtYW5hZ2VkIGVuZHBvaW50LiBJZiBuZWl0aGVyIGlzIHByb3ZpZGVkLCB0aGVcbiAgICogICAgIHtAbGlua3BsYWluICMjZ2V0RGVmYXVsdFNlcnZpY2UgZGVmYXVsdCBzZXJ2aWNlfSB3aWxsIGJlIHVzZWQgYnlcbiAgICogICAgIGRlZmF1bHQuXG4gICAqIEByZXR1cm4geyFEcml2ZXJ9IEEgbmV3IGRyaXZlciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVTZXNzaW9uKG9wdF9jb25maWcsIG9wdF9zZXJ2aWNlRXhlY3V0b3IpIHtcbiAgICBsZXQgY2FwcyA9IG9wdF9jb25maWcgfHwgbmV3IE9wdGlvbnMoKVxuICAgIHJldHVybiAvKiogQHR5cGUgeyFEcml2ZXJ9ICovIChcbiAgICAgIHN1cGVyLmNyZWF0ZVNlc3Npb24oY2Fwcywgb3B0X3NlcnZpY2VFeGVjdXRvcilcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBuZXcgaW5zdGFuY2UgY2hyb21lIGRyaXZlciBzZXJ2aWNlXG4gICAqIEByZXR1cm5zIHtyZW1vdGUuRHJpdmVyU2VydmljZX1cbiAgICovXG4gIHN0YXRpYyBnZXREZWZhdWx0U2VydmljZSgpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZpY2VCdWlsZGVyKCkuYnVpbGQoKVxuICB9XG59XG5cbi8qKlxuICogX1N5bmNocm9ub3VzbHlfIGF0dGVtcHRzIHRvIGxvY2F0ZSB0aGUgY2hyb21lZHJpdmVyIGV4ZWN1dGFibGUgb24gdGhlIGN1cnJlbnRcbiAqIHN5c3RlbS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSB0aGUgbG9jYXRlZCBleGVjdXRhYmxlLCBvciBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGxvY2F0ZVN5bmNocm9ub3VzbHkoKSB7XG4gIHJldHVybiBpby5maW5kSW5QYXRoKENIUk9NRURSSVZFUl9FWEUsIHRydWUpXG59XG5cbk9wdGlvbnMucHJvdG90eXBlLkNBUEFCSUxJVFlfS0VZID0gJ2dvb2c6Y2hyb21lT3B0aW9ucydcbk9wdGlvbnMucHJvdG90eXBlLkJST1dTRVJfTkFNRV9WQUxVRSA9IEJyb3dzZXIuQ0hST01FXG5Ecml2ZXIucHJvdG90eXBlLlZFTkRPUl9DT01NQU5EX1BSRUZJWCA9ICdnb29nJ1xuXG4vLyBQVUJMSUMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRHJpdmVyOiBEcml2ZXIsXG4gIE9wdGlvbnMsXG4gIFNlcnZpY2VCdWlsZGVyLFxuICBsb2NhdGVTeW5jaHJvbm91c2x5LFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmluZXMgYW4gYWJzdHJhY3Qge0BsaW5rcGxhaW4gRHJpdmVyIFdlYkRyaXZlcn0gY2xpZW50IGZvclxuICogQ2hyb21pdW0tYmFzZWQgd2ViIGJyb3dzZXJzLiBUaGVzZSBjbGFzc2VzIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkXG4gKiBkaXJlY3RseS5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgcHJpbWFyeSBjbGFzc2VzIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlOlxuICpcbiAqIDEuIHtAbGlua3BsYWluIFNlcnZpY2VCdWlsZGVyfTogY29uZmlndXJlcyB0aGVcbiAqICAgICB7QGxpbmsgc2VsZW5pdW0td2ViZHJpdmVyL3JlbW90ZS5Ecml2ZXJTZXJ2aWNlIHJlbW90ZS5Ecml2ZXJTZXJ2aWNlfVxuICogICAgIHRoYXQgbWFuYWdlcyBhIFdlYkRyaXZlciBzZXJ2ZXIgY2hpbGQgcHJvY2Vzcy5cbiAqXG4gKiAyLiB7QGxpbmtwbGFpbiBPcHRpb25zfTogZGVmaW5lcyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGVhY2ggbmV3IENocm9taXVtXG4gKiAgICAgc2Vzc2lvbiwgc3VjaCBhcyB3aGljaCB7QGxpbmtwbGFpbiBPcHRpb25zI3NldFByb3h5IHByb3h5fSB0byB1c2UsXG4gKiAgICAgd2hhdCB7QGxpbmtwbGFpbiBPcHRpb25zI2FkZEV4dGVuc2lvbnMgZXh0ZW5zaW9uc30gdG8gaW5zdGFsbCwgb3JcbiAqICAgICB3aGF0IHtAbGlua3BsYWluIE9wdGlvbnMjYWRkQXJndW1lbnRzIGNvbW1hbmQtbGluZSBzd2l0Y2hlc30gdG8gdXNlIHdoZW5cbiAqICAgICBzdGFydGluZyB0aGUgYnJvd3Nlci5cbiAqXG4gKiAzLiB7QGxpbmtwbGFpbiBEcml2ZXJ9OiB0aGUgV2ViRHJpdmVyIGNsaWVudDsgZWFjaCBuZXcgaW5zdGFuY2Ugd2lsbCBjb250cm9sXG4gKiAgICAgYSB1bmlxdWUgYnJvd3NlciBzZXNzaW9uIHdpdGggYSBjbGVhbiB1c2VyIHByb2ZpbGUgKHVubGVzcyBvdGhlcndpc2VcbiAqICAgICBjb25maWd1cmVkIHRocm91Z2ggdGhlIHtAbGluayBPcHRpb25zfSBjbGFzcykuXG4gKlxuICogX19IZWFkbGVzcyBDaHJvbWl1bV9fIDxhIGlkPVwiaGVhZGxlc3NcIj48L2E+XG4gKlxuICogVG8gc3RhcnQgdGhlIGJyb3dzZXIgaW4gaGVhZGxlc3MgbW9kZSwgc2ltcGx5IGNhbGxcbiAqIHtAbGlua3BsYWluIE9wdGlvbnMjaGVhZGxlc3MgT3B0aW9ucy5oZWFkbGVzcygpfS5cbiAqXG4gKiAgICAgbGV0IGNocm9tZSA9IHJlcXVpcmUoJ3NlbGVuaXVtLXdlYmRyaXZlci9jaHJvbWUnKTtcbiAqICAgICBsZXQge0J1aWxkZXJ9ID0gcmVxdWlyZSgnc2VsZW5pdW0td2ViZHJpdmVyJyk7XG4gKlxuICogICAgIGxldCBkcml2ZXIgPSBuZXcgQnVpbGRlcigpXG4gKiAgICAgICAgIC5mb3JCcm93c2VyKCdjaHJvbWUnKVxuICogICAgICAgICAuc2V0Q2hyb21lT3B0aW9ucyhuZXcgY2hyb21lLk9wdGlvbnMoKS5oZWFkbGVzcygpKVxuICogICAgICAgICAuYnVpbGQoKTtcbiAqXG4gKiBfX0N1c3RvbWl6aW5nIHRoZSBDaHJvbWl1bSBXZWJEcml2ZXIgU2VydmVyX18gPGEgaWQ9XCJjdXN0b20tc2VydmVyXCI+PC9hPlxuICpcbiAqIFN1YmNsYXNzZXMgb2Yge0BsaW5rIERyaXZlcn0gYXJlIGV4cGVjdGVkIHRvIHByb3ZpZGUgYSBzdGF0aWNcbiAqIGdldERlZmF1bHRTZXJ2aWNlIG1ldGhvZC4gQnkgZGVmYXVsdCwgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZVxuICogYSB7QGxpbmsgRHJpdmVyfSBpbnN0YW5jZSBpcyBjcmVhdGVkIHRvIG9idGFpbiB0aGUgZGVmYXVsdCBkcml2ZXIgc2VydmljZVxuICogZm9yIHRoYXQgc3BlY2lmaWMgYnJvd3NlciAoZS5nLiBDaHJvbWUgb3IgQ2hyb21pdW0gRWRnZSkuIFN1YmNsYXNzZXMgYXJlXG4gKiByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgdGhlIGxpZmV0aW1lIG9mIHRoZSBkZWZhdWx0IHNlcnZpY2UuXG4gKlxuICogWW91IG1heSBhbHNvIGNyZWF0ZSBhIHtAbGluayBEcml2ZXJ9IHdpdGggaXRzIG93biBkcml2ZXIgc2VydmljZS4gVGhpcyBpc1xuICogdXNlZnVsIGlmIHlvdSBuZWVkIHRvIGNhcHR1cmUgdGhlIHNlcnZlcidzIGxvZyBvdXRwdXQgZm9yIGEgc3BlY2lmaWMgc2Vzc2lvbjpcbiAqXG4gKiAgICAgbGV0IGNocm9tZSA9IHJlcXVpcmUoJ3NlbGVuaXVtLXdlYmRyaXZlci9jaHJvbWUnKTtcbiAqXG4gKiAgICAgbGV0IHNlcnZpY2UgPSBuZXcgY2hyb21lLlNlcnZpY2VCdWlsZGVyKClcbiAqICAgICAgICAgLmxvZ2dpbmdUbygnL215L2xvZy9maWxlLnR4dCcpXG4gKiAgICAgICAgIC5lbmFibGVWZXJib3NlTG9nZ2luZygpXG4gKiAgICAgICAgIC5idWlsZCgpO1xuICpcbiAqICAgICBsZXQgb3B0aW9ucyA9IG5ldyBjaHJvbWUuT3B0aW9ucygpO1xuICogICAgIC8vIGNvbmZpZ3VyZSBicm93c2VyIG9wdGlvbnMgLi4uXG4gKlxuICogICAgIGxldCBkcml2ZXIgPSBjaHJvbWUuRHJpdmVyLmNyZWF0ZVNlc3Npb24ob3B0aW9ucywgc2VydmljZSk7XG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGh0dHAgPSByZXF1aXJlKCcuL2h0dHAnKVxuY29uc3QgaW8gPSByZXF1aXJlKCcuL2lvJylcbmNvbnN0IHsgQ2FwYWJpbGl0aWVzLCBDYXBhYmlsaXR5IH0gPSByZXF1aXJlKCcuL2xpYi9jYXBhYmlsaXRpZXMnKVxuY29uc3QgY29tbWFuZCA9IHJlcXVpcmUoJy4vbGliL2NvbW1hbmQnKVxuY29uc3QgZXJyb3IgPSByZXF1aXJlKCcuL2xpYi9lcnJvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi9saWIvc3ltYm9scycpXG5jb25zdCB3ZWJkcml2ZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJkcml2ZXInKVxuY29uc3QgcmVtb3RlID0gcmVxdWlyZSgnLi9yZW1vdGUnKVxuY29uc3QgeyBnZXRQYXRoIH0gPSByZXF1aXJlKCcuL2NvbW1vbi9kcml2ZXJGaW5kZXInKVxuXG4vKipcbiAqIEN1c3RvbSBjb21tYW5kIG5hbWVzIHN1cHBvcnRlZCBieSBDaHJvbWl1bSBXZWJEcml2ZXIuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBDb21tYW5kID0ge1xuICBMQVVOQ0hfQVBQOiAnbGF1bmNoQXBwJyxcbiAgR0VUX05FVFdPUktfQ09ORElUSU9OUzogJ2dldE5ldHdvcmtDb25kaXRpb25zJyxcbiAgU0VUX05FVFdPUktfQ09ORElUSU9OUzogJ3NldE5ldHdvcmtDb25kaXRpb25zJyxcbiAgREVMRVRFX05FVFdPUktfQ09ORElUSU9OUzogJ2RlbGV0ZU5ldHdvcmtDb25kaXRpb25zJyxcbiAgU0VORF9ERVZUT09MU19DT01NQU5EOiAnc2VuZERldlRvb2xzQ29tbWFuZCcsXG4gIFNFTkRfQU5EX0dFVF9ERVZUT09MU19DT01NQU5EOiAnc2VuZEFuZEdldERldlRvb2xzQ29tbWFuZCcsXG4gIFNFVF9QRVJNSVNTSU9OOiAnc2V0UGVybWlzc2lvbicsXG4gIEdFVF9DQVNUX1NJTktTOiAnZ2V0Q2FzdFNpbmtzJyxcbiAgU0VUX0NBU1RfU0lOS19UT19VU0U6ICdzZXRDYXN0U2lua1RvVXNlJyxcbiAgU1RBUlRfQ0FTVF9ERVNLVE9QX01JUlJPUklORzogJ3N0YXJ0RGVza3RvcE1pcnJvcmluZycsXG4gIFNUQVJUX0NBU1RfVEFCX01JUlJPUklORzogJ3NldENhc3RUYWJNaXJyb3JpbmcnLFxuICBHRVRfQ0FTVF9JU1NVRV9NRVNTQUdFOiAnZ2V0Q2FzdElzc3VlTWVzc2FnZScsXG4gIFNUT1BfQ0FTVElORzogJ3N0b3BDYXN0aW5nJyxcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tbWFuZCBleGVjdXRvciB3aXRoIHN1cHBvcnQgZm9yIENocm9taXVtJ3MgY3VzdG9tIGNvbW1hbmRzLlxuICogQHBhcmFtIHshUHJvbWlzZTxzdHJpbmc+fSB1cmwgVGhlIHNlcnZlcidzIFVSTC5cbiAqIEBwYXJhbSB2ZW5kb3JQcmVmaXhcbiAqIEByZXR1cm4geyFjb21tYW5kLkV4ZWN1dG9yfSBUaGUgbmV3IGNvbW1hbmQgZXhlY3V0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV4ZWN1dG9yKHVybCwgdmVuZG9yUHJlZml4KSB7XG4gIGNvbnN0IGFnZW50ID0gbmV3IGh0dHAuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSlcbiAgY29uc3QgY2xpZW50ID0gdXJsLnRoZW4oKHVybCkgPT4gbmV3IGh0dHAuSHR0cENsaWVudCh1cmwsIGFnZW50KSlcbiAgY29uc3QgZXhlY3V0b3IgPSBuZXcgaHR0cC5FeGVjdXRvcihjbGllbnQpXG4gIGNvbmZpZ3VyZUV4ZWN1dG9yKGV4ZWN1dG9yLCB2ZW5kb3JQcmVmaXgpXG4gIHJldHVybiBleGVjdXRvclxufVxuXG4vKipcbiAqIENvbmZpZ3VyZXMgdGhlIGdpdmVuIGV4ZWN1dG9yIHdpdGggQ2hyb21pdW0tc3BlY2lmaWMgY29tbWFuZHMuXG4gKiBAcGFyYW0geyFodHRwLkV4ZWN1dG9yfSBleGVjdXRvciB0aGUgZXhlY3V0b3IgdG8gY29uZmlndXJlLlxuICovXG5mdW5jdGlvbiBjb25maWd1cmVFeGVjdXRvcihleGVjdXRvciwgdmVuZG9yUHJlZml4KSB7XG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgQ29tbWFuZC5MQVVOQ0hfQVBQLFxuICAgICdQT1NUJyxcbiAgICAnL3Nlc3Npb24vOnNlc3Npb25JZC9jaHJvbWl1bS9sYXVuY2hfYXBwJ1xuICApXG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgQ29tbWFuZC5HRVRfTkVUV09SS19DT05ESVRJT05TLFxuICAgICdHRVQnLFxuICAgICcvc2Vzc2lvbi86c2Vzc2lvbklkL2Nocm9taXVtL25ldHdvcmtfY29uZGl0aW9ucydcbiAgKVxuICBleGVjdXRvci5kZWZpbmVDb21tYW5kKFxuICAgIENvbW1hbmQuU0VUX05FVFdPUktfQ09ORElUSU9OUyxcbiAgICAnUE9TVCcsXG4gICAgJy9zZXNzaW9uLzpzZXNzaW9uSWQvY2hyb21pdW0vbmV0d29ya19jb25kaXRpb25zJ1xuICApXG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgQ29tbWFuZC5ERUxFVEVfTkVUV09SS19DT05ESVRJT05TLFxuICAgICdERUxFVEUnLFxuICAgICcvc2Vzc2lvbi86c2Vzc2lvbklkL2Nocm9taXVtL25ldHdvcmtfY29uZGl0aW9ucydcbiAgKVxuICBleGVjdXRvci5kZWZpbmVDb21tYW5kKFxuICAgIENvbW1hbmQuU0VORF9ERVZUT09MU19DT01NQU5ELFxuICAgICdQT1NUJyxcbiAgICAnL3Nlc3Npb24vOnNlc3Npb25JZC9jaHJvbWl1bS9zZW5kX2NvbW1hbmQnXG4gIClcbiAgZXhlY3V0b3IuZGVmaW5lQ29tbWFuZChcbiAgICBDb21tYW5kLlNFTkRfQU5EX0dFVF9ERVZUT09MU19DT01NQU5ELFxuICAgICdQT1NUJyxcbiAgICAnL3Nlc3Npb24vOnNlc3Npb25JZC9jaHJvbWl1bS9zZW5kX2NvbW1hbmRfYW5kX2dldF9yZXN1bHQnXG4gIClcbiAgZXhlY3V0b3IuZGVmaW5lQ29tbWFuZChcbiAgICBDb21tYW5kLlNFVF9QRVJNSVNTSU9OLFxuICAgICdQT1NUJyxcbiAgICAnL3Nlc3Npb24vOnNlc3Npb25JZC9wZXJtaXNzaW9ucydcbiAgKVxuICBleGVjdXRvci5kZWZpbmVDb21tYW5kKFxuICAgIENvbW1hbmQuR0VUX0NBU1RfU0lOS1MsXG4gICAgJ0dFVCcsXG4gICAgYC9zZXNzaW9uLzpzZXNzaW9uSWQvJHt2ZW5kb3JQcmVmaXh9L2Nhc3QvZ2V0X3NpbmtzYFxuICApXG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgQ29tbWFuZC5TRVRfQ0FTVF9TSU5LX1RPX1VTRSxcbiAgICAnUE9TVCcsXG4gICAgYC9zZXNzaW9uLzpzZXNzaW9uSWQvJHt2ZW5kb3JQcmVmaXh9L2Nhc3Qvc2V0X3NpbmtfdG9fdXNlYFxuICApXG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgQ29tbWFuZC5TVEFSVF9DQVNUX0RFU0tUT1BfTUlSUk9SSU5HLFxuICAgICdQT1NUJyxcbiAgICBgL3Nlc3Npb24vOnNlc3Npb25JZC8ke3ZlbmRvclByZWZpeH0vY2FzdC9zdGFydF9kZXNrdG9wX21pcnJvcmluZ2BcbiAgKVxuICBleGVjdXRvci5kZWZpbmVDb21tYW5kKFxuICAgIENvbW1hbmQuU1RBUlRfQ0FTVF9UQUJfTUlSUk9SSU5HLFxuICAgICdQT1NUJyxcbiAgICBgL3Nlc3Npb24vOnNlc3Npb25JZC8ke3ZlbmRvclByZWZpeH0vY2FzdC9zdGFydF90YWJfbWlycm9yaW5nYFxuICApXG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgQ29tbWFuZC5HRVRfQ0FTVF9JU1NVRV9NRVNTQUdFLFxuICAgICdHRVQnLFxuICAgIGAvc2Vzc2lvbi86c2Vzc2lvbklkLyR7dmVuZG9yUHJlZml4fS9jYXN0L2dldF9pc3N1ZV9tZXNzYWdlYFxuICApXG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgQ29tbWFuZC5TVE9QX0NBU1RJTkcsXG4gICAgJ1BPU1QnLFxuICAgIGAvc2Vzc2lvbi86c2Vzc2lvbklkLyR7dmVuZG9yUHJlZml4fS9jYXN0L3N0b3BfY2FzdGluZ2BcbiAgKVxufVxuXG4vKipcbiAqIENyZWF0ZXMge0BsaW5rIHNlbGVuaXVtLXdlYmRyaXZlci9yZW1vdGUuRHJpdmVyU2VydmljZX0gaW5zdGFuY2VzIHRoYXQgbWFuYWdlXG4gKiBhIFdlYkRyaXZlciBzZXJ2ZXIgaW4gYSBjaGlsZCBwcm9jZXNzLlxuICovXG5jbGFzcyBTZXJ2aWNlQnVpbGRlciBleHRlbmRzIHJlbW90ZS5Ecml2ZXJTZXJ2aWNlLkJ1aWxkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBleGUgUGF0aCB0byB0aGUgc2VydmVyIGV4ZWN1dGFibGUgdG8gdXNlLiBTdWJjbGFzc2VzXG4gICAqIHNob3VsZCBlbnN1cmUgYSB2YWxpZCBwYXRoIHRvIHRoZSBhcHByb3ByaWF0ZSBleGUgaXMgcHJvdmlkZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleGUpIHtcbiAgICBzdXBlcihleGUpXG4gICAgdGhpcy5zZXRMb29wYmFjayh0cnVlKSAvLyBSZXF1aXJlZFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hpY2ggcG9ydCBhZGIgaXMgbGlzdGVuaW5nIHRvLiBfVGhlIGRyaXZlciB3aWxsIGNvbm5lY3QgdG8gYWRiXG4gICAqIGlmIGFuIHtAbGlua3BsYWluIE9wdGlvbnMjYW5kcm9pZFBhY2thZ2UgQW5kcm9pZCBzZXNzaW9ufSBpcyByZXF1ZXN0ZWQsIGJ1dFxuICAgKiBhZGIgKiptdXN0KiogYmUgc3RhcnRlZCBiZWZvcmVoYW5kLl9cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnQgV2hpY2ggcG9ydCBhZGIgaXMgcnVubmluZyBvbi5cbiAgICogQHJldHVybiB7IVNlcnZpY2VCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0QWRiUG9ydChwb3J0KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQXJndW1lbnRzKCctLWFkYi1wb3J0PScgKyBwb3J0KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhdGggb2YgdGhlIGxvZyBmaWxlIHRoZSBkcml2ZXIgc2hvdWxkIGxvZyB0by4gSWYgYSBsb2cgZmlsZSBpc1xuICAgKiBub3Qgc3BlY2lmaWVkLCB0aGUgZHJpdmVyIHdpbGwgbG9nIHRvIHN0ZGVyci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBvZiB0aGUgbG9nIGZpbGUgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHshU2VydmljZUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBsb2dnaW5nVG8ocGF0aCkge1xuICAgIHJldHVybiB0aGlzLmFkZEFyZ3VtZW50cygnLS1sb2ctcGF0aD0nICsgcGF0aClcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIENocm9tZSBsb2dnaW5nLlxuICAgKiBAcmV0dXJucyB7IVNlcnZpY2VCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgZW5hYmxlQ2hyb21lTG9nZ2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRBcmd1bWVudHMoJy0tZW5hYmxlLWNocm9tZS1sb2dzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHZlcmJvc2UgbG9nZ2luZy5cbiAgICogQHJldHVybiB7IVNlcnZpY2VCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgZW5hYmxlVmVyYm9zZUxvZ2dpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQXJndW1lbnRzKCctLXZlcmJvc2UnKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG51bWJlciBvZiB0aHJlYWRzIHRoZSBkcml2ZXIgc2hvdWxkIHVzZSB0byBtYW5hZ2UgSFRUUCByZXF1ZXN0cy5cbiAgICogQnkgZGVmYXVsdCwgdGhlIGRyaXZlciB3aWxsIHVzZSA0IHRocmVhZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGhyZWFkcyB0byB1c2UuXG4gICAqIEByZXR1cm4geyFTZXJ2aWNlQnVpbGRlcn0gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNldE51bUh0dHBUaHJlYWRzKG4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRBcmd1bWVudHMoJy0taHR0cC10aHJlYWRzPScgKyBuKVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0UGF0aChwYXRoKSB7XG4gICAgc3VwZXIuc2V0UGF0aChwYXRoKVxuICAgIHJldHVybiB0aGlzLmFkZEFyZ3VtZW50cygnLS11cmwtYmFzZT0nICsgcGF0aClcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIGZvciBtYW5hZ2luZyBXZWJEcml2ZXIgb3B0aW9ucyBzcGVjaWZpYyB0byBhIENocm9taXVtLWJhc2VkIGJyb3dzZXIuXG4gKi9cbmNsYXNzIE9wdGlvbnMgZXh0ZW5kcyBDYXBhYmlsaXRpZXMge1xuICAvKipcbiAgICogQHBhcmFtIHsoQ2FwYWJpbGl0aWVzfE1hcDxzdHJpbmcsID8+fE9iamVjdCk9fSBvdGhlciBBbm90aGVyIHNldCBvZlxuICAgKiAgICAgY2FwYWJpbGl0aWVzIHRvIGluaXRpYWxpemUgdGhpcyBpbnN0YW5jZSBmcm9tLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3RoZXIgPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihvdGhlcilcblxuICAgIC8qKiBAcHJpdmF0ZSB7IU9iamVjdH0gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0gdGhpcy5nZXQodGhpcy5DQVBBQklMSVRZX0tFWSkgfHwge31cblxuICAgIHRoaXMuc2V0QnJvd3Nlck5hbWUodGhpcy5CUk9XU0VSX05BTUVfVkFMVUUpXG4gICAgdGhpcy5zZXQodGhpcy5DQVBBQklMSVRZX0tFWSwgdGhpcy5vcHRpb25zXylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYWRkaXRpb25hbCBjb21tYW5kIGxpbmUgYXJndW1lbnRzIHRvIHVzZSB3aGVuIGxhdW5jaGluZyB0aGUgYnJvd3Nlci5cbiAgICogRWFjaCBhcmd1bWVudCBtYXkgYmUgc3BlY2lmaWVkIHdpdGggb3Igd2l0aG91dCB0aGUgXCItLVwiIHByZWZpeFxuICAgKiAoZS5nLiBcIi0tZm9vXCIgYW5kIFwiZm9vXCIpLiBBcmd1bWVudHMgd2l0aCBhbiBhc3NvY2lhdGVkIHZhbHVlIHNob3VsZCBiZVxuICAgKiBkZWxpbWl0ZWQgYnkgYW4gXCI9XCI6IFwiZm9vPWJhclwiLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihzdHJpbmd8IUFycmF5PHN0cmluZz4pfSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGFkZEFyZ3VtZW50cyguLi5hcmdzKSB7XG4gICAgbGV0IG5ld0FyZ3MgPSAodGhpcy5vcHRpb25zXy5hcmdzIHx8IFtdKS5jb25jYXQoLi4uYXJncylcbiAgICBpZiAobmV3QXJncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMub3B0aW9uc18uYXJncyA9IG5ld0FyZ3NcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhZGRyZXNzIG9mIGEgQ2hyb21pdW0gcmVtb3RlIGRlYnVnZ2luZyBzZXJ2ZXIgdG8gY29ubmVjdCB0by5cbiAgICogQWRkcmVzcyBzaG91bGQgYmUgb2YgdGhlIGZvcm0gXCJ7aG9zdG5hbWV8SVAgYWRkcmVzc306cG9ydFwiXG4gICAqIChlLmcuIFwibG9jYWxob3N0OjkyMjJcIikuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGNvbm5lY3QgdG8uXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgZGVidWdnZXJBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0aGlzLm9wdGlvbnNfLmRlYnVnZ2VyQWRkcmVzcyA9IGFkZHJlc3NcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgT3B0aW9ucyNhZGRBcmd1bWVudHN9IGluc3RlYWQuXG4gICAqIEBleGFtcGxlXG4gICAqIG9wdGlvbnMuYWRkQXJndW1lbnRzKCctLWhlYWRsZXNzPWNocm9tZScpOyAob3IpXG4gICAqIG9wdGlvbnMuYWRkQXJndW1lbnRzKCctLWhlYWRsZXNzJyk7XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFJlY29tbWVuZGVkIHRvIHVzZSAnLS1oZWFkbGVzcz1jaHJvbWUnIGFzIGFyZ3VtZW50IGZvciBicm93c2VycyB2OTQtMTA4LlxuICAgKiBSZWNvbW1lbmRlZCB0byB1c2UgJy0taGVhZGxlc3M9bmV3JyBhcyBhcmd1bWVudCBmb3IgYnJvd3NlcnMgdjEwOSsuXG4gICAqXG4gICAqIENvbmZpZ3VyZXMgdGhlIGRyaXZlciB0byBzdGFydCB0aGUgYnJvd3NlciBpbiBoZWFkbGVzcyBtb2RlLlxuICAgKlxuICAgKiA+IF9fTk9URTpfXyBSZXNpemluZyB0aGUgYnJvd3NlciB3aW5kb3cgaW4gaGVhZGxlc3MgbW9kZSBpcyBvbmx5IHN1cHBvcnRlZFxuICAgKiA+IGluIENocm9taXVtIDYwKy4gVXNlcnMgYXJlIGVuY291cmFnZWQgdG8gc2V0IGFuIGluaXRpYWwgd2luZG93IHNpemUgd2l0aFxuICAgKiA+IHRoZSB7QGxpbmsgI3dpbmRvd1NpemUgd2luZG93U2l6ZSh7d2lkdGgsIGhlaWdodH0pfSBvcHRpb24uXG4gICAqXG4gICAqID4gX19OT1RFX186IEZvciBzZWN1cml0eSwgQ2hyb21pdW0gZGlzYWJsZXMgZG93bmxvYWRzIGJ5IGRlZmF1bHQgd2hlblxuICAgKiA+IGluIGhlYWRsZXNzIG1vZGUgKHRvIHByZXZlbnQgc2l0ZXMgZnJvbSBzaWxlbnRseSBkb3dubG9hZGluZyBmaWxlcyB0b1xuICAgKiA+IHlvdXIgbWFjaGluZSkuIEFmdGVyIGNyZWF0aW5nIGEgc2Vzc2lvbiwgeW91IG1heSBjYWxsXG4gICAqID4ge0BsaW5rIC4vY2hyb21lLkRyaXZlciNzZXREb3dubG9hZFBhdGggc2V0RG93bmxvYWRQYXRofSB0byByZS1lbmFibGVcbiAgICogPiBkb3dubG9hZHMsIHNhdmluZyBmaWxlcyBpbiB0aGUgc3BlY2lmaWVkIGRpcmVjdG9yeS5cbiAgICpcbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBoZWFkbGVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRBcmd1bWVudHMoJ2hlYWRsZXNzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbml0aWFsIHdpbmRvdyBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHNpemUgVGhlIGRlc2lyZWQgd2luZG93IHNpemUuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHdpZHRoIG9yIGhlaWdodCBpcyB1bnNwZWNpZmllZCwgbm90IGEgbnVtYmVyLCBvclxuICAgKiAgICAgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDAuXG4gICAqL1xuICB3aW5kb3dTaXplKHsgd2lkdGgsIGhlaWdodCB9KSB7XG4gICAgZnVuY3Rpb24gY2hlY2tBcmcoYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDw9IDApIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSB7d2lkdGgsIGhlaWdodH0gd2l0aCBudW1iZXJzID4gMCcpXG4gICAgICB9XG4gICAgfVxuICAgIGNoZWNrQXJnKHdpZHRoKVxuICAgIGNoZWNrQXJnKGhlaWdodClcbiAgICByZXR1cm4gdGhpcy5hZGRBcmd1bWVudHMoYHdpbmRvdy1zaXplPSR7d2lkdGh9LCR7aGVpZ2h0fWApXG4gIH1cblxuICAvKipcbiAgICogTGlzdCBvZiBDaHJvbWUgY29tbWFuZCBsaW5lIHN3aXRjaGVzIHRvIGV4Y2x1ZGUgdGhhdCBDaHJvbWVEcml2ZXIgYnkgZGVmYXVsdFxuICAgKiBwYXNzZXMgd2hlbiBzdGFydGluZyBDaHJvbWUuICBEbyBub3QgcHJlZml4IHN3aXRjaGVzIHdpdGggXCItLVwiLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihzdHJpbmd8IUFycmF5PHN0cmluZz4pfSBhcmdzIFRoZSBzd2l0Y2hlcyB0byBleGNsdWRlLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGV4Y2x1ZGVTd2l0Y2hlcyguLi5hcmdzKSB7XG4gICAgbGV0IHN3aXRjaGVzID0gKHRoaXMub3B0aW9uc18uZXhjbHVkZVN3aXRjaGVzIHx8IFtdKS5jb25jYXQoLi4uYXJncylcbiAgICBpZiAoc3dpdGNoZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9wdGlvbnNfLmV4Y2x1ZGVTd2l0Y2hlcyA9IHN3aXRjaGVzXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQWRkIGFkZGl0aW9uYWwgZXh0ZW5zaW9ucyB0byBpbnN0YWxsIHdoZW4gbGF1bmNoaW5nIHRoZSBicm93c2VyLiBFYWNoIGV4dGVuc2lvblxuICAgKiBzaG91bGQgYmUgc3BlY2lmaWVkIGFzIHRoZSBwYXRoIHRvIHRoZSBwYWNrZWQgQ1JYIGZpbGUsIG9yIGEgQnVmZmVyIGZvciBhblxuICAgKiBleHRlbnNpb24uXG4gICAqIEBwYXJhbSB7Li4uKHN0cmluZ3whQnVmZmVyfCFBcnJheTwoc3RyaW5nfCFCdWZmZXIpPil9IGFyZ3MgVGhlXG4gICAqICAgICBleHRlbnNpb25zIHRvIGFkZC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBhZGRFeHRlbnNpb25zKC4uLmFyZ3MpIHtcbiAgICBsZXQgZXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9uc18uZXh0ZW5zaW9ucyB8fCBuZXcgRXh0ZW5zaW9ucygpXG4gICAgZXh0ZW5zaW9ucy5hZGQoLi4uYXJncylcbiAgICBpZiAoZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMub3B0aW9uc18uZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnNcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYXRoIHRvIHRoZSBicm93c2VyIGJpbmFyeSB0byB1c2UuIE9uIE1hYyBPUyBYLCB0aGlzIHBhdGggc2hvdWxkXG4gICAqIHJlZmVyZW5jZSB0aGUgYWN0dWFsIENocm9taXVtIGV4ZWN1dGFibGUsIG5vdCBqdXN0IHRoZSBhcHBsaWNhdGlvbiBiaW5hcnlcbiAgICogKGUuZy4gXCIvQXBwbGljYXRpb25zL0dvb2dsZSBDaHJvbWUuYXBwL0NvbnRlbnRzL01hY09TL0dvb2dsZSBDaHJvbWVcIikuXG4gICAqXG4gICAqIFRoZSBiaW5hcnkgcGF0aCBjYW4gYmUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8gdGhlIFdlYkRyaXZlciBzZXJ2ZXJcbiAgICogZXhlY3V0YWJsZSwgYnV0IGl0IG11c3QgZXhpc3Qgb24gdGhlIG1hY2hpbmUgdGhhdCB3aWxsIGxhdW5jaCB0aGUgYnJvd3Nlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gdGhlIGJyb3dzZXIgYmluYXJ5IHRvIHVzZS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRCaW5hcnlQYXRoKHBhdGgpIHtcbiAgICB0aGlzLm9wdGlvbnNfLmJpbmFyeSA9IHBhdGhcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBsZWF2ZSB0aGUgc3RhcnRlZCBicm93c2VyIHByb2Nlc3MgcnVubmluZyBpZiB0aGUgY29udHJvbGxpbmdcbiAgICogZHJpdmVyIHNlcnZpY2UgaXMga2lsbGVkIGJlZm9yZSB7QGxpbmsgd2ViZHJpdmVyLldlYkRyaXZlciNxdWl0KCl9IGlzXG4gICAqIGNhbGxlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBkZXRhY2ggV2hldGhlciB0byBsZWF2ZSB0aGUgYnJvd3NlciBydW5uaW5nIGlmIHRoZVxuICAgKiAgICAgZHJpdmVyIHNlcnZpY2UgaXMga2lsbGVkIGJlZm9yZSB0aGUgc2Vzc2lvbi5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBkZXRhY2hEcml2ZXIoZGV0YWNoKSB7XG4gICAgdGhpcy5vcHRpb25zXy5kZXRhY2ggPSBkZXRhY2hcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVzZXIgcHJlZmVyZW5jZXMgZm9yIENocm9tZSdzIHVzZXIgcHJvZmlsZS4gU2VlIHRoZSBcIlByZWZlcmVuY2VzXCJcbiAgICogZmlsZSBpbiBDaHJvbWUncyB1c2VyIGRhdGEgZGlyZWN0b3J5IGZvciBleGFtcGxlcy5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBwcmVmcyBEaWN0aW9uYXJ5IG9mIHVzZXIgcHJlZmVyZW5jZXMgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNldFVzZXJQcmVmZXJlbmNlcyhwcmVmcykge1xuICAgIHRoaXMub3B0aW9uc18ucHJlZnMgPSBwcmVmc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGVyZm9ybWFuY2UgbG9nZ2luZyBwcmVmZXJlbmNlcy4gT3B0aW9ucyBpbmNsdWRlOlxuICAgKlxuICAgKiAtIGBlbmFibGVOZXR3b3JrYDogV2hldGhlciBvciBub3QgdG8gY29sbGVjdCBldmVudHMgZnJvbSBOZXR3b3JrIGRvbWFpbi5cbiAgICogLSBgZW5hYmxlUGFnZWA6IFdoZXRoZXIgb3Igbm90IHRvIGNvbGxlY3QgZXZlbnRzIGZyb20gUGFnZSBkb21haW4uXG4gICAqIC0gYGVuYWJsZVRpbWVsaW5lYDogV2hldGhlciBvciBub3QgdG8gY29sbGVjdCBldmVudHMgZnJvbSBUaW1lbGluZSBkb21haW4uXG4gICAqICAgICBOb3RlOiB3aGVuIHRyYWNpbmcgaXMgZW5hYmxlZCwgVGltZWxpbmUgZG9tYWluIGlzIGltcGxpY2l0bHkgZGlzYWJsZWQsXG4gICAqICAgICB1bmxlc3MgYGVuYWJsZVRpbWVsaW5lYCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuICAgKiAtIGB0cmFjZUNhdGVnb3JpZXNgOiBBIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgb2YgQ2hyb21pdW0gdHJhY2luZ1xuICAgKiAgICAgY2F0ZWdvcmllcyBmb3Igd2hpY2ggdHJhY2UgZXZlbnRzIHNob3VsZCBiZSBjb2xsZWN0ZWQuIEFuIHVuc3BlY2lmaWVkXG4gICAqICAgICBvciBlbXB0eSBzdHJpbmcgZGlzYWJsZXMgdHJhY2luZy5cbiAgICogLSBgYnVmZmVyVXNhZ2VSZXBvcnRpbmdJbnRlcnZhbGA6IFRoZSByZXF1ZXN0ZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgKiAgICAgYmV0d2VlbiBEZXZUb29scyB0cmFjZSBidWZmZXIgdXNhZ2UgZXZlbnRzLiBGb3IgZXhhbXBsZSwgaWYgMTAwMCwgdGhlblxuICAgKiAgICAgb25jZSBwZXIgc2Vjb25kLCBEZXZUb29scyB3aWxsIHJlcG9ydCBob3cgZnVsbCB0aGUgdHJhY2UgYnVmZmVyIGlzLiBJZlxuICAgKiAgICAgYSByZXBvcnQgaW5kaWNhdGVzIHRoZSBidWZmZXIgdXNhZ2UgaXMgMTAwJSwgYSB3YXJuaW5nIHdpbGwgYmUgaXNzdWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3tlbmFibGVOZXR3b3JrOiBib29sZWFuLFxuICAgKiAgICAgICAgICBlbmFibGVQYWdlOiBib29sZWFuLFxuICAgKiAgICAgICAgICBlbmFibGVUaW1lbGluZTogYm9vbGVhbixcbiAgICogICAgICAgICAgdHJhY2VDYXRlZ29yaWVzOiBzdHJpbmcsXG4gICAqICAgICAgICAgIGJ1ZmZlclVzYWdlUmVwb3J0aW5nSW50ZXJ2YWw6IG51bWJlcn19IHByZWZzIFRoZSBwZXJmb3JtYW5jZVxuICAgKiAgICAgbG9nZ2luZyBwcmVmZXJlbmNlcy5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRQZXJmTG9nZ2luZ1ByZWZzKHByZWZzKSB7XG4gICAgdGhpcy5vcHRpb25zXy5wZXJmTG9nZ2luZ1ByZWZzID0gcHJlZnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgcHJlZmVyZW5jZXMgZm9yIHRoZSBcIkxvY2FsIFN0YXRlXCIgZmlsZSBpbiBDaHJvbWUncyB1c2VyIGRhdGFcbiAgICogZGlyZWN0b3J5LlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHN0YXRlIERpY3Rpb25hcnkgb2YgbG9jYWwgc3RhdGUgcHJlZmVyZW5jZXMuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMub3B0aW9uc18ubG9jYWxTdGF0ZSA9IHN0YXRlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBhY3Rpdml0eSBob3N0aW5nIGEgQ2hyb21lLWJhc2VkIEFuZHJvaWQgV2ViVmlldy4gVGhpc1xuICAgKiBvcHRpb24gbXVzdCBiZSBzZXQgdG8gY29ubmVjdCB0byBhbiBbQW5kcm9pZCBXZWJWaWV3XShcbiAgICogaHR0cHM6Ly9jaHJvbWVkcml2ZXIuY2hyb21pdW0ub3JnL2dldHRpbmctc3RhcnRlZC9nZXR0aW5nLXN0YXJ0ZWQtLS1hbmRyb2lkKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWN0aXZpdHkgbmFtZS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBhbmRyb2lkQWN0aXZpdHkobmFtZSkge1xuICAgIHRoaXMub3B0aW9uc18uYW5kcm9pZEFjdGl2aXR5ID0gbmFtZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGV2aWNlIHNlcmlhbCBudW1iZXIgdG8gY29ubmVjdCB0byB2aWEgQURCLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcbiAgICogV2ViRHJpdmVyIHNlcnZlciB3aWxsIHNlbGVjdCBhbiB1bnVzZWQgZGV2aWNlIGF0IHJhbmRvbS4gQW4gZXJyb3Igd2lsbCBiZVxuICAgKiByZXR1cm5lZCBpZiBhbGwgZGV2aWNlcyBhbHJlYWR5IGhhdmUgYWN0aXZlIHNlc3Npb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWFsIFRoZSBkZXZpY2Ugc2VyaWFsIG51bWJlciB0byBjb25uZWN0IHRvLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGFuZHJvaWREZXZpY2VTZXJpYWwoc2VyaWFsKSB7XG4gICAgdGhpcy5vcHRpb25zXy5hbmRyb2lkRGV2aWNlU2VyaWFsID0gc2VyaWFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYWNrYWdlIG5hbWUgb2YgdGhlIENocm9tZSBvciBXZWJWaWV3IGFwcC5cbiAgICpcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBwa2cgVGhlIHBhY2thZ2UgdG8gY29ubmVjdCB0bywgb3IgYG51bGxgIHRvIGRpc2FibGUgQW5kcm9pZFxuICAgKiAgICAgYW5kIHN3aXRjaCBiYWNrIHRvIHVzaW5nIGRlc2t0b3AgYnJvd3Nlci5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBhbmRyb2lkUGFja2FnZShwa2cpIHtcbiAgICB0aGlzLm9wdGlvbnNfLmFuZHJvaWRQYWNrYWdlID0gcGtnXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9jZXNzIG5hbWUgb2YgdGhlIEFjdGl2aXR5IGhvc3RpbmcgdGhlIFdlYlZpZXcgKGFzIGdpdmVuIGJ5XG4gICAqIGBwc2ApLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvY2VzcyBuYW1lIGlzIGFzc3VtZWQgdG8gYmUgdGhlIHNhbWUgYXNcbiAgICoge0BsaW5rICNhbmRyb2lkUGFja2FnZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9jZXNzTmFtZSBUaGUgbWFpbiBhY3Rpdml0eSBuYW1lLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGFuZHJvaWRQcm9jZXNzKHByb2Nlc3NOYW1lKSB7XG4gICAgdGhpcy5vcHRpb25zXy5hbmRyb2lkUHJvY2VzcyA9IHByb2Nlc3NOYW1lXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdG8gY29ubmVjdCB0byBhbiBhbHJlYWR5LXJ1bm5pbmcgaW5zdGVhZCBvZiB0aGUgc3BlY2lmaWVkXG4gICAqIHtAbGlua3BsYWluICNhbmRyb2lkUHJvY2VzcyBhcHB9IGluc3RlYWQgb2YgbGF1bmNoaW5nIHRoZSBhcHAgd2l0aCBhIGNsZWFuXG4gICAqIGRhdGEgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZVJ1bm5pbmcgV2hldGhlciB0byBjb25uZWN0IHRvIGEgcnVubmluZyBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBhbmRyb2lkVXNlUnVubmluZ0FwcCh1c2VSdW5uaW5nKSB7XG4gICAgdGhpcy5vcHRpb25zXy5hbmRyb2lkVXNlUnVubmluZ0FwcCA9IHVzZVJ1bm5pbmdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhdGggdG8gdGhlIGJyb3dzZXIncyBsb2cgZmlsZS4gVGhpcyBwYXRoIHNob3VsZCBleGlzdCBvbiB0aGUgbWFjaGluZVxuICAgKiB0aGF0IHdpbGwgbGF1bmNoIHRoZSBicm93c2VyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIHRoZSBsb2cgZmlsZSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0QnJvd3NlckxvZ0ZpbGUocGF0aCkge1xuICAgIHRoaXMub3B0aW9uc18ubG9nUGF0aCA9IHBhdGhcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcmVjdG9yeSB0byBzdG9yZSBicm93c2VyIG1pbmlkdW1wcyBpbi4gVGhpcyBvcHRpb24gaXMgb25seVxuICAgKiBzdXBwb3J0ZWQgd2hlbiB0aGUgZHJpdmVyIGlzIHJ1bm5pbmcgb24gTGludXguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBkaXJlY3RvcnkgcGF0aC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRCcm93c2VyTWluaWR1bXBQYXRoKHBhdGgpIHtcbiAgICB0aGlzLm9wdGlvbnNfLm1pbmlkdW1wUGF0aCA9IHBhdGhcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhlIGJyb3dzZXIgdG8gZW11bGF0ZSBhIG1vYmlsZSBkZXZpY2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlclxuICAgKiB0byB0aGUgQ2hyb21lRHJpdmVyIHByb2plY3QgcGFnZSBvbiBbbW9iaWxlIGVtdWxhdGlvbl1bZW1dLiBDb25maWd1cmF0aW9uXG4gICAqIG9wdGlvbnMgaW5jbHVkZTpcbiAgICpcbiAgICogLSBgZGV2aWNlTmFtZWA6IFRoZSBuYW1lIG9mIGEgcHJlLWNvbmZpZ3VyZWQgW2VtdWxhdGVkIGRldmljZV1bZGV2ZW1dXG4gICAqIC0gYHdpZHRoYDogc2NyZWVuIHdpZHRoLCBpbiBwaXhlbHNcbiAgICogLSBgaGVpZ2h0YDogc2NyZWVuIGhlaWdodCwgaW4gcGl4ZWxzXG4gICAqIC0gYHBpeGVsUmF0aW9gOiBzY3JlZW4gcGl4ZWwgcmF0aW9cbiAgICpcbiAgICogX19FeGFtcGxlIDE6IFVzaW5nIGEgUHJlLWNvbmZpZ3VyZWQgRGV2aWNlX19cbiAgICpcbiAgICogICAgIGxldCBvcHRpb25zID0gbmV3IGNocm9tZS5PcHRpb25zKCkuc2V0TW9iaWxlRW11bGF0aW9uKFxuICAgKiAgICAgICAgIHtkZXZpY2VOYW1lOiAnR29vZ2xlIE5leHVzIDUnfSk7XG4gICAqXG4gICAqICAgICBsZXQgZHJpdmVyID0gY2hyb21lLkRyaXZlci5jcmVhdGVTZXNzaW9uKG9wdGlvbnMpO1xuICAgKlxuICAgKiBfX0V4YW1wbGUgMjogVXNpbmcgQ3VzdG9tIFNjcmVlbiBDb25maWd1cmF0aW9uX19cbiAgICpcbiAgICogICAgIGxldCBvcHRpb25zID0gbmV3IGNocm9tZS5PcHRpb25zKCkuc2V0TW9iaWxlRW11bGF0aW9uKHtkZXZpY2VNZXRyaWNzOiB7XG4gICAqICAgICAgICAgd2lkdGg6IDM2MCxcbiAgICogICAgICAgICBoZWlnaHQ6IDY0MCxcbiAgICogICAgICAgICBwaXhlbFJhdGlvOiAzLjBcbiAgICogICAgIH19KTtcbiAgICpcbiAgICogICAgIGxldCBkcml2ZXIgPSBjaHJvbWUuRHJpdmVyLmNyZWF0ZVNlc3Npb24ob3B0aW9ucyk7XG4gICAqXG4gICAqXG4gICAqIFtlbV06IGh0dHBzOi8vY2hyb21lZHJpdmVyLmNocm9taXVtLm9yZy9tb2JpbGUtZW11bGF0aW9uXG4gICAqIFtkZXZlbV06IGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9kZXZpY2UtbW9kZVxuICAgKlxuICAgKiBAcGFyYW0gez8oe2RldmljZU5hbWU6IHN0cmluZ318XG4gICAqICAgICAgICAgICB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHBpeGVsUmF0aW86IG51bWJlcn0pfSBjb25maWcgVGhlXG4gICAqICAgICBtb2JpbGUgZW11bGF0aW9uIGNvbmZpZ3VyYXRpb24sIG9yIGBudWxsYCB0byBkaXNhYmxlIGVtdWxhdGlvbi5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRNb2JpbGVFbXVsYXRpb24oY29uZmlnKSB7XG4gICAgdGhpcy5vcHRpb25zXy5tb2JpbGVFbXVsYXRpb24gPSBjb25maWdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBsaXN0IG9mIHRoZSB3aW5kb3cgdHlwZXMgdGhhdCB3aWxsIGFwcGVhciB3aGVuIGdldHRpbmcgd2luZG93XG4gICAqIGhhbmRsZXMuIEZvciBhY2Nlc3MgdG8gPHdlYnZpZXc+IGVsZW1lbnRzLCBpbmNsdWRlIFwid2Vidmlld1wiIGluIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gey4uLihzdHJpbmd8IUFycmF5PHN0cmluZz4pfSBhcmdzIFRoZSB3aW5kb3cgdHlwZXMgdGhhdCB3aWxsIGFwcGVhclxuICAgKiB3aGVuIGdldHRpbmcgd2luZG93IGhhbmRsZXMuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgd2luZG93VHlwZXMoLi4uYXJncykge1xuICAgIGxldCB3aW5kb3dUeXBlcyA9ICh0aGlzLm9wdGlvbnNfLndpbmRvd1R5cGVzIHx8IFtdKS5jb25jYXQoLi4uYXJncylcbiAgICBpZiAod2luZG93VHlwZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9wdGlvbnNfLndpbmRvd1R5cGVzID0gd2luZG93VHlwZXNcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgYmlkaSBjb25uZWN0aW9uXG4gICAqIEByZXR1cm5zIHshQ2FwYWJpbGl0aWVzfVxuICAgKi9cbiAgZW5hYmxlQmlkaSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJ3dlYlNvY2tldFVybCcsIHRydWUpXG4gIH1cbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXh0ZW5zaW9ucyB0byBpbnN0YWxsIHdoZW4gbGF1bmNoaW5nIHRoZSBicm93c2VyLlxuICovXG5jbGFzcyBFeHRlbnNpb25zIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIGV4dGVuc2lvbnMgbGlzdC5cbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYWRkaXRpb25hbCBleHRlbnNpb25zIHRvIGluc3RhbGwgd2hlbiBsYXVuY2hpbmcgdGhlIGJyb3dzZXIuIEVhY2hcbiAgICogZXh0ZW5zaW9uIHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgdGhlIHBhdGggdG8gdGhlIHBhY2tlZCBDUlggZmlsZSwgb3IgYVxuICAgKiBCdWZmZXIgZm9yIGFuIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oc3RyaW5nfCFCdWZmZXJ8IUFycmF5PChzdHJpbmd8IUJ1ZmZlcik+KX0gYXJncyBUaGVcbiAgICogICAgIGV4dGVuc2lvbnMgdG8gYWRkLlxuICAgKi9cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnMuY29uY2F0KC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU9iamVjdH0gQSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRXh0ZW5zaW9ucyBvYmplY3QuXG4gICAqL1xuICBbU3ltYm9scy5zZXJpYWxpemVdKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMubWFwKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZXh0ZW5zaW9uKSkge1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlvXG4gICAgICAgIC5yZWFkKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZXh0ZW5zaW9uKSlcbiAgICAgICAgLnRoZW4oKGJ1ZmZlcikgPT4gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKSlcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBXZWJEcml2ZXIgY2xpZW50IGZvciBDaHJvbWl1bS1iYXNlZCBicm93c2Vycy5cbiAqL1xuY2xhc3MgRHJpdmVyIGV4dGVuZHMgd2ViZHJpdmVyLldlYkRyaXZlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHNlc3Npb24gd2l0aCB0aGUgV2ViRHJpdmVyIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHsoQ2FwYWJpbGl0aWVzfE9wdGlvbnMpPX0gb3B0X2NvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0geyhyZW1vdGUuRHJpdmVyU2VydmljZXxodHRwLkV4ZWN1dG9yKT19IG9wdF9zZXJ2aWNlRXhlY3V0b3IgRWl0aGVyXG4gICAqICAgICBhICBEcml2ZXJTZXJ2aWNlIHRvIHVzZSBmb3IgdGhlIHJlbW90ZSBlbmQsIG9yIGEgcHJlY29uZmlndXJlZCBleGVjdXRvclxuICAgKiAgICAgZm9yIGFuIGV4dGVybmFsbHkgbWFuYWdlZCBlbmRwb2ludC4gSWYgbmVpdGhlciBpcyBwcm92aWRlZCwgdGhlXG4gICAqICAgICB7QGxpbmtwbGFpbiAjI2dldERlZmF1bHRTZXJ2aWNlIGRlZmF1bHQgc2VydmljZX0gd2lsbCBiZSB1c2VkIGJ5XG4gICAqICAgICBkZWZhdWx0LlxuICAgKiBAcmV0dXJuIHshRHJpdmVyfSBBIG5ldyBkcml2ZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlU2Vzc2lvbihjYXBzLCBvcHRfc2VydmljZUV4ZWN1dG9yKSB7XG4gICAgbGV0IGV4ZWN1dG9yXG4gICAgbGV0IG9uUXVpdFxuICAgIGlmIChvcHRfc2VydmljZUV4ZWN1dG9yIGluc3RhbmNlb2YgaHR0cC5FeGVjdXRvcikge1xuICAgICAgZXhlY3V0b3IgPSBvcHRfc2VydmljZUV4ZWN1dG9yXG4gICAgICBjb25maWd1cmVFeGVjdXRvcihleGVjdXRvciwgdGhpcy5WRU5ET1JfQ09NTUFORF9QUkVGSVgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzZXJ2aWNlID0gb3B0X3NlcnZpY2VFeGVjdXRvciB8fCB0aGlzLmdldERlZmF1bHRTZXJ2aWNlKClcbiAgICAgIGlmICghc2VydmljZS5nZXRFeGVjdXRhYmxlKCkpIHtcbiAgICAgICAgc2VydmljZS5zZXRFeGVjdXRhYmxlKGdldFBhdGgoc2VydmljZSwgY2FwcykpXG4gICAgICB9XG4gICAgICBvblF1aXQgPSAoKSA9PiBzZXJ2aWNlLmtpbGwoKVxuICAgICAgZXhlY3V0b3IgPSBjcmVhdGVFeGVjdXRvcihzZXJ2aWNlLnN0YXJ0KCksIHRoaXMuVkVORE9SX0NPTU1BTkRfUFJFRklYKVxuICAgIH1cblxuICAgIC8vIFczQyBzcGVjIHJlcXVpcmVzIG5vUHJveHkgdmFsdWUgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncywgYnV0IENocm9taXVtXG4gICAgLy8gZXhwZWN0cyBhIHNpbmdsZSBob3N0IGFzIGEgc3RyaW5nLlxuICAgIGxldCBwcm94eSA9IGNhcHMuZ2V0KENhcGFiaWxpdHkuUFJPWFkpXG4gICAgaWYgKHByb3h5ICYmIEFycmF5LmlzQXJyYXkocHJveHkubm9Qcm94eSkpIHtcbiAgICAgIHByb3h5Lm5vUHJveHkgPSBwcm94eS5ub1Byb3h5WzBdXG4gICAgICBpZiAoIXByb3h5Lm5vUHJveHkpIHtcbiAgICAgICAgcHJveHkubm9Qcm94eSA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAvKiogQHR5cGUgeyFEcml2ZXJ9ICovIChzdXBlci5jcmVhdGVTZXNzaW9uKGV4ZWN1dG9yLCBjYXBzLCBvblF1aXQpKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgYSBuby1vcCBhcyBmaWxlIGRldGVjdG9ycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGlzXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNldEZpbGVEZXRlY3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhIGNvbW1hbmQgdG8gbGF1bmNoIENocm9tZSBBcHAgd2l0aCBnaXZlbiBJRC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBBcHAgdG8gbGF1bmNoLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiAgICAgd2hlbiBhcHAgaXMgbGF1bmNoZWQuXG4gICAqL1xuICBsYXVuY2hBcHAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChDb21tYW5kLkxBVU5DSF9BUFApLnNldFBhcmFtZXRlcignaWQnLCBpZClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgY29tbWFuZCB0byBnZXQgQ2hyb21pdW0gbmV0d29yayBlbXVsYXRpb24gc2V0dGluZ3MuXG4gICAqIEByZXR1cm4geyFQcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gbmV0d29ya1xuICAgKiAgICAgZW11bGF0aW9uIHNldHRpbmdzIGFyZSByZXRyaWV2ZWQuXG4gICAqL1xuICBnZXROZXR3b3JrQ29uZGl0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoQ29tbWFuZC5HRVRfTkVUV09SS19DT05ESVRJT05TKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBjb21tYW5kIHRvIGRlbGV0ZSBDaHJvbWl1bSBuZXR3b3JrIGVtdWxhdGlvbiBzZXR0aW5ncy5cbiAgICogQHJldHVybiB7IVByb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiBuZXR3b3JrXG4gICAqICAgICBlbXVsYXRpb24gc2V0dGluZ3MgaGF2ZSBiZWVuIGRlbGV0ZWQuXG4gICAqL1xuICBkZWxldGVOZXR3b3JrQ29uZGl0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoQ29tbWFuZC5ERUxFVEVfTkVUV09SS19DT05ESVRJT05TKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBjb21tYW5kIHRvIHNldCBDaHJvbWl1bSBuZXR3b3JrIGVtdWxhdGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogX19TYW1wbGUgVXNhZ2U6X19cbiAgICpcbiAgICogIGRyaXZlci5zZXROZXR3b3JrQ29uZGl0aW9ucyh7XG4gICAqICAgIG9mZmxpbmU6IGZhbHNlLFxuICAgKiAgICBsYXRlbmN5OiA1LCAvLyBBZGRpdGlvbmFsIGxhdGVuY3kgKG1zKS5cbiAgICogICAgZG93bmxvYWRfdGhyb3VnaHB1dDogNTAwICogMTAyNCwgLy8gTWF4aW1hbCBhZ2dyZWdhdGVkIGRvd25sb2FkIHRocm91Z2hwdXQuXG4gICAqICAgIHVwbG9hZF90aHJvdWdocHV0OiA1MDAgKiAxMDI0IC8vIE1heGltYWwgYWdncmVnYXRlZCB1cGxvYWQgdGhyb3VnaHB1dC5cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIERlZmluZXMgdGhlIG5ldHdvcmsgY29uZGl0aW9ucyB0byBzZXRcbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiBuZXR3b3JrXG4gICAqICAgICBlbXVsYXRpb24gc2V0dGluZ3MgYXJlIHNldC5cbiAgICovXG4gIHNldE5ldHdvcmtDb25kaXRpb25zKHNwZWMpIHtcbiAgICBpZiAoIXNwZWMgfHwgdHlwZW9mIHNwZWMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAgICdzZXROZXR3b3JrQ29uZGl0aW9ucyBjYWxsZWQgd2l0aCBub24tbmV0d29yay1jb25kaXRpb25zIHBhcmFtZXRlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoQ29tbWFuZC5TRVRfTkVUV09SS19DT05ESVRJT05TKS5zZXRQYXJhbWV0ZXIoXG4gICAgICAgICduZXR3b3JrX2NvbmRpdGlvbnMnLFxuICAgICAgICBzcGVjXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGFyYml0cmFyeSBkZXZ0b29scyBjb21tYW5kIHRvIHRoZSBicm93c2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY21kIFRoZSBuYW1lIG9mIHRoZSBjb21tYW5kIHRvIHNlbmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcGFyYW1zIFRoZSBjb21tYW5kIHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvbW1hbmRcbiAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICogQHNlZSA8aHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvPlxuICAgKi9cbiAgc2VuZERldlRvb2xzQ29tbWFuZChjbWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoQ29tbWFuZC5TRU5EX0RFVlRPT0xTX0NPTU1BTkQpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ2NtZCcsIGNtZClcbiAgICAgICAgLnNldFBhcmFtZXRlcigncGFyYW1zJywgcGFyYW1zKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhbiBhcmJpdHJhcnkgZGV2dG9vbHMgY29tbWFuZCB0byB0aGUgYnJvd3NlciBhbmQgZ2V0IHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbWQgVGhlIG5hbWUgb2YgdGhlIGNvbW1hbmQgdG8gc2VuZC5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwYXJhbXMgVGhlIGNvbW1hbmQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBjb21tYW5kXG4gICAqICAgICBoYXMgZmluaXNoZWQuXG4gICAqIEBzZWUgPGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sLz5cbiAgICovXG4gIHNlbmRBbmRHZXREZXZUb29sc0NvbW1hbmQoY21kLCBwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKENvbW1hbmQuU0VORF9BTkRfR0VUX0RFVlRPT0xTX0NPTU1BTkQpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ2NtZCcsIGNtZClcbiAgICAgICAgLnNldFBhcmFtZXRlcigncGFyYW1zJywgcGFyYW1zKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBwZXJtaXNzaW9uIHN0YXRlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHsoJ2dyYW50ZWQnfCdkZW5pZWQnfCdwcm9tcHQnKX0gc3RhdGUgU3RhdGUgdG8gc2V0IHBlcm1pc3Npb24gdG8uXG4gICAqIEByZXR1cm5zIHshUHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlXG4gICAqICAgICBjb21tYW5kIGhhcyBmaW5pc2hlZC5cbiAgICogQHNlZSA8aHR0cHM6Ly93M2MuZ2l0aHViLmlvL3Blcm1pc3Npb25zLyNwZXJtaXNzaW9uLXJlZ2lzdHJ5PiBmb3IgdmFsaWRcbiAgICogICAgIG5hbWVzXG4gICAqL1xuICBzZXRQZXJtaXNzaW9uKG5hbWUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoQ29tbWFuZC5TRVRfUEVSTUlTU0lPTilcbiAgICAgICAgLnNldFBhcmFtZXRlcignZGVzY3JpcHRvcicsIHsgbmFtZSB9KVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCdzdGF0ZScsIHN0YXRlKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIERldlRvb2xzIGNvbW1hbmQgdG8gY2hhbmdlIHRoZSBicm93c2VyJ3MgZG93bmxvYWQgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgZGVzaXJlZCBkb3dubG9hZCBkaXJlY3RvcnkuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvbW1hbmRcbiAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICogQHNlZSAjc2VuZERldlRvb2xzQ29tbWFuZFxuICAgKi9cbiAgYXN5bmMgc2V0RG93bmxvYWRQYXRoKHBhdGgpIHtcbiAgICBpZiAoIXBhdGggfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3IuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZG93bmxvYWQgcGF0aCcpXG4gICAgfVxuICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBpby5zdGF0KHBhdGgpXG4gICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvci5JbnZhbGlkQXJndW1lbnRFcnJvcignbm90IGEgZGlyZWN0b3J5OiAnICsgcGF0aClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VuZERldlRvb2xzQ29tbWFuZCgnUGFnZS5zZXREb3dubG9hZEJlaGF2aW9yJywge1xuICAgICAgYmVoYXZpb3I6ICdhbGxvdycsXG4gICAgICBkb3dubG9hZFBhdGg6IHBhdGgsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGNhc3Qgc2lua3MgKENhc3QgZGV2aWNlcykgYXZhaWxhYmxlIHRvIHRoZSBDaHJvbWUgbWVkaWEgcm91dGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHshcHJvbWlzZS5UaGVuYWJsZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIFN0cmluZ3NcbiAgICogICBjb250YWluaW5nIHRoZSBmcmllbmRseSBkZXZpY2UgbmFtZXMgb2YgYXZhaWxhYmxlIGNhc3Qgc2luayB0YXJnZXRzLlxuICAgKi9cbiAgZ2V0Q2FzdFNpbmtzKCkge1xuICAgIHJldHVybiB0aGlzLnNjaGVkdWxlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChDb21tYW5kLkdFVF9DQVNUX1NJTktTKSxcbiAgICAgICdEcml2ZXIuZ2V0Q2FzdFNpbmtzKCknXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSBjYXN0IHNpbmsgKENhc3QgZGV2aWNlKSBhcyB0aGUgcmVjaXBpZW50IG9mIG1lZGlhIHJvdXRlciBpbnRlbnRzIChjb25uZWN0IG9yIHBsYXkpLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGV2aWNlTmFtZSBuYW1lIG9mIHRoZSB0YXJnZXQgZGV2aWNlLlxuICAgKiBAcmV0dXJuIHshcHJvbWlzZS5UaGVuYWJsZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiAgICAgd2hlbiB0aGUgdGFyZ2V0IGRldmljZSBoYXMgYmVlbiBzZWxlY3RlZCB0byByZXNwb25kIGZ1cnRoZXIgd2ViZHJpdmVyIGNvbW1hbmRzLlxuICAgKi9cbiAgc2V0Q2FzdFNpbmtUb1VzZShkZXZpY2VOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKENvbW1hbmQuU0VUX0NBU1RfU0lOS19UT19VU0UpLnNldFBhcmFtZXRlcihcbiAgICAgICAgJ3NpbmtOYW1lJyxcbiAgICAgICAgZGV2aWNlTmFtZVxuICAgICAgKSxcbiAgICAgICdEcml2ZXIuc2V0Q2FzdFNpbmtUb1VzZSgnICsgZGV2aWNlTmFtZSArICcpJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgZGVza3RvcCBtaXJyb3JpbmcgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIgdGFiIG9uIHRoZSBzcGVjaWZpZWQgZGV2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGV2aWNlTmFtZSBuYW1lIG9mIHRoZSB0YXJnZXQgZGV2aWNlLlxuICAgKiBAcmV0dXJuIHshcHJvbWlzZS5UaGVuYWJsZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiAgICAgd2hlbiB0aGUgbWlycm9yIGNvbW1hbmQgaGFzIGJlZW4gaXNzdWVkIHRvIHRoZSBkZXZpY2UuXG4gICAqL1xuICBzdGFydERlc2t0b3BNaXJyb3JpbmcoZGV2aWNlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNjaGVkdWxlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChDb21tYW5kLlNUQVJUX0NBU1RfREVTS1RPUF9NSVJST1JJTkcpLnNldFBhcmFtZXRlcihcbiAgICAgICAgJ3NpbmtOYW1lJyxcbiAgICAgICAgZGV2aWNlTmFtZVxuICAgICAgKSxcbiAgICAgICdEcml2ZXIuc3RhcnREZXNrdG9wTWlycm9yaW5nKCcgKyBkZXZpY2VOYW1lICsgJyknXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0YWIgbWlycm9yaW5nIGZvciB0aGUgY3VycmVudCBicm93c2VyIHRhYiBvbiB0aGUgc3BlY2lmaWVkIGRldmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRldmljZU5hbWUgbmFtZSBvZiB0aGUgdGFyZ2V0IGRldmljZS5cbiAgICogQHJldHVybiB7IXByb21pc2UuVGhlbmFibGU8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcbiAgICogICAgIHdoZW4gdGhlIG1pcnJvciBjb21tYW5kIGhhcyBiZWVuIGlzc3VlZCB0byB0aGUgZGV2aWNlLlxuICAgKi9cbiAgc3RhcnRDYXN0VGFiTWlycm9yaW5nKGRldmljZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2hlZHVsZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoQ29tbWFuZC5TVEFSVF9DQVNUX1RBQl9NSVJST1JJTkcpLnNldFBhcmFtZXRlcihcbiAgICAgICAgJ3NpbmtOYW1lJyxcbiAgICAgICAgZGV2aWNlTmFtZVxuICAgICAgKSxcbiAgICAgICdEcml2ZXIuc3RhcnRDYXN0VGFiTWlycm9yaW5nKCcgKyBkZXZpY2VOYW1lICsgJyknXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgbWVzc2FnZSB3aGVuIHRoZXJlIGlzIGFueSBpc3N1ZSBpbiBhIENhc3Qgc2Vzc2lvbi5cbiAgICogQHJldHVybiB7IXByb21pc2UuVGhlbmFibGU8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcbiAgICogICAgIHdoZW4gdGhlIG1pcnJvciBjb21tYW5kIGhhcyBiZWVuIGlzc3VlZCB0byB0aGUgZGV2aWNlLlxuICAgKi9cbiAgZ2V0Q2FzdElzc3VlTWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2hlZHVsZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoQ29tbWFuZC5HRVRfQ0FTVF9JU1NVRV9NRVNTQUdFKSxcbiAgICAgICdEcml2ZXIuZ2V0Q2FzdElzc3VlTWVzc2FnZSgpJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBjYXN0aW5nIGZyb20gbWVkaWEgcm91dGVyIHRvIHRoZSBzcGVjaWZpZWQgZGV2aWNlLCBpZiBjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZXZpY2VOYW1lIG5hbWUgb2YgdGhlIHRhcmdldCBkZXZpY2UuXG4gICAqIEByZXR1cm4geyFwcm9taXNlLlRoZW5hYmxlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkXG4gICAqICAgICB3aGVuIHRoZSBzdG9wIGNvbW1hbmQgaGFzIGJlZW4gaXNzdWVkIHRvIHRoZSBkZXZpY2UuXG4gICAqL1xuICBzdG9wQ2FzdGluZyhkZXZpY2VOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKENvbW1hbmQuU1RPUF9DQVNUSU5HKS5zZXRQYXJhbWV0ZXIoXG4gICAgICAgICdzaW5rTmFtZScsXG4gICAgICAgIGRldmljZU5hbWVcbiAgICAgICksXG4gICAgICAnRHJpdmVyLnN0b3BDYXN0aW5nKCcgKyBkZXZpY2VOYW1lICsgJyknXG4gICAgKVxuICB9XG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIERyaXZlcixcbiAgT3B0aW9ucyxcbiAgU2VydmljZUJ1aWxkZXIsXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqICBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHN0aWxsIGluIGJldGEsIGFuZCBtYXkgY2hhbmdlLlxuICpcbiAqICBVdGlsaXR5IHRvIGZpbmQgaWYgYSBnaXZlbiBmaWxlIGlzIHByZXNlbnQgYW5kIGV4ZWN1dGFibGUuXG4gKi9cblxuY29uc3QgeyBkcml2ZXJMb2NhdGlvbiB9ID0gcmVxdWlyZSgnLi9zZWxlbml1bU1hbmFnZXInKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcGF0aCBvZiB0aGUgY29ycmVjdCBTZWxlbml1bSBNYW5hZ2VyIGJpbmFyeVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aChzZXJ2aWNlLCBjYXBhYmlsaXRpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcGF0aEV4aXN0cyhzZXJ2aWNlLmdldEV4ZWN1dGFibGUoKSkgfHwgZHJpdmVyTG9jYXRpb24oY2FwYWJpbGl0aWVzKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgVW5hYmxlIHRvIG9idGFpbiBicm93c2VyIGRyaXZlci5cbiAgICAgICAgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGluc3RhbGwgZHJpdmVycyBzZWVcbiAgICAgICAgaHR0cHM6Ly93d3cuc2VsZW5pdW0uZGV2L2RvY3VtZW50YXRpb24vd2ViZHJpdmVyL2dldHRpbmdfc3RhcnRlZC9pbnN0YWxsX2RyaXZlcnMvLiAke2V9YFxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIF9TeW5jaHJvbm91c2x5XyBhdHRlbXB0cyB0byBsb2NhdGUgdGhlIGRyaXZlciBleGVjdXRhYmxlIG9uIHRoZSBjdXJyZW50XG4gKiBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBkcml2ZXJQYXRoXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gdGhlIGxvY2F0ZWQgZXhlY3V0YWJsZSwgb3IgYG51bGxgLlxuICovXG5mdW5jdGlvbiBwYXRoRXhpc3RzKGRyaXZlclBhdGgpIHtcbiAgaWYgKCFkcml2ZXJQYXRoIHx8ICFmcy5leGlzdHNTeW5jKGRyaXZlclBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gZHJpdmVyUGF0aFxufVxuXG4vLyBQVUJMSUMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHsgZ2V0UGF0aCB9XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqICBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHN0aWxsIGluIGJldGEsIGFuZCBtYXkgY2hhbmdlLlxuICpcbiAqICBXcmFwcGVyIGZvciBnZXR0aW5nIGluZm9ybWF0aW9uIGZyb20gdGhlIFNlbGVuaXVtIE1hbmFnZXIgYmluYXJpZXNcbiAqL1xuXG5jb25zdCB7IHBsYXRmb3JtIH0gPSByZXF1aXJlKCdwcm9jZXNzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3Qgc3Bhd25TeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduU3luY1xuXG4vKipcbiAqIGN1cnJlbnRseSBzdXBwb3J0ZWQgYnJvd3NlcnMgZm9yIHNlbGVuaXVtLW1hbmFnZXJcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xuY29uc3QgQnJvd3NlciA9IFsnY2hyb21lJywgJ2ZpcmVmb3gnLCAnZWRnZScsICdNaWNyb3NvZnRFZGdlJywgJ2lleHBsb3JlciddXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcGF0aCBvZiB0aGUgY29ycmVjdCBTZWxlbml1bSBNYW5hZ2VyIGJpbmFyeVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5KCkge1xuICBjb25zdCBkaXJlY3RvcnkgPSB7XG4gICAgZGFyd2luOiAnbWFjb3MnLFxuICAgIHdpbjMyOiAnd2luZG93cycsXG4gICAgY3lnd2luOiAnd2luZG93cycsXG4gICAgbGludXg6ICdsaW51eCcsXG4gIH1bcGxhdGZvcm1dXG5cbiAgY29uc3QgZmlsZSA9XG4gICAgZGlyZWN0b3J5ID09PSAnd2luZG93cycgPyAnc2VsZW5pdW0tbWFuYWdlci5leGUnIDogJ3NlbGVuaXVtLW1hbmFnZXInXG5cbiAgbGV0IHNlbGVuaXVtTWFuYWdlckJhc2VQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy9iaW4nKVxuXG4gIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHNlbGVuaXVtTWFuYWdlckJhc2VQYXRoLCBkaXJlY3RvcnksIGZpbGUpXG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG9idGFpbiBTZWxlbml1bSBNYW5hZ2VyYClcbiAgfVxuXG4gIHJldHVybiBmaWxlUGF0aFxufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIHBhdGggb2YgdGhlIGNvcnJlY3QgZHJpdmVyXG4gKiBAcGFyYW0ge0NhcGFiaWxpdGllc30gb3B0aW9ucyBicm93c2VyIG9wdGlvbnMgdG8gZmV0Y2ggdGhlIGRyaXZlclxuICogQHJldHVybnMge3N0cmluZ30gcGF0aCBvZiB0aGUgZHJpdmVyIGxvY2F0aW9uXG4gKi9cblxuZnVuY3Rpb24gZHJpdmVyTG9jYXRpb24ob3B0aW9ucykge1xuICBpZiAoIUJyb3dzZXIuaW5jbHVkZXMob3B0aW9ucy5nZXRCcm93c2VyTmFtZSgpLnRvTG9jYWxlU3RyaW5nKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVuYWJsZSB0byBsb2NhdGUgZHJpdmVyIGFzc29jaWF0ZWQgd2l0aCBicm93c2VyIG5hbWU6ICR7b3B0aW9ucy5nZXRCcm93c2VyTmFtZSgpfWBcbiAgICApXG4gIH1cblxuICBjb25zb2xlLmRlYnVnKFxuICAgICdBcHBsaWNhYmxlIGRyaXZlciBub3QgZm91bmQ7IGF0dGVtcHRpbmcgdG8gaW5zdGFsbCB3aXRoIFNlbGVuaXVtIE1hbmFnZXIgKEJldGEpJ1xuICApXG5cbiAgbGV0IGFyZ3MgPSBbJy0tYnJvd3NlcicsIG9wdGlvbnMuZ2V0QnJvd3Nlck5hbWUoKSwgJy0tb3V0cHV0JywgJ2pzb24nXVxuXG4gIGlmIChvcHRpb25zLmdldEJyb3dzZXJWZXJzaW9uKCkgJiYgb3B0aW9ucy5nZXRCcm93c2VyVmVyc2lvbigpICE9PSAnJykge1xuICAgIGFyZ3MucHVzaCgnLS1icm93c2VyLXZlcnNpb24nLCBvcHRpb25zLmdldEJyb3dzZXJWZXJzaW9uKCkpXG4gIH1cblxuICBjb25zdCB2ZW5kb3JPcHRpb25zID1cbiAgICBvcHRpb25zLmdldCgnZ29vZzpjaHJvbWVPcHRpb25zJykgfHxcbiAgICBvcHRpb25zLmdldCgnbXM6ZWRnZU9wdGlvbnMnKSB8fFxuICAgIG9wdGlvbnMuZ2V0KCdtb3o6ZmlyZWZveE9wdGlvbnMnKVxuICBpZiAodmVuZG9yT3B0aW9ucyAmJiB2ZW5kb3JPcHRpb25zLmJpbmFyeSAmJiB2ZW5kb3JPcHRpb25zLmJpbmFyeSAhPT0gJycpIHtcbiAgICBhcmdzLnB1c2goJy0tYnJvd3Nlci1wYXRoJywgJ1wiJyArIHZlbmRvck9wdGlvbnMuYmluYXJ5ICsgJ1wiJylcbiAgfVxuXG4gIGNvbnN0IHByb3h5T3B0aW9ucyA9IG9wdGlvbnMuZ2V0UHJveHkoKTtcblxuICAvLyBDaGVjayBpZiBwcm94eU9wdGlvbnMgZXhpc3RzIGFuZCBoYXMgcHJvcGVydGllc1xuICBpZiAocHJveHlPcHRpb25zICYmIE9iamVjdC5rZXlzKHByb3h5T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGh0dHBQcm94eSA9IHByb3h5T3B0aW9uc1snaHR0cFByb3h5J107XG4gICAgY29uc3Qgc3NsUHJveHkgPSBwcm94eU9wdGlvbnNbJ3NzbFByb3h5J107XG5cbiAgICBpZiAoaHR0cFByb3h5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1wcm94eScsIGh0dHBQcm94eSk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoc3NsUHJveHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJncy5wdXNoKCctLXByb3h5Jywgc3NsUHJveHkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNtQmluYXJ5ID0gZ2V0QmluYXJ5KClcbiAgY29uc3Qgc3Bhd25SZXN1bHQgPSBzcGF3blN5bmMoc21CaW5hcnksIGFyZ3MpXG4gIGxldCBvdXRwdXRcbiAgaWYgKHNwYXduUmVzdWx0LnN0YXR1cykge1xuICAgIGxldCBlcnJvck1lc3NhZ2VcbiAgICBpZiAoc3Bhd25SZXN1bHQuc3RkZXJyLnRvU3RyaW5nKCkpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IHNwYXduUmVzdWx0LnN0ZGVyci50b1N0cmluZygpXG4gICAgfVxuICAgIGlmIChzcGF3blJlc3VsdC5zdGRvdXQudG9TdHJpbmcoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0cHV0ID0gSlNPTi5wYXJzZShzcGF3blJlc3VsdC5zdGRvdXQudG9TdHJpbmcoKSlcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gb3V0cHV0LnJlc3VsdC5tZXNzYWdlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGUudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXJyb3IgZXhlY3V0aW5nIGNvbW1hbmQgZm9yICR7c21CaW5hcnl9IHdpdGggJHthcmdzfTogJHtlcnJvck1lc3NhZ2V9YFxuICAgIClcbiAgfVxuICB0cnkge1xuICAgIG91dHB1dCA9IEpTT04ucGFyc2Uoc3Bhd25SZXN1bHQuc3Rkb3V0LnRvU3RyaW5nKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXJyb3IgZXhlY3V0aW5nIGNvbW1hbmQgZm9yICR7c21CaW5hcnl9IHdpdGggJHthcmdzfTogJHtlLnRvU3RyaW5nKCl9YFxuICAgIClcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIG91dHB1dC5sb2dzKSB7XG4gICAgaWYgKG91dHB1dC5sb2dzW2tleV0ubGV2ZWwgPT09ICdXQVJOJykge1xuICAgICAgY29uc29sZS53YXJuKGAke291dHB1dC5sb2dzW2tleV0ubWVzc2FnZX1gKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQucmVzdWx0Lm1lc3NhZ2Vcbn1cblxuLy8gUFVCTElDIEFQSVxubW9kdWxlLmV4cG9ydHMgPSB7IGRyaXZlckxvY2F0aW9uIH1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmNvbnN0IFJFU1BPTlNFX1RJTUVPVVQgPSAxMDAwICogMzBcbmNsYXNzIENEUENvbm5lY3Rpb24ge1xuICBjb25zdHJ1Y3Rvcih3c0Nvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl93c0Nvbm5lY3Rpb24gPSB3c0Nvbm5lY3Rpb25cbiAgICB0aGlzLmNtZF9pZCA9IDBcbiAgICB0aGlzLnRhcmdldElEID0gbnVsbFxuICAgIHRoaXMuc2Vzc2lvbklkID0gbnVsbFxuICB9XG5cbiAgZXhlY3V0ZShtZXRob2QsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBsZXQgbWVzc2FnZSA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGlkOiB0aGlzLmNtZF9pZCsrLFxuICAgIH1cbiAgICBpZiAodGhpcy5zZXNzaW9uSWQpIHtcbiAgICAgIG1lc3NhZ2VbJ3Nlc3Npb25JZCddID0gdGhpcy5zZXNzaW9uSWRcbiAgICB9XG5cbiAgICBjb25zdCBtZXJnZWRNZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7IHBhcmFtczogcGFyYW1zIH0sIG1lc3NhZ2UpXG4gICAgdGhpcy5fd3NDb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVyZ2VkTWVzc2FnZSksIGNhbGxiYWNrKVxuICB9XG5cbiAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgIGxldCBjZHBfaWQgPSB0aGlzLmNtZF9pZCsrXG4gICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICBpZDogY2RwX2lkLFxuICAgIH1cbiAgICBpZiAodGhpcy5zZXNzaW9uSWQpIHtcbiAgICAgIG1lc3NhZ2VbJ3Nlc3Npb25JZCddID0gdGhpcy5zZXNzaW9uSWRcbiAgICB9XG5cbiAgICBjb25zdCBtZXJnZWRNZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7IHBhcmFtczogcGFyYW1zIH0sIG1lc3NhZ2UpXG4gICAgdGhpcy5fd3NDb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVyZ2VkTWVzc2FnZSkpXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFJlcXVlc3Qgd2l0aCBpZCAke2NkcF9pZH0gdGltZWQgb3V0YCkpXG4gICAgICAgIGhhbmRsZXIub2ZmKCdtZXNzYWdlJywgbGlzdGVuZXIpXG4gICAgICB9LCBSRVNQT05TRV9USU1FT1VUKVxuXG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChkYXRhKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZGF0YS50b1N0cmluZygpKVxuICAgICAgICAgIGlmIChwYXlsb2FkLmlkID09PSBjZHBfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICAgICAgICBoYW5kbGVyLm9mZignbWVzc2FnZScsIGxpc3RlbmVyKVxuICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHBhcnNlIG1lc3NhZ2U6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fd3NDb25uZWN0aW9uLm9uKCdtZXNzYWdlJywgbGlzdGVuZXIpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnRzLkNkcENvbm5lY3Rpb24gPSBDRFBDb25uZWN0aW9uXG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBhIHtAbGlua3BsYWluIERyaXZlciBXZWJEcml2ZXJ9IGNsaWVudCBmb3JcbiAqIE1pY3Jvc29mdCdzIEVkZ2Ugd2ViIGJyb3dzZXIuIEVkZ2UgKENocm9taXVtKSBpcyBzdXBwb3J0ZWQgYW5kIHN1cHBvcnRcbiAqIGZvciBFZGdlIExlZ2FjeSAoRWRnZUhUTUwpIGFzIHBhcnQgb2YgaHR0cHM6Ly9naXRodWIuY29tL1NlbGVuaXVtSFEvc2VsZW5pdW0vaXNzdWVzLzkxNjYuXG4gKiBCZWZvcmUgdXNpbmcgdGhpcyBtb2R1bGUsIHlvdSBtdXN0IGRvd25sb2FkIGFuZCBpbnN0YWxsIHRoZSBjb3JyZWN0XG4gKiBbV2ViRHJpdmVyXShodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3Rvb2xzL3dlYmRyaXZlci8pIHNlcnZlci5cbiAqXG4gKiBFbnN1cmUgdGhhdCB0aGUgbXNlZGdlZHJpdmVyIChDaHJvbWl1bSlcbiAqIGlzIG9uIHlvdXIgW1BBVEhdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUEFUSF8lMjh2YXJpYWJsZSUyOSkuXG4gKlxuICogWW91IG1heSB1c2Uge0BsaW5rIE9wdGlvbnN9IHRvIHNwZWNpZnkgd2hldGhlciBFZGdlIENocm9taXVtIG9wdGlvbnMgc2hvdWxkIGJlIHVzZWQ6XG5cbiAqICAgICBjb25zdCBlZGdlID0gcmVxdWlyZSgnc2VsZW5pdW0td2ViZHJpdmVyL2VkZ2UnKTtcbiAqICAgICBjb25zdCBvcHRpb25zID0gbmV3IGVkZ2UuT3B0aW9ucygpO1xuXG4gKiBUaGVyZSBhcmUgdGhyZWUgcHJpbWFyeSBjbGFzc2VzIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlOlxuICpcbiAqIDEuIHtAbGlua3BsYWluIFNlcnZpY2VCdWlsZGVyfTogY29uZmlndXJlcyB0aGVcbiAqICAgICB7QGxpbmsgLi9yZW1vdGUuRHJpdmVyU2VydmljZSByZW1vdGUuRHJpdmVyU2VydmljZX1cbiAqICAgICB0aGF0IG1hbmFnZXMgdGhlIFtXZWJEcml2ZXJdIGNoaWxkIHByb2Nlc3MuXG4gKlxuICogMi4ge0BsaW5rcGxhaW4gT3B0aW9uc306IGRlZmluZXMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBlYWNoIG5ld1xuICogICAgIFdlYkRyaXZlciBzZXNzaW9uLCBzdWNoIGFzIHdoaWNoXG4gKiAgICAge0BsaW5rcGxhaW4gT3B0aW9ucyNzZXRQcm94eSBwcm94eX0gdG8gdXNlIHdoZW4gc3RhcnRpbmcgdGhlIGJyb3dzZXIuXG4gKlxuICogMy4ge0BsaW5rcGxhaW4gRHJpdmVyfTogdGhlIFdlYkRyaXZlciBjbGllbnQ7IGVhY2ggbmV3IGluc3RhbmNlIHdpbGwgY29udHJvbFxuICogICAgIGEgdW5pcXVlIGJyb3dzZXIgc2Vzc2lvbi5cbiAqXG4gKiBfX0N1c3RvbWl6aW5nIHRoZSBXZWJEcml2ZXIgU2VydmVyX18gPGEgaWQ9XCJjdXN0b20tc2VydmVyXCI+PC9hPlxuICpcbiAqIEJ5IGRlZmF1bHQsIGV2ZXJ5IE1pY3Jvc29mdEVkZ2Ugc2Vzc2lvbiB3aWxsIHVzZSBhIHNpbmdsZSBkcml2ZXIgc2VydmljZSxcbiAqIHdoaWNoIGlzIHN0YXJ0ZWQgdGhlIGZpcnN0IHRpbWUgYSB7QGxpbmsgRHJpdmVyfSBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZFxuICogdGVybWluYXRlZCB3aGVuIHRoaXMgcHJvY2VzcyBleGl0cy4gVGhlIGRlZmF1bHQgc2VydmljZSB3aWxsIGluaGVyaXQgaXRzXG4gKiBlbnZpcm9ubWVudCBmcm9tIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGhhbmRsZSB0byB0aGlzIGRlZmF1bHQgc2VydmljZSB1c2luZ1xuICoge0BsaW5rICNnZXREZWZhdWx0U2VydmljZSBnZXREZWZhdWx0U2VydmljZSgpfSBhbmQgY2hhbmdlIGl0cyBjb25maWd1cmF0aW9uXG4gKiB3aXRoIHtAbGluayAjc2V0RGVmYXVsdFNlcnZpY2Ugc2V0RGVmYXVsdFNlcnZpY2UoKX0uXG4gKlxuICogWW91IG1heSBhbHNvIGNyZWF0ZSBhIHtAbGluayBEcml2ZXJ9IHdpdGggaXRzIG93biBkcml2ZXIgc2VydmljZS4gVGhpcyBpc1xuICogdXNlZnVsIGlmIHlvdSBuZWVkIHRvIGNhcHR1cmUgdGhlIHNlcnZlcidzIGxvZyBvdXRwdXQgZm9yIGEgc3BlY2lmaWMgc2Vzc2lvbjpcbiAqXG4gKiAgICAgY29uc3QgZWRnZSA9IHJlcXVpcmUoJ3NlbGVuaXVtLXdlYmRyaXZlci9lZGdlJyk7XG4gKlxuICogICAgIGNvbnN0IHNlcnZpY2UgPSBuZXcgZWRnZS5TZXJ2aWNlQnVpbGRlcigpXG4gKiAgICAgICAgIC5zZXRQb3J0KDU1NTU1KVxuICogICAgICAgICAuYnVpbGQoKTtcbiAqXG4gKiAgICAgbGV0IG9wdGlvbnMgPSBuZXcgZWRnZS5PcHRpb25zKCk7XG4gKiAgICAgLy8gY29uZmlndXJlIGJyb3dzZXIgb3B0aW9ucyAuLi5cbiAqXG4gKiAgICAgbGV0IGRyaXZlciA9IGVkZ2UuRHJpdmVyLmNyZWF0ZVNlc3Npb24ob3B0aW9ucywgc2VydmljZSk7XG4gKlxuICogVXNlcnMgc2hvdWxkIG9ubHkgaW5zdGFudGlhdGUgdGhlIHtAbGluayBEcml2ZXJ9IGNsYXNzIGRpcmVjdGx5IHdoZW4gdGhleVxuICogbmVlZCBhIGN1c3RvbSBkcml2ZXIgc2VydmljZSBjb25maWd1cmF0aW9uIChhcyBzaG93biBhYm92ZSkuIEZvciBub3JtYWxcbiAqIG9wZXJhdGlvbiwgdXNlcnMgc2hvdWxkIHN0YXJ0IG1zZWRnZWRyaXZlciB1c2luZyB0aGVcbiAqIHtAbGluayAuL2J1aWxkZXIuQnVpbGRlciBzZWxlbml1bS13ZWJkcml2ZXIuQnVpbGRlcn0uXG4gKlxuICogW1dlYkRyaXZlciAoQ2hyb21pdW0pXTogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2Uvd2ViZHJpdmVyLWNocm9taXVtXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnJvd3NlciB9ID0gcmVxdWlyZSgnLi9saWIvY2FwYWJpbGl0aWVzJylcbmNvbnN0IGlvID0gcmVxdWlyZSgnLi9pbycpXG5jb25zdCBjaHJvbWl1bSA9IHJlcXVpcmUoJy4vY2hyb21pdW0nKVxuXG4vKipcbiAqIE5hbWUgb2YgdGhlIEVkZ2VEcml2ZXIgZXhlY3V0YWJsZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xuY29uc3QgRURHRURSSVZFUl9DSFJPTUlVTV9FWEUgPVxuICBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJ21zZWRnZWRyaXZlci5leGUnIDogJ21zZWRnZWRyaXZlcidcblxuLyoqIEB0eXBlIHtyZW1vdGUuRHJpdmVyU2VydmljZX0gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHtAbGluayBzZWxlbml1bS13ZWJkcml2ZXIvcmVtb3RlLkRyaXZlclNlcnZpY2V9IGluc3RhbmNlcyB0aGF0IG1hbmFnZVxuICogYSBbTVNFZGdlRHJpdmVyXShodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3Rvb2xzL3dlYmRyaXZlci8pXG4gKiBzZXJ2ZXIgaW4gYSBjaGlsZCBwcm9jZXNzLlxuICovXG5jbGFzcyBTZXJ2aWNlQnVpbGRlciBleHRlbmRzIGNocm9taXVtLlNlcnZpY2VCdWlsZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2V4ZSBQYXRoIHRvIHRoZSBzZXJ2ZXIgZXhlY3V0YWJsZSB0byB1c2UuIElmIG9taXR0ZWQsXG4gICAqICAgICB0aGUgYnVpbGRlciB3aWxsIGF0dGVtcHQgdG8gbG9jYXRlIHRoZSBtc2VkZ2Vkcml2ZXIgb24gdGhlIGN1cnJlbnRcbiAgICogICAgIFBBVEguXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwcm92aWRlZCBleGVjdXRhYmxlIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgbXNlZGdlZHJpdmVyXG4gICAqICAgICBjYW5ub3QgYmUgZm91bmQgb24gdGhlIFBBVEguXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXhlKSB7XG4gICAgbGV0IGV4ZSA9IG9wdF9leGUgfHwgbG9jYXRlU3luY2hyb25vdXNseSgpXG4gICAgc3VwZXIoZXhlKVxuICAgIHRoaXMuc2V0TG9vcGJhY2sodHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIGZvciBtYW5hZ2luZyBlZGdlIGNocm9taXVtIHNwZWNpZmljIG9wdGlvbnMuXG4gKi9cbmNsYXNzIE9wdGlvbnMgZXh0ZW5kcyBjaHJvbWl1bS5PcHRpb25zIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhdGggdG8gdGhlIGVkZ2UgYmluYXJ5IHRvIHVzZVxuICAgKlxuICAgKiBUaGUgYmluYXJ5IHBhdGggYmUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8gdGhlIG1zZWRnZWRyaXZlciBzZXJ2ZXJcbiAgICogZXhlY3V0YWJsZSwgYnV0IGl0IG11c3QgZXhpc3Qgb24gdGhlIG1hY2hpbmUgdGhhdCB3aWxsIGxhdW5jaCBlZGdlIGNocm9taXVtLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgbXNlZGdlZHJpdmVyIGJpbmFyeSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0RWRnZUNocm9taXVtQmluYXJ5UGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QmluYXJ5UGF0aChwYXRoKVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGJyb3dzZXIgbmFtZSB0byAnd2VidmlldzInIHRvIGVuYWJsZVxuICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3dlYnZpZXcyL2hvdy10by93ZWJkcml2ZXJcIj5cbiAgICogICB0ZXN0IGF1dG9tYXRpb24gb2YgV2ViVmlldzIgYXBwcyB3aXRoIE1pY3Jvc29mdCBFZGdlIFdlYkRyaXZlclxuICAgKiA8L2E+XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlICBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSAnd2VidmlldzInIHVzYWdlXG4gICAqL1xuICB1c2VXZWJWaWV3KGVuYWJsZSkge1xuICAgIGNvbnN0IGJyb3dzZXJOYW1lID0gZW5hYmxlID8gJ3dlYnZpZXcyJyA6IEJyb3dzZXIuRURHRVxuICAgIHJldHVybiB0aGlzLnNldEJyb3dzZXJOYW1lKGJyb3dzZXJOYW1lKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBXZWJEcml2ZXIgY2xpZW50IGZvciBNaWNyb3NvZnQncyBFZGdlLlxuICovXG5jbGFzcyBEcml2ZXIgZXh0ZW5kcyBjaHJvbWl1bS5Ecml2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBicm93c2VyIHNlc3Npb24gZm9yIE1pY3Jvc29mdCdzIEVkZ2UgYnJvd3Nlci5cbiAgICpcbiAgICogQHBhcmFtIHsoQ2FwYWJpbGl0aWVzfE9wdGlvbnMpPX0gb3B0X2NvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3JlbW90ZS5Ecml2ZXJTZXJ2aWNlPX0gb3B0X3NlcnZpY2VFeGVjdXRvciBUaGUgc2VydmljZSB0byB1c2U7IHdpbGwgY3JlYXRlXG4gICAqICAgICBhIG5ldyBMZWdhY3kgb3IgQ2hyb21pdW0gc2VydmljZSBiYXNlZCBvbiB7QGxpbmtwbGFpbiBPcHRpb25zfSBieSBkZWZhdWx0LlxuICAgKiBAcmV0dXJuIHshRHJpdmVyfSBBIG5ldyBkcml2ZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlU2Vzc2lvbihvcHRfY29uZmlnLCBvcHRfc2VydmljZUV4ZWN1dG9yKSB7XG4gICAgbGV0IGNhcHMgPSBvcHRfY29uZmlnIHx8IG5ldyBPcHRpb25zKClcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshRHJpdmVyfSAqLyAoXG4gICAgICBzdXBlci5jcmVhdGVTZXNzaW9uKGNhcHMsIG9wdF9zZXJ2aWNlRXhlY3V0b3IpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgbmV3IGluc3RhbmNlIG9mIGVkZ2UgZHJpdmVyIHNlcnZpY2VcbiAgICogQHJldHVybnMge3JlbW90ZS5Ecml2ZXJTZXJ2aWNlfVxuICAgKi9cbiAgc3RhdGljIGdldERlZmF1bHRTZXJ2aWNlKCkge1xuICAgIHJldHVybiBuZXcgU2VydmljZUJ1aWxkZXIoKS5idWlsZCgpXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBhIG5vLW9wIGFzIGZpbGUgZGV0ZWN0b3JzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXNcbiAgICogaW1wbGVtZW50YXRpb24uXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0RmlsZURldGVjdG9yKCkge31cbn1cblxuLyoqXG4gKiBfU3luY2hyb25vdXNseV8gYXR0ZW1wdHMgdG8gbG9jYXRlIHRoZSBjaHJvbWVkcml2ZXIgZXhlY3V0YWJsZSBvbiB0aGUgY3VycmVudFxuICogc3lzdGVtLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IHRoZSBsb2NhdGVkIGV4ZWN1dGFibGUsIG9yIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gbG9jYXRlU3luY2hyb25vdXNseSgpIHtcbiAgcmV0dXJuIGlvLmZpbmRJblBhdGgoRURHRURSSVZFUl9DSFJPTUlVTV9FWEUsIHRydWUpXG59XG5cbk9wdGlvbnMucHJvdG90eXBlLkJST1dTRVJfTkFNRV9WQUxVRSA9IEJyb3dzZXIuRURHRVxuT3B0aW9ucy5wcm90b3R5cGUuQ0FQQUJJTElUWV9LRVkgPSAnbXM6ZWRnZU9wdGlvbnMnXG5Ecml2ZXIucHJvdG90eXBlLlZFTkRPUl9DQVBBQklMSVRZX1BSRUZJWCA9ICdtcydcblxuLy8gUFVCTElDIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRHJpdmVyLFxuICBPcHRpb25zLFxuICBTZXJ2aWNlQnVpbGRlcixcbiAgbG9jYXRlU3luY2hyb25vdXNseSxcbn1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEZWZpbmVzIHRoZSB7QGxpbmtwbGFpbiBEcml2ZXIgV2ViRHJpdmVyfSBjbGllbnQgZm9yIEZpcmVmb3guXG4gKiBCZWZvcmUgdXNpbmcgdGhpcyBtb2R1bGUsIHlvdSBtdXN0IGRvd25sb2FkIHRoZSBsYXRlc3RcbiAqIFtnZWNrb2RyaXZlciByZWxlYXNlXSBhbmQgZW5zdXJlIGl0IGNhbiBiZSBmb3VuZCBvbiB5b3VyIHN5c3RlbSBbUEFUSF0uXG4gKlxuICogRWFjaCBGaXJlZm94RHJpdmVyIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZCB3aXRoIGFuIGFub255bW91cyBwcm9maWxlLFxuICogZW5zdXJpbmcgYnJvd3NlciBoaXN0b3J5cyBkbyBub3Qgc2hhcmUgc2Vzc2lvbiBkYXRhIChjb29raWVzLCBoaXN0b3J5LCBjYWNoZSxcbiAqIG9mZmxpbmUgc3RvcmFnZSwgZXRjLilcbiAqXG4gKiBfX0N1c3RvbWl6aW5nIHRoZSBGaXJlZm94IFByb2ZpbGVfX1xuICpcbiAqIFRoZSBwcm9maWxlIHVzZWQgZm9yIGVhY2ggV2ViRHJpdmVyIHNlc3Npb24gbWF5IGJlIGNvbmZpZ3VyZWQgdXNpbmcgdGhlXG4gKiB7QGxpbmtwbGFpbiBPcHRpb25zfSBjbGFzcy4gRm9yIGV4YW1wbGUsIHlvdSBtYXkgaW5zdGFsbCBhbiBleHRlbnNpb24sIGxpa2VcbiAqIEZpcmVidWc6XG4gKlxuICogICAgIGNvbnN0IHtCdWlsZGVyfSA9IHJlcXVpcmUoJ3NlbGVuaXVtLXdlYmRyaXZlcicpO1xuICogICAgIGNvbnN0IGZpcmVmb3ggPSByZXF1aXJlKCdzZWxlbml1bS13ZWJkcml2ZXIvZmlyZWZveCcpO1xuICpcbiAqICAgICBsZXQgb3B0aW9ucyA9IG5ldyBmaXJlZm94Lk9wdGlvbnMoKVxuICogICAgICAgICAuYWRkRXh0ZW5zaW9ucygnL3BhdGgvdG8vZmlyZWJ1Zy54cGknKVxuICogICAgICAgICAuc2V0UHJlZmVyZW5jZSgnZXh0ZW5zaW9ucy5maXJlYnVnLnNob3dDaHJvbWVFcnJvcnMnLCB0cnVlKTtcbiAqXG4gKiAgICAgbGV0IGRyaXZlciA9IG5ldyBCdWlsZGVyKClcbiAqICAgICAgICAgLmZvckJyb3dzZXIoJ2ZpcmVmb3gnKVxuICogICAgICAgICAuc2V0RmlyZWZveE9wdGlvbnMob3B0aW9ucylcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogVGhlIHtAbGlua3BsYWluIE9wdGlvbnN9IGNsYXNzIG1heSBhbHNvIGJlIHVzZWQgdG8gY29uZmlndXJlIFdlYkRyaXZlciBiYXNlZFxuICogb24gYSBwcmUtZXhpc3RpbmcgYnJvd3NlciBwcm9maWxlOlxuICpcbiAqICAgICBsZXQgcHJvZmlsZSA9ICcvdXNyL2xvY2FsL2hvbWUvYm9iLy5tb3ppbGxhL2ZpcmVmb3gvM2Znb2c3NWgudGVzdGluZyc7XG4gKiAgICAgbGV0IG9wdGlvbnMgPSBuZXcgZmlyZWZveC5PcHRpb25zKCkuc2V0UHJvZmlsZShwcm9maWxlKTtcbiAqXG4gKiBUaGUgRmlyZWZveERyaXZlciB3aWxsIF9uZXZlcl8gbW9kaWZ5IGEgcHJlLWV4aXN0aW5nIHByb2ZpbGU7IGluc3RlYWQgaXQgd2lsbFxuICogY3JlYXRlIGEgY29weSBmb3IgaXQgdG8gbW9kaWZ5LiBCeSBleHRlbnNpb24sIHRoZXJlIGFyZSBjZXJ0YWluIGJyb3dzZXJcbiAqIHByZWZlcmVuY2VzIHRoYXQgYXJlIHJlcXVpcmVkIGZvciBXZWJEcml2ZXIgdG8gZnVuY3Rpb24gcHJvcGVybHkgYW5kIHRoZXlcbiAqIHdpbGwgYWx3YXlzIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIF9fVXNpbmcgYSBDdXN0b20gRmlyZWZveCBCaW5hcnlfX1xuICpcbiAqIE9uIFdpbmRvd3MgYW5kIE1hY09TLCB0aGUgRmlyZWZveERyaXZlciB3aWxsIHNlYXJjaCBmb3IgRmlyZWZveCBpbiBpdHNcbiAqIGRlZmF1bHQgaW5zdGFsbGF0aW9uIGxvY2F0aW9uOlxuICpcbiAqIC0gV2luZG93czogQzpcXFByb2dyYW0gRmlsZXMgYW5kIEM6XFxQcm9ncmFtIEZpbGVzICh4ODYpLlxuICogLSBNYWNPUzogL0FwcGxpY2F0aW9ucy9GaXJlZm94LmFwcFxuICpcbiAqIEZvciBMaW51eCwgRmlyZWZveCB3aWxsIGFsd2F5cyBiZSBsb2NhdGVkIG9uIHRoZSBQQVRIOiBgJCh3aGVyZSBmaXJlZm94KWAuXG4gKlxuICogU2V2ZXJhbCBtZXRob2RzIGFyZSBwcm92aWRlZCBmb3Igc3RhcnRpbmcgRmlyZWZveCB3aXRoIGEgY3VzdG9tIGV4ZWN1dGFibGUuXG4gKiBGaXJzdCwgb24gV2luZG93cyBhbmQgTWFjT1MsIHlvdSBtYXkgY29uZmlndXJlIFdlYkRyaXZlciB0byBjaGVjayB0aGUgZGVmYXVsdFxuICogaW5zdGFsbCBsb2NhdGlvbiBmb3IgYSBub24tcmVsZWFzZSBjaGFubmVsLiBJZiB0aGUgcmVxdWVzdGVkIGNoYW5uZWwgY2Fubm90XG4gKiBiZSBmb3VuZCBpbiBpdHMgZGVmYXVsdCBsb2NhdGlvbiwgV2ViRHJpdmVyIHdpbGwgZmFsbGJhY2sgdG8gc2VhcmNoaW5nIHlvdXJcbiAqIFBBVEguIF9Ob3RlOl8gb24gTGludXgsIEZpcmVmb3ggaXMgX2Fsd2F5c18gbG9jYXRlZCBvbiB5b3VyIHBhdGgsIHJlZ2FyZGxlc3NcbiAqIG9mIHRoZSByZXF1ZXN0ZWQgY2hhbm5lbC5cbiAqXG4gKiAgICAgY29uc3Qge0J1aWxkZXJ9ID0gcmVxdWlyZSgnc2VsZW5pdW0td2ViZHJpdmVyJyk7XG4gKiAgICAgY29uc3QgZmlyZWZveCA9IHJlcXVpcmUoJ3NlbGVuaXVtLXdlYmRyaXZlci9maXJlZm94Jyk7XG4gKlxuICogICAgIGxldCBvcHRpb25zID0gbmV3IGZpcmVmb3guT3B0aW9ucygpLnNldEJpbmFyeShmaXJlZm94LkNoYW5uZWwuTklHSFRMWSk7XG4gKiAgICAgbGV0IGRyaXZlciA9IG5ldyBCdWlsZGVyKClcbiAqICAgICAgICAgLmZvckJyb3dzZXIoJ2ZpcmVmb3gnKVxuICogICAgICAgICAuc2V0RmlyZWZveE9wdGlvbnMob3B0aW9ucylcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogT24gYWxsIHBsYXRmb3JtcywgeW91IG1heSBjb25maWd1cmUgV2ViRHJpdmVyIHRvIHVzZSBhIEZpcmVmb3ggc3BlY2lmaWNcbiAqIGV4ZWN1dGFibGU6XG4gKlxuICogICAgIGxldCBvcHRpb25zID0gbmV3IGZpcmVmb3guT3B0aW9ucygpXG4gKiAgICAgICAgIC5zZXRCaW5hcnkoJy9teS9maXJlZm94L2luc3RhbGwvZGlyL2ZpcmVmb3gtYmluJyk7XG4gKlxuICogX19SZW1vdGUgVGVzdGluZ19fXG4gKlxuICogWW91IG1heSBjdXN0b21pemUgdGhlIEZpcmVmb3ggYmluYXJ5IGFuZCBwcm9maWxlIHdoZW4gcnVubmluZyBhZ2FpbnN0IGFcbiAqIHJlbW90ZSBTZWxlbml1bSBzZXJ2ZXIuIFlvdXIgY3VzdG9tIHByb2ZpbGUgd2lsbCBiZSBwYWNrYWdlZCBhcyBhIHppcCBhbmRcbiAqIHRyYW5zZmVycmVkIHRvIHRoZSByZW1vdGUgaG9zdCBmb3IgdXNlLiBUaGUgcHJvZmlsZSB3aWxsIGJlIHRyYW5zZmVycmVkXG4gKiBfb25jZSBmb3IgZWFjaCBuZXcgc2Vzc2lvbl8uIFRoZSBwZXJmb3JtYW5jZSBpbXBhY3Qgc2hvdWxkIGJlIG1pbmltYWwgaWZcbiAqIHlvdSd2ZSBvbmx5IGNvbmZpZ3VyZWQgYSBmZXcgZXh0cmEgYnJvd3NlciBwcmVmZXJlbmNlcy4gSWYgeW91IGhhdmUgYSBsYXJnZVxuICogcHJvZmlsZSB3aXRoIHNldmVyYWwgZXh0ZW5zaW9ucywgeW91IHNob3VsZCBjb25zaWRlciBpbnN0YWxsaW5nIGl0IG9uIHRoZVxuICogcmVtb3RlIGhvc3QgYW5kIGRlZmluaW5nIGl0cyBwYXRoIHZpYSB0aGUge0BsaW5rIE9wdGlvbnN9IGNsYXNzLiBDdXN0b21cbiAqIGJpbmFyaWVzIGFyZSBuZXZlciBjb3BpZWQgdG8gcmVtb3RlIG1hY2hpbmVzIGFuZCBtdXN0IGJlIHJlZmVyZW5jZWQgYnlcbiAqIGluc3RhbGxhdGlvbiBwYXRoLlxuICpcbiAqICAgICBjb25zdCB7QnVpbGRlcn0gPSByZXF1aXJlKCdzZWxlbml1bS13ZWJkcml2ZXInKTtcbiAqICAgICBjb25zdCBmaXJlZm94ID0gcmVxdWlyZSgnc2VsZW5pdW0td2ViZHJpdmVyL2ZpcmVmb3gnKTtcbiAqXG4gKiAgICAgbGV0IG9wdGlvbnMgPSBuZXcgZmlyZWZveC5PcHRpb25zKClcbiAqICAgICAgICAgLnNldFByb2ZpbGUoJy9wcm9maWxlL3BhdGgvb24vcmVtb3RlL2hvc3QnKVxuICogICAgICAgICAuc2V0QmluYXJ5KCcvaW5zdGFsbC9kaXIvb24vcmVtb3RlL2hvc3QvZmlyZWZveC1iaW4nKTtcbiAqXG4gKiAgICAgbGV0IGRyaXZlciA9IG5ldyBCdWlsZGVyKClcbiAqICAgICAgICAgLmZvckJyb3dzZXIoJ2ZpcmVmb3gnKVxuICogICAgICAgICAudXNpbmdTZXJ2ZXIoJ2h0dHA6Ly8xMjcuMC4wLjE6NDQ0NC93ZC9odWInKVxuICogICAgICAgICAuc2V0RmlyZWZveE9wdGlvbnMob3B0aW9ucylcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogW2dlY2tvZHJpdmVyIHJlbGVhc2VdOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrb2RyaXZlci9yZWxlYXNlcy9cbiAqIFtQQVRIXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QQVRIXyUyOHZhcmlhYmxlJTI5XG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4vbGliL3N5bWJvbHMnKVxuY29uc3QgY29tbWFuZCA9IHJlcXVpcmUoJy4vbGliL2NvbW1hbmQnKVxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJy4vaHR0cCcpXG5jb25zdCBpbyA9IHJlcXVpcmUoJy4vaW8nKVxuY29uc3QgcmVtb3RlID0gcmVxdWlyZSgnLi9yZW1vdGUnKVxuY29uc3Qgd2ViZHJpdmVyID0gcmVxdWlyZSgnLi9saWIvd2ViZHJpdmVyJylcbmNvbnN0IHppcCA9IHJlcXVpcmUoJy4vaW8vemlwJylcbmNvbnN0IHsgQnJvd3NlciwgQ2FwYWJpbGl0aWVzIH0gPSByZXF1aXJlKCcuL2xpYi9jYXBhYmlsaXRpZXMnKVxuY29uc3QgeyBaaXAgfSA9IHJlcXVpcmUoJy4vaW8vemlwJylcbmNvbnN0IHsgZ2V0UGF0aCB9ID0gcmVxdWlyZSgnLi9jb21tb24vZHJpdmVyRmluZGVyJylcblxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGVyZSBhbiBhZGQtb24gaXMgbWFsZm9ybWVkLlxuICogQGZpbmFsXG4gKi9cbmNsYXNzIEFkZG9uRm9ybWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gbXNnIFRoZSBlcnJvciBtZXNzYWdlLiAqL1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2cpXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZVxuICB9XG59XG5cbi8qKlxuICogSW5zdGFsbHMgYW4gZXh0ZW5zaW9uIHRvIHRoZSBnaXZlbiBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5zaW9uIFBhdGggdG8gdGhlIHhwaSBleHRlbnNpb24gZmlsZSB0byBpbnN0YWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpciBQYXRoIHRvIHRoZSBkaXJlY3RvcnkgdG8gaW5zdGFsbCB0aGUgZXh0ZW5zaW9uIGluLlxuICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIGZvciB0aGUgYWRkLW9uIElEIG9uY2VcbiAqICAgICBpbnN0YWxsZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxFeHRlbnNpb24oZXh0ZW5zaW9uLCBkaXIpIHtcbiAgY29uc3QgZXh0ID0gZXh0ZW5zaW9uLnNsaWNlKC00KVxuICBpZiAoZXh0ICE9PSAnLnhwaScgJiYgZXh0ICE9PSAnLnppcCcpIHtcbiAgICB0aHJvdyBFcnJvcignRmlsZSBuYW1lIGRvZXMgbm90IGVuZCBpbiBcIi56aXBcIiBvciBcIi54cGlcIjogJyArIGV4dClcbiAgfVxuXG4gIGxldCBhcmNoaXZlID0gYXdhaXQgemlwLmxvYWQoZXh0ZW5zaW9uKVxuICBpZiAoIWFyY2hpdmUuaGFzKCdtYW5pZmVzdC5qc29uJykpIHtcbiAgICB0aHJvdyBuZXcgQWRkb25Gb3JtYXRFcnJvcihgQ291bGRuJ3QgZmluZCBtYW5pZmVzdC5qc29uIGluICR7ZXh0ZW5zaW9ufWApXG4gIH1cblxuICBsZXQgYnVmID0gYXdhaXQgYXJjaGl2ZS5nZXRGaWxlKCdtYW5pZmVzdC5qc29uJylcbiAgbGV0IHBhcnNlZEpTT04gPSBKU09OLnBhcnNlKGJ1Zi50b1N0cmluZygndXRmOCcpKVxuXG4gIGxldCB7IGJyb3dzZXJfc3BlY2lmaWNfc2V0dGluZ3MgfSA9XG4gICAgLyoqIEB0eXBlIHt7YnJvd3Nlcl9zcGVjaWZpY19zZXR0aW5nczp7Z2Vja286e2lkOnN0cmluZ319fX0gKi9cbiAgICBwYXJzZWRKU09OXG5cbiAgaWYgKGJyb3dzZXJfc3BlY2lmaWNfc2V0dGluZ3MgJiYgYnJvd3Nlcl9zcGVjaWZpY19zZXR0aW5ncy5nZWNrbykge1xuICAgIC8qIGJyb3dzZXJfc3BlY2lmaWNfc2V0dGluZ3MgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYXBwbGljYXRpb25zXG4gICAgICogSXQgaXMgbWVhbnQgdG8gZmFjaWxpdGF0ZSBjcm9zcy1icm93c2VyIHBsdWdpbnMgc2luY2UgRmlyZWZveDQ4XG4gICAgICogc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNjIwMDVcbiAgICAgKi9cbiAgICBwYXJzZWRKU09OLmFwcGxpY2F0aW9ucyA9IGJyb3dzZXJfc3BlY2lmaWNfc2V0dGluZ3NcbiAgfVxuXG4gIGxldCB7IGFwcGxpY2F0aW9ucyB9ID1cbiAgICAvKiogQHR5cGUge3thcHBsaWNhdGlvbnM6e2dlY2tvOntpZDpzdHJpbmd9fX19ICovXG4gICAgcGFyc2VkSlNPTlxuICBpZiAoIShhcHBsaWNhdGlvbnMgJiYgYXBwbGljYXRpb25zLmdlY2tvICYmIGFwcGxpY2F0aW9ucy5nZWNrby5pZCkpIHtcbiAgICB0aHJvdyBuZXcgQWRkb25Gb3JtYXRFcnJvcihgQ291bGQgbm90IGZpbmQgYWRkLW9uIElEIGZvciAke2V4dGVuc2lvbn1gKVxuICB9XG5cbiAgYXdhaXQgaW8uY29weShleHRlbnNpb24sIGAke3BhdGguam9pbihkaXIsIGFwcGxpY2F0aW9ucy5nZWNrby5pZCl9LnhwaWApXG4gIHJldHVybiBhcHBsaWNhdGlvbnMuZ2Vja28uaWRcbn1cblxuY2xhc3MgUHJvZmlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAcHJpdmF0ZSB7P3N0cmluZ30gKi9cbiAgICB0aGlzLnRlbXBsYXRlXyA9IG51bGxcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFycmF5PHN0cmluZz59ICovXG4gICAgdGhpcy5leHRlbnNpb25zXyA9IFtdXG4gIH1cblxuICBhZGRFeHRlbnNpb25zKC8qKiAhQXJyYXk8c3RyaW5nPiAqLyBwYXRocykge1xuICAgIHRoaXMuZXh0ZW5zaW9uc18gPSB0aGlzLmV4dGVuc2lvbnNfLmNvbmNhdCguLi5wYXRocylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHsoIVByb21pc2U8c3RyaW5nPnx1bmRlZmluZWQpfSBhIHByb21pc2UgZm9yIGEgYmFzZTY0IGVuY29kZWRcbiAgICogICAgIHByb2ZpbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSdzIG5vIGRhdGEgdG8gaW5jbHVkZS5cbiAgICovXG4gIFtTeW1ib2xzLnNlcmlhbGl6ZV0oKSB7XG4gICAgaWYgKHRoaXMudGVtcGxhdGVfIHx8IHRoaXMuZXh0ZW5zaW9uc18ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYnVpbGRQcm9maWxlKHRoaXMudGVtcGxhdGVfLCB0aGlzLmV4dGVuc2lvbnNfKVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHRlbXBsYXRlIHBhdGggdG8gYW4gZXhpc3RpbmcgcHJvZmlsZSB0byB1c2UgYXMgYSB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGV4dGVuc2lvbnMgcGF0aHMgdG8gZXh0ZW5zaW9ucyB0byBpbnN0YWxsIGluIHRoZSBuZXdcbiAqICAgICBwcm9maWxlLlxuICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gYSBwcm9taXNlIGZvciB0aGUgYmFzZTY0IGVuY29kZWQgcHJvZmlsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYnVpbGRQcm9maWxlKHRlbXBsYXRlLCBleHRlbnNpb25zKSB7XG4gIGxldCBkaXIgPSB0ZW1wbGF0ZVxuXG4gIGlmIChleHRlbnNpb25zLmxlbmd0aCkge1xuICAgIGRpciA9IGF3YWl0IGlvLnRtcERpcigpXG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBhd2FpdCBpby5jb3B5RGlyKFxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRlbXBsYXRlKSxcbiAgICAgICAgZGlyLFxuICAgICAgICAvKHBhcmVudFxcLmxvY2t8bG9ja3xcXC5wYXJlbnRsb2NrKS9cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbnNpb25zRGlyID0gcGF0aC5qb2luKGRpciwgJ2V4dGVuc2lvbnMnKVxuICAgIGF3YWl0IGlvLm1rZGlyKGV4dGVuc2lvbnNEaXIpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF3YWl0IGluc3RhbGxFeHRlbnNpb24oZXh0ZW5zaW9uc1tpXSwgZXh0ZW5zaW9uc0RpcilcbiAgICB9XG4gIH1cblxuICBsZXQgemlwID0gbmV3IFppcCgpXG4gIHJldHVybiB6aXBcbiAgICAuYWRkRGlyKGRpcilcbiAgICAudGhlbigoKSA9PiB6aXAudG9CdWZmZXIoKSlcbiAgICAudGhlbigoYnVmKSA9PiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpKVxufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEZpcmVmb3hEcml2ZXIuXG4gKi9cbmNsYXNzIE9wdGlvbnMgZXh0ZW5kcyBDYXBhYmlsaXRpZXMge1xuICAvKipcbiAgICogQHBhcmFtIHsoQ2FwYWJpbGl0aWVzfE1hcDxzdHJpbmcsID8+fE9iamVjdCk9fSBvdGhlciBBbm90aGVyIHNldCBvZlxuICAgKiAgICAgY2FwYWJpbGl0aWVzIHRvIGluaXRpYWxpemUgdGhpcyBpbnN0YW5jZSBmcm9tLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3RoZXIpIHtcbiAgICBzdXBlcihvdGhlcilcbiAgICB0aGlzLnNldEJyb3dzZXJOYW1lKEJyb3dzZXIuRklSRUZPWClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmlyZWZveE9wdGlvbnNfKCkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5nZXQoJ21vejpmaXJlZm94T3B0aW9ucycpXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICAgIHRoaXMuc2V0KCdtb3o6ZmlyZWZveE9wdGlvbnMnLCBvcHRpb25zKVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFQcm9maWxlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvZmlsZV8oKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLmZpcmVmb3hPcHRpb25zXygpXG4gICAgaWYgKCFvcHRpb25zLnByb2ZpbGUpIHtcbiAgICAgIG9wdGlvbnMucHJvZmlsZSA9IG5ldyBQcm9maWxlKClcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMucHJvZmlsZVxuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYWRkaXRpb25hbCBjb21tYW5kIGxpbmUgYXJndW1lbnRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBzdGFydGluZ1xuICAgKiB0aGUgRmlyZWZveCBicm93c2VyLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihzdHJpbmd8IUFycmF5PHN0cmluZz4pfSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW5jbHVkZS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBhZGRBcmd1bWVudHMoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLmZpcmVmb3hPcHRpb25zXygpXG4gICAgICBvcHRpb25zLmFyZ3MgPSBvcHRpb25zLmFyZ3MgPyBvcHRpb25zLmFyZ3MuY29uY2F0KC4uLmFyZ3MpIDogYXJnc1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgT3B0aW9ucyNhZGRBcmd1bWVudHN9IGluc3RlYWQuXG4gICAqIEBleGFtcGxlXG4gICAqIG9wdGlvbnMuYWRkQXJndW1lbnRzKCctaGVhZGxlc3MnKTtcbiAgICogQGV4YW1wbGVcbiAgICogQ29uZmlndXJlcyB0aGUgZ2Vja29kcml2ZXIgdG8gc3RhcnQgRmlyZWZveCBpbiBoZWFkbGVzcyBtb2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGhlYWRsZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmFkZEFyZ3VtZW50cygnLWhlYWRsZXNzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbml0aWFsIHdpbmRvdyBzaXplIHdoZW4gcnVubmluZyBpblxuICAgKiB7QGxpbmtwbGFpbiAjaGVhZGxlc3MgaGVhZGxlc3N9IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gc2l6ZSBUaGUgZGVzaXJlZCB3aW5kb3cgc2l6ZS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd2lkdGggb3IgaGVpZ2h0IGlzIHVuc3BlY2lmaWVkLCBub3QgYSBudW1iZXIsIG9yXG4gICAqICAgICBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMC5cbiAgICovXG4gIHdpbmRvd1NpemUoeyB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgICBmdW5jdGlvbiBjaGVja0FyZyhhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPD0gMCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIHt3aWR0aCwgaGVpZ2h0fSB3aXRoIG51bWJlcnMgPiAwJylcbiAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBcmcod2lkdGgpXG4gICAgY2hlY2tBcmcoaGVpZ2h0KVxuICAgIHJldHVybiB0aGlzLmFkZEFyZ3VtZW50cyhgLS13aWR0aD0ke3dpZHRofWAsIGAtLWhlaWdodD0ke2hlaWdodH1gKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBleHRlbnNpb25zIHRoYXQgc2hvdWxkIGJlIGluc3RhbGxlZCB3aGVuIHN0YXJ0aW5nIEZpcmVmb3guXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRocyBUaGUgcGF0aHMgdG8gdGhlIGV4dGVuc2lvbiBYUEkgZmlsZXMgdG8gaW5zdGFsbC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBhZGRFeHRlbnNpb25zKC4uLnBhdGhzKSB7XG4gICAgdGhpcy5wcm9maWxlXygpLmFkZEV4dGVuc2lvbnMocGF0aHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBwcmVmZXJlbmNlIGtleS5cbiAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxib29sZWFuKX0gdmFsdWUgdGhlIHByZWZlcmVuY2UgdmFsdWUuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIGVpdGhlciB0aGUga2V5IG9yIHZhbHVlIGhhcyBhbiBpbnZhbGlkIHR5cGUuXG4gICAqL1xuICBzZXRQcmVmZXJlbmNlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihga2V5IG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHt0eXBlb2Yga2V5fWApXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nXG4gICAgKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAgIGB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4sIGJ1dCBnb3QgJHt0eXBlb2YgdmFsdWV9YFxuICAgICAgKVxuICAgIH1cbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuZmlyZWZveE9wdGlvbnNfKClcbiAgICBvcHRpb25zLnByZWZzID0gb3B0aW9ucy5wcmVmcyB8fCB7fVxuICAgIG9wdGlvbnMucHJlZnNba2V5XSA9IHZhbHVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYXRoIHRvIGFuIGV4aXN0aW5nIHByb2ZpbGUgdG8gdXNlIGFzIGEgdGVtcGxhdGUgZm9yIG5ldyBicm93c2VyXG4gICAqIHNlc3Npb25zLiBUaGlzIHByb2ZpbGUgd2lsbCBiZSBjb3BpZWQgZm9yIGVhY2ggbmV3IHNlc3Npb24gLSBjaGFuZ2VzIHdpbGxcbiAgICogbm90IGJlIGFwcGxpZWQgdG8gdGhlIHByb2ZpbGUgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZmlsZSBUaGUgcHJvZmlsZSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHByb2ZpbGUgaXMgbm90IGEgc3RyaW5nLlxuICAgKi9cbiAgc2V0UHJvZmlsZShwcm9maWxlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9maWxlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBwcm9maWxlIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHt0eXBlb2YgcHJvZmlsZX1gKVxuICAgIH1cbiAgICB0aGlzLnByb2ZpbGVfKCkudGVtcGxhdGVfID0gcHJvZmlsZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYmluYXJ5IHRvIHVzZS4gVGhlIGJpbmFyeSBtYXkgYmUgc3BlY2lmaWVkIGFzIHRoZSBwYXRoIHRvIGFcbiAgICogRmlyZWZveCBleGVjdXRhYmxlIG9yIGEgZGVzaXJlZCByZWxlYXNlIHtAbGluayBDaGFubmVsfS5cbiAgICpcbiAgICogQHBhcmFtIHsoc3RyaW5nfCFDaGFubmVsKX0gYmluYXJ5IFRoZSBiaW5hcnkgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgYmluYXJ5YCBpcyBhbiBpbnZhbGlkIHR5cGUuXG4gICAqL1xuICBzZXRCaW5hcnkoYmluYXJ5KSB7XG4gICAgaWYgKGJpbmFyeSBpbnN0YW5jZW9mIENoYW5uZWwgfHwgdHlwZW9mIGJpbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZmlyZWZveE9wdGlvbnNfKCkuYmluYXJ5ID0gYmluYXJ5XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2JpbmFyeSBtdXN0IGJlIGEgc3RyaW5nIHBhdGggb3IgQ2hhbm5lbCBvYmplY3QnKVxuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgTW9iaWxlIHN0YXJ0IHVwIGZlYXR1cmVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmRyb2lkUGFja2FnZSBUaGUgcGFja2FnZSB0byB1c2VcbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2VcbiAgICovXG4gIGVuYWJsZU1vYmlsZShcbiAgICBhbmRyb2lkUGFja2FnZSA9ICdvcmcubW96aWxsYS5maXJlZm94JyxcbiAgICBhbmRyb2lkQWN0aXZpdHkgPSBudWxsLFxuICAgIGRldmljZVNlcmlhbCA9IG51bGxcbiAgKSB7XG4gICAgdGhpcy5maXJlZm94T3B0aW9uc18oKS5hbmRyb2lkUGFja2FnZSA9IGFuZHJvaWRQYWNrYWdlXG5cbiAgICBpZiAoYW5kcm9pZEFjdGl2aXR5KSB7XG4gICAgICB0aGlzLmZpcmVmb3hPcHRpb25zXygpLmFuZHJvaWRBY3Rpdml0eSA9IGFuZHJvaWRBY3Rpdml0eVxuICAgIH1cbiAgICBpZiAoZGV2aWNlU2VyaWFsKSB7XG4gICAgICB0aGlzLmZpcmVmb3hPcHRpb25zXygpLmRldmljZVNlcmlhbCA9IGRldmljZVNlcmlhbFxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgbW96OmRlYnVnZ2VyQWRkcmVzcyBmb3IgZmlyZWZveCBjZHBcbiAgICovXG4gIGVuYWJsZURlYnVnZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLnNldCgnbW96OmRlYnVnZ2VyQWRkcmVzcycsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIGJpZGkgY29ubmVjdGlvblxuICAgKiBAcmV0dXJucyB7IUNhcGFiaWxpdGllc31cbiAgICovXG4gIGVuYWJsZUJpZGkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KCd3ZWJTb2NrZXRVcmwnLCB0cnVlKVxuICB9XG59XG5cbi8qKlxuICogRW51bSBvZiBhdmFpbGFibGUgY29tbWFuZCBjb250ZXh0cy5cbiAqXG4gKiBDb21tYW5kIGNvbnRleHRzIGFyZSBzcGVjaWZpYyB0byBNYXJpb25ldHRlLCBhbmQgbWF5IGJlIHVzZWQgd2l0aCB0aGVcbiAqIHtAbGluayAjY29udGV4dD19IG1ldGhvZC4gQ29udGV4dHMgYWxsb3cgeW91IHRvIGRpcmVjdCBhbGwgc3Vic2VxdWVudFxuICogY29tbWFuZHMgdG8gZWl0aGVyIFwiY29udGVudFwiIChkZWZhdWx0KSBvciBcImNocm9tZVwiLiBUaGUgbGF0dGVyIGdpdmVzXG4gKiB5b3UgZWxldmF0ZWQgc2VjdXJpdHkgcGVybWlzc2lvbnMuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgQ29udGV4dCA9IHtcbiAgQ09OVEVOVDogJ2NvbnRlbnQnLFxuICBDSFJPTUU6ICdjaHJvbWUnLFxufVxuXG5jb25zdCBHRUNLT19EUklWRVJfRVhFID1cbiAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdnZWNrb2RyaXZlci5leGUnIDogJ2dlY2tvZHJpdmVyJ1xuXG4vKipcbiAqIF9TeW5jaHJvbm91c2x5XyBhdHRlbXB0cyB0byBsb2NhdGUgdGhlIGdlY2tvZHJpdmVyIGV4ZWN1dGFibGUgb24gdGhlIGN1cnJlbnRcbiAqIHN5c3RlbS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSB0aGUgbG9jYXRlZCBleGVjdXRhYmxlLCBvciBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGxvY2F0ZVN5bmNocm9ub3VzbHkoKSB7XG4gIHJldHVybiBpby5maW5kSW5QYXRoKEdFQ0tPX0RSSVZFUl9FWEUsIHRydWUpXG59XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSAuXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gZmluZEdlY2tvRHJpdmVyKCkge1xuICByZXR1cm4gbG9jYXRlU3luY2hyb25vdXNseSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgUGF0aCB0byB0aGUgZmlsZSB0byBmaW5kLCByZWxhdGl2ZSB0byB0aGUgcHJvZ3JhbSBmaWxlc1xuICogICAgIHJvb3QuXG4gKiBAcmV0dXJuIHshUHJvbWlzZTw/c3RyaW5nPn0gQSBwcm9taXNlIGZvciB0aGUgbG9jYXRlZCBleGVjdXRhYmxlLlxuICogICAgIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSB0byB7QGNvZGUgbnVsbH0gaWYgRmlyZWZveCB3YXMgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBmaW5kSW5Qcm9ncmFtRmlsZXMoZmlsZSkge1xuICBsZXQgZmlsZXMgPSBbXG4gICAgcHJvY2Vzcy5lbnZbJ1BST0dSQU1GSUxFUyddIHx8ICdDOlxcXFxQcm9ncmFtIEZpbGVzJyxcbiAgICBwcm9jZXNzLmVudlsnUFJPR1JBTUZJTEVTKFg4NiknXSB8fCAnQzpcXFxcUHJvZ3JhbSBGaWxlcyAoeDg2KScsXG4gIF0ubWFwKChwcmVmaXgpID0+IHBhdGguam9pbihwcmVmaXgsIGZpbGUpKVxuICByZXR1cm4gaW8uZXhpc3RzKGZpbGVzWzBdKS50aGVuKGZ1bmN0aW9uIChleGlzdHMpIHtcbiAgICByZXR1cm4gZXhpc3RzXG4gICAgICA/IGZpbGVzWzBdXG4gICAgICA6IGlvLmV4aXN0cyhmaWxlc1sxXSkudGhlbihmdW5jdGlvbiAoZXhpc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0cyA/IGZpbGVzWzFdIDogbnVsbFxuICAgICAgICB9KVxuICB9KVxufVxuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IEV4dGVuc2lvbkNvbW1hbmQgPSB7XG4gIEdFVF9DT05URVhUOiAnZ2V0Q29udGV4dCcsXG4gIFNFVF9DT05URVhUOiAnc2V0Q29udGV4dCcsXG4gIElOU1RBTExfQURET046ICdpbnN0YWxsIGFkZG9uJyxcbiAgVU5JTlNUQUxMX0FERE9OOiAndW5pbnN0YWxsIGFkZG9uJyxcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tbWFuZCBleGVjdXRvciB3aXRoIHN1cHBvcnQgZm9yIE1hcmlvbmV0dGUncyBjdXN0b20gY29tbWFuZHMuXG4gKiBAcGFyYW0geyFQcm9taXNlPHN0cmluZz59IHNlcnZlclVybCBUaGUgc2VydmVyJ3MgVVJMLlxuICogQHJldHVybiB7IWNvbW1hbmQuRXhlY3V0b3J9IFRoZSBuZXcgY29tbWFuZCBleGVjdXRvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXhlY3V0b3Ioc2VydmVyVXJsKSB7XG4gIGxldCBjbGllbnQgPSBzZXJ2ZXJVcmwudGhlbigodXJsKSA9PiBuZXcgaHR0cC5IdHRwQ2xpZW50KHVybCkpXG4gIGxldCBleGVjdXRvciA9IG5ldyBodHRwLkV4ZWN1dG9yKGNsaWVudClcbiAgY29uZmlndXJlRXhlY3V0b3IoZXhlY3V0b3IpXG4gIHJldHVybiBleGVjdXRvclxufVxuXG4vKipcbiAqIENvbmZpZ3VyZXMgdGhlIGdpdmVuIGV4ZWN1dG9yIHdpdGggRmlyZWZveC1zcGVjaWZpYyBjb21tYW5kcy5cbiAqIEBwYXJhbSB7IWh0dHAuRXhlY3V0b3J9IGV4ZWN1dG9yIHRoZSBleGVjdXRvciB0byBjb25maWd1cmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZUV4ZWN1dG9yKGV4ZWN1dG9yKSB7XG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgRXh0ZW5zaW9uQ29tbWFuZC5HRVRfQ09OVEVYVCxcbiAgICAnR0VUJyxcbiAgICAnL3Nlc3Npb24vOnNlc3Npb25JZC9tb3ovY29udGV4dCdcbiAgKVxuXG4gIGV4ZWN1dG9yLmRlZmluZUNvbW1hbmQoXG4gICAgRXh0ZW5zaW9uQ29tbWFuZC5TRVRfQ09OVEVYVCxcbiAgICAnUE9TVCcsXG4gICAgJy9zZXNzaW9uLzpzZXNzaW9uSWQvbW96L2NvbnRleHQnXG4gIClcblxuICBleGVjdXRvci5kZWZpbmVDb21tYW5kKFxuICAgIEV4dGVuc2lvbkNvbW1hbmQuSU5TVEFMTF9BRERPTixcbiAgICAnUE9TVCcsXG4gICAgJy9zZXNzaW9uLzpzZXNzaW9uSWQvbW96L2FkZG9uL2luc3RhbGwnXG4gIClcblxuICBleGVjdXRvci5kZWZpbmVDb21tYW5kKFxuICAgIEV4dGVuc2lvbkNvbW1hbmQuVU5JTlNUQUxMX0FERE9OLFxuICAgICdQT1NUJyxcbiAgICAnL3Nlc3Npb24vOnNlc3Npb25JZC9tb3ovYWRkb24vdW5pbnN0YWxsJ1xuICApXG59XG5cbi8qKlxuICogQ3JlYXRlcyB7QGxpbmsgc2VsZW5pdW0td2ViZHJpdmVyL3JlbW90ZS5Ecml2ZXJTZXJ2aWNlfSBpbnN0YW5jZXMgdGhhdCBtYW5hZ2VcbiAqIGEgW2dlY2tvZHJpdmVyXShodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrb2RyaXZlcikgc2VydmVyIGluIGEgY2hpbGRcbiAqIHByb2Nlc3MuXG4gKi9cbmNsYXNzIFNlcnZpY2VCdWlsZGVyIGV4dGVuZHMgcmVtb3RlLkRyaXZlclNlcnZpY2UuQnVpbGRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9leGUgUGF0aCB0byB0aGUgc2VydmVyIGV4ZWN1dGFibGUgdG8gdXNlLiBJZiBvbWl0dGVkLFxuICAgKiAgICAgdGhlIGJ1aWxkZXIgd2lsbCBhdHRlbXB0IHRvIGxvY2F0ZSB0aGUgZ2Vja29kcml2ZXIgb24gdGhlIHN5c3RlbSBQQVRILlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X2V4ZSkge1xuICAgIHN1cGVyKG9wdF9leGUgfHwgZmluZEdlY2tvRHJpdmVyKCkpXG4gICAgdGhpcy5zZXRMb29wYmFjayh0cnVlKSAvLyBSZXF1aXJlZC5cbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHZlcmJvc2UgbG9nZ2luZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3RyYWNlIFdoZXRoZXIgdG8gZW5hYmxlIHRyYWNlLWxldmVsIGxvZ2dpbmcuIEJ5XG4gICAqICAgICBkZWZhdWx0LCBvbmx5IGRlYnVnIGxvZ2dpbmcgaXMgZW5hYmxlZC5cbiAgICogQHJldHVybiB7IVNlcnZpY2VCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgZW5hYmxlVmVyYm9zZUxvZ2dpbmcob3B0X3RyYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQXJndW1lbnRzKG9wdF90cmFjZSA/ICctdnYnIDogJy12JylcbiAgfVxufVxuXG4vKipcbiAqIEEgV2ViRHJpdmVyIGNsaWVudCBmb3IgRmlyZWZveC5cbiAqL1xuY2xhc3MgRHJpdmVyIGV4dGVuZHMgd2ViZHJpdmVyLldlYkRyaXZlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEZpcmVmb3ggc2Vzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHsoT3B0aW9uc3xDYXBhYmlsaXRpZXN8T2JqZWN0KT19IG9wdF9jb25maWcgVGhlXG4gICAqICAgIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBkcml2ZXIsIHNwZWNpZmllZCBhcyBlaXRoZXIgYW5cbiAgICogICAge0BsaW5rIE9wdGlvbnN9IG9yIHtAbGluayBDYXBhYmlsaXRpZXN9LCBvciBhcyBhIHJhdyBoYXNoIG9iamVjdC5cbiAgICogQHBhcmFtIHsoaHR0cC5FeGVjdXRvcnxyZW1vdGUuRHJpdmVyU2VydmljZSk9fSBvcHRfZXhlY3V0b3IgRWl0aGVyIGFcbiAgICogICBwcmUtY29uZmlndXJlZCBjb21tYW5kIGV4ZWN1dG9yIHRvIHVzZSBmb3IgY29tbXVuaWNhdGluZyB3aXRoIGFuXG4gICAqICAgZXh0ZXJuYWxseSBtYW5hZ2VkIHJlbW90ZSBlbmQgKHdoaWNoIGlzIGFzc3VtZWQgdG8gYWxyZWFkeSBiZSBydW5uaW5nKSxcbiAgICogICBvciB0aGUgYERyaXZlclNlcnZpY2VgIHRvIHVzZSB0byBzdGFydCB0aGUgZ2Vja29kcml2ZXIgaW4gYSBjaGlsZFxuICAgKiAgIHByb2Nlc3MuXG4gICAqXG4gICAqICAgSWYgYW4gZXhlY3V0b3IgaXMgcHJvdmlkZWQsIGNhcmUgc2hvdWxkIGUgdGFrZW4gbm90IHRvIHVzZSByZXVzZSBpdCB3aXRoXG4gICAqICAgb3RoZXIgY2xpZW50cyBhcyBpdHMgaW50ZXJuYWwgY29tbWFuZCBtYXBwaW5ncyB3aWxsIGJlIHVwZGF0ZWQgdG8gc3VwcG9ydFxuICAgKiAgIEZpcmVmb3gtc3BlY2lmaWMgY29tbWFuZHMuXG4gICAqXG4gICAqICAgX1RoaXMgcGFyYW1ldGVyIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBNb3ppbGxhJ3MgR2Vja29Ecml2ZXIuX1xuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBjdXN0b20gY29tbWFuZCBleGVjdXRvciBpcyBwcm92aWRlZCBhbmQgdGhlIGRyaXZlciBpc1xuICAgKiAgICAgY29uZmlndXJlZCB0byB1c2UgdGhlIGxlZ2FjeSBGaXJlZm94RHJpdmVyIGZyb20gdGhlIFNlbGVuaXVtIHByb2plY3QuXG4gICAqIEByZXR1cm4geyFEcml2ZXJ9IEEgbmV3IGRyaXZlciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVTZXNzaW9uKG9wdF9jb25maWcsIG9wdF9leGVjdXRvcikge1xuICAgIGxldCBjYXBzID1cbiAgICAgIG9wdF9jb25maWcgaW5zdGFuY2VvZiBDYXBhYmlsaXRpZXMgPyBvcHRfY29uZmlnIDogbmV3IE9wdGlvbnMob3B0X2NvbmZpZylcblxuICAgIGxldCBleGVjdXRvclxuICAgIGxldCBvblF1aXRcblxuICAgIGlmIChvcHRfZXhlY3V0b3IgaW5zdGFuY2VvZiBodHRwLkV4ZWN1dG9yKSB7XG4gICAgICBleGVjdXRvciA9IG9wdF9leGVjdXRvclxuICAgICAgY29uZmlndXJlRXhlY3V0b3IoZXhlY3V0b3IpXG4gICAgfSBlbHNlIGlmIChvcHRfZXhlY3V0b3IgaW5zdGFuY2VvZiByZW1vdGUuRHJpdmVyU2VydmljZSkge1xuICAgICAgaWYgKCFvcHRfZXhlY3V0b3IuZ2V0RXhlY3V0YWJsZSgpKSB7XG4gICAgICAgIG9wdF9leGVjdXRvci5zZXRFeGVjdXRhYmxlKGdldFBhdGgob3B0X2V4ZWN1dG9yLCBvcHRfY29uZmlnKSlcbiAgICAgIH1cbiAgICAgIGV4ZWN1dG9yID0gY3JlYXRlRXhlY3V0b3Iob3B0X2V4ZWN1dG9yLnN0YXJ0KCkpXG4gICAgICBvblF1aXQgPSAoKSA9PiBvcHRfZXhlY3V0b3Iua2lsbCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzZXJ2aWNlID0gbmV3IFNlcnZpY2VCdWlsZGVyKCkuYnVpbGQoKVxuICAgICAgaWYgKCFzZXJ2aWNlLmdldEV4ZWN1dGFibGUoKSkge1xuICAgICAgICBzZXJ2aWNlLnNldEV4ZWN1dGFibGUoZ2V0UGF0aChzZXJ2aWNlLCBvcHRfY29uZmlnKSlcbiAgICAgIH1cbiAgICAgIGV4ZWN1dG9yID0gY3JlYXRlRXhlY3V0b3Ioc2VydmljZS5zdGFydCgpKVxuICAgICAgb25RdWl0ID0gKCkgPT4gc2VydmljZS5raWxsKClcbiAgICB9XG5cbiAgICByZXR1cm4gLyoqIEB0eXBlIHshRHJpdmVyfSAqLyAoc3VwZXIuY3JlYXRlU2Vzc2lvbihleGVjdXRvciwgY2Fwcywgb25RdWl0KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGEgbm8tb3AgYXMgZmlsZSBkZXRlY3RvcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhpc1xuICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRGaWxlRGV0ZWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnRleHQgdGhhdCBpcyBjdXJyZW50bHkgaW4gZWZmZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxDb250ZXh0Pn0gQ3VycmVudCBjb250ZXh0LlxuICAgKi9cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoRXh0ZW5zaW9uQ29tbWFuZC5HRVRfQ09OVEVYVCkpXG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0YXJnZXQgY29udGV4dCBmb3IgY29tbWFuZHMgYmV0d2VlbiBjaHJvbWUtIGFuZCBjb250ZW50LlxuICAgKlxuICAgKiBDaGFuZ2luZyB0aGUgY3VycmVudCBjb250ZXh0IGhhcyBhIHN0YXRlZnVsIGltcGFjdCBvbiBhbGwgc3Vic2VxdWVudFxuICAgKiBjb21tYW5kcy4gVGhlIHtAbGluayBDb250ZXh0LkNPTlRFTlR9IGNvbnRleHQgaGFzIG5vcm1hbCB3ZWJcbiAgICogcGxhdGZvcm0gZG9jdW1lbnQgcGVybWlzc2lvbnMsIGFzIGlmIHlvdSB3b3VsZCBldmFsdWF0ZSBhcmJpdHJhcnlcbiAgICogSmF2YVNjcmlwdC4gVGhlIHtAbGluayBDb250ZXh0LkNIUk9NRX0gY29udGV4dCBnZXRzIGVsZXZhdGVkXG4gICAqIHBlcm1pc3Npb25zIHRoYXQgbGV0cyB5b3UgbWFuaXB1bGF0ZSB0aGUgYnJvd3NlciBjaHJvbWUgaXRzZWxmLFxuICAgKiB3aXRoIGZ1bGwgYWNjZXNzIHRvIHRoZSBYVUwgdG9vbGtpdC5cbiAgICpcbiAgICogVXNlIHlvdXIgcG93ZXJzIHdpc2VseS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvbWlzZTx2b2lkPn0gY3R4IFRoZSBjb250ZXh0IHRvIHN3aXRjaCB0by5cbiAgICovXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoRXh0ZW5zaW9uQ29tbWFuZC5TRVRfQ09OVEVYVCkuc2V0UGFyYW1ldGVyKFxuICAgICAgICAnY29udGV4dCcsXG4gICAgICAgIGN0eFxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YWxscyBhIG5ldyBhZGRvbiB3aXRoIHRoZSBjdXJyZW50IHNlc3Npb24uIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW5cbiAgICogSUQgdGhhdCBtYXkgbGF0ZXIgYmUgdXNlZCB0byB7QGxpbmtwbGFpbiAjdW5pbnN0YWxsQWRkb24gdW5pbnN0YWxsfSB0aGVcbiAgICogYWRkb24uXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggb24gdGhlIGxvY2FsIGZpbGVzeXN0ZW0gdG8gdGhlIHdlYiBleHRlbnNpb24gdG9cbiAgICogICAgIGluc3RhbGwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdGVtcG9yYXJ5IEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBleHRlbnNpb24gc2hvdWxkIGJlXG4gICAqICAgICBpbnN0YWxsZWQgdGVtcG9yYXJpbHkgLSBnZXRzIHJlbW92ZWQgb24gcmVzdGFydFxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gYW4gSUQgZm9yIHRoZVxuICAgKiAgICAgbmV3bHkgaW5zdGFsbGVkIGFkZG9uLlxuICAgKiBAc2VlICN1bmluc3RhbGxBZGRvblxuICAgKi9cbiAgYXN5bmMgaW5zdGFsbEFkZG9uKHBhdGgsIHRlbXBvcmFyeSA9IGZhbHNlKSB7XG4gICAgbGV0IHN0YXRzID0gZnMuc3RhdFN5bmMocGF0aClcbiAgICBsZXQgYnVmXG4gICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGxldCB6aXAgPSBuZXcgWmlwKClcbiAgICAgIGF3YWl0IHppcC5hZGREaXIocGF0aClcbiAgICAgIGJ1ZiA9IGF3YWl0IHppcC50b0J1ZmZlcignREVGTEFURScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZiA9IGF3YWl0IGlvLnJlYWQocGF0aClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoRXh0ZW5zaW9uQ29tbWFuZC5JTlNUQUxMX0FERE9OKVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCdhZGRvbicsIGJ1Zi50b1N0cmluZygnYmFzZTY0JykpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ3RlbXBvcmFyeScsIHRlbXBvcmFyeSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogVW5pbnN0YWxscyBhbiBhZGRvbiBmcm9tIHRoZSBjdXJyZW50IGJyb3dzZXIgc2Vzc2lvbidzIHByb2ZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7KHN0cmluZ3whUHJvbWlzZTxzdHJpbmc+KX0gaWQgSUQgb2YgdGhlIGFkZG9uIHRvIHVuaW5zdGFsbC5cbiAgICogQHJldHVybiB7IVByb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBvcGVyYXRpb24gaGFzXG4gICAqICAgICBjb21wbGV0ZWQuXG4gICAqIEBzZWUgI2luc3RhbGxBZGRvblxuICAgKi9cbiAgYXN5bmMgdW5pbnN0YWxsQWRkb24oaWQpIHtcbiAgICBpZCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShpZClcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChFeHRlbnNpb25Db21tYW5kLlVOSU5TVEFMTF9BRERPTikuc2V0UGFyYW1ldGVyKFxuICAgICAgICAnaWQnLFxuICAgICAgICBpZFxuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGxvY2F0aW5nIHRoZSBleGVjdXRhYmxlIGZvciBhIEZpcmVmb3ggcmVsZWFzZSBjaGFubmVsXG4gKiBvbiBXaW5kb3dzIGFuZCBNYWNPUy4gRm9yIG90aGVyIHN5c3RlbXMgKGkuZS4gTGludXgpLCBGaXJlZm94IHdpbGwgYWx3YXlzXG4gKiBiZSBsb2NhdGVkIG9uIHRoZSBzeXN0ZW0gUEFUSC5cbiAqXG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgQ2hhbm5lbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGFyd2luIFRoZSBwYXRoIHRvIGNoZWNrIHdoZW4gcnVubmluZyBvbiBNYWNPUy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHdpbjMyIFRoZSBwYXRoIHRvIGNoZWNrIHdoZW4gcnVubmluZyBvbiBXaW5kb3dzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGFyd2luLCB3aW4zMikge1xuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgKi8gdGhpcy5kYXJ3aW5fID0gZGFyd2luXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCAqLyB0aGlzLndpbjMyXyA9IHdpbjMyXG4gICAgLyoqIEBwcml2YXRlIHtQcm9taXNlPHN0cmluZz59ICovXG4gICAgdGhpcy5mb3VuZF8gPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gbG9jYXRlIHRoZSBGaXJlZm94IGV4ZWN1dGFibGUgZm9yIHRoaXMgcmVsZWFzZSBjaGFubmVsLiBUaGlzXG4gICAqIHdpbGwgZmlyc3QgY2hlY2sgdGhlIGRlZmF1bHQgaW5zdGFsbGF0aW9uIGxvY2F0aW9uIGZvciB0aGUgY2hhbm5lbCBiZWZvcmVcbiAgICogY2hlY2tpbmcgdGhlIHVzZXIncyBQQVRILiBUaGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIGlmIEZpcmVmb3hcbiAgICogY2FuIG5vdCBiZSBmb3VuZC5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIGZvciB0aGUgbG9jYXRpb24gb2YgdGhlIGxvY2F0ZWRcbiAgICogICAgIEZpcmVmb3ggZXhlY3V0YWJsZS5cbiAgICovXG4gIGxvY2F0ZSgpIHtcbiAgICBpZiAodGhpcy5mb3VuZF8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kX1xuICAgIH1cblxuICAgIGxldCBmb3VuZFxuICAgIHN3aXRjaCAocHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgICAgY2FzZSAnZGFyd2luJzpcbiAgICAgICAgZm91bmQgPSBpb1xuICAgICAgICAgIC5leGlzdHModGhpcy5kYXJ3aW5fKVxuICAgICAgICAgIC50aGVuKChleGlzdHMpID0+IChleGlzdHMgPyB0aGlzLmRhcndpbl8gOiBpby5maW5kSW5QYXRoKCdmaXJlZm94JykpKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICd3aW4zMic6XG4gICAgICAgIGZvdW5kID0gZmluZEluUHJvZ3JhbUZpbGVzKHRoaXMud2luMzJfKS50aGVuKFxuICAgICAgICAgIChmb3VuZCkgPT4gZm91bmQgfHwgaW8uZmluZEluUGF0aCgnZmlyZWZveC5leGUnKVxuICAgICAgICApXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZvdW5kID0gUHJvbWlzZS5yZXNvbHZlKGlvLmZpbmRJblBhdGgoJ2ZpcmVmb3gnKSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0aGlzLmZvdW5kXyA9IGZvdW5kLnRoZW4oKGZvdW5kKSA9PiB7XG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgLy8gVE9ETzogdmVyaWZ5IHZlcnNpb24gaW5mby5cbiAgICAgICAgcmV0dXJuIGZvdW5kXG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGxvY2F0ZSBGaXJlZm94IG9uIHRoZSBjdXJyZW50IHN5c3RlbScpXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5mb3VuZF9cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSAqL1xuICBbU3ltYm9scy5zZXJpYWxpemVdKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2F0ZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBGaXJlZm94J3MgZGV2ZWxvcGVyIGNoYW5uZWwuXG4gKiBAY29uc3RcbiAqIEBzZWUgPGh0dHBzOi8vd3d3Lm1vemlsbGEub3JnL2VuLVVTL2ZpcmVmb3gvY2hhbm5lbC9kZXNrdG9wLyNhdXJvcmE+XG4gKi9cbkNoYW5uZWwuQVVST1JBID0gbmV3IENoYW5uZWwoXG4gICcvQXBwbGljYXRpb25zL0ZpcmVmb3hEZXZlbG9wZXJFZGl0aW9uLmFwcC9Db250ZW50cy9NYWNPUy9maXJlZm94LWJpbicsXG4gICdGaXJlZm94IERldmVsb3BlciBFZGl0aW9uXFxcXGZpcmVmb3guZXhlJ1xuKVxuXG4vKipcbiAqIEZpcmVmb3gncyBiZXRhIGNoYW5uZWwuIE5vdGUgdGhpcyBpcyBwcm92aWRlZCBtYWlubHkgZm9yIGNvbnZlbmllbmNlIGFzXG4gKiB0aGUgYmV0YSBjaGFubmVsIGhhcyB0aGUgc2FtZSBpbnN0YWxsYXRpb24gbG9jYXRpb24gYXMgdGhlIG1haW4gcmVsZWFzZVxuICogY2hhbm5lbC5cbiAqIEBjb25zdFxuICogQHNlZSA8aHR0cHM6Ly93d3cubW96aWxsYS5vcmcvZW4tVVMvZmlyZWZveC9jaGFubmVsL2Rlc2t0b3AvI2JldGE+XG4gKi9cbkNoYW5uZWwuQkVUQSA9IG5ldyBDaGFubmVsKFxuICAnL0FwcGxpY2F0aW9ucy9GaXJlZm94LmFwcC9Db250ZW50cy9NYWNPUy9maXJlZm94LWJpbicsXG4gICdNb3ppbGxhIEZpcmVmb3hcXFxcZmlyZWZveC5leGUnXG4pXG5cbi8qKlxuICogRmlyZWZveCdzIHJlbGVhc2UgY2hhbm5lbC5cbiAqIEBjb25zdFxuICogQHNlZSA8aHR0cHM6Ly93d3cubW96aWxsYS5vcmcvZW4tVVMvZmlyZWZveC9kZXNrdG9wLz5cbiAqL1xuQ2hhbm5lbC5SRUxFQVNFID0gbmV3IENoYW5uZWwoXG4gICcvQXBwbGljYXRpb25zL0ZpcmVmb3guYXBwL0NvbnRlbnRzL01hY09TL2ZpcmVmb3gtYmluJyxcbiAgJ01vemlsbGEgRmlyZWZveFxcXFxmaXJlZm94LmV4ZSdcbilcblxuLyoqXG4gKiBGaXJlZm94J3MgbmlnaHRseSByZWxlYXNlIGNoYW5uZWwuXG4gKiBAY29uc3RcbiAqIEBzZWUgPGh0dHBzOi8vd3d3Lm1vemlsbGEub3JnL2VuLVVTL2ZpcmVmb3gvY2hhbm5lbC9kZXNrdG9wLyNuaWdodGx5PlxuICovXG5DaGFubmVsLk5JR0hUTFkgPSBuZXcgQ2hhbm5lbChcbiAgJy9BcHBsaWNhdGlvbnMvRmlyZWZveCBOaWdodGx5LmFwcC9Db250ZW50cy9NYWNPUy9maXJlZm94LWJpbicsXG4gICdOaWdodGx5XFxcXGZpcmVmb3guZXhlJ1xuKVxuXG4vLyBQVUJMSUMgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDaGFubmVsLFxuICBDb250ZXh0LFxuICBEcml2ZXIsXG4gIE9wdGlvbnMsXG4gIFNlcnZpY2VCdWlsZGVyLFxuICBsb2NhdGVTeW5jaHJvbm91c2x5LFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmluZXMgYW4ge0BsaW5rcGxhaW4gY21kLkV4ZWN1dG9yIGNvbW1hbmQgZXhlY3V0b3J9IHRoYXRcbiAqIGNvbW11bmljYXRlcyB3aXRoIGEgcmVtb3RlIGVuZCB1c2luZyBIVFRQICsgSlNPTi5cbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5jb25zdCBodHRwTGliID0gcmVxdWlyZSgnLi4vbGliL2h0dHAnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7cHJvdG9jb2w6ICg/c3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgICAgICAgICAgIGF1dGg6ICg/c3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgICAgICAgICAgIGhvc3RuYW1lOiAoP3N0cmluZ3x1bmRlZmluZWQpLFxuICogICAgICAgICAgICBob3N0OiAoP3N0cmluZ3x1bmRlZmluZWQpLFxuICogICAgICAgICAgICBwb3J0OiAoP3N0cmluZ3x1bmRlZmluZWQpLFxuICogICAgICAgICAgICBwYXRoOiAoP3N0cmluZ3x1bmRlZmluZWQpLFxuICogICAgICAgICAgICBwYXRobmFtZTogKD9zdHJpbmd8dW5kZWZpbmVkKX19XG4gKi9cbmxldCBSZXF1ZXN0T3B0aW9ucyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGFVcmwgVGhlIHJlcXVlc3QgVVJMIHRvIHBhcnNlLlxuICogQHJldHVybiB7UmVxdWVzdE9wdGlvbnN9IFRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaG9zdG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGdldFJlcXVlc3RPcHRpb25zKGFVcmwpIHtcbiAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby1kZXByZWNhdGVkLWFwaVxuICBsZXQgb3B0aW9ucyA9IHVybC5wYXJzZShhVXJsKVxuICBpZiAoIW9wdGlvbnMuaG9zdG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVJMOiAnICsgYVVybClcbiAgfVxuICAvLyBEZWxldGUgdGhlIHNlYXJjaCBhbmQgaGFzIHBvcnRpb25zIGFzIHRoZXkgYXJlIG5vdCB1c2VkLlxuICBvcHRpb25zLnNlYXJjaCA9IG51bGxcbiAgb3B0aW9ucy5oYXNoID0gbnVsbFxuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnBhdGhuYW1lXG4gIG9wdGlvbnMuaG9zdG5hbWUgPVxuICAgIG9wdGlvbnMuaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnID8gJzEyNy4wLjAuMScgOiBvcHRpb25zLmhvc3RuYW1lIC8vIFRvIHN1cHBvcnQgTm9kZSAxNyBhbmQgYWJvdmUuIFJlZmVyIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDA3MDIgZm9yIGRldGFpbHMuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IFVTRVJfQUdFTlQgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuICBjb25zdCBwbGF0Zm9ybSA9XG4gICAgeyBkYXJ3aW46ICdtYWMnLCB3aW4zMjogJ3dpbmRvd3MnIH1bcHJvY2Vzcy5wbGF0Zm9ybV0gfHwgJ2xpbnV4J1xuICByZXR1cm4gYHNlbGVuaXVtLyR7dmVyc2lvbn0gKGpzICR7cGxhdGZvcm19KWBcbn0pKClcblxuLyoqXG4gKiBBIGJhc2ljIEhUVFAgY2xpZW50IHVzZWQgdG8gc2VuZCBtZXNzYWdlcyB0byBhIHJlbW90ZSBlbmQuXG4gKlxuICogQGltcGxlbWVudHMge2h0dHBMaWIuQ2xpZW50fVxuICovXG5jbGFzcyBIdHRwQ2xpZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJVcmwgVVJMIGZvciB0aGUgV2ViRHJpdmVyIHNlcnZlciB0byBzZW5kIGNvbW1hbmRzIHRvLlxuICAgKiBAcGFyYW0ge2h0dHAuQWdlbnQ9fSBvcHRfYWdlbnQgVGhlIGFnZW50IHRvIHVzZSBmb3IgZWFjaCByZXF1ZXN0LlxuICAgKiAgICAgRGVmYXVsdHMgdG8gYGh0dHAuZ2xvYmFsQWdlbnRgLlxuICAgKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfcHJveHkgVGhlIHByb3h5IHRvIHVzZSBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gdGhlXG4gICAqICAgICBzZXJ2ZXIuIERlZmF1bHQgaXMgdG8gdXNlIG5vIHByb3h5LlxuICAgKiBAcGFyYW0gez9PYmplY3QuPHN0cmluZyxPYmplY3Q+fSBjbGllbnRfb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioc2VydmVyVXJsLCBvcHRfYWdlbnQsIG9wdF9wcm94eSwgY2xpZW50X29wdGlvbnMgPSB7fSkge1xuICAgIC8qKiBAcHJpdmF0ZSB7aHR0cC5BZ2VudH0gKi9cbiAgICB0aGlzLmFnZW50XyA9IG9wdF9hZ2VudCB8fCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBCYXNlIG9wdGlvbnMgZm9yIGVhY2ggcmVxdWVzdC5cbiAgICAgKiBAcHJpdmF0ZSB7UmVxdWVzdE9wdGlvbnN9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zXyA9IGdldFJlcXVlc3RPcHRpb25zKHNlcnZlclVybClcblxuICAgIC8qKlxuICAgICAqIGNsaWVudCBvcHRpb25zLCBoZWFkZXIgb3ZlcnJpZGVzXG4gICAgICovXG4gICAgdGhpcy5jbGllbnRfb3B0aW9ucyA9IGNsaWVudF9vcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBzZXRzIGtlZXAtYWxpdmUgZm9yIHRoZSBhZ2VudFxuICAgICAqIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTgzMzI5MTBcbiAgICAgKi9cbiAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMuY2xpZW50X29wdGlvbnNbJ2tlZXAtYWxpdmUnXVxuXG4gICAgLyoqICBAcHJpdmF0ZSB7P1JlcXVlc3RPcHRpb25zfSAqL1xuICAgIHRoaXMucHJveHlPcHRpb25zXyA9IG9wdF9wcm94eSA/IGdldFJlcXVlc3RPcHRpb25zKG9wdF9wcm94eSkgOiBudWxsXG4gIH1cblxuICBnZXQga2VlcEFsaXZlKCkge1xuICAgIHJldHVybiB0aGlzLmFnZW50Xy5rZWVwQWxpdmVcbiAgfVxuXG4gIHNldCBrZWVwQWxpdmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5hZ2VudF8ua2VlcEFsaXZlID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgc2VuZChodHRwUmVxdWVzdCkge1xuICAgIGxldCBkYXRhXG5cbiAgICBsZXQgaGVhZGVycyA9IHt9XG5cbiAgICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVycykge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsdWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaGVhZGVyc1snVXNlci1BZ2VudCddID0gdGhpcy5jbGllbnRfb3B0aW9uc1sndXNlci1hZ2VudCddIHx8IFVTRVJfQUdFTlRcbiAgICBoZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gMFxuICAgIGlmIChodHRwUmVxdWVzdC5tZXRob2QgPT0gJ1BPU1QnIHx8IGh0dHBSZXF1ZXN0Lm1ldGhvZCA9PSAnUFVUJykge1xuICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGh0dHBSZXF1ZXN0LmRhdGEpXG4gICAgICBoZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSwgJ3V0ZjgnKVxuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04J1xuICAgIH1cblxuICAgIGxldCBwYXRoID0gdGhpcy5vcHRpb25zXy5wYXRoXG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSAmJiBodHRwUmVxdWVzdC5wYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgcGF0aCArPSBodHRwUmVxdWVzdC5wYXRoLnN1YnN0cmluZygxKVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoICs9IGh0dHBSZXF1ZXN0LnBhdGhcbiAgICB9XG4gICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby1kZXByZWNhdGVkLWFwaVxuICAgIGxldCBwYXJzZWRQYXRoID0gdXJsLnBhcnNlKHBhdGgpXG5cbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIGFnZW50OiB0aGlzLmFnZW50XyB8fCBudWxsLFxuICAgICAgbWV0aG9kOiBodHRwUmVxdWVzdC5tZXRob2QsXG5cbiAgICAgIGF1dGg6IHRoaXMub3B0aW9uc18uYXV0aCxcbiAgICAgIGhvc3RuYW1lOiB0aGlzLm9wdGlvbnNfLmhvc3RuYW1lLFxuICAgICAgcG9ydDogdGhpcy5vcHRpb25zXy5wb3J0LFxuICAgICAgcHJvdG9jb2w6IHRoaXMub3B0aW9uc18ucHJvdG9jb2wsXG5cbiAgICAgIHBhdGg6IHBhcnNlZFBhdGgucGF0aCxcbiAgICAgIHBhdGhuYW1lOiBwYXJzZWRQYXRoLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiBwYXJzZWRQYXRoLnNlYXJjaCxcbiAgICAgIGhhc2g6IHBhcnNlZFBhdGguaGFzaCxcblxuICAgICAgaGVhZGVycyxcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgc2VuZFJlcXVlc3Qob3B0aW9ucywgZnVsZmlsbCwgcmVqZWN0LCBkYXRhLCB0aGlzLnByb3h5T3B0aW9uc18pXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIFNlbmRzIGEgc2luZ2xlIEhUVFAgcmVxdWVzdC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb3B0aW9ucyBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbighaHR0cExpYi5SZXNwb25zZSl9IG9uT2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhlXG4gKiAgICAgcmVxdWVzdCBzdWNjZWVkcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oIUVycm9yKX0gb25FcnJvciBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF9kYXRhIFRoZSBkYXRhIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7P1JlcXVlc3RPcHRpb25zPX0gb3B0X3Byb3h5IFRoZSBwcm94eSBzZXJ2ZXIgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3JldHJpZXMgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIHJldHJpZXMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0KG9wdGlvbnMsIG9uT2ssIG9uRXJyb3IsIG9wdF9kYXRhLCBvcHRfcHJveHksIG9wdF9yZXRyaWVzKSB7XG4gIHZhciBob3N0bmFtZSA9IG9wdGlvbnMuaG9zdG5hbWVcbiAgdmFyIHBvcnQgPSBvcHRpb25zLnBvcnRcblxuICBpZiAob3B0X3Byb3h5KSB7XG4gICAgbGV0IHByb3h5ID0gLyoqIEB0eXBlIHtSZXF1ZXN0T3B0aW9uc30gKi8gKG9wdF9wcm94eSlcblxuICAgIC8vIFJGQyAyNjE2LCBzZWN0aW9uIDUuMS4yOlxuICAgIC8vIFRoZSBhYnNvbHV0ZVVSSSBmb3JtIGlzIFJFUVVJUkVEIHdoZW4gdGhlIHJlcXVlc3QgaXMgYmVpbmcgbWFkZSB0byBhXG4gICAgLy8gcHJveHkuXG4gICAgbGV0IGFic29sdXRlVXJpID0gdXJsLmZvcm1hdChvcHRpb25zKVxuXG4gICAgLy8gUkZDIDI2MTYsIHNlY3Rpb24gMTQuMjM6XG4gICAgLy8gQW4gSFRUUC8xLjEgcHJveHkgTVVTVCBlbnN1cmUgdGhhdCBhbnkgcmVxdWVzdCBtZXNzYWdlIGl0IGZvcndhcmRzIGRvZXNcbiAgICAvLyBjb250YWluIGFuIGFwcHJvcHJpYXRlIEhvc3QgaGVhZGVyIGZpZWxkIHRoYXQgaWRlbnRpZmllcyB0aGUgc2VydmljZVxuICAgIC8vIGJlaW5nIHJlcXVlc3RlZCBieSB0aGUgcHJveHkuXG4gICAgbGV0IHRhcmdldEhvc3QgPSBvcHRpb25zLmhvc3RuYW1lXG4gICAgaWYgKG9wdGlvbnMucG9ydCkge1xuICAgICAgdGFyZ2V0SG9zdCArPSAnOicgKyBvcHRpb25zLnBvcnRcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHJlcXVlc3Qgb3B0aW9ucyB3aXRoIG91ciBwcm94eSBpbmZvLlxuICAgIG9wdGlvbnMuaGVhZGVyc1snSG9zdCddID0gdGFyZ2V0SG9zdFxuICAgIG9wdGlvbnMucGF0aCA9IGFic29sdXRlVXJpXG4gICAgb3B0aW9ucy5ob3N0ID0gcHJveHkuaG9zdFxuICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwcm94eS5ob3N0bmFtZVxuICAgIG9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnRcblxuICAgIC8vIFVwZGF0ZSB0aGUgcHJvdG9jb2wgdG8gYXZvaWQgRVBST1RPIGVycm9ycyB3aGVuIHRoZSB3ZWJkcml2ZXIgcHJveHlcbiAgICAvLyB1c2VzIGEgZGlmZmVyZW50IHByb3RvY29sIGZyb20gdGhlIHJlbW90ZSBzZWxlbml1bSBzZXJ2ZXIuXG4gICAgb3B0aW9ucy5wcm90b2NvbCA9IG9wdF9wcm94eS5wcm90b2NvbFxuXG4gICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShwcm94eS5hdXRoKS50b1N0cmluZygnYmFzZTY0JylcbiAgICB9XG4gIH1cblxuICBsZXQgcmVxdWVzdEZuID0gb3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0XG4gIHZhciByZXF1ZXN0ID0gcmVxdWVzdEZuKG9wdGlvbnMsIGZ1bmN0aW9uIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PSAzMDIgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PSAzMDMpIHtcbiAgICAgIGxldCBsb2NhdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGlcbiAgICAgICAgbG9jYXRpb24gPSB1cmwucGFyc2UocmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSlcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIHBhcnNlIFwiTG9jYXRpb25cIiBoZWFkZXIgZm9yIHNlcnZlciByZWRpcmVjdDogJyArXG4gICAgICAgICAgICAgIGV4Lm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAnXFxuUmVzcG9uc2Ugd2FzOiBcXG4nICtcbiAgICAgICAgICAgICAgbmV3IGh0dHBMaWIuUmVzcG9uc2UocmVzcG9uc2Uuc3RhdHVzQ29kZSwgcmVzcG9uc2UuaGVhZGVycywgJycpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWxvY2F0aW9uLmhvc3RuYW1lKSB7XG4gICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lID0gaG9zdG5hbWVcbiAgICAgICAgbG9jYXRpb24ucG9ydCA9IHBvcnRcbiAgICAgICAgbG9jYXRpb24uYXV0aCA9IG9wdGlvbnMuYXV0aFxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmRlc3Ryb3koKVxuICAgICAgc2VuZFJlcXVlc3QoXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIHByb3RvY29sOiBsb2NhdGlvbi5wcm90b2NvbCB8fCBvcHRpb25zLnByb3RvY29sLFxuICAgICAgICAgIGhvc3RuYW1lOiBsb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiBsb2NhdGlvbi5wb3J0LFxuICAgICAgICAgIHBhdGg6IGxvY2F0aW9uLnBhdGgsXG4gICAgICAgICAgYXV0aDogbG9jYXRpb24uYXV0aCxcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgc2VhcmNoOiBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgICAgaGFzaDogbG9jYXRpb24uaGFzaCxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgICAgICdVc2VyLUFnZW50Jzogb3B0aW9ucy5oZWFkZXJzWydVc2VyLUFnZW50J10gfHwgVVNFUl9BR0VOVCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvbk9rLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG9wdF9wcm94eVxuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IFtdXG4gICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBib2R5LnB1c2guYmluZChib2R5KSlcbiAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgcmVzcCA9IG5ldyBodHRwTGliLlJlc3BvbnNlKFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKHJlc3BvbnNlLnN0YXR1c0NvZGUpLFxuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nPn0gKi8gKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBCdWZmZXIuY29uY2F0KGJvZHkpLnRvU3RyaW5nKCd1dGY4JykucmVwbGFjZSgvXFwwL2csICcnKVxuICAgICAgKVxuICAgICAgb25PayhyZXNwKVxuICAgIH0pXG4gIH0pXG5cbiAgcmVxdWVzdC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0X3JldHJpZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRfcmV0cmllcyA9IDBcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmV0cnlSZXF1ZXN0KG9wdF9yZXRyaWVzLCBlKSkge1xuICAgICAgb3B0X3JldHJpZXMgKz0gMVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbmRSZXF1ZXN0KG9wdGlvbnMsIG9uT2ssIG9uRXJyb3IsIG9wdF9kYXRhLCBvcHRfcHJveHksIG9wdF9yZXRyaWVzKVxuICAgICAgfSwgMTUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXNzYWdlID0gZS5tZXNzYWdlXG4gICAgICBpZiAoZS5jb2RlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlLmNvZGUgKyAnICcgKyBtZXNzYWdlXG4gICAgICB9XG4gICAgICBvbkVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSlcbiAgICB9XG4gIH0pXG5cbiAgaWYgKG9wdF9kYXRhKSB7XG4gICAgcmVxdWVzdC53cml0ZShvcHRfZGF0YSlcbiAgfVxuXG4gIHJlcXVlc3QuZW5kKClcbn1cblxuY29uc3QgTUFYX1JFVFJJRVMgPSAzXG5cbi8qKlxuICogQSByZXRyeSBpcyBzb21ldGltZXMgbmVlZGVkIG9uIFdpbmRvd3Mgd2hlcmUgd2UgbWF5IHF1aWNrbHkgcnVuIG91dCBvZlxuICogZXBoZW1lcmFsIHBvcnRzLiBBIG1vcmUgcm9idXN0IHNvbHV0aW9uIGlzIGJ1bXBpbmcgdGhlIE1heFVzZXJQb3J0IHNldHRpbmdcbiAqIGFzIGRlc2NyaWJlZCBoZXJlOiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWE1NjA2MTAlMjh2PWJ0cy4yMCUyOS5hc3B4XG4gKlxuICogQHBhcmFtIHshbnVtYmVyfSByZXRyaWVzXG4gKiBAcGFyYW0geyFFcnJvcn0gZXJyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzaG91bGRSZXRyeVJlcXVlc3QocmV0cmllcywgZXJyKSB7XG4gIHJldHVybiByZXRyaWVzIDwgTUFYX1JFVFJJRVMgJiYgaXNSZXRyeWFibGVOZXR3b3JrRXJyb3IoZXJyKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7IUVycm9yfSBlcnJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUmV0cnlhYmxlTmV0d29ya0Vycm9yKGVycikge1xuICBpZiAoZXJyICYmIGVyci5jb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVyci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJyB8fFxuICAgICAgZXJyLmNvZGUgPT09ICdFQ09OTlJFU0VUJyB8fFxuICAgICAgZXJyLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnIHx8XG4gICAgICBlcnIuY29kZSA9PT0gJ0VBRERSSU5VU0UnIHx8XG4gICAgICBlcnIuY29kZSA9PT0gJ0VQSVBFJyB8fFxuICAgICAgZXJyLmNvZGUgPT09ICdFVElNRURPVVQnXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMuQWdlbnQgPSBodHRwLkFnZW50XG5tb2R1bGUuZXhwb3J0cy5FeGVjdXRvciA9IGh0dHBMaWIuRXhlY3V0b3Jcbm1vZHVsZS5leHBvcnRzLkh0dHBDbGllbnQgPSBIdHRwQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gaHR0cExpYi5SZXF1ZXN0XG5tb2R1bGUuZXhwb3J0cy5SZXNwb25zZSA9IGh0dHBMaWIuUmVzcG9uc2VcbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBWYXJpb3VzIEhUVFAgdXRpbGl0aWVzLlxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFeGVjdXRvciA9IHJlcXVpcmUoJy4vaW5kZXgnKS5FeGVjdXRvclxuY29uc3QgSHR0cENsaWVudCA9IHJlcXVpcmUoJy4vaW5kZXgnKS5IdHRwQ2xpZW50XG5jb25zdCBIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJy4vaW5kZXgnKS5SZXF1ZXN0XG5jb25zdCBDb21tYW5kID0gcmVxdWlyZSgnLi4vbGliL2NvbW1hbmQnKS5Db21tYW5kXG5jb25zdCBDb21tYW5kTmFtZSA9IHJlcXVpcmUoJy4uL2xpYi9jb21tYW5kJykuTmFtZVxuY29uc3QgZXJyb3IgPSByZXF1aXJlKCcuLi9saWIvZXJyb3InKVxuXG4vKipcbiAqIFF1ZXJpZXMgYSBXZWJEcml2ZXIgc2VydmVyIGZvciBpdHMgY3VycmVudCBzdGF0dXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIEJhc2UgVVJMIG9mIHRoZSBzZXJ2ZXIgdG8gcXVlcnkuXG4gKiBAcmV0dXJuIHshUHJvbWlzZTwhT2JqZWN0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aFxuICogICAgIGEgaGFzaCBvZiB0aGUgc2VydmVyIHN0YXR1cy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdHVzKHVybCkge1xuICBjb25zdCBjbGllbnQgPSBuZXcgSHR0cENsaWVudCh1cmwpXG4gIGNvbnN0IGV4ZWN1dG9yID0gbmV3IEV4ZWN1dG9yKGNsaWVudClcbiAgY29uc3QgY29tbWFuZCA9IG5ldyBDb21tYW5kKENvbW1hbmROYW1lLkdFVF9TRVJWRVJfU1RBVFVTKVxuICByZXR1cm4gZXhlY3V0b3IuZXhlY3V0ZShjb21tYW5kKVxufVxuXG5jbGFzcyBDYW5jZWxsYXRpb25FcnJvciB7fVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIFdlYkRyaXZlciBzZXJ2ZXIgdG8gYmUgaGVhbHRoeSBhbmQgYWNjZXB0aW5nIHJlcXVlc3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBCYXNlIFVSTCBvZiB0aGUgc2VydmVyIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgSG93IGxvbmcgdG8gd2FpdCBmb3IgdGhlIHNlcnZlci5cbiAqIEBwYXJhbSB7UHJvbWlzZT19IG9wdF9jYW5jZWxUb2tlbiBBIHByb21pc2UgdXNlZCBhcyBhIGNhbmNlbGxhdGlvbiBzaWduYWw6XG4gKiAgICAgaWYgcmVzb2x2ZWQgYmVmb3JlIHRoZSBzZXJ2ZXIgaXMgcmVhZHksIHRoZSB3YWl0IHdpbGwgYmUgdGVybWluYXRlZFxuICogICAgIGVhcmx5IHdpdGggYSB7QGxpbmsgQ2FuY2VsbGF0aW9uRXJyb3J9LlxuICogQHJldHVybiB7IVByb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBzZXJ2ZXIgaXMgcmVhZHksIG9yXG4gKiAgICAgaWYgdGhlIHdhaXQgaXMgY2FuY2VsbGVkLlxuICovXG5mdW5jdGlvbiB3YWl0Rm9yU2VydmVyKHVybCwgdGltZW91dCwgb3B0X2NhbmNlbFRva2VuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgob25SZXNvbHZlLCBvblJlamVjdCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KClcblxuICAgIGxldCBkb25lID0gZmFsc2VcbiAgICBsZXQgcmVzb2x2ZSA9IChzdGF0dXMpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBvblJlc29sdmUoc3RhdHVzKVxuICAgIH1cbiAgICBsZXQgcmVqZWN0ID0gKGVycikgPT4ge1xuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIG9uUmVqZWN0KGVycilcbiAgICB9XG5cbiAgICBpZiAob3B0X2NhbmNlbFRva2VuKSB7XG4gICAgICBvcHRfY2FuY2VsVG9rZW4udGhlbigoXykgPT4gcmVqZWN0KG5ldyBDYW5jZWxsYXRpb25FcnJvcigpKSlcbiAgICB9XG5cbiAgICBjaGVja1NlcnZlclN0YXR1cygpXG4gICAgZnVuY3Rpb24gY2hlY2tTZXJ2ZXJTdGF0dXMoKSB7XG4gICAgICByZXR1cm4gZ2V0U3RhdHVzKHVybCkudGhlbigoc3RhdHVzKSA9PiByZXNvbHZlKHN0YXR1cyksIG9uRXJyb3IpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlKSB7XG4gICAgICAvLyBTb21lIHNlcnZlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgc3RhdHVzIGNvbW1hbmQuIElmIHRoZXkgYXJlIGFibGUgdG9cbiAgICAgIC8vIHJlc3BvbnNlIHdpdGggYW4gZXJyb3IsIHRoZW4gY2FuIGNvbnNpZGVyIHRoZSBzZXJ2ZXIgcmVhZHkuXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIGVycm9yLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IpIHtcbiAgICAgICAgcmVzb2x2ZSh7fSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgIHJlamVjdChFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSBXZWJEcml2ZXIgc2VydmVyIGF0ICcgKyB1cmwpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjaGVja1NlcnZlclN0YXR1cygpXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogUG9sbHMgYSBVUkwgd2l0aCBHRVQgcmVxdWVzdHMgdW50aWwgaXQgcmV0dXJucyBhIDJ4eCByZXNwb25zZSBvciB0aGVcbiAqIHRpbWVvdXQgZXhwaXJlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBwb2xsLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgSG93IGxvbmcgdG8gd2FpdCwgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtQcm9taXNlPX0gb3B0X2NhbmNlbFRva2VuIEEgcHJvbWlzZSB1c2VkIGFzIGEgY2FuY2VsbGF0aW9uIHNpZ25hbDpcbiAqICAgICBpZiByZXNvbHZlZCBiZWZvcmUgdGhlIGEgMnh4IHJlc3BvbnNlIGlzIHJlY2VpdmVkLCB0aGUgd2FpdCB3aWxsIGJlXG4gKiAgICAgdGVybWluYXRlZCBlYXJseSB3aXRoIGEge0BsaW5rIENhbmNlbGxhdGlvbkVycm9yfS5cbiAqIEByZXR1cm4geyFQcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiBhIDJ4eCBpcyByZWNlaXZlZCBmcm9tXG4gKiAgICAgdGhlIGdpdmVuIFVSTCwgb3IgaWYgdGhlIHdhaXQgaXMgY2FuY2VsbGVkLlxuICovXG5mdW5jdGlvbiB3YWl0Rm9yVXJsKHVybCwgdGltZW91dCwgb3B0X2NhbmNlbFRva2VuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgob25SZXNvbHZlLCBvblJlamVjdCkgPT4ge1xuICAgIGxldCBjbGllbnQgPSBuZXcgSHR0cENsaWVudCh1cmwpXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgSHR0cFJlcXVlc3QoJ0dFVCcsICcnKVxuICAgIGxldCBzdGFydCA9IERhdGUubm93KClcblxuICAgIGxldCBkb25lID0gZmFsc2VcbiAgICBsZXQgcmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBvblJlc29sdmUoKVxuICAgIH1cbiAgICBsZXQgcmVqZWN0ID0gKGVycikgPT4ge1xuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIG9uUmVqZWN0KGVycilcbiAgICB9XG5cbiAgICBpZiAob3B0X2NhbmNlbFRva2VuKSB7XG4gICAgICBvcHRfY2FuY2VsVG9rZW4udGhlbigoXykgPT4gcmVqZWN0KG5ldyBDYW5jZWxsYXRpb25FcnJvcigpKSlcbiAgICB9XG5cbiAgICB0ZXN0VXJsKClcblxuICAgIGZ1bmN0aW9uIHRlc3RVcmwoKSB7XG4gICAgICBjbGllbnQuc2VuZChyZXF1ZXN0KS50aGVuKG9uUmVzcG9uc2UsIG9uRXJyb3IpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgIHJlamVjdChFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSBVUkwgdG8gcmV0dXJuIDJ4eDogJyArIHVybCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIHRlc3RVcmwoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTApXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID4gMTk5ICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBvbkVycm9yKClcbiAgICB9XG4gIH0pXG59XG5cbi8vIFBVQkxJQyBBUElcbm1vZHVsZS5leHBvcnRzLmdldFN0YXR1cyA9IGdldFN0YXR1c1xubW9kdWxlLmV4cG9ydHMuQ2FuY2VsbGF0aW9uRXJyb3IgPSBDYW5jZWxsYXRpb25FcnJvclxubW9kdWxlLmV4cG9ydHMud2FpdEZvclNlcnZlciA9IHdhaXRGb3JTZXJ2ZXJcbm1vZHVsZS5leHBvcnRzLndhaXRGb3JVcmwgPSB3YWl0Rm9yVXJsXG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBhIHtAbGlua3BsYWluIERyaXZlciBXZWJEcml2ZXJ9IGNsaWVudCBmb3IgTWljcm9zb2Z0J3NcbiAqIEludGVybmV0IEV4cGxvcmVyLiBCZWZvcmUgdXNpbmcgdGhlIElFRHJpdmVyLCB5b3UgbXVzdCBkb3dubG9hZCB0aGUgbGF0ZXN0XG4gKiBbSUVEcml2ZXJTZXJ2ZXJdKGh0dHBzOi8vd3d3LnNlbGVuaXVtLmRldi9kb3dubG9hZHMvKVxuICogYW5kIHBsYWNlIGl0IG9uIHlvdXJcbiAqIFtQQVRIXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BBVEhfJTI4dmFyaWFibGUlMjkpLiBZb3UgbXVzdCBhbHNvIGFwcGx5XG4gKiB0aGUgc3lzdGVtIGNvbmZpZ3VyYXRpb24gb3V0bGluZWQgb24gdGhlIFNlbGVuaXVtIHByb2plY3RcbiAqIFt3aWtpXShodHRwczovL2dpdGh1Yi5jb20vU2VsZW5pdW1IUS9zZWxlbml1bS93aWtpL0ludGVybmV0RXhwbG9yZXJEcml2ZXIpXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJy4vaHR0cCcpXG5jb25zdCBpbyA9IHJlcXVpcmUoJy4vaW8nKVxuY29uc3QgcG9ydHByb2JlciA9IHJlcXVpcmUoJy4vbmV0L3BvcnRwcm9iZXInKVxuY29uc3QgcmVtb3RlID0gcmVxdWlyZSgnLi9yZW1vdGUnKVxuY29uc3Qgd2ViZHJpdmVyID0gcmVxdWlyZSgnLi9saWIvd2ViZHJpdmVyJylcbmNvbnN0IHsgQnJvd3NlciwgQ2FwYWJpbGl0aWVzIH0gPSByZXF1aXJlKCcuL2xpYi9jYXBhYmlsaXRpZXMnKVxuY29uc3QgZXJyb3IgPSByZXF1aXJlKCcuL2xpYi9lcnJvcicpXG5jb25zdCB7IGdldFBhdGggfSA9IHJlcXVpcmUoJy4vY29tbW9uL2RyaXZlckZpbmRlcicpXG5cbmNvbnN0IElFRFJJVkVSX0VYRSA9ICdJRURyaXZlclNlcnZlci5leGUnXG5jb25zdCBPUFRJT05TX0NBUEFCSUxJVFlfS0VZID0gJ3NlOmllT3B0aW9ucydcbmNvbnN0IFNDUk9MTF9CRUhBVklPVVIgPSB7XG4gIEJPVFRPTTogMSxcbiAgVE9QOiAwLFxufVxuXG4vKipcbiAqIElFRHJpdmVyU2VydmVyIGxvZ2dpbmcgbGV2ZWxzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgTGV2ZWwgPSB7XG4gIEZBVEFMOiAnRkFUQUwnLFxuICBFUlJPUjogJ0VSUk9SJyxcbiAgV0FSTjogJ1dBUk4nLFxuICBJTkZPOiAnSU5GTycsXG4gIERFQlVHOiAnREVCVUcnLFxuICBUUkFDRTogJ1RSQUNFJyxcbn1cblxuLyoqXG4gKiBPcHRpb24ga2V5czpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TZWxlbml1bUhRL3NlbGVuaXVtL3dpa2kvRGVzaXJlZENhcGFiaWxpdGllcyNpZS1zcGVjaWZpY1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgS2V5ID0ge1xuICBJR05PUkVfUFJPVEVDVEVEX01PREVfU0VUVElOR1M6ICdpZ25vcmVQcm90ZWN0ZWRNb2RlU2V0dGluZ3MnLFxuICBJR05PUkVfWk9PTV9TRVRUSU5HOiAnaWdub3JlWm9vbVNldHRpbmcnLFxuICBJTklUSUFMX0JST1dTRVJfVVJMOiAnaW5pdGlhbEJyb3dzZXJVcmwnLFxuICBFTkFCTEVfUEVSU0lTVEVOVF9IT1ZFUjogJ2VuYWJsZVBlcnNpc3RlbnRIb3ZlcicsXG4gIEVOQUJMRV9FTEVNRU5UX0NBQ0hFX0NMRUFOVVA6ICdlbmFibGVFbGVtZW50Q2FjaGVDbGVhbnVwJyxcbiAgRUxFTUVOVF9TQ1JPTExfQkVIQVZJT1I6ICdlbGVtZW50U2Nyb2xsQmVoYXZpb3InLFxuICBSRVFVSVJFX1dJTkRPV19GT0NVUzogJ3JlcXVpcmVXaW5kb3dGb2N1cycsXG4gIEJST1dTRVJfQVRUQUNIX1RJTUVPVVQ6ICdicm93c2VyQXR0YWNoVGltZW91dCcsXG4gIEZPUkNFX0NSRUFURV9QUk9DRVNTOiAnaWUuZm9yY2VDcmVhdGVQcm9jZXNzQXBpJyxcbiAgQlJPV1NFUl9DT01NQU5EX0xJTkVfU1dJVENIRVM6ICdpZS5icm93c2VyQ29tbWFuZExpbmVTd2l0Y2hlcycsXG4gIFVTRV9QRVJfUFJPQ0VTU19QUk9YWTogJ2llLnVzZVBlclByb2Nlc3NQcm94eScsXG4gIEVOU1VSRV9DTEVBTl9TRVNTSU9OOiAnaWUuZW5zdXJlQ2xlYW5TZXNzaW9uJyxcbiAgTE9HX0ZJTEU6ICdsb2dGaWxlJyxcbiAgTE9HX0xFVkVMOiAnbG9nTGV2ZWwnLFxuICBIT1NUOiAnaG9zdCcsXG4gIEVYVFJBQ1RfUEFUSDogJ2V4dHJhY3RQYXRoJyxcbiAgU0lMRU5UOiAnc2lsZW50JyxcbiAgRklMRV9VUExPQURfRElBTE9HX1RJTUVPVVQ6ICdpZS5maWxlVXBsb2FkRGlhbG9nVGltZW91dCcsXG4gIEFUVEFDSF9UT19FREdFX0NIUk9NSVVNOiAnaWUuZWRnZWNocm9taXVtJyxcbiAgRURHRV9FWEVDVVRBQkxFX1BBVEg6ICdpZS5lZGdlcGF0aCcsXG59XG5cbi8qKlxuICogQ2xhc3MgZm9yIG1hbmFnaW5nIElFRHJpdmVyIHNwZWNpZmljIG9wdGlvbnMuXG4gKi9cbmNsYXNzIE9wdGlvbnMgZXh0ZW5kcyBDYXBhYmlsaXRpZXMge1xuICAvKipcbiAgICogQHBhcmFtIHsoQ2FwYWJpbGl0aWVzfE1hcDxzdHJpbmcsID8+fE9iamVjdCk9fSBvdGhlciBBbm90aGVyIHNldCBvZlxuICAgKiAgICAgY2FwYWJpbGl0aWVzIHRvIGluaXRpYWxpemUgdGhpcyBpbnN0YW5jZSBmcm9tLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3RoZXIgPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihvdGhlcilcblxuICAgIC8qKiBAcHJpdmF0ZSB7IU9iamVjdH0gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0gdGhpcy5nZXQoT1BUSU9OU19DQVBBQklMSVRZX0tFWSkgfHwge31cblxuICAgIHRoaXMuc2V0KE9QVElPTlNfQ0FQQUJJTElUWV9LRVksIHRoaXMub3B0aW9uc18pXG4gICAgdGhpcy5zZXRCcm93c2VyTmFtZShCcm93c2VyLklOVEVSTkVUX0VYUExPUkVSKVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGlzYWJsZSB0aGUgcHJvdGVjdGVkIG1vZGUgc2V0dGluZ3MgY2hlY2sgd2hlbiB0aGUgc2Vzc2lvbiBpc1xuICAgKiBjcmVhdGVkLiBEaXNhYmxpbmcgdGhpcyBzZXR0aW5nIG1heSBsZWFkIHRvIHNpZ25pZmljYW50IGluc3RhYmlsaXR5IGFzIHRoZVxuICAgKiBicm93c2VyIG1heSBiZWNvbWUgdW5yZXNwb25zaXZlL2hhbmcuIE9ubHkgXCJiZXN0IGVmZm9ydFwiIHN1cHBvcnQgaXMgcHJvdmlkZWRcbiAgICogd2hlbiB1c2luZyB0aGlzIGNhcGFiaWxpdHkuXG4gICAqXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgSUVEcml2ZXInc1xuICAgKiBbcmVxdWlyZWQgc3lzdGVtIGNvbmZpZ3VyYXRpb25dKGh0dHA6Ly9nb28uZ2wvZUgwWWkzKS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVTZXR0aW5ncyBXaGV0aGVyIHRvIGlnbm9yZSBwcm90ZWN0ZWQgbW9kZSBzZXR0aW5ncy5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBpbnRyb2R1Y2VGbGFraW5lc3NCeUlnbm9yaW5nUHJvdGVjdGVkTW9kZVNldHRpbmdzKGlnbm9yZVNldHRpbmdzKSB7XG4gICAgdGhpcy5vcHRpb25zX1tLZXkuSUdOT1JFX1BST1RFQ1RFRF9NT0RFX1NFVFRJTkdTXSA9ICEhaWdub3JlU2V0dGluZ3NcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRvIHNraXAgdGhlIGNoZWNrIHRoYXQgdGhlIGJyb3dzZXIncyB6b29tIGxldmVsIGlzIHNldCB0b1xuICAgKiAxMDAlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZSBXaGV0aGVyIHRvIGlnbm9yZSB0aGUgYnJvd3NlcidzIHpvb20gbGV2ZWwgc2V0dGluZ3MuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgaWdub3JlWm9vbVNldHRpbmcoaWdub3JlKSB7XG4gICAgdGhpcy5vcHRpb25zX1tLZXkuSUdOT1JFX1pPT01fU0VUVElOR10gPSAhIWlnbm9yZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5pdGlhbCBVUkwgbG9hZGVkIHdoZW4gSUUgc3RhcnRzLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aFxuICAgKiB7QGxpbmsgI2ludHJvZHVjZUZsYWtpbmVzc0J5SWdub3JpbmdQcm90ZWN0ZWRNb2RlU2V0dGluZ3N9IHRvIGFsbG93IHRoZSB1c2VyIHRvIGluaXRpYWxpemUgSUUgaW5cbiAgICogdGhlIHByb3BlciBQcm90ZWN0ZWQgTW9kZSB6b25lLiBTZXR0aW5nIHRoaXMgb3B0aW9uIG1heSBjYXVzZSBicm93c2VyXG4gICAqIGluc3RhYmlsaXR5IG9yIGZsYWt5IGFuZCB1bnJlc3BvbnNpdmUgY29kZS4gT25seSBcImJlc3QgZWZmb3J0XCIgc3VwcG9ydCBpc1xuICAgKiBwcm92aWRlZCB3aGVuIHVzaW5nIHRoaXMgb3B0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBpbml0aWFsIGJyb3dzZXIgVVJMLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGluaXRpYWxCcm93c2VyVXJsKHVybCkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LklOSVRJQUxfQlJPV1NFUl9VUkxdID0gdXJsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHdoZXRoZXIgdG8gZW5hYmxlIHBlcnNpc3RlbnQgbW91c2UgaG92ZXJpbmcgKHRydWUgYnkgZGVmYXVsdCkuXG4gICAqIFBlcnNpc3RlbnQgaG92ZXJpbmcgaXMgYWNoaWV2ZWQgYnkgY29udGludW91c2x5IGZpcmluZyBtb3VzZSBvdmVyIGV2ZW50cyBhdFxuICAgKiB0aGUgbGFzdCBsb2NhdGlvbiB0aGUgbW91c2UgY3Vyc29yIGhhcyBiZWVuIG1vdmVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSBXaGV0aGVyIHRvIGVuYWJsZSBwZXJzaXN0ZW50IGhvdmVyaW5nLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGVuYWJsZVBlcnNpc3RlbnRIb3ZlcihlbmFibGUpIHtcbiAgICB0aGlzLm9wdGlvbnNfW0tleS5FTkFCTEVfUEVSU0lTVEVOVF9IT1ZFUl0gPSAhIWVuYWJsZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyB3aGV0aGVyIHRoZSBkcml2ZXIgc2hvdWxkIGF0dGVtcHQgdG8gcmVtb3ZlIG9ic29sZXRlXG4gICAqIHtAbGlua3BsYWluIHdlYmRyaXZlci5XZWJFbGVtZW50IFdlYkVsZW1lbnRzfSBmcm9tIGl0cyBpbnRlcm5hbCBjYWNoZSBvblxuICAgKiBwYWdlIG5hdmlnYXRpb24gKHRydWUgYnkgZGVmYXVsdCkuIERpc2FibGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZVxuICAgKiBkcml2ZXIgdG8gcnVuIHdpdGggYSBsYXJnZXIgbWVtb3J5IGZvb3RwcmludC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgV2hldGhlciB0byBlbmFibGUgZWxlbWVudCByZWZlcmVuY2UgY2xlYW51cC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBlbmFibGVFbGVtZW50Q2FjaGVDbGVhbnVwKGVuYWJsZSkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LkVOQUJMRV9FTEVNRU5UX0NBQ0hFX0NMRUFOVVBdID0gISFlbmFibGVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgd2hldGhlciB0byByZXF1aXJlIHRoZSBJRSB3aW5kb3cgdG8gaGF2ZSBpbnB1dCBmb2N1cyBiZWZvcmVcbiAgICogcGVyZm9ybWluZyBhbnkgdXNlciBpbnRlcmFjdGlvbnMgKGkuZS4gbW91c2Ugb3Iga2V5Ym9hcmQgZXZlbnRzKS4gVGhpc1xuICAgKiBvcHRpb24gaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCwgYnV0IGRlbGl2ZXJzIG11Y2ggbW9yZSBhY2N1cmF0ZSBpbnRlcmFjdGlvblxuICAgKiBldmVudHMgd2hlbiBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmUgV2hldGhlciB0byByZXF1aXJlIHdpbmRvdyBmb2N1cy5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICByZXF1aXJlV2luZG93Rm9jdXMocmVxdWlyZSkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LlJFUVVJUkVfV0lORE9XX0ZPQ1VTXSA9ICEhcmVxdWlyZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgdGltZW91dCwgaW4gbWlsbGlzZWNvbmRzLCB0aGF0IHRoZSBkcml2ZXIgd2lsbCBhdHRlbXB0IHRvXG4gICAqIGxvY2F0ZWQgYW5kIGF0dGFjaCB0byBhIG5ld2x5IG9wZW5lZCBpbnN0YW5jZSBvZiBJbnRlcm5ldCBFeHBsb3Jlci4gVGhlXG4gICAqIGRlZmF1bHQgaXMgemVybywgd2hpY2ggaW5kaWNhdGVzIHdhaXRpbmcgaW5kZWZpbml0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBIb3cgbG9uZyB0byB3YWl0IGZvciBJRS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBicm93c2VyQXR0YWNoVGltZW91dCh0aW1lb3V0KSB7XG4gICAgdGhpcy5vcHRpb25zX1tLZXkuQlJPV1NFUl9BVFRBQ0hfVElNRU9VVF0gPSBNYXRoLm1heCh0aW1lb3V0LCAwKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyB3aGV0aGVyIHRvIGxhdW5jaCBJbnRlcm5ldCBFeHBsb3JlciB1c2luZyB0aGUgQ3JlYXRlUHJvY2VzcyBBUEkuXG4gICAqIElmIHRoaXMgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIElFIGlzIGxhdW5jaGVkIHVzaW5nIElFTGF1bmNoVVJMLCBpZlxuICAgKiBhdmFpbGFibGUuIEZvciBJRSA4IGFuZCBhYm92ZSwgdGhpcyBvcHRpb24gcmVxdWlyZXMgdGhlIFRhYlByb2NHcm93dGhcbiAgICogcmVnaXN0cnkgdmFsdWUgdG8gYmUgc2V0IHRvIDAuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hldGhlciB0byB1c2UgdGhlIENyZWF0ZVByb2Nlc3MgQVBJLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGZvcmNlQ3JlYXRlUHJvY2Vzc0FwaShmb3JjZSkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LkZPUkNFX0NSRUFURV9QUk9DRVNTXSA9ICEhZm9yY2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBjb21tYW5kLWxpbmUgc3dpdGNoZXMgdG8gdXNlIHdoZW4gbGF1bmNoaW5nIEludGVybmV0IEV4cGxvcmVyLlxuICAgKiBUaGlzIGlzIG9ubHkgdmFsaWQgd2hlbiB1c2VkIHdpdGgge0BsaW5rICNmb3JjZUNyZWF0ZVByb2Nlc3NBcGl9LlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihzdHJpbmd8IUFycmF5LjxzdHJpbmc+KX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGFkZC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuXG4gIGFkZEJyb3dzZXJDb21tYW5kU3dpdGNoZXMoLi4uYXJncykge1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5vcHRpb25zX1tLZXkuQlJPV1NFUl9DT01NQU5EX0xJTkVfU1dJVENIRVNdIHx8IFtdXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09ICdzdHJpbmcnKSBjdXJyZW50ID0gY3VycmVudC5zcGxpdCgnICcpXG4gICAgdGhpcy5vcHRpb25zX1tLZXkuQlJPV1NFUl9DT01NQU5EX0xJTkVfU1dJVENIRVNdID0gY3VycmVudFxuICAgICAgLmNvbmNhdChhcmdzKVxuICAgICAgLmpvaW4oJyAnKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmaWVzIGNvbW1hbmQtbGluZSBzd2l0Y2hlcyB0byB1c2Ugd2hlbiBsYXVuY2hpbmcgSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAqIFRoaXMgaXMgb25seSB2YWxpZCB3aGVuIHVzZWQgd2l0aCB7QGxpbmsgI2ZvcmNlQ3JlYXRlUHJvY2Vzc0FwaX0uXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKHN0cmluZ3whQXJyYXkuPHN0cmluZz4pfSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gYWRkLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rICNhZGRCcm93c2VyQ29tbWFuZFN3aXRjaGVzfSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG5cbiAgYWRkQXJndW1lbnRzKC4uLmFyZ3MpIHtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMub3B0aW9uc19bS2V5LkJST1dTRVJfQ09NTUFORF9MSU5FX1NXSVRDSEVTXSB8fCBbXVxuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PSAnc3RyaW5nJykgY3VycmVudCA9IGN1cnJlbnQuc3BsaXQoJyAnKVxuICAgIHRoaXMub3B0aW9uc19bS2V5LkJST1dTRVJfQ09NTUFORF9MSU5FX1NXSVRDSEVTXSA9IGN1cnJlbnRcbiAgICAgIC5jb25jYXQoYXJncylcbiAgICAgIC5qb2luKCcgJylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgd2hldGhlciBwcm94aWVzIHNob3VsZCBiZSBjb25maWd1cmVkIG9uIGEgcGVyLXByb2Nlc3MgYmFzaXMuIElmXG4gICAqIG5vdCBzZXQsIHNldHRpbmcgYSB7QGxpbmtwbGFpbiAjc2V0UHJveHkgcHJveHl9IHdpbGwgY29uZmlndXJlIHRoZSBzeXN0ZW1cbiAgICogcHJveHkuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHVzZSB0aGUgc3lzdGVtIHByb3h5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSBXaGV0aGVyIHRvIGVuYWJsZSBwZXItcHJvY2VzcyBwcm94eSBzZXR0aW5ncy5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICB1c2VQZXJQcm9jZXNzUHJveHkoZW5hYmxlKSB7XG4gICAgdGhpcy5vcHRpb25zX1tLZXkuVVNFX1BFUl9QUk9DRVNTX1BST1hZXSA9ICEhZW5hYmxlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHdoZXRoZXIgdG8gY2xlYXIgdGhlIGNhY2hlLCBjb29raWVzLCBoaXN0b3J5LCBhbmQgc2F2ZWQgZm9ybSBkYXRhXG4gICAqIGJlZm9yZSBzdGFydGluZyB0aGUgYnJvd3Nlci4gX1VzaW5nIHRoaXMgY2FwYWJpbGl0eSB3aWxsIGNsZWFyIHNlc3Npb24gZGF0YVxuICAgKiBmb3IgYWxsIHJ1bm5pbmcgaW5zdGFuY2VzIG9mIEludGVybmV0IEV4cGxvcmVyLCBpbmNsdWRpbmcgdGhvc2Ugc3RhcnRlZFxuICAgKiBtYW51YWxseS5fXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYW5TZXNzaW9uIFdoZXRoZXIgdG8gY2xlYXIgYWxsIHNlc3Npb24gZGF0YSBvbiBzdGFydHVwLlxuICAgKiBAcmV0dXJuIHshT3B0aW9uc30gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGVuc3VyZUNsZWFuU2Vzc2lvbihjbGVhblNlc3Npb24pIHtcbiAgICB0aGlzLm9wdGlvbnNfW0tleS5FTlNVUkVfQ0xFQU5fU0VTU0lPTl0gPSAhIWNsZWFuU2Vzc2lvblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGF0aCB0byB0aGUgbG9nIGZpbGUgdGhlIGRyaXZlciBzaG91bGQgbG9nIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZSBUaGUgbG9nIGZpbGUgcGF0aC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRMb2dGaWxlKGZpbGUpIHtcbiAgICB0aGlzLm9wdGlvbnNfW0tleS5MT0dfRklMRV0gPSBmaWxlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBJRURyaXZlclNlcnZlcidzIGxvZ2dpbmcge0BsaW5rcGxhaW4gTGV2ZWwgbGV2ZWx9LlxuICAgKiBAcGFyYW0ge0xldmVsfSBsZXZlbCBUaGUgbG9nZ2luZyBsZXZlbC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRMb2dMZXZlbChsZXZlbCkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LkxPR19MRVZFTF0gPSBsZXZlbFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgSVAgYWRkcmVzcyBvZiB0aGUgZHJpdmVyJ3MgaG9zdCBhZGFwdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9zdCBUaGUgSVAgYWRkcmVzcyB0byB1c2UuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0SG9zdChob3N0KSB7XG4gICAgdGhpcy5vcHRpb25zX1tLZXkuSE9TVF0gPSBob3N0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYXRoIG9mIHRoZSB0ZW1wb3JhcnkgZGF0YSBkaXJlY3RvcnkgdG8gdXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgbG9nIGZpbGUgcGF0aC5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRFeHRyYWN0UGF0aChwYXRoKSB7XG4gICAgdGhpcy5vcHRpb25zX1tLZXkuRVhUUkFDVF9QQVRIXSA9IHBhdGhcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgZHJpdmVyIHNob3VsZCBzdGFydCBpbiBzaWxlbnQgbW9kZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgV2hldGhlciB0byBydW4gaW4gc2lsZW50IG1vZGUuXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2lsZW50KHNpbGVudCkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LlNJTEVOVF0gPSBzaWxlbnRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb25zIEZpbGUgVXBsb2FkIERpYWxvZyBUaW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBIb3cgbG9uZyB0byB3YWl0IGZvciBJRS5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBmaWxlVXBsb2FkRGlhbG9nVGltZW91dCh0aW1lb3V0KSB7XG4gICAgdGhpcy5vcHRpb25zX1tLZXkuRklMRV9VUExPQURfRElBTE9HX1RJTUVPVVRdID0gTWF0aC5tYXgodGltZW91dCwgMClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhdGggb2YgdGhlIEVkZ2VDaHJvbWl1bSBkcml2ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBFZGdlQ2hyb21pdW0gZHJpdmVyIHBhdGguXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0RWRnZVBhdGgocGF0aCkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LkVER0VfRVhFQ1VUQUJMRV9QQVRIXSA9IHBhdGhcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIElFRHJpdmVyIHRvIGRyaXZlIENocm9taXVtLWJhc2VkIEVkZ2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBhdHRhY2hFZGdlQ2hyb21pdW0gV2hldGhlciB0byBydW4gaW4gQ2hyb21pdW0tYmFzZWQtRWRnZSBpbiBJRSBtb2RlXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0RWRnZUNocm9taXVtKGF0dGFjaEVkZ2VDaHJvbWl1bSkge1xuICAgIHRoaXMub3B0aW9uc19bS2V5LkFUVEFDSF9UT19FREdFX0NIUk9NSVVNXSA9ICEhYXR0YWNoRWRnZUNocm9taXVtXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGhvdyBlbGVtZW50cyBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGZvciBpbnRlcmFjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJlaGF2aW9yIFRoZSBkZXNpcmVkIHNjcm9sbCBiZWhhdmlvcjogZWl0aGVyIDAgdG8gYWxpZ24gd2l0aFxuICAgKiAgICAgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgb3IgMSB0byBhbGlnbiB3aXRoIHRoZSBib3R0b20uXG4gICAqIEByZXR1cm4geyFPcHRpb25zfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0U2Nyb2xsQmVoYXZpb3IoYmVoYXZpb3IpIHtcbiAgICBpZiAoXG4gICAgICBiZWhhdmlvciAmJlxuICAgICAgYmVoYXZpb3IgIT09IFNDUk9MTF9CRUhBVklPVVIuVE9QICYmXG4gICAgICBiZWhhdmlvciAhPT0gU0NST0xMX0JFSEFWSU9VUi5CT1RUT01cbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBlcnJvci5JbnZhbGlkQXJndW1lbnRFcnJvcihgRWxlbWVudCBTY3JvbGwgQmVoYXZpb3Igb3V0IG9mIHJhbmdlLlxuICAgICAgSXQgc2hvdWxkIGJlIGVpdGhlciAke1NDUk9MTF9CRUhBVklPVVIuVE9QfSBvciAke1NDUk9MTF9CRUhBVklPVVIuQk9UVE9NfWApXG4gICAgfVxuICAgIHRoaXMub3B0aW9uc19bS2V5LkVMRU1FTlRfU0NST0xMX0JFSEFWSU9SXSA9IGJlaGF2aW9yXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIF9TeW5jaHJvbm91c2x5XyBhdHRlbXB0cyB0byBsb2NhdGUgdGhlIElFIGRyaXZlciBleGVjdXRhYmxlIG9uIHRoZSBjdXJyZW50XG4gKiBzeXN0ZW0uXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gdGhlIGxvY2F0ZWQgZXhlY3V0YWJsZSwgb3IgYG51bGxgLlxuICovXG5mdW5jdGlvbiBsb2NhdGVTeW5jaHJvbm91c2x5KCkge1xuICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IGlvLmZpbmRJblBhdGgoSUVEUklWRVJfRVhFLCB0cnVlKSA6IG51bGxcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VydmljZUZyb21DYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICAnVGhlIElFRHJpdmVyIG1heSBvbmx5IGJlIHVzZWQgb24gV2luZG93cywgYnV0IHlvdSBhcHBlYXIgdG8gYmUgb24gJyArXG4gICAgICAgIHByb2Nlc3MucGxhdGZvcm0gK1xuICAgICAgICAnLiBEaWQgeW91IG1lYW4gdG8gcnVuIGFnYWluc3QgYSByZW1vdGUgJyArXG4gICAgICAgICdXZWJEcml2ZXIgc2VydmVyPydcbiAgICApXG4gIH1cblxuICBsZXQgZXhlID0gbG9jYXRlU3luY2hyb25vdXNseSgpXG4gIHZhciBhcmdzID0gW11cbiAgaWYgKGNhcGFiaWxpdGllcy5oYXMoS2V5LkhPU1QpKSB7XG4gICAgYXJncy5wdXNoKCctLWhvc3Q9JyArIGNhcGFiaWxpdGllcy5nZXQoS2V5LkhPU1QpKVxuICB9XG4gIGlmIChjYXBhYmlsaXRpZXMuaGFzKEtleS5MT0dfRklMRSkpIHtcbiAgICBhcmdzLnB1c2goJy0tbG9nLWZpbGU9JyArIGNhcGFiaWxpdGllcy5nZXQoS2V5LkxPR19GSUxFKSlcbiAgfVxuICBpZiAoY2FwYWJpbGl0aWVzLmhhcyhLZXkuTE9HX0xFVkVMKSkge1xuICAgIGFyZ3MucHVzaCgnLS1sb2ctbGV2ZWw9JyArIGNhcGFiaWxpdGllcy5nZXQoS2V5LkxPR19MRVZFTCkpXG4gIH1cbiAgaWYgKGNhcGFiaWxpdGllcy5oYXMoS2V5LkVYVFJBQ1RfUEFUSCkpIHtcbiAgICBhcmdzLnB1c2goJy0tZXh0cmFjdC1wYXRoPScgKyBjYXBhYmlsaXRpZXMuZ2V0KEtleS5FWFRSQUNUX1BBVEgpKVxuICB9XG4gIGlmIChjYXBhYmlsaXRpZXMuZ2V0KEtleS5TSUxFTlQpKSB7XG4gICAgYXJncy5wdXNoKCctLXNpbGVudCcpXG4gIH1cblxuICB2YXIgcG9ydCA9IHBvcnRwcm9iZXIuZmluZEZyZWVQb3J0KClcbiAgcmV0dXJuIG5ldyByZW1vdGUuRHJpdmVyU2VydmljZShleGUsIHtcbiAgICBsb29wYmFjazogdHJ1ZSxcbiAgICBwb3J0OiBwb3J0LFxuICAgIGFyZ3M6IHBvcnQudGhlbihmdW5jdGlvbiAocG9ydCkge1xuICAgICAgcmV0dXJuIGFyZ3MuY29uY2F0KCctLXBvcnQ9JyArIHBvcnQpXG4gICAgfSksXG4gICAgc3RkaW86ICdpZ25vcmUnLFxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMge0BsaW5rIHNlbGVuaXVtLXdlYmRyaXZlci9yZW1vdGUuRHJpdmVyU2VydmljZX0gaW5zdGFuY2VzIHRoYXQgbWFuYWdlXG4gKiBhbiBbSUVEcml2ZXJTZXJ2ZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9TZWxlbml1bUhRL3NlbGVuaXVtL3dpa2kvSW50ZXJuZXRFeHBsb3JlckRyaXZlcilcbiAqIHNlcnZlciBpbiBhIGNoaWxkIHByb2Nlc3MuXG4gKi9cbmNsYXNzIFNlcnZpY2VCdWlsZGVyIGV4dGVuZHMgcmVtb3RlLkRyaXZlclNlcnZpY2UuQnVpbGRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9leGUgUGF0aCB0byB0aGUgc2VydmVyIGV4ZWN1dGFibGUgdG8gdXNlLiBJZiBvbWl0dGVkLFxuICAgKiAgICAgdGhlIGJ1aWxkZXIgd2lsbCBhdHRlbXB0IHRvIGxvY2F0ZSB0aGUgSUVEcml2ZXJTZXJ2ZXIgb24gdGhlIHN5c3RlbSBQQVRILlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X2V4ZSkge1xuICAgIHN1cGVyKG9wdF9leGUgfHwgSUVEUklWRVJfRVhFKVxuICAgIHRoaXMuc2V0TG9vcGJhY2sodHJ1ZSkgLy8gUmVxdWlyZWQuXG4gIH1cbn1cblxuLyoqXG4gKiBBIFdlYkRyaXZlciBjbGllbnQgZm9yIE1pY3Jvc29mdCdzIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5jbGFzcyBEcml2ZXIgZXh0ZW5kcyB3ZWJkcml2ZXIuV2ViRHJpdmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc2Vzc2lvbiBmb3IgTWljcm9zb2Z0J3MgSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7KENhcGFiaWxpdGllc3xPcHRpb25zKT19IG9wdGlvbnMgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIHsocmVtb3RlLkRyaXZlclNlcnZpY2UpPX0gb3B0X3NlcnZpY2UgVGhlIGBEcml2ZXJTZXJ2aWNlYCB0byB1c2VcbiAgICogICB0byBzdGFydCB0aGUgSUVEcml2ZXJTZXJ2ZXIgaW4gYSBjaGlsZCBwcm9jZXNzLCBvcHRpb25hbGx5LlxuICAgKiBAcmV0dXJuIHshRHJpdmVyfSBBIG5ldyBkcml2ZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlU2Vzc2lvbihvcHRpb25zLCBvcHRfc2VydmljZSkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IG5ldyBPcHRpb25zKClcblxuICAgIGxldCBzZXJ2aWNlXG5cbiAgICBpZiAob3B0X3NlcnZpY2UgaW5zdGFuY2VvZiByZW1vdGUuRHJpdmVyU2VydmljZSkge1xuICAgICAgc2VydmljZSA9IG9wdF9zZXJ2aWNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcnZpY2UgPSBjcmVhdGVTZXJ2aWNlRnJvbUNhcGFiaWxpdGllcyhvcHRpb25zKVxuICAgIH1cbiAgICBpZiAoIXNlcnZpY2UuZ2V0RXhlY3V0YWJsZSgpKSB7XG4gICAgICBzZXJ2aWNlLnNldEV4ZWN1dGFibGUoZ2V0UGF0aChzZXJ2aWNlLCBvcHRpb25zKSlcbiAgICB9XG5cbiAgICBsZXQgY2xpZW50ID0gc2VydmljZS5zdGFydCgpLnRoZW4oKHVybCkgPT4gbmV3IGh0dHAuSHR0cENsaWVudCh1cmwpKVxuICAgIGxldCBleGVjdXRvciA9IG5ldyBodHRwLkV4ZWN1dG9yKGNsaWVudClcblxuICAgIHJldHVybiAvKiogQHR5cGUgeyFEcml2ZXJ9ICovIChcbiAgICAgIHN1cGVyLmNyZWF0ZVNlc3Npb24oZXhlY3V0b3IsIG9wdGlvbnMsICgpID0+IHNlcnZpY2Uua2lsbCgpKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGEgbm8tb3AgYXMgZmlsZSBkZXRlY3RvcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhpc1xuICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRGaWxlRGV0ZWN0b3IoKSB7fVxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbmV4cG9ydHMuRHJpdmVyID0gRHJpdmVyXG5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zXG5leHBvcnRzLkxldmVsID0gTGV2ZWxcbmV4cG9ydHMuU2VydmljZUJ1aWxkZXIgPSBTZXJ2aWNlQnVpbGRlclxuZXhwb3J0cy5LZXkgPSBLZXlcbmV4cG9ydHMuVkVORE9SX0NPTU1BTkRfUFJFRklYID0gT1BUSU9OU19DQVBBQklMSVRZX0tFWVxuZXhwb3J0cy5CZWhhdmlvciA9IFNDUk9MTF9CRUhBVklPVVJcbmV4cG9ydHMubG9jYXRlU3luY2hyb25vdXNseSA9IGxvY2F0ZVN5bmNocm9ub3VzbHlcbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGUgbWFpbiB1c2VyIGZhY2luZyBtb2R1bGUuIEV4cG9ydHMgV2ViRHJpdmVyJ3MgcHJpbWFyeVxuICogcHVibGljIEFQSSBhbmQgcHJvdmlkZXMgY29udmVuaWVuY2UgYXNzZXNzb3JzIHRvIGNlcnRhaW4gc3ViLW1vZHVsZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IF9odHRwID0gcmVxdWlyZSgnLi9odHRwJylcbmNvbnN0IGJ5ID0gcmVxdWlyZSgnLi9saWIvYnknKVxuY29uc3QgY2FwYWJpbGl0aWVzID0gcmVxdWlyZSgnLi9saWIvY2FwYWJpbGl0aWVzJylcbmNvbnN0IGNocm9tZSA9IHJlcXVpcmUoJy4vY2hyb21lJylcbmNvbnN0IGVkZ2UgPSByZXF1aXJlKCcuL2VkZ2UnKVxuY29uc3QgZXJyb3IgPSByZXF1aXJlKCcuL2xpYi9lcnJvcicpXG5jb25zdCBmaXJlZm94ID0gcmVxdWlyZSgnLi9maXJlZm94JylcbmNvbnN0IGllID0gcmVxdWlyZSgnLi9pZScpXG5jb25zdCBpbnB1dCA9IHJlcXVpcmUoJy4vbGliL2lucHV0JylcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKCcuL2xpYi9sb2dnaW5nJylcbmNvbnN0IHByb21pc2UgPSByZXF1aXJlKCcuL2xpYi9wcm9taXNlJylcbmNvbnN0IHJlbW90ZSA9IHJlcXVpcmUoJy4vcmVtb3RlJylcbmNvbnN0IHNhZmFyaSA9IHJlcXVpcmUoJy4vc2FmYXJpJylcbmNvbnN0IHNlc3Npb24gPSByZXF1aXJlKCcuL2xpYi9zZXNzaW9uJylcbmNvbnN0IHVudGlsID0gcmVxdWlyZSgnLi9saWIvdW50aWwnKVxuY29uc3Qgd2ViZHJpdmVyID0gcmVxdWlyZSgnLi9saWIvd2ViZHJpdmVyJylcbmNvbnN0IHNlbGVjdCA9IHJlcXVpcmUoJy4vbGliL3NlbGVjdCcpXG5jb25zdCBMb2dJbnNwZWN0b3IgPSByZXF1aXJlKCcuL2JpZGkvbG9nSW5zcGVjdG9yJylcbmNvbnN0IEJyb3dzaW5nQ29udGV4dCA9IHJlcXVpcmUoJy4vYmlkaS9icm93c2luZ0NvbnRleHQnKVxuY29uc3QgQnJvd3NpbmdDb25leHRJbnNwZWN0b3IgPSByZXF1aXJlKCcuL2JpZGkvYnJvd3NpbmdDb250ZXh0SW5zcGVjdG9yJylcbmNvbnN0IFNjcmlwdE1hbmFnZXIgPSByZXF1aXJlKCcuL2JpZGkvc2NyaXB0TWFuYWdlcicpXG5cbmNvbnN0IEJyb3dzZXIgPSBjYXBhYmlsaXRpZXMuQnJvd3NlclxuY29uc3QgQ2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzLkNhcGFiaWxpdGllc1xuY29uc3QgQ2FwYWJpbGl0eSA9IGNhcGFiaWxpdGllcy5DYXBhYmlsaXR5XG5jb25zdCBXZWJEcml2ZXIgPSB3ZWJkcml2ZXIuV2ViRHJpdmVyXG5cbmxldCBzZWxlbml1bVNlcnZlclxuXG4vKipcbiAqIFN0YXJ0cyBhbiBpbnN0YW5jZSBvZiB0aGUgU2VsZW5pdW0gc2VydmVyIGlmIG5vdCB5ZXQgcnVubmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBqYXIgUGF0aCB0byB0aGUgc2VydmVyIGphciB0byB1c2UuXG4gKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgZm9yIHRoZSBzZXJ2ZXInc1xuICogICAgIGFkZHJlc3Mgb25jZSBzdGFydGVkLlxuICovXG5mdW5jdGlvbiBzdGFydFNlbGVuaXVtU2VydmVyKGphcikge1xuICBpZiAoIXNlbGVuaXVtU2VydmVyKSB7XG4gICAgc2VsZW5pdW1TZXJ2ZXIgPSBuZXcgcmVtb3RlLlNlbGVuaXVtU2VydmVyKGphcilcbiAgfVxuICByZXR1cm4gc2VsZW5pdW1TZXJ2ZXIuc3RhcnQoKVxufVxuXG4vKipcbiAqIHtAbGlua3BsYWluIHdlYmRyaXZlci5XZWJEcml2ZXIjc2V0RmlsZURldGVjdG9yIFdlYkRyaXZlcidzIHNldEZpbGVEZXRlY3Rvcn1cbiAqIG1ldGhvZCB1c2VzIGEgbm9uLXN0YW5kYXJkIGNvbW1hbmQgdG8gdHJhbnNmZXIgZmlsZXMgZnJvbSB0aGUgbG9jYWwgY2xpZW50XG4gKiB0byB0aGUgcmVtb3RlIGVuZCBob3N0aW5nIHRoZSBicm93c2VyLiBNYW55IG9mIHRoZSBXZWJEcml2ZXIgc3ViLXR5cGVzLCBsaWtlXG4gKiB0aGUge0BsaW5rIGNocm9tZS5Ecml2ZXJ9IGFuZCB7QGxpbmsgZmlyZWZveC5Ecml2ZXJ9LCBkbyBub3Qgc3VwcG9ydCB0aGlzXG4gKiBjb21tYW5kLiBUaHVzLCB0aGVzZSBjbGFzc2VzIG92ZXJyaWRlIHRoZSBgc2V0RmlsZURldGVjdG9yYCB0byBuby1vcC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYSBtaXhpbiB0byByZS1lbmFibGUgYHNldEZpbGVEZXRlY3RvcmAgYnkgY2FsbGluZyB0aGVcbiAqIG9yaWdpbmFsIG1ldGhvZCBvbiB0aGUgV2ViRHJpdmVyIHByb3RvdHlwZSBkaXJlY3RseS4gVGhpcyBpcyB1c2VkIG9ubHkgd2hlblxuICogdGhlIGJ1aWxkZXIgY3JlYXRlcyBhIENocm9tZSBvciBGaXJlZm94IGluc3RhbmNlIHRoYXQgY29tbXVuaWNhdGVzIHdpdGggYVxuICogcmVtb3RlIGVuZCAoYW5kIHRodXMsIHN1cHBvcnQgZm9yIHJlbW90ZSBmaWxlIGRldGVjdG9ycyBpcyB1bmtub3duKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzogd2ViZHJpdmVyLldlYkRyaXZlciwgLi4uPyl9IGN0b3JcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzogd2ViZHJpdmVyLldlYkRyaXZlciwgLi4uPyl9XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUZpbGVEZXRlY3RvcnNBcmVFbmFibGVkKGN0b3IpIHtcbiAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgY3RvciB7XG4gICAgLyoqIEBwYXJhbSB7aW5wdXQuRmlsZURldGVjdG9yfSBkZXRlY3RvciAqL1xuICAgIHNldEZpbGVEZXRlY3RvcihkZXRlY3Rvcikge1xuICAgICAgd2ViZHJpdmVyLldlYkRyaXZlci5wcm90b3R5cGUuc2V0RmlsZURldGVjdG9yLmNhbGwodGhpcywgZGV0ZWN0b3IpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSB0aGVuYWJsZSB3cmFwcGVyIGFyb3VuZCBhIHtAbGlua3BsYWluIHdlYmRyaXZlci5JV2ViRHJpdmVyIElXZWJEcml2ZXJ9XG4gKiBpbnN0YW5jZSB0aGF0IGFsbG93cyBjb21tYW5kcyB0byBiZSBpc3N1ZWQgZGlyZWN0bHkgaW5zdGVhZCBvZiBoYXZpbmcgdG9cbiAqIHJlcGVhdGVkbHkgY2FsbCBgdGhlbmA6XG4gKlxuICogICAgIGxldCBkcml2ZXIgPSBuZXcgQnVpbGRlcigpLmJ1aWxkKCk7XG4gKiAgICAgZHJpdmVyLnRoZW4oZCA9PiBkLmdldCh1cmwpKTsgIC8vIFlvdSBjYW4gZG8gdGhpcy4uLlxuICogICAgIGRyaXZlci5nZXQodXJsKTsgICAgICAgICAgICAgICAvLyAuLi5vciB0aGlzXG4gKlxuICogSWYgdGhlIGRyaXZlciBpbnN0YW5jZSBmYWlscyB0byByZXNvbHZlIChlLmcuIHRoZSBzZXNzaW9uIGNhbm5vdCBiZSBjcmVhdGVkKSxcbiAqIGV2ZXJ5IGlzc3VlZCBjb21tYW5kIHdpbGwgZmFpbC5cbiAqXG4gKiBAZXh0ZW5kcyB7d2ViZHJpdmVyLklXZWJEcml2ZXJ9XG4gKiBAZXh0ZW5kcyB7SVRoZW5hYmxlPCF3ZWJkcml2ZXIuSVdlYkRyaXZlcj59XG4gKiBAaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFRoZW5hYmxlV2ViRHJpdmVyIHtcbiAgLyoqIEBwYXJhbSB7Li4uP30gYXJncyAqL1xuICBzdGF0aWMgY3JlYXRlU2Vzc2lvbiguLi5hcmdzKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbi8qKlxuICogQGNvbnN0IHshTWFwPGZ1bmN0aW9uKG5ldzogV2ViRHJpdmVyLCAhSVRoZW5hYmxlPCFTZXNzaW9uPiwgLi4uPyksXG4gKiAgICAgICAgICAgICAgZnVuY3Rpb24obmV3OiBUaGVuYWJsZVdlYkRyaXZlciwgIUlUaGVuYWJsZTwhU2Vzc2lvbj4sIC4uLj8pPn1cbiAqL1xuY29uc3QgVEhFTkFCTEVfRFJJVkVSUyA9IG5ldyBNYXAoKVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OiBXZWJEcml2ZXIsICFJVGhlbmFibGU8IVNlc3Npb24+LCAuLi4/KX0gY3RvclxuICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gKiBAcmV0dXJuIHshVGhlbmFibGVXZWJEcml2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURyaXZlcihjdG9yLCAuLi5hcmdzKSB7XG4gIGxldCB0aGVuYWJsZVdlYkRyaXZlclByb3h5ID0gVEhFTkFCTEVfRFJJVkVSUy5nZXQoY3RvcilcbiAgaWYgKCF0aGVuYWJsZVdlYkRyaXZlclByb3h5KSB7XG4gICAgLyoqXG4gICAgICogQGV4dGVuZHMge1dlYkRyaXZlcn0gIC8vIE5lZWRlZCBzaW5jZSBgY3RvcmAgaXMgZHluYW1pY2FsbHkgdHlwZWQuXG4gICAgICogQGltcGxlbWVudHMge1RoZW5hYmxlV2ViRHJpdmVyfVxuICAgICAqL1xuICAgIHRoZW5hYmxlV2ViRHJpdmVyUHJveHkgPSBjbGFzcyBleHRlbmRzIGN0b3Ige1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFJVGhlbmFibGU8IVNlc3Npb24+fSBzZXNzaW9uXG4gICAgICAgKiBAcGFyYW0gey4uLj99IHJlc3RcbiAgICAgICAqL1xuICAgICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgLi4ucmVzdCkge1xuICAgICAgICBzdXBlcihzZXNzaW9uLCAuLi5yZXN0KVxuXG4gICAgICAgIGNvbnN0IHBkID0gdGhpcy5nZXRTZXNzaW9uKCkudGhlbigoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgY3RvcihzZXNzaW9uLCAuLi5yZXN0KVxuICAgICAgICB9KVxuXG4gICAgICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICAgICAgdGhpcy50aGVuID0gcGQudGhlbi5iaW5kKHBkKVxuXG4gICAgICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICAgICAgdGhpcy5jYXRjaCA9IHBkLmNhdGNoLmJpbmQocGQpXG4gICAgICB9XG4gICAgfVxuICAgIFRIRU5BQkxFX0RSSVZFUlMuc2V0KGN0b3IsIHRoZW5hYmxlV2ViRHJpdmVyUHJveHkpXG4gIH1cbiAgcmV0dXJuIHRoZW5hYmxlV2ViRHJpdmVyUHJveHkuY3JlYXRlU2Vzc2lvbiguLi5hcmdzKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgbmV3IHtAbGluayB3ZWJkcml2ZXIuV2ViRHJpdmVyIFdlYkRyaXZlcn0gaW5zdGFuY2VzLiBUaGUgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlcyBsaXN0ZWQgYmVsb3cgbWF5IGJlIHVzZWQgdG8gb3ZlcnJpZGUgYSBidWlsZGVyJ3MgY29uZmlndXJhdGlvbixcbiAqIGFsbG93aW5nIHF1aWNrIHJ1bnRpbWUgY2hhbmdlcy5cbiAqXG4gKiAtIHtAY29kZSBTRUxFTklVTV9CUk9XU0VSfTogZGVmaW5lcyB0aGUgdGFyZ2V0IGJyb3dzZXIgaW4gdGhlIGZvcm1cbiAqICAge0Bjb2RlIGJyb3dzZXJbOnZlcnNpb25dWzpwbGF0Zm9ybV19LlxuICpcbiAqIC0ge0Bjb2RlIFNFTEVOSVVNX1JFTU9URV9VUkx9OiBkZWZpbmVzIHRoZSByZW1vdGUgVVJMIGZvciBhbGwgYnVpbGRlclxuICogICBpbnN0YW5jZXMuIFRoaXMgZW52aXJvbm1lbnQgdmFyaWFibGUgc2hvdWxkIGJlIHNldCB0byBhIGZ1bGx5IHF1YWxpZmllZFxuICogICBVUkwgZm9yIGEgV2ViRHJpdmVyIHNlcnZlciAoZS5nLiBodHRwOi8vbG9jYWxob3N0OjQ0NDQvd2QvaHViKS4gVGhpc1xuICogICBvcHRpb24gYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB7QGNvZGUgU0VMRU5JVU1fU0VSVkVSX0pBUn0uXG4gKlxuICogLSB7QGNvZGUgU0VMRU5JVU1fU0VSVkVSX0pBUn06IGRlZmluZXMgdGhlIHBhdGggdG8gdGhlXG4gKiAgIDxhIGhyZWY9XCJodHRwczovL3d3dy5zZWxlbml1bS5kZXYvZG93bmxvYWRzL1wiPlxuICogICBzdGFuZGFsb25lIFNlbGVuaXVtIHNlcnZlcjwvYT4gamFyIHRvIHVzZS4gVGhlIHNlcnZlciB3aWxsIGJlIHN0YXJ0ZWQgdGhlXG4gKiAgIGZpcnN0IHRpbWUgYSBXZWJEcml2ZXIgaW5zdGFuY2UgYW5kIGJlIGtpbGxlZCB3aGVuIHRoZSBwcm9jZXNzIGV4aXRzLlxuICpcbiAqIFN1cHBvc2UgeW91IGhhZCBteXRlc3QuanMgdGhhdCBjcmVhdGVkIFdlYkRyaXZlciB3aXRoXG4gKlxuICogICAgIHZhciBkcml2ZXIgPSBuZXcgd2ViZHJpdmVyLkJ1aWxkZXIoKVxuICogICAgICAgICAuZm9yQnJvd3NlcignY2hyb21lJylcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogVGhpcyB0ZXN0IGNvdWxkIGJlIG1hZGUgdG8gdXNlIEZpcmVmb3ggb24gdGhlIGxvY2FsIG1hY2hpbmUgYnkgcnVubmluZyB3aXRoXG4gKiBgU0VMRU5JVU1fQlJPV1NFUj1maXJlZm94IG5vZGUgbXl0ZXN0LmpzYC4gUmF0aGVyIHRoYW4gY2hhbmdlIHRoZSBjb2RlIHRvXG4gKiB0YXJnZXQgR29vZ2xlIENocm9tZSBvbiBhIHJlbW90ZSBtYWNoaW5lLCB5b3UgY2FuIHNpbXBseSBzZXQgdGhlXG4gKiBgU0VMRU5JVU1fQlJPV1NFUmAgYW5kIGBTRUxFTklVTV9SRU1PVEVfVVJMYCBlbnZpcm9ubWVudCB2YXJpYWJsZXM6XG4gKlxuICogICAgIFNFTEVOSVVNX0JST1dTRVI9Y2hyb21lOjM2OkxJTlVYIFxcXG4gKiAgICAgU0VMRU5JVU1fUkVNT1RFX1VSTD1odHRwOi8vd3d3LmV4YW1wbGUuY29tOjQ0NDQvd2QvaHViIFxcXG4gKiAgICAgbm9kZSBteXRlc3QuanNcbiAqXG4gKiBZb3UgY291bGQgYWxzbyB1c2UgYSBsb2NhbCBjb3B5IG9mIHRoZSBzdGFuZGFsb25lIFNlbGVuaXVtIHNlcnZlcjpcbiAqXG4gKiAgICAgU0VMRU5JVU1fQlJPV1NFUj1jaHJvbWU6MzY6TElOVVggXFxcbiAqICAgICBTRUxFTklVTV9TRVJWRVJfSkFSPS9wYXRoL3RvL3NlbGVuaXVtLXNlcnZlci1zdGFuZGFsb25lLmphciBcXFxuICogICAgIG5vZGUgbXl0ZXN0LmpzXG4gKi9cbmNsYXNzIEJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHByaXZhdGUgQGNvbnN0ICovXG4gICAgdGhpcy5sb2dfID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3dlYmRyaXZlci5CdWlsZGVyJylcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMudXJsXyA9ICcnXG5cbiAgICAvKiogQHByaXZhdGUgez9zdHJpbmd9ICovXG4gICAgdGhpcy5wcm94eV8gPSBudWxsXG5cbiAgICAvKiogQHByaXZhdGUgeyFDYXBhYmlsaXRpZXN9ICovXG4gICAgdGhpcy5jYXBhYmlsaXRpZXNfID0gbmV3IENhcGFiaWxpdGllcygpXG5cbiAgICAvKiogQHByaXZhdGUge2Nocm9tZS5PcHRpb25zfSAqL1xuICAgIHRoaXMuY2hyb21lT3B0aW9uc18gPSBudWxsXG5cbiAgICAvKiogQHByaXZhdGUge2Nocm9tZS5TZXJ2aWNlQnVpbGRlcn0gKi9cbiAgICB0aGlzLmNocm9tZVNlcnZpY2VfID0gbnVsbFxuXG4gICAgLyoqIEBwcml2YXRlIHtmaXJlZm94Lk9wdGlvbnN9ICovXG4gICAgdGhpcy5maXJlZm94T3B0aW9uc18gPSBudWxsXG5cbiAgICAvKiogQHByaXZhdGUge2ZpcmVmb3guU2VydmljZUJ1aWxkZXJ9ICovXG4gICAgdGhpcy5maXJlZm94U2VydmljZV8gPSBudWxsXG5cbiAgICAvKiogQHByaXZhdGUge2llLk9wdGlvbnN9ICovXG4gICAgdGhpcy5pZU9wdGlvbnNfID0gbnVsbFxuXG4gICAgLyoqIEBwcml2YXRlIHtpZS5TZXJ2aWNlQnVpbGRlcn0gKi9cbiAgICB0aGlzLmllU2VydmljZV8gPSBudWxsXG5cbiAgICAvKiogQHByaXZhdGUge3NhZmFyaS5PcHRpb25zfSAqL1xuICAgIHRoaXMuc2FmYXJpT3B0aW9uc18gPSBudWxsXG5cbiAgICAvKiogQHByaXZhdGUge2VkZ2UuT3B0aW9uc30gKi9cbiAgICB0aGlzLmVkZ2VPcHRpb25zXyA9IG51bGxcblxuICAgIC8qKiBAcHJpdmF0ZSB7cmVtb3RlLkRyaXZlclNlcnZpY2UuQnVpbGRlcn0gKi9cbiAgICB0aGlzLmVkZ2VTZXJ2aWNlXyA9IG51bGxcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlnbm9yZUVudl8gPSBmYWxzZVxuXG4gICAgLyoqIEBwcml2YXRlIHtodHRwLkFnZW50fSAqL1xuICAgIHRoaXMuYWdlbnRfID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhpcyBidWlsZGVyIHRvIGlnbm9yZSBhbnkgZW52aXJvbm1lbnQgdmFyaWFibGUgb3ZlcnJpZGVzIGFuZCB0b1xuICAgKiBvbmx5IHVzZSB0aGUgY29uZmlndXJhdGlvbiBzcGVjaWZpZWQgdGhyb3VnaCB0aGlzIGluc3RhbmNlJ3MgQVBJLlxuICAgKlxuICAgKiBAcmV0dXJuIHshQnVpbGRlcn0gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGRpc2FibGVFbnZpcm9ubWVudE92ZXJyaWRlcygpIHtcbiAgICB0aGlzLmlnbm9yZUVudl8gPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBVUkwgb2YgYSByZW1vdGUgV2ViRHJpdmVyIHNlcnZlciB0byB1c2UuIE9uY2UgYSByZW1vdGUgVVJMIGhhc1xuICAgKiBiZWVuIHNwZWNpZmllZCwgdGhlIGJ1aWxkZXIgZGlyZWN0IGFsbCBuZXcgY2xpZW50cyB0byB0aGF0IHNlcnZlci4gSWYgdGhpc1xuICAgKiBtZXRob2QgaXMgbmV2ZXIgY2FsbGVkLCB0aGUgQnVpbGRlciB3aWxsIGF0dGVtcHQgdG8gY3JlYXRlIGFsbCBjbGllbnRzXG4gICAqIGxvY2FsbHkuXG4gICAqXG4gICAqIEFzIGFuIGFsdGVybmF0aXZlIHRvIHRoaXMgbWV0aG9kLCB5b3UgbWF5IGFsc28gc2V0IHRoZVxuICAgKiBgU0VMRU5JVU1fUkVNT1RFX1VSTGAgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiBhIHJlbW90ZSBzZXJ2ZXIgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHshQnVpbGRlcn0gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHVzaW5nU2VydmVyKHVybCkge1xuICAgIHRoaXMudXJsXyA9IHVybFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVJMIG9mIHRoZSBXZWJEcml2ZXIgc2VydmVyIHRoaXMgaW5zdGFuY2UgaXNcbiAgICogICAgIGNvbmZpZ3VyZWQgdG8gdXNlLlxuICAgKi9cbiAgZ2V0U2VydmVyVXJsKCkge1xuICAgIHJldHVybiB0aGlzLnVybF9cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBVUkwgb2YgdGhlIHByb3h5IHRvIHVzZSBmb3IgdGhlIFdlYkRyaXZlcidzIEhUVFAgY29ubmVjdGlvbnMuXG4gICAqIElmIHRoaXMgbWV0aG9kIGlzIG5ldmVyIGNhbGxlZCwgdGhlIEJ1aWxkZXIgd2lsbCBjcmVhdGUgYSBjb25uZWN0aW9uXG4gICAqIHdpdGhvdXQgYSBwcm94eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3h5IFRoZSBVUkwgb2YgYSBwcm94eSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgdXNpbmdXZWJEcml2ZXJQcm94eShwcm94eSkge1xuICAgIHRoaXMucHJveHlfID0gcHJveHlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBVUkwgb2YgdGhlIHByb3h5IHNlcnZlciB0byB1c2UgZm9yIHRoZSBXZWJEcml2ZXInc1xuICAgKiAgICBIVFRQIGNvbm5lY3Rpb25zLCBvciBgbnVsbGAgaWYgbm90IHNldC5cbiAgICovXG4gIGdldFdlYkRyaXZlclByb3h5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3h5X1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGh0dHAgYWdlbnQgdG8gdXNlIGZvciBlYWNoIHJlcXVlc3QuXG4gICAqIElmIHRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHRoZSBCdWlsZGVyIHdpbGwgdXNlIGh0dHAuZ2xvYmFsQWdlbnQgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkFnZW50fSBhZ2VudCBUaGUgYWdlbnQgdG8gdXNlIGZvciBlYWNoIHJlcXVlc3QuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgdXNpbmdIdHRwQWdlbnQoYWdlbnQpIHtcbiAgICB0aGlzLmFnZW50XyA9IGFnZW50XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtodHRwLkFnZW50fSBUaGUgaHR0cCBhZ2VudCB1c2VkIGZvciBlYWNoIHJlcXVlc3RcbiAgICovXG4gIGdldEh0dHBBZ2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZ2VudF9cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbW1lbmRlZCB3YXkgaXMgdG8gdXNlIHNldCpPcHRpb25zIHdoZXJlICogaXMgdGhlIGJyb3dzZXIoZWcgc2V0Q2hyb21lT3B0aW9ucylcbiAgICpcbiAgICogU2V0cyB0aGUgZGVzaXJlZCBjYXBhYmlsaXRpZXMgd2hlbiByZXF1ZXN0aW5nIGEgbmV3IHNlc3Npb24uIFRoaXMgd2lsbFxuICAgKiBvdmVyd3JpdGUgYW55IHByZXZpb3VzbHkgc2V0IGNhcGFiaWxpdGllcy5cbiAgICogQHBhcmFtIHshKE9iamVjdHxDYXBhYmlsaXRpZXMpfSBjYXBhYmlsaXRpZXMgVGhlIGRlc2lyZWQgY2FwYWJpbGl0aWVzIGZvclxuICAgKiAgICAgYSBuZXcgc2Vzc2lvbi5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICB3aXRoQ2FwYWJpbGl0aWVzKGNhcGFiaWxpdGllcykge1xuICAgIHRoaXMuY2FwYWJpbGl0aWVzXyA9IG5ldyBDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSBzZXQgb2YgY2FwYWJpbGl0aWVzIHRoaXMgaW5zdGFuY2UgaXMgY3VycmVudGx5IGNvbmZpZ3VyZWRcbiAgICogdG8gdXNlLlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBUaGUgY3VycmVudCBjYXBhYmlsaXRpZXMgZm9yIHRoaXMgYnVpbGRlci5cbiAgICovXG4gIGdldENhcGFiaWxpdGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXNfXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGVzaXJlZCBjYXBhYmlsaXR5IHdoZW4gcmVxdWVzdGluZyBhIG5ldyBzZXNzaW9uLlxuICAgKiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2FwYWJpbGl0eSBuYW1lZCBrZXksIGl0cyB2YWx1ZSB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdmFsdWUuXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCBidWlsZGVyLmdldENhcGFiaWxpdGllcygpLnNldChrZXksIHZhbHVlKSB0byBzdXBwb3J0IEJ1aWxkZXIgbWV0aG9kIGNoYWluaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBjYXBhYmlsaXR5IGtleS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgY2FwYWJpbGl0eSB2YWx1ZS5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRDYXBhYmlsaXR5KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmNhcGFiaWxpdGllc18uc2V0KGtleSwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHRoZSB0YXJnZXQgYnJvd3NlciBmb3IgY2xpZW50cyBjcmVhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAqIEFueSBjYWxscyB0byB7QGxpbmsgI3dpdGhDYXBhYmlsaXRpZXN9IGFmdGVyIHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiBvdmVyd3JpdGUgdGhlc2Ugc2V0dGluZ3MuXG4gICAqXG4gICAqIFlvdSBtYXkgYWxzbyBkZWZpbmUgdGhlIHRhcmdldCBicm93c2VyIHVzaW5nIHRoZSB7QGNvZGUgU0VMRU5JVU1fQlJPV1NFUn1cbiAgICogZW52aXJvbm1lbnQgdmFyaWFibGUuIElmIHNldCwgdGhpcyBlbnZpcm9ubWVudCB2YXJpYWJsZSBzaG91bGQgYmUgb2YgdGhlXG4gICAqIGZvcm0gYGJyb3dzZXJbOlt2ZXJzaW9uXVs6cGxhdGZvcm1dXWAuXG4gICAqXG4gICAqIEBwYXJhbSB7KHN0cmluZ3whQnJvd3Nlcil9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhcmdldCBicm93c2VyO1xuICAgKiAgICAgY29tbW9uIGRlZmF1bHRzIGFyZSBhdmFpbGFibGUgb24gdGhlIHtAbGluayB3ZWJkcml2ZXIuQnJvd3Nlcn0gZW51bS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdmVyc2lvbiBBIGRlc2lyZWQgdmVyc2lvbjsgbWF5IGJlIG9taXR0ZWQgaWYgYW55XG4gICAqICAgICB2ZXJzaW9uIHNob3VsZCBiZSB1c2VkLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8IWNhcGFiaWxpdGllcy5QbGF0Zm9ybSk9fSBvcHRfcGxhdGZvcm1cbiAgICogICAgIFRoZSBkZXNpcmVkIHBsYXRmb3JtOyBtYXkgYmUgb21pdHRlZCBpZiBhbnkgcGxhdGZvcm0gbWF5IGJlIHVzZWQuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgZm9yQnJvd3NlcihuYW1lLCBvcHRfdmVyc2lvbiwgb3B0X3BsYXRmb3JtKSB7XG4gICAgdGhpcy5jYXBhYmlsaXRpZXNfLnNldEJyb3dzZXJOYW1lKG5hbWUpXG4gICAgaWYgKG9wdF92ZXJzaW9uKSB7XG4gICAgICB0aGlzLmNhcGFiaWxpdGllc18uc2V0QnJvd3NlclZlcnNpb24ob3B0X3ZlcnNpb24pXG4gICAgfVxuICAgIGlmIChvcHRfcGxhdGZvcm0pIHtcbiAgICAgIHRoaXMuY2FwYWJpbGl0aWVzXy5zZXRQbGF0Zm9ybShvcHRfcGxhdGZvcm0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJveHkgY29uZmlndXJhdGlvbiBmb3IgdGhlIHRhcmdldCBicm93c2VyLlxuICAgKiBBbnkgY2FsbHMgdG8ge0BsaW5rICN3aXRoQ2FwYWJpbGl0aWVzfSBhZnRlciB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAgICogb3ZlcndyaXRlIHRoZXNlIHNldHRpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0geyEuL2xpYi9wcm94eS5Db25maWd9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0UHJveHkoY29uZmlnKSB7XG4gICAgdGhpcy5jYXBhYmlsaXRpZXNfLnNldFByb3h5KGNvbmZpZylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxvZ2dpbmcgcHJlZmVyZW5jZXMgZm9yIHRoZSBjcmVhdGVkIHNlc3Npb24uIFByZWZlcmVuY2VzIG1heSBiZVxuICAgKiBjaGFuZ2VkIGJ5IHJlcGVhdGVkIGNhbGxzLCBvciBieSBjYWxsaW5nIHtAbGluayAjd2l0aENhcGFiaWxpdGllc30uXG4gICAqIEBwYXJhbSB7ISguL2xpYi9sb2dnaW5nLlByZWZlcmVuY2VzfE9iamVjdDxzdHJpbmcsIHN0cmluZz4pfSBwcmVmcyBUaGVcbiAgICogICAgIGRlc2lyZWQgbG9nZ2luZyBwcmVmZXJlbmNlcy5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRMb2dnaW5nUHJlZnMocHJlZnMpIHtcbiAgICB0aGlzLmNhcGFiaWxpdGllc18uc2V0TG9nZ2luZ1ByZWZzKHByZWZzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gdGFrZSB3aXRoIGFuIHVuZXhwZWN0ZWQgYWxlcnQgYmVmb3JlIHJldHVybmluZ1xuICAgKiBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHs/Y2FwYWJpbGl0aWVzLlVzZXJQcm9tcHRIYW5kbGVyfSBiZWhhdmlvciBUaGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqIEBzZWUgY2FwYWJpbGl0aWVzLkNhcGFiaWxpdGllcyNzZXRBbGVydEJlaGF2aW9yXG4gICAqL1xuICBzZXRBbGVydEJlaGF2aW9yKGJlaGF2aW9yKSB7XG4gICAgdGhpcy5jYXBhYmlsaXRpZXNfLnNldEFsZXJ0QmVoYXZpb3IoYmVoYXZpb3IpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIENocm9tZSBzcGVjaWZpYyB7QGxpbmtwbGFpbiBjaHJvbWUuT3B0aW9ucyBvcHRpb25zfSBmb3IgZHJpdmVyc1xuICAgKiBjcmVhdGVkIGJ5IHRoaXMgYnVpbGRlci4gQW55IGxvZ2dpbmcgb3IgcHJveHkgc2V0dGluZ3MgZGVmaW5lZCBvbiB0aGUgZ2l2ZW5cbiAgICogb3B0aW9ucyB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRob3NlIHNldCB0aHJvdWdoXG4gICAqIHtAbGluayAjc2V0TG9nZ2luZ1ByZWZzfSBhbmQge0BsaW5rICNzZXRQcm94eX0sIHJlc3BlY3RpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIHshY2hyb21lLk9wdGlvbnN9IG9wdGlvbnMgVGhlIENocm9tZURyaXZlciBvcHRpb25zIHRvIHVzZS5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRDaHJvbWVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNocm9tZU9wdGlvbnNfID0gb3B0aW9uc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Y2hyb21lLk9wdGlvbnN9IHRoZSBDaHJvbWUgc3BlY2lmaWMgb3B0aW9ucyBjdXJyZW50bHkgY29uZmlndXJlZFxuICAgKiAgICAgZm9yIHRoaXMgYnVpbGRlci5cbiAgICovXG4gIGdldENocm9tZU9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hyb21lT3B0aW9uc19cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZXJ2aWNlIGJ1aWxkZXIgdG8gdXNlIGZvciBtYW5hZ2luZyB0aGUgY2hyb21lZHJpdmVyIGNoaWxkIHByb2Nlc3NcbiAgICogd2hlbiBjcmVhdGluZyBuZXcgQ2hyb21lIHNlc3Npb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2Nocm9tZS5TZXJ2aWNlQnVpbGRlcn0gc2VydmljZSB0aGUgc2VydmljZSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0Q2hyb21lU2VydmljZShzZXJ2aWNlKSB7XG4gICAgaWYgKHNlcnZpY2UgJiYgIShzZXJ2aWNlIGluc3RhbmNlb2YgY2hyb21lLlNlcnZpY2VCdWlsZGVyKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdub3QgYSBjaHJvbWUuU2VydmljZUJ1aWxkZXIgb2JqZWN0JylcbiAgICB9XG4gICAgdGhpcy5jaHJvbWVTZXJ2aWNlXyA9IHNlcnZpY2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgRmlyZWZveCBzcGVjaWZpYyB7QGxpbmtwbGFpbiBmaXJlZm94Lk9wdGlvbnMgb3B0aW9uc30gZm9yIGRyaXZlcnNcbiAgICogY3JlYXRlZCBieSB0aGlzIGJ1aWxkZXIuIEFueSBsb2dnaW5nIG9yIHByb3h5IHNldHRpbmdzIGRlZmluZWQgb24gdGhlIGdpdmVuXG4gICAqIG9wdGlvbnMgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aG9zZSBzZXQgdGhyb3VnaFxuICAgKiB7QGxpbmsgI3NldExvZ2dpbmdQcmVmc30gYW5kIHtAbGluayAjc2V0UHJveHl9LCByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IWZpcmVmb3guT3B0aW9uc30gb3B0aW9ucyBUaGUgRmlyZWZveERyaXZlciBvcHRpb25zIHRvIHVzZS5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRGaXJlZm94T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5maXJlZm94T3B0aW9uc18gPSBvcHRpb25zXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtmaXJlZm94Lk9wdGlvbnN9IHRoZSBGaXJlZm94IHNwZWNpZmljIG9wdGlvbnMgY3VycmVudGx5IGNvbmZpZ3VyZWRcbiAgICogICAgIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0RmlyZWZveE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyZWZveE9wdGlvbnNfXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIGZpcmVmb3guU2VydmljZUJ1aWxkZXJ9IHRvIHVzZSB0byBtYW5hZ2UgdGhlIGdlY2tvZHJpdmVyXG4gICAqIGNoaWxkIHByb2Nlc3Mgd2hlbiBjcmVhdGluZyBGaXJlZm94IHNlc3Npb25zIGxvY2FsbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZmlyZWZveC5TZXJ2aWNlQnVpbGRlcn0gc2VydmljZSB0aGUgc2VydmljZSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0RmlyZWZveFNlcnZpY2Uoc2VydmljZSkge1xuICAgIGlmIChzZXJ2aWNlICYmICEoc2VydmljZSBpbnN0YW5jZW9mIGZpcmVmb3guU2VydmljZUJ1aWxkZXIpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ25vdCBhIGZpcmVmb3guU2VydmljZUJ1aWxkZXIgb2JqZWN0JylcbiAgICB9XG4gICAgdGhpcy5maXJlZm94U2VydmljZV8gPSBzZXJ2aWNlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgSW50ZXJuZXQgRXhwbG9yZXIgc3BlY2lmaWMge0BsaW5rcGxhaW4gaWUuT3B0aW9ucyBvcHRpb25zfSBmb3IgZHJpdmVyc1xuICAgKiBjcmVhdGVkIGJ5IHRoaXMgYnVpbGRlci4gQW55IHByb3h5IHNldHRpbmdzIGRlZmluZWQgb24gdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aG9zZSBzZXQgdGhyb3VnaCB7QGxpbmsgI3NldFByb3h5fS5cbiAgICpcbiAgICogQHBhcmFtIHshaWUuT3B0aW9uc30gb3B0aW9ucyBUaGUgSUVEcml2ZXIgb3B0aW9ucyB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0SWVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmllT3B0aW9uc18gPSBvcHRpb25zXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB7QGxpbmsgaWUuU2VydmljZUJ1aWxkZXJ9IHRvIHVzZSB0byBtYW5hZ2UgdGhlIGdlY2tvZHJpdmVyXG4gICAqIGNoaWxkIHByb2Nlc3Mgd2hlbiBjcmVhdGluZyBJRSBzZXNzaW9ucyBsb2NhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0ge2llLlNlcnZpY2VCdWlsZGVyfSBzZXJ2aWNlIHRoZSBzZXJ2aWNlIHRvIHVzZS5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IGEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRJZVNlcnZpY2Uoc2VydmljZSkge1xuICAgIHRoaXMuaWVTZXJ2aWNlXyA9IHNlcnZpY2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB7QGxpbmtwbGFpbiBlZGdlLk9wdGlvbnMgb3B0aW9uc30gc3BlY2lmaWMgdG8gTWljcm9zb2Z0J3MgRWRnZSBicm93c2VyXG4gICAqIGZvciBkcml2ZXJzIGNyZWF0ZWQgYnkgdGhpcyBidWlsZGVyLiBBbnkgcHJveHkgc2V0dGluZ3MgZGVmaW5lZCBvbiB0aGVcbiAgICogZ2l2ZW4gb3B0aW9ucyB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRob3NlIHNldCB0aHJvdWdoXG4gICAqIHtAbGluayAjc2V0UHJveHl9LlxuICAgKlxuICAgKiBAcGFyYW0geyFlZGdlLk9wdGlvbnN9IG9wdGlvbnMgVGhlIE1pY3Jvc29mdEVkZ2VEcml2ZXIgb3B0aW9ucyB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0RWRnZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuZWRnZU9wdGlvbnNfID0gb3B0aW9uc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIGVkZ2UuU2VydmljZUJ1aWxkZXJ9IHRvIHVzZSB0byBtYW5hZ2UgdGhlXG4gICAqIE1pY3Jvc29mdEVkZ2VEcml2ZXIgY2hpbGQgcHJvY2VzcyB3aGVuIGNyZWF0aW5nIHNlc3Npb25zIGxvY2FsbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZWRnZS5TZXJ2aWNlQnVpbGRlcn0gc2VydmljZSB0aGUgc2VydmljZSB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCdWlsZGVyfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0RWRnZVNlcnZpY2Uoc2VydmljZSkge1xuICAgIGlmIChzZXJ2aWNlICYmICEoc2VydmljZSBpbnN0YW5jZW9mIGVkZ2UuU2VydmljZUJ1aWxkZXIpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ25vdCBhIGVkZ2UuU2VydmljZUJ1aWxkZXIgb2JqZWN0JylcbiAgICB9XG4gICAgdGhpcy5lZGdlU2VydmljZV8gPSBzZXJ2aWNlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIFNhZmFyaSBzcGVjaWZpYyB7QGxpbmtwbGFpbiBzYWZhcmkuT3B0aW9ucyBvcHRpb25zfSBmb3IgZHJpdmVyc1xuICAgKiBjcmVhdGVkIGJ5IHRoaXMgYnVpbGRlci4gQW55IGxvZ2dpbmcgc2V0dGluZ3MgZGVmaW5lZCBvbiB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRob3NlIHNldCB0aHJvdWdoIHtAbGluayAjc2V0TG9nZ2luZ1ByZWZzfS5cbiAgICpcbiAgICogQHBhcmFtIHshc2FmYXJpLk9wdGlvbnN9IG9wdGlvbnMgVGhlIFNhZmFyaSBvcHRpb25zIHRvIHVzZS5cbiAgICogQHJldHVybiB7IUJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRTYWZhcmlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNhZmFyaU9wdGlvbnNfID0gb3B0aW9uc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c2FmYXJpLk9wdGlvbnN9IHRoZSBTYWZhcmkgc3BlY2lmaWMgb3B0aW9ucyBjdXJyZW50bHkgY29uZmlndXJlZFxuICAgKiAgICAgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBnZXRTYWZhcmlPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmFyaU9wdGlvbnNfXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBXZWJEcml2ZXIgY2xpZW50IGJhc2VkIG9uIHRoaXMgYnVpbGRlcidzIGN1cnJlbnRcbiAgICogY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYSB7QGxpbmtwbGFpbiBUaGVuYWJsZVdlYkRyaXZlcn0gaW5zdGFuY2UsIGFsbG93aW5nXG4gICAqIHVzZXJzIHRvIGlzc3VlIGNvbW1hbmRzIGRpcmVjdGx5IHdpdGhvdXQgY2FsbGluZyBgdGhlbigpYC4gVGhlIHJldHVybmVkXG4gICAqIHRoZW5hYmxlIHdyYXBzIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byBhIGNvbmNyZXRlXG4gICAqIHtAbGlua3BsYWluIHdlYmRyaXZlci5XZWJEcml2ZXIgV2ViRHJpdmVyfSBpbnN0YW5jZS4gVGhlIHByb21pc2Ugd2lsbCBiZVxuICAgKiByZWplY3RlZCBpZiB0aGUgcmVtb3RlIGVuZCBmYWlscyB0byBjcmVhdGUgYSBuZXcgc2Vzc2lvbi5cbiAgICpcbiAgICogQHJldHVybiB7IVRoZW5hYmxlV2ViRHJpdmVyfSBBIG5ldyBXZWJEcml2ZXIgaW5zdGFuY2UuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGlzIGludmFsaWQuXG4gICAqL1xuICBidWlsZCgpIHtcbiAgICAvLyBDcmVhdGUgYSBjb3B5IGZvciBhbnkgY2hhbmdlcyB3ZSBtYXkgbmVlZCB0byBtYWtlIGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAgLy8gZW52aXJvbm1lbnQuXG4gICAgY29uc3QgY2FwYWJpbGl0aWVzID0gbmV3IENhcGFiaWxpdGllcyh0aGlzLmNhcGFiaWxpdGllc18pXG5cbiAgICBsZXQgYnJvd3NlclxuICAgIGlmICghdGhpcy5pZ25vcmVFbnZfICYmIHByb2Nlc3MuZW52LlNFTEVOSVVNX0JST1dTRVIpIHtcbiAgICAgIHRoaXMubG9nXy5maW5lKGBTRUxFTklVTV9CUk9XU0VSPSR7cHJvY2Vzcy5lbnYuU0VMRU5JVU1fQlJPV1NFUn1gKVxuICAgICAgYnJvd3NlciA9IHByb2Nlc3MuZW52LlNFTEVOSVVNX0JST1dTRVIuc3BsaXQoLzovLCAzKVxuICAgICAgY2FwYWJpbGl0aWVzLnNldEJyb3dzZXJOYW1lKGJyb3dzZXJbMF0pXG5cbiAgICAgIGJyb3dzZXJbMV0gJiYgY2FwYWJpbGl0aWVzLnNldEJyb3dzZXJWZXJzaW9uKGJyb3dzZXJbMV0pXG4gICAgICBicm93c2VyWzJdICYmIGNhcGFiaWxpdGllcy5zZXRQbGF0Zm9ybShicm93c2VyWzJdKVxuICAgIH1cblxuICAgIGJyb3dzZXIgPSBjYXBhYmlsaXRpZXMuZ2V0KENhcGFiaWxpdHkuQlJPV1NFUl9OQU1FKVxuXG4gICAgaWYgKHR5cGVvZiBicm93c2VyICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgICBgVGFyZ2V0IGJyb3dzZXIgbXVzdCBiZSBhIHN0cmluZywgYnV0IGlzIDwke3R5cGVvZiBicm93c2VyfT47YCArXG4gICAgICAgICAgJyBkaWQgeW91IGZvcmdldCB0byBjYWxsIGZvckJyb3dzZXIoKT8nXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGJyb3dzZXIgPT09ICdpZScpIHtcbiAgICAgIGJyb3dzZXIgPSBCcm93c2VyLklOVEVSTkVUX0VYUExPUkVSXG4gICAgfVxuXG4gICAgLy8gQXBwbHkgYnJvd3NlciBzcGVjaWZpYyBvdmVycmlkZXMuXG4gICAgaWYgKGJyb3dzZXIgPT09IEJyb3dzZXIuQ0hST01FICYmIHRoaXMuY2hyb21lT3B0aW9uc18pIHtcbiAgICAgIGNhcGFiaWxpdGllcy5tZXJnZSh0aGlzLmNocm9tZU9wdGlvbnNfKVxuICAgIH0gZWxzZSBpZiAoYnJvd3NlciA9PT0gQnJvd3Nlci5GSVJFRk9YICYmIHRoaXMuZmlyZWZveE9wdGlvbnNfKSB7XG4gICAgICBjYXBhYmlsaXRpZXMubWVyZ2UodGhpcy5maXJlZm94T3B0aW9uc18pXG4gICAgfSBlbHNlIGlmIChicm93c2VyID09PSBCcm93c2VyLklOVEVSTkVUX0VYUExPUkVSICYmIHRoaXMuaWVPcHRpb25zXykge1xuICAgICAgY2FwYWJpbGl0aWVzLm1lcmdlKHRoaXMuaWVPcHRpb25zXylcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXIgPT09IEJyb3dzZXIuU0FGQVJJICYmIHRoaXMuc2FmYXJpT3B0aW9uc18pIHtcbiAgICAgIGNhcGFiaWxpdGllcy5tZXJnZSh0aGlzLnNhZmFyaU9wdGlvbnNfKVxuICAgIH0gZWxzZSBpZiAoYnJvd3NlciA9PT0gQnJvd3Nlci5FREdFICYmIHRoaXMuZWRnZU9wdGlvbnNfKSB7XG4gICAgICBjYXBhYmlsaXRpZXMubWVyZ2UodGhpcy5lZGdlT3B0aW9uc18pXG4gICAgfVxuXG4gICAgY2hlY2tPcHRpb25zKFxuICAgICAgY2FwYWJpbGl0aWVzLFxuICAgICAgJ2Nocm9tZU9wdGlvbnMnLFxuICAgICAgY2hyb21lLk9wdGlvbnMsXG4gICAgICAnc2V0Q2hyb21lT3B0aW9ucydcbiAgICApXG4gICAgY2hlY2tPcHRpb25zKFxuICAgICAgY2FwYWJpbGl0aWVzLFxuICAgICAgJ21vejpmaXJlZm94T3B0aW9ucycsXG4gICAgICBmaXJlZm94Lk9wdGlvbnMsXG4gICAgICAnc2V0RmlyZWZveE9wdGlvbnMnXG4gICAgKVxuICAgIGNoZWNrT3B0aW9ucyhcbiAgICAgIGNhcGFiaWxpdGllcyxcbiAgICAgICdzYWZhcmkub3B0aW9ucycsXG4gICAgICBzYWZhcmkuT3B0aW9ucyxcbiAgICAgICdzZXRTYWZhcmlPcHRpb25zJ1xuICAgIClcblxuICAgIC8vIENoZWNrIGZvciBhIHJlbW90ZSBicm93c2VyLlxuICAgIGxldCB1cmwgPSB0aGlzLnVybF9cbiAgICBpZiAoIXRoaXMuaWdub3JlRW52Xykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LlNFTEVOSVVNX1JFTU9URV9VUkwpIHtcbiAgICAgICAgdGhpcy5sb2dfLmZpbmUoYFNFTEVOSVVNX1JFTU9URV9VUkw9JHtwcm9jZXNzLmVudi5TRUxFTklVTV9SRU1PVEVfVVJMfWApXG4gICAgICAgIHVybCA9IHByb2Nlc3MuZW52LlNFTEVOSVVNX1JFTU9URV9VUkxcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuU0VMRU5JVU1fU0VSVkVSX0pBUikge1xuICAgICAgICB0aGlzLmxvZ18uZmluZShgU0VMRU5JVU1fU0VSVkVSX0pBUj0ke3Byb2Nlc3MuZW52LlNFTEVOSVVNX1NFUlZFUl9KQVJ9YClcbiAgICAgICAgdXJsID0gc3RhcnRTZWxlbml1bVNlcnZlcihwcm9jZXNzLmVudi5TRUxFTklVTV9TRVJWRVJfSkFSKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMubG9nXy5maW5lKCdDcmVhdGluZyBzZXNzaW9uIG9uIHJlbW90ZSBzZXJ2ZXInKVxuICAgICAgbGV0IGNsaWVudCA9IFByb21pc2UucmVzb2x2ZSh1cmwpLnRoZW4oXG4gICAgICAgICh1cmwpID0+IG5ldyBfaHR0cC5IdHRwQ2xpZW50KHVybCwgdGhpcy5hZ2VudF8sIHRoaXMucHJveHlfKVxuICAgICAgKVxuICAgICAgbGV0IGV4ZWN1dG9yID0gbmV3IF9odHRwLkV4ZWN1dG9yKGNsaWVudClcblxuICAgICAgaWYgKGJyb3dzZXIgPT09IEJyb3dzZXIuQ0hST01FKSB7XG4gICAgICAgIGNvbnN0IGRyaXZlciA9IGVuc3VyZUZpbGVEZXRlY3RvcnNBcmVFbmFibGVkKGNocm9tZS5Ecml2ZXIpXG4gICAgICAgIHJldHVybiBjcmVhdGVEcml2ZXIoZHJpdmVyLCBjYXBhYmlsaXRpZXMsIGV4ZWN1dG9yKVxuICAgICAgfVxuXG4gICAgICBpZiAoYnJvd3NlciA9PT0gQnJvd3Nlci5GSVJFRk9YKSB7XG4gICAgICAgIGNvbnN0IGRyaXZlciA9IGVuc3VyZUZpbGVEZXRlY3RvcnNBcmVFbmFibGVkKGZpcmVmb3guRHJpdmVyKVxuICAgICAgICByZXR1cm4gY3JlYXRlRHJpdmVyKGRyaXZlciwgY2FwYWJpbGl0aWVzLCBleGVjdXRvcilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVEcml2ZXIoV2ViRHJpdmVyLCBleGVjdXRvciwgY2FwYWJpbGl0aWVzKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBhIG5hdGl2ZSBicm93c2VyLlxuICAgIHN3aXRjaCAoYnJvd3Nlcikge1xuICAgICAgY2FzZSBCcm93c2VyLkNIUk9NRToge1xuICAgICAgICBsZXQgc2VydmljZSA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuY2hyb21lU2VydmljZV8pIHtcbiAgICAgICAgICBzZXJ2aWNlID0gdGhpcy5jaHJvbWVTZXJ2aWNlXy5idWlsZCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZURyaXZlcihjaHJvbWUuRHJpdmVyLCBjYXBhYmlsaXRpZXMsIHNlcnZpY2UpXG4gICAgICB9XG5cbiAgICAgIGNhc2UgQnJvd3Nlci5GSVJFRk9YOiB7XG4gICAgICAgIGxldCBzZXJ2aWNlID0gbnVsbFxuICAgICAgICBpZiAodGhpcy5maXJlZm94U2VydmljZV8pIHtcbiAgICAgICAgICBzZXJ2aWNlID0gdGhpcy5maXJlZm94U2VydmljZV8uYnVpbGQoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEcml2ZXIoZmlyZWZveC5Ecml2ZXIsIGNhcGFiaWxpdGllcywgc2VydmljZSlcbiAgICAgIH1cblxuICAgICAgY2FzZSBCcm93c2VyLklOVEVSTkVUX0VYUExPUkVSOiB7XG4gICAgICAgIGxldCBzZXJ2aWNlID0gbnVsbFxuICAgICAgICBpZiAodGhpcy5pZVNlcnZpY2VfKSB7XG4gICAgICAgICAgc2VydmljZSA9IHRoaXMuaWVTZXJ2aWNlXy5idWlsZCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZURyaXZlcihpZS5Ecml2ZXIsIGNhcGFiaWxpdGllcywgc2VydmljZSlcbiAgICAgIH1cblxuICAgICAgY2FzZSBCcm93c2VyLkVER0U6IHtcbiAgICAgICAgbGV0IHNlcnZpY2UgPSBudWxsXG4gICAgICAgIGlmICh0aGlzLmVkZ2VTZXJ2aWNlXykge1xuICAgICAgICAgIHNlcnZpY2UgPSB0aGlzLmVkZ2VTZXJ2aWNlXy5idWlsZCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZURyaXZlcihlZGdlLkRyaXZlciwgY2FwYWJpbGl0aWVzLCBzZXJ2aWNlKVxuICAgICAgfVxuXG4gICAgICBjYXNlIEJyb3dzZXIuU0FGQVJJOlxuICAgICAgICByZXR1cm4gY3JlYXRlRHJpdmVyKHNhZmFyaS5Ecml2ZXIsIGNhcGFiaWxpdGllcylcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdEbyBub3Qga25vdyBob3cgdG8gYnVpbGQgZHJpdmVyOiAnICtcbiAgICAgICAgICAgIGJyb3dzZXIgK1xuICAgICAgICAgICAgJzsgZGlkIHlvdSBmb3JnZXQgdG8gY2FsbCB1c2luZ1NlcnZlcih1cmwpPydcbiAgICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluIHRoZSAzLnggcmVsZWFzZXMsIHRoZSB2YXJpb3VzIGJyb3dzZXIgb3B0aW9uIGNsYXNzZXNcbiAqIChlLmcuIGZpcmVmb3guT3B0aW9ucykgaGFkIHRvIGJlIG1hbnVhbGx5IHNldCBhcyBhbiBvcHRpb24gdXNpbmcgdGhlXG4gKiBDYXBhYmlsdGllcyBjbGFzczpcbiAqXG4gKiAgICAgbGV0IGZmbyA9IG5ldyBmaXJlZm94Lk9wdGlvbnMoKTtcbiAqICAgICAvLyBDb25maWd1cmUgZmlyZWZveCBvcHRpb25zLi4uXG4gKlxuICogICAgIGxldCBjYXBzID0gbmV3IENhcGFiaWxpdGllcygpO1xuICogICAgIGNhcHMuc2V0KCdtb3o6ZmlyZWZveE9wdGlvbnMnLCBmZm8pO1xuICpcbiAqICAgICBsZXQgZHJpdmVyID0gbmV3IEJ1aWxkZXIoKVxuICogICAgICAgICAud2l0aENhcGFiaWxpdGllcyhjYXBzKVxuICogICAgICAgICAuYnVpbGQoKTtcbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmUgbm93IHN1YmNsYXNzZXMgb2YgQ2FwYWJpbGl0aWVzIGFuZCBjYW4gYmUgdXNlZCBkaXJlY3RseS4gQVxuICogZGlyZWN0IHRyYW5zbGF0aW9uIG9mIHRoZSBhYm92ZSBpczpcbiAqXG4gKiAgICAgbGV0IGZmbyA9IG5ldyBmaXJlZm94Lk9wdGlvbnMoKTtcbiAqICAgICAvLyBDb25maWd1cmUgZmlyZWZveCBvcHRpb25zLi4uXG4gKlxuICogICAgIGxldCBkcml2ZXIgPSBuZXcgQnVpbGRlcigpXG4gKiAgICAgICAgIC53aXRoQ2FwYWJpbGl0aWVzKGZmbylcbiAqICAgICAgICAgLmJ1aWxkKCk7XG4gKlxuICogWW91IGNhbiBhbHNvIHNldCB0aGUgb3B0aW9ucyBmb3IgdmFyaW91cyBicm93c2VycyBhdCBvbmNlIGFuZCBsZXQgdGhlIGJ1aWxkZXJcbiAqIGNob29zZSB0aGUgY29ycmVjdCBzZXQgYXQgcnVudGltZSAoc2VlIEJ1aWxkZXIgZG9jcyBhYm92ZSk6XG4gKlxuICogICAgIGxldCBmZm8gPSBuZXcgZmlyZWZveC5PcHRpb25zKCk7XG4gKiAgICAgLy8gQ29uZmlndXJlIC4uLlxuICpcbiAqICAgICBsZXQgY28gPSBuZXcgY2hyb21lLk9wdGlvbnMoKTtcbiAqICAgICAvLyBDb25maWd1cmUgLi4uXG4gKlxuICogICAgIGxldCBkcml2ZXIgPSBuZXcgQnVpbGRlcigpXG4gKiAgICAgICAgIC5zZXRDaHJvbWVPcHRpb25zKGNvKVxuICogICAgICAgICAuc2V0RmlyZWZveE9wdGlvbnMoZmZvKVxuICogICAgICAgICAuYnVpbGQoKTtcbiAqXG4gKiBAcGFyYW0geyFDYXBhYmlsaXRpZXN9IGNhcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OiBDYXBhYmlsaXRpZXMpfSBvcHRpb25UeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc2V0TWV0aG9kXG4gKiBAdGhyb3dzIHtlcnJvci5JbnZhbGlkQXJndW1lbnRFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tPcHRpb25zKGNhcHMsIGtleSwgb3B0aW9uVHlwZSwgc2V0TWV0aG9kKSB7XG4gIGxldCB2YWwgPSBjYXBzLmdldChrZXkpXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBvcHRpb25UeXBlKSB7XG4gICAgdGhyb3cgbmV3IGVycm9yLkludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgJ09wdGlvbnMgY2xhc3MgZXh0ZW5kcyBDYXBhYmlsaXRpZXMgYW5kIHNob3VsZCBub3QgYmUgc2V0IGFzIGtleSAnICtcbiAgICAgICAgYFwiJHtrZXl9XCI7IHNldCBicm93c2VyLXNwZWNpZmljIG9wdGlvbnMgd2l0aCBgICtcbiAgICAgICAgYEJ1aWxkZXIuJHtzZXRNZXRob2R9KCkuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGAgK1xuICAgICAgICAnZG9jdW1lbnRhdGlvbiBhdHRhY2hlZCB0byB0aGUgZnVuY3Rpb24gdGhhdCB0aHJldyB0aGlzIGVycm9yJ1xuICAgIClcbiAgfVxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbmV4cG9ydHMuQnJvd3NlciA9IGNhcGFiaWxpdGllcy5Ccm93c2VyXG5leHBvcnRzLkJ1aWxkZXIgPSBCdWlsZGVyXG5leHBvcnRzLkJ1dHRvbiA9IGlucHV0LkJ1dHRvblxuZXhwb3J0cy5CeSA9IGJ5LkJ5XG5leHBvcnRzLlJlbGF0aXZlQnkgPSBieS5SZWxhdGl2ZUJ5XG5leHBvcnRzLndpdGhUYWdOYW1lID0gYnkud2l0aFRhZ05hbWVcbmV4cG9ydHMubG9jYXRlV2l0aCA9IGJ5LmxvY2F0ZVdpdGhcbmV4cG9ydHMuQ2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzLkNhcGFiaWxpdGllc1xuZXhwb3J0cy5DYXBhYmlsaXR5ID0gY2FwYWJpbGl0aWVzLkNhcGFiaWxpdHlcbmV4cG9ydHMuQ29uZGl0aW9uID0gd2ViZHJpdmVyLkNvbmRpdGlvblxuZXhwb3J0cy5GaWxlRGV0ZWN0b3IgPSBpbnB1dC5GaWxlRGV0ZWN0b3JcbmV4cG9ydHMuS2V5ID0gaW5wdXQuS2V5XG5leHBvcnRzLk9yaWdpbiA9IGlucHV0Lk9yaWdpblxuZXhwb3J0cy5TZXNzaW9uID0gc2Vzc2lvbi5TZXNzaW9uXG5leHBvcnRzLlRoZW5hYmxlV2ViRHJpdmVyID0gVGhlbmFibGVXZWJEcml2ZXJcbmV4cG9ydHMuV2ViRHJpdmVyID0gd2ViZHJpdmVyLldlYkRyaXZlclxuZXhwb3J0cy5XZWJFbGVtZW50ID0gd2ViZHJpdmVyLldlYkVsZW1lbnRcbmV4cG9ydHMuV2ViRWxlbWVudENvbmRpdGlvbiA9IHdlYmRyaXZlci5XZWJFbGVtZW50Q29uZGl0aW9uXG5leHBvcnRzLldlYkVsZW1lbnRQcm9taXNlID0gd2ViZHJpdmVyLldlYkVsZW1lbnRQcm9taXNlXG5leHBvcnRzLmVycm9yID0gZXJyb3JcbmV4cG9ydHMubG9nZ2luZyA9IGxvZ2dpbmdcbmV4cG9ydHMucHJvbWlzZSA9IHByb21pc2VcbmV4cG9ydHMudW50aWwgPSB1bnRpbFxuZXhwb3J0cy5TZWxlY3QgPSBzZWxlY3QuU2VsZWN0XG5leHBvcnRzLkxvZ0luc3BlY3RvciA9IExvZ0luc3BlY3RvclxuZXhwb3J0cy5Ccm93c2luZ0NvbnRleHQgPSBCcm93c2luZ0NvbnRleHRcbmV4cG9ydHMuQnJvd3NpbmdDb25leHRJbnNwZWN0b3IgPSBCcm93c2luZ0NvbmV4dEluc3BlY3RvclxuZXhwb3J0cy5TY3JpcHRNYW5hZ2VyID0gU2NyaXB0TWFuYWdlclxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNoaWxkUHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIGFuIGV4ZWN1dGVkIGNvbW1hbmQuXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBPcHRpb25zIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogQ29tbWFuZCBsaW5lIGFyZ3VtZW50cyBmb3IgdGhlIGNoaWxkIHByb2Nlc3MsIGlmIGFueS5cbiAgICAgKiBAdHlwZSAoIUFycmF5PHN0cmluZz58dW5kZWZpbmVkKVxuICAgICAqL1xuICAgIHRoaXMuYXJnc1xuXG4gICAgLyoqXG4gICAgICogRW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciB0aGUgc3Bhd25lZCBwcm9jZXNzLiBJZiB1bnNwZWNpZmllZCwgdGhlXG4gICAgICogY2hpbGQgd2lsbCBpbmhlcml0IHRoaXMgcHJvY2VzcycgZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7KCFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgdGhpcy5lbnZcblxuICAgIC8qKlxuICAgICAqIElPIGNvbmlmZ3VyYXRpb24gZm9yIHRoZSBzcGF3bmVkIHNlcnZlciBjaGlsZCBwcm9jZXNzLiBJZiB1bnNwZWNpZmllZCxcbiAgICAgKiB0aGUgY2hpbGQgcHJvY2VzcycgSU8gb3V0cHV0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHsoc3RyaW5nfCFBcnJheTxzdHJpbmd8bnVtYmVyfCFzdHJlYW0uU3RyZWFtfG51bGx8dW5kZWZpbmVkPnxcbiAgICAgKiAgICAgICAgICAgdW5kZWZpbmVkKX1cbiAgICAgKiBAc2VlIDxodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjgueC9kb2NzL2FwaS9jaGlsZF9wcm9jZXNzLmh0bWwjY2hpbGRfcHJvY2Vzc19vcHRpb25zX3N0ZGlvPlxuICAgICAqL1xuICAgIHRoaXMuc3RkaW9cbiAgfVxufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIGNvbW1hbmQncyB0ZXJtaW5hdGlvbiBjb25kaXRpb25zLlxuICovXG5jbGFzcyBSZXN1bHQge1xuICAvKipcbiAgICogQHBhcmFtIHs/bnVtYmVyfSBjb2RlIFRoZSBleGl0IGNvZGUsIG9yIHtAY29kZSBudWxsfSBpZiB0aGUgY29tbWFuZCBkaWQgbm90XG4gICAqICAgICBleGl0IG5vcm1hbGx5LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHNpZ25hbCBUaGUgc2lnbmFsIHVzZWQgdG8ga2lsbCB0aGUgY29tbWFuZCwgb3JcbiAgICogICAgIHtAY29kZSBudWxsfS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIHNpZ25hbCkge1xuICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICB0aGlzLmNvZGUgPSBjb2RlXG5cbiAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgdGhpcy5zaWduYWwgPSBzaWduYWxcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBSZXN1bHQoY29kZT0ke3RoaXMuY29kZX0sIHNpZ25hbD0ke3RoaXMuc2lnbmFsfSlgXG4gIH1cbn1cblxuY29uc3QgQ09NTUFORF9SRVNVTFQgPVxuICAvKiogIVdlYWtNYXA8IUNvbW1hbmQsICFQcm9taXNlPCFSZXN1bHQ+PiAqLyBuZXcgV2Vha01hcCgpXG5jb25zdCBLSUxMX0hPT0sgPSAvKiogIVdlYWtNYXA8IUNvbW1hbmQsIGZ1bmN0aW9uKHN0cmluZyk+ICovIG5ldyBXZWFrTWFwKClcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29tbWFuZCBydW5uaW5nIGluIGEgc3ViLXByb2Nlc3MuXG4gKi9cbmNsYXNzIENvbW1hbmQge1xuICAvKipcbiAgICogQHBhcmFtIHshUHJvbWlzZTwhUmVzdWx0Pn0gcmVzdWx0IFRoZSBjb21tYW5kIHJlc3VsdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpfSBvbktpbGwgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB7QGxpbmsgI2tpbGwoKX1cbiAgICogICAgIGlzIGNhbGxlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc3VsdCwgb25LaWxsKSB7XG4gICAgQ09NTUFORF9SRVNVTFQuc2V0KHRoaXMsIHJlc3VsdClcbiAgICBLSUxMX0hPT0suc2V0KHRoaXMsIG9uS2lsbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTwhUmVzdWx0Pn0gQSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoaXNcbiAgICogICAgIGNvbW1hbmQuXG4gICAqL1xuICByZXN1bHQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IVByb21pc2U8IVJlc3VsdD59ICovIChDT01NQU5EX1JFU1VMVC5nZXQodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBzaWduYWwgdG8gdGhlIHVuZGVybHlpbmcgcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2lnbmFsIFRoZSBzaWduYWwgdG8gc2VuZDsgZGVmYXVsdHMgdG8gYFNJR1RFUk1gLlxuICAgKi9cbiAga2lsbChvcHRfc2lnbmFsKSB7XG4gICAgS0lMTF9IT09LLmdldCh0aGlzKShvcHRfc2lnbmFsIHx8ICdTSUdURVJNJylcbiAgfVxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbi8qKlxuICogU3Bhd25zIGEgY2hpbGQgcHJvY2Vzcy4gVGhlIHJldHVybmVkIHtAbGluayBDb21tYW5kfSBtYXkgYmUgdXNlZCB0byB3YWl0XG4gKiBmb3IgdGhlIHByb2Nlc3MgcmVzdWx0IG9yIHRvIHNlbmQgc2lnbmFscyB0byB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCBUaGUgZXhlY3V0YWJsZSB0byBzcGF3bi5cbiAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIFRoZSBjb21tYW5kIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHshQ29tbWFuZH0gVGhlIGxhdW5jaGVkIGNvbW1hbmQuXG4gKi9cbmZ1bmN0aW9uIGV4ZWMoY29tbWFuZCwgb3B0X29wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9XG5cbiAgbGV0IHByb2MgPSBjaGlsZFByb2Nlc3Muc3Bhd24oY29tbWFuZCwgb3B0aW9ucy5hcmdzIHx8IFtdLCB7XG4gICAgZW52OiBvcHRpb25zLmVudiB8fCBwcm9jZXNzLmVudixcbiAgICBzdGRpbzogb3B0aW9ucy5zdGRpbyB8fCAnaWdub3JlJyxcbiAgfSlcblxuICAvLyBUaGlzIHByb2Nlc3Mgc2hvdWxkIG5vdCB3YWl0IG9uIHRoZSBzcGF3bmVkIGNoaWxkLCBob3dldmVyLCB3ZSBkb1xuICAvLyB3YW50IHRvIGVuc3VyZSB0aGUgY2hpbGQgaXMga2lsbGVkIHdoZW4gdGhpcyBwcm9jZXNzIGV4aXRzLlxuICBwcm9jLnVucmVmKClcbiAgcHJvY2Vzcy5vbmNlKCdleGl0Jywgb25Qcm9jZXNzRXhpdClcblxuICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcHJvYy5vbmNlKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgcHJvYyA9IG51bGxcbiAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvblByb2Nlc3NFeGl0KVxuICAgICAgcmVzb2x2ZShuZXcgUmVzdWx0KGNvZGUsIHNpZ25hbCkpXG4gICAgfSlcblxuICAgIHByb2Mub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICByZWplY3QoZXJyKVxuICAgIH0pXG4gIH0pXG4gIHJldHVybiBuZXcgQ29tbWFuZChyZXN1bHQsIGtpbGxDb21tYW5kKVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc0V4aXQoKSB7XG4gICAga2lsbENvbW1hbmQoJ1NJR1RFUk0nKVxuICB9XG5cbiAgZnVuY3Rpb24ga2lsbENvbW1hbmQoc2lnbmFsKSB7XG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uUHJvY2Vzc0V4aXQpXG4gICAgaWYgKHByb2MpIHtcbiAgICAgIHByb2Mua2lsbChzaWduYWwpXG4gICAgICBwcm9jID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnRlZCB0byBpbXByb3ZlIGdlbmVyYXRlZCBBUEkgZG9jdW1lbnRhdGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbW1hbmQsXG4gIE9wdGlvbnMsXG4gIFJlc3VsdCxcbiAgZXhlYyxcbn1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHRtcCA9IHJlcXVpcmUoJ3RtcCcpXG5cbi8qKlxuICogQHBhcmFtIHshRnVuY3Rpb259IGZuIC5cbiAqIEByZXR1cm4geyFQcm9taXNlPFQ+fSAuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5mdW5jdGlvbiBjaGVja2VkQ2FsbChmbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmbigoZXJyLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChlKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSByZW1vdmVzIGEgZGlyZWN0b3J5IGFuZCBhbGwgb2YgaXRzIGNvbnRlbnRzLiBUaGlzIGlzIGVxdWl2YWxlbnRcbiAqIHRvIHtAY29kZSBybSAtcmZ9IG9uIGEgUE9TSVggc3lzdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpclBhdGggUGF0aCB0byB0aGUgZGlyZWN0b3J5IHRvIHJlbW92ZS5cbiAqIEByZXR1cm4geyFQcm9taXNlfSBBIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGhhc1xuICogICAgIGNvbXBsZXRlZC5cbiAqL1xuZnVuY3Rpb24gcm1EaXIoZGlyUGF0aCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xuICAgIGZzLnJtKGRpclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBtYXhSZXRyaWVzOiAyIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIGZ1bGZpbGwoKVxuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH1cbiAgICAgIGZ1bGZpbGwoKVxuICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogQ29waWVzIG9uZSBmaWxlIHRvIGFub3RoZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkc3QgVGhlIGRlc3RpbmF0aW9uIGZpbGUuXG4gKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgZm9yIHRoZSBjb3BpZWQgZmlsZSdzIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICBjb25zdCBycyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oc3JjKVxuICAgIHJzLm9uKCdlcnJvcicsIHJlamVjdClcblxuICAgIGNvbnN0IHdzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZHN0KVxuICAgIHdzLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICB3cy5vbignY2xvc2UnLCAoKSA9PiBmdWxmaWxsKGRzdCkpXG5cbiAgICBycy5waXBlKHdzKVxuICB9KVxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvcGllcyB0aGUgY29udGVudHMgb2Ygb25lIGRpcmVjdG9yeSB0byBhbm90aGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgc291cmNlIGRpcmVjdG9yeSB0byBjb3B5LlxuICogQHBhcmFtIHtzdHJpbmd9IGRzdCBUaGUgZGlyZWN0b3J5IHRvIGNvcHkgaW50by5cbiAqIEBwYXJhbSB7KFJlZ0V4cHxmdW5jdGlvbihzdHJpbmcpOiBib29sZWFuKT19IG9wdF9leGNsdWRlIEFuIGV4Y2x1c2lvbiBmaWx0ZXJcbiAqICAgICBhcyBlaXRoZXIgYSByZWdleCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIEFsbCBmaWxlcyBtYXRjaGluZyB0aGlzIGZpbHRlclxuICogICAgIHdpbGwgbm90IGJlIGNvcGllZC5cbiAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSBmb3IgdGhlIGRlc3RpbmF0aW9uXG4gKiAgICAgZGlyZWN0b3J5J3MgcGF0aCBvbmNlIGFsbCBmaWxlcyBoYXZlIGJlZW4gY29waWVkLlxuICovXG5mdW5jdGlvbiBjb3B5RGlyKHNyYywgZHN0LCBvcHRfZXhjbHVkZSkge1xuICBsZXQgcHJlZGljYXRlID0gb3B0X2V4Y2x1ZGVcbiAgaWYgKG9wdF9leGNsdWRlICYmIHR5cGVvZiBvcHRfZXhjbHVkZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gIW9wdF9leGNsdWRlLnRlc3QocClcbiAgICB9XG4gIH1cblxuICBpZiAoIWZzLmV4aXN0c1N5bmMoZHN0KSkge1xuICAgIGZzLm1rZGlyU3luYyhkc3QpXG4gIH1cblxuICBsZXQgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhzcmMpXG4gIGZpbGVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbihzcmMsIGZpbGUpXG4gIH0pXG5cbiAgaWYgKHByZWRpY2F0ZSkge1xuICAgIGZpbGVzID0gZmlsZXMuZmlsdGVyKC8qKiBAdHlwZSB7ZnVuY3Rpb24oc3RyaW5nKTogYm9vbGVhbn0gKi8gKHByZWRpY2F0ZSkpXG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gW11cbiAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgICBjb25zdCB0YXJnZXQgPSBwYXRoLmpvaW4oZHN0LCBwYXRoLmJhc2VuYW1lKGZpbGUpKVxuXG4gICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyh0YXJnZXQpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyh0YXJnZXQsIHN0YXRzLm1vZGUpXG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2goY29weURpcihmaWxlLCB0YXJnZXQsIHByZWRpY2F0ZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMucHVzaChjb3B5KGZpbGUsIHRhcmdldCkpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKCgpID0+IGRzdClcbn1cblxuLyoqXG4gKiBUZXN0cyBpZiBhIGZpbGUgcGF0aCBleGlzdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYVBhdGggVGhlIHBhdGggdG8gdGVzdC5cbiAqIEByZXR1cm4geyFQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgZm9yIHdoZXRoZXIgdGhlIGZpbGUgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBleGlzdHMoYVBhdGgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBhUGF0aFxuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmVqZWN0KFR5cGVFcnJvcihgZXhwZWN0ZWQgc3RyaW5nIHBhdGgsIGJ1dCBnb3QgJHt0eXBlfWApKVxuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKGZzLmV4aXN0c1N5bmMoYVBhdGgpKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBDYWxscyBgc3RhdCgyKWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gYVBhdGggVGhlIHBhdGggdG8gc3RhdC5cbiAqIEByZXR1cm4geyFQcm9taXNlPCFmcy5TdGF0cz59IEEgcHJvbWlzZSBmb3IgdGhlIGZpbGUgc3RhdHMuXG4gKi9cbmZ1bmN0aW9uIHN0YXQoYVBhdGgpIHtcbiAgcmV0dXJuIGNoZWNrZWRDYWxsKChjYWxsYmFjaykgPT4gZnMuc3RhdChhUGF0aCwgY2FsbGJhY2spKVxufVxuXG4vKipcbiAqIERlbGV0ZXMgYSBuYW1lIGZyb20gdGhlIGZpbGVzeXN0ZW0gYW5kIHBvc3NpYmx5IHRoZSBmaWxlIGl0IHJlZmVycyB0by4gSGFzXG4gKiBubyBlZmZlY3QgaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gYVBhdGggVGhlIHBhdGggdG8gcmVtb3ZlLlxuICogQHJldHVybiB7IVByb21pc2V9IEEgcHJvbWlzZSBmb3Igd2hlbiB0aGUgZmlsZSBoYXMgYmVlbiByZW1vdmVkLlxuICovXG5mdW5jdGlvbiB1bmxpbmsoYVBhdGgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGFQYXRoKVxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGZzLnVubGluayhhUGF0aCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICA7KGVyciAmJiByZWplY3QoZXJyKSkgfHwgZnVsZmlsbCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIGZvciB0aGUgcGF0aCB0byBhIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL3RtcFxuICovXG5mdW5jdGlvbiB0bXBEaXIoKSB7XG4gIHJldHVybiBjaGVja2VkQ2FsbCgoY2FsbGJhY2spID0+IHRtcC5kaXIoeyB1bnNhZmVDbGVhbnVwOiB0cnVlIH0sIGNhbGxiYWNrKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3twb3N0Zml4OiBzdHJpbmd9PX0gb3B0X29wdGlvbnMgVGVtcG9yYXJ5IGZpbGUgb3B0aW9ucy5cbiAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSBmb3IgdGhlIHBhdGggdG8gYSB0ZW1wb3JhcnkgZmlsZS5cbiAqIEBzZWUgaHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvdG1wXG4gKi9cbmZ1bmN0aW9uIHRtcEZpbGUob3B0X29wdGlvbnMpIHtcbiAgcmV0dXJuIGNoZWNrZWRDYWxsKChjYWxsYmFjaykgPT4ge1xuICAgIC8qKiAgY2hlY2sgZml4ZWQgaW4gdiA+IDAuMi4xIGlmXG4gICAgICogKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICogICAgIHJldHVybiBbe30sIG9wdGlvbnNdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB0bXAuZmlsZShvcHRfb3B0aW9ucywgY2FsbGJhY2spXG4gIH0pXG59XG5cbi8qKlxuICogU2VhcmNoZXMgdGhlIHtAY29kZSBQQVRIfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgdGhlIGdpdmVuIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSBUaGUgZmlsZSB0byBsb2NhdGUgb24gdGhlIFBBVEguXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfY2hlY2tDd2QgV2hldGhlciB0byBhbHdheXMgc3RhcnQgd2l0aCB0aGUgc2VhcmNoIHdpdGhcbiAqICAgICB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGV4cGxpY2l0bHlcbiAqICAgICBsaXN0ZWQgb24gdGhlIFBBVEguXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBQYXRoIHRvIHRoZSBsb2NhdGVkIGZpbGUsIG9yIHtAY29kZSBudWxsfSBpZiBpdCBjb3VsZFxuICogICAgIG5vdCBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmluZEluUGF0aChmaWxlLCBvcHRfY2hlY2tDd2QpIHtcbiAgY29uc3QgZGlycyA9IFtdXG4gIGlmIChvcHRfY2hlY2tDd2QpIHtcbiAgICBkaXJzLnB1c2gocHJvY2Vzcy5jd2QoKSlcbiAgfVxuICBkaXJzLnB1c2guYXBwbHkoZGlycywgcHJvY2Vzcy5lbnZbJ1BBVEgnXS5zcGxpdChwYXRoLmRlbGltaXRlcikpXG5cbiAgbGV0IGZvdW5kSW5EaXIgPSBkaXJzLmZpbmQoKGRpcikgPT4ge1xuICAgIGxldCB0bXAgPSBwYXRoLmpvaW4oZGlyLCBmaWxlKVxuICAgIHRyeSB7XG4gICAgICBsZXQgc3RhdHMgPSBmcy5zdGF0U3luYyh0bXApXG4gICAgICByZXR1cm4gc3RhdHMuaXNGaWxlKCkgJiYgIXN0YXRzLmlzRGlyZWN0b3J5KClcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBmb3VuZEluRGlyID8gcGF0aC5qb2luKGZvdW5kSW5EaXIsIGZpbGUpIDogbnVsbFxufVxuXG4vKipcbiAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gZmlsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYVBhdGggUGF0aCB0byB0aGUgZmlsZSB0byByZWFkLlxuICogQHJldHVybiB7IVByb21pc2U8IUJ1ZmZlcj59IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIGEgYnVmZmVyIG9mIHRoZVxuICogICAgIGZpbGUgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIHJlYWQoYVBhdGgpIHtcbiAgcmV0dXJuIGNoZWNrZWRDYWxsKChjYWxsYmFjaykgPT4gZnMucmVhZEZpbGUoYVBhdGgsIGNhbGxiYWNrKSlcbn1cblxuLyoqXG4gKiBXcml0ZXMgdG8gYSBmaWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhUGF0aCBQYXRoIHRvIHRoZSBmaWxlIHRvIHdyaXRlIHRvLlxuICogQHBhcmFtIHsoc3RyaW5nfCFCdWZmZXIpfSBkYXRhIFRoZSBkYXRhIHRvIHdyaXRlLlxuICogQHJldHVybiB7IVByb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBvcGVyYXRpb24gaGFzXG4gKiAgICAgY29tcGxldGVkLlxuICovXG5mdW5jdGlvbiB3cml0ZShhUGF0aCwgZGF0YSkge1xuICByZXR1cm4gY2hlY2tlZENhbGwoKGNhbGxiYWNrKSA9PiBmcy53cml0ZUZpbGUoYVBhdGgsIGRhdGEsIGNhbGxiYWNrKSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhUGF0aCBUaGUgZGlyZWN0b3J5IHBhdGguXG4gKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGUgcGF0aCBvZiB0aGVcbiAqICAgICBjcmVhdGVkIGRpcmVjdG9yeS5cbiAqL1xuZnVuY3Rpb24gbWtkaXIoYVBhdGgpIHtcbiAgcmV0dXJuIGNoZWNrZWRDYWxsKChjYWxsYmFjaykgPT4ge1xuICAgIGZzLm1rZGlyKGFQYXRoLCB1bmRlZmluZWQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFRVhJU1QnKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGFQYXRoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY3JlYXRlcyBhIGRpcmVjdG9yeSBhbmQgYW55IGFuY2VzdG9ycyB0aGF0IGRvIG5vdCB5ZXQgZXhpc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpciBUaGUgZGlyZWN0b3J5IHBhdGggdG8gY3JlYXRlLlxuICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdpdGggdGhlIHBhdGggb2YgdGhlXG4gKiAgICAgY3JlYXRlZCBkaXJlY3RvcnkuXG4gKi9cbmZ1bmN0aW9uIG1rZGlycChkaXIpIHtcbiAgcmV0dXJuIGNoZWNrZWRDYWxsKChjYWxsYmFjaykgPT4ge1xuICAgIGZzLm1rZGlyKGRpciwgdW5kZWZpbmVkLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkaXIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ0VFWElTVCc6XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGlyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICAgIHJldHVybiBta2RpcnAocGF0aC5kaXJuYW1lKGRpcikpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBta2RpcnAoZGlyKSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAoKSA9PiBjYWxsYmFjayhudWxsLCBkaXIpLFxuICAgICAgICAgICAgICAoZXJyKSA9PiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICApXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgd2Fsa3MgYSBkaXJlY3RvcnksIHJldHVybmluZyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aFxuICogYSBsaXN0IG9mIGFsbCBmaWxlcy9kaXJlY3RvcmllcyBzZWVuLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByb290UGF0aCB0aGUgZGlyZWN0b3J5IHRvIHdhbGsuXG4gKiBAcmV0dXJuIHshUHJvbWlzZTwhQXJyYXk8e3BhdGg6IHN0cmluZywgZGlyOiBib29sZWFufT4+fSBhIHByb21pc2UgdGhhdCB3aWxsXG4gKiAgICAgcmVzb2x2ZSB3aXRoIGEgbGlzdCBvZiBlbnRyaWVzIHNlZW4uIEZvciBlYWNoIGVudHJ5LCB0aGUgcmVjb3JkZWQgcGF0aFxuICogICAgIHdpbGwgYmUgcmVsYXRpdmUgdG8gYHJvb3RQYXRoYC5cbiAqL1xuZnVuY3Rpb24gd2Fsa0Rpcihyb290UGF0aCkge1xuICBjb25zdCBzZWVuID0gW11cbiAgcmV0dXJuIChmdW5jdGlvbiB3YWxrKGRpcikge1xuICAgIHJldHVybiBjaGVja2VkQ2FsbCgoY2FsbGJhY2spID0+IGZzLnJlYWRkaXIoZGlyLCBjYWxsYmFjaykpLnRoZW4oKGZpbGVzKSA9PlxuICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgIGZpbGVzLm1hcCgoZmlsZSkgPT4ge1xuICAgICAgICAgIGZpbGUgPSBwYXRoLmpvaW4oZGlyLCBmaWxlKVxuICAgICAgICAgIHJldHVybiBjaGVja2VkQ2FsbCgoY2IpID0+IGZzLnN0YXQoZmlsZSwgY2IpKS50aGVuKChzdGF0cykgPT4ge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aC5yZWxhdGl2ZShyb290UGF0aCwgZmlsZSksXG4gICAgICAgICAgICAgIGRpcjogc3RhdHMuaXNEaXJlY3RvcnkoKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gc3RhdHMuaXNEaXJlY3RvcnkoKSAmJiB3YWxrKGZpbGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4gIH0pKHJvb3RQYXRoKS50aGVuKCgpID0+IHNlZW4pXG59XG5cbi8vIFBVQkxJQyBBUElcbm1vZHVsZS5leHBvcnRzID0ge1xuICB3YWxrRGlyLFxuICBybURpcixcbiAgbWtkaXJwLFxuICBta2RpcixcbiAgd3JpdGUsXG4gIHJlYWQsXG4gIGZpbmRJblBhdGgsXG4gIHRtcEZpbGUsXG4gIHRtcERpcixcbiAgdW5saW5rLFxuICBjb3B5LFxuICBjb3B5RGlyLFxuICBleGlzdHMsXG4gIHN0YXQsXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QganN6aXAgPSByZXF1aXJlKCdqc3ppcCcpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IGlvID0gcmVxdWlyZSgnLi9pbmRleCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9saWIvZXJyb3InKVxuXG4vKipcbiAqIE1hbmFnZXMgYSB6aXAgYXJjaGl2ZS5cbiAqL1xuY2xhc3MgWmlwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCAqL1xuICAgIHRoaXMuel8gPSBuZXcganN6aXAoKVxuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IVNldDwhUHJvbWlzZTw/Pj59ICovXG4gICAgdGhpcy5wZW5kaW5nQWRkc18gPSBuZXcgU2V0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZmlsZSB0byB0aGlzIHppcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoIHBhdGggdG8gdGhlIGZpbGUgdG8gYWRkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHppcFBhdGggcGF0aCB0byB0aGUgZmlsZSBpbiB0aGUgemlwIGFyY2hpdmUsIGRlZmF1bHRzXG4gICAqICAgICB0byB0aGUgYmFzZW5hbWUgb2YgYGZpbGVQYXRoYC5cbiAgICogQHJldHVybiB7IVByb21pc2U8Pz59IGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGFkZGVkLlxuICAgKi9cbiAgYWRkRmlsZShmaWxlUGF0aCwgemlwUGF0aCA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpKSB7XG4gICAgbGV0IGFkZCA9IGlvXG4gICAgICAucmVhZChmaWxlUGF0aClcbiAgICAgIC50aGVuKChidWZmZXIpID0+XG4gICAgICAgIHRoaXMuel8uZmlsZShcbiAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi8gKHppcFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpKSxcbiAgICAgICAgICBidWZmZXJcbiAgICAgICAgKVxuICAgICAgKVxuICAgIHRoaXMucGVuZGluZ0FkZHNfLmFkZChhZGQpXG4gICAgcmV0dXJuIGFkZC50aGVuKFxuICAgICAgKCkgPT4gdGhpcy5wZW5kaW5nQWRkc18uZGVsZXRlKGFkZCksXG4gICAgICAoZSkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdBZGRzXy5kZWxldGUoYWRkKVxuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGFkZHMgYSBkaXJlY3RvcnkgYW5kIGFsbCBvZiBpdHMgY29udGVudHMgdG8gdGhpcyBhcmNoaXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyUGF0aCBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgdG8gYWRkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHppcFBhdGggcGF0aCB0byB0aGUgZm9sZGVyIGluIHRoZSBhcmNoaXZlIHRvIGFkZCB0aGVcbiAgICogICAgIGRpcmVjdG9yeSBjb250ZW50cyB0by4gRGVmYXVsdHMgdG8gdGhlIHJvb3QgZm9sZGVyLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTw/Pn0gcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlblxuICAgKiB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgYWRkRGlyKGRpclBhdGgsIHppcFBhdGggPSAnJykge1xuICAgIHJldHVybiBpby53YWxrRGlyKGRpclBhdGgpLnRoZW4oKGVudHJpZXMpID0+IHtcbiAgICAgIGxldCBhcmNoaXZlID0gdGhpcy56X1xuICAgICAgaWYgKHppcFBhdGgpIHtcbiAgICAgICAgYXJjaGl2ZSA9IGFyY2hpdmUuZm9sZGVyKHppcFBhdGgpXG4gICAgICB9XG5cbiAgICAgIGxldCBmaWxlcyA9IFtdXG4gICAgICBlbnRyaWVzLmZvckVhY2goKHNwZWMpID0+IHtcbiAgICAgICAgaWYgKHNwZWMuZGlyKSB7XG4gICAgICAgICAgYXJjaGl2ZS5mb2xkZXIoc3BlYy5wYXRoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGVzLnB1c2goXG4gICAgICAgICAgICB0aGlzLmFkZEZpbGUoXG4gICAgICAgICAgICAgIHBhdGguam9pbihkaXJQYXRoLCBzcGVjLnBhdGgpLFxuICAgICAgICAgICAgICBwYXRoLmpvaW4oemlwUGF0aCwgc3BlYy5wYXRoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZpbGVzKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggRmlsZSBwYXRoIHRvIHRlc3QgZm9yIHdpdGhpbiB0aGUgYXJjaGl2ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHppcCBhcmNoaXZlIGNvbnRhaW5zIGFuIGVudHJ5IHdpdGggdGhlIGdpdmVuXG4gICAqICAgICBwYXRoLlxuICAgKi9cbiAgaGFzKHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy56Xy5maWxlKHBhdGgpICE9PSBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgaW4gdGhpcyB6aXAgYXJjaGl2ZSB3aXRoIHRoZSBnaXZlbiBgcGF0aGAuXG4gICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiB7QGxpbmsgSW52YWxpZEFyZ3VtZW50RXJyb3J9XG4gICAqIGlmIGVpdGhlciBgcGF0aGAgZG9lcyBub3QgZXhpc3Qgd2l0aGluIHRoZSBhcmNoaXZlLCBvciBpZiBgcGF0aGAgcmVmZXJzXG4gICAqIHRvIGEgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB0aGUgZmlsZSB3aG9zZSBjb250ZW50cyB0byByZXR1cm4uXG4gICAqIEByZXR1cm4geyFQcm9taXNlPCFCdWZmZXI+fSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGZpbGUnc1xuICAgKiAgICAgY29udGVudHMgYXMgYSBidWZmZXIuXG4gICAqL1xuICBnZXRGaWxlKHBhdGgpIHtcbiAgICBsZXQgZmlsZSA9IHRoaXMuel8uZmlsZShwYXRoKVxuICAgIGlmICghZmlsZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYE5vIHN1Y2ggZmlsZSBpbiB6aXAgYXJjaGl2ZTogJHtwYXRofWApXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGZpbGUuZGlyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgVGhlIHJlcXVlc3RlZCBmaWxlIGlzIGEgZGlyZWN0b3J5OiAke3BhdGh9YClcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUuYXN5bmMoJ25vZGVidWZmZXInKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wcmVzc2VkIGRhdGEgZm9yIHRoaXMgYXJjaGl2ZSBpbiBhIGJ1ZmZlci4gX1RoaXMgbWV0aG9kIHdpbGxcbiAgICogbm90IHdhaXQgZm9yIGFueSBvdXRzdGFuZGluZyB7QGxpbmsgI2FkZEZpbGUgYWRkfVxuICAgKiB7QGxpbmsgI2FkZERpciBvcGVyYXRpb25zfSBiZWZvcmUgZW5jb2RpbmcgdGhlIGFyY2hpdmUuX1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb24gVGhlIGRlc2lyZWQgY29tcHJlc3Npb24uXG4gICAqICAgICBNdXN0IGJlIGBTVE9SRWAgKHRoZSBkZWZhdWx0KSBvciBgREVGTEFURWAuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPCFCdWZmZXI+fSBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGlzIGFyY2hpdmVcbiAgICogICAgIGFzIGEgYnVmZmVyLlxuICAgKi9cbiAgdG9CdWZmZXIoY29tcHJlc3Npb24gPSAnU1RPUkUnKSB7XG4gICAgaWYgKGNvbXByZXNzaW9uICE9PSAnU1RPUkUnICYmIGNvbXByZXNzaW9uICE9PSAnREVGTEFURScpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICAgIGBjb21wcmVzc2lvbiBtdXN0IGJlIG9uZSBvZiB7U1RPUkUsIERFRkxBVEV9LCBnb3QgJHtjb21wcmVzc2lvbn1gXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgIHRoaXMuel8uZ2VuZXJhdGVBc3luYyh7IGNvbXByZXNzaW9uLCB0eXBlOiAnbm9kZWJ1ZmZlcicgfSlcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBvcGVucyBhIHppcCBhcmNoaXZlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRvIHRoZSB6aXAgYXJjaGl2ZSB0byBsb2FkLlxuICogQHJldHVybiB7IVByb21pc2U8IVppcD59IGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBvcGVuZWRcbiAqICAgICBhcmNoaXZlLlxuICovXG5mdW5jdGlvbiBsb2FkKHBhdGgpIHtcbiAgcmV0dXJuIGlvLnJlYWQocGF0aCkudGhlbigoZGF0YSkgPT4ge1xuICAgIGxldCB6aXAgPSBuZXcgWmlwKClcbiAgICByZXR1cm4gemlwLnpfLmxvYWRBc3luYyhkYXRhKS50aGVuKCgpID0+IHppcClcbiAgfSlcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSB1bnppcHMgYW4gYXJjaGl2ZSBmaWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgcGF0aCB0byB0aGUgc291cmNlIGZpbGUgdG8gdW56aXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZHN0IHBhdGggdG8gdGhlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeS5cbiAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIGBkc3RgIG9uY2UgdGhlXG4gKiAgICAgYXJjaGl2ZSBoYXMgYmVlbiB1bnppcHBlZC5cbiAqL1xuZnVuY3Rpb24gdW56aXAoc3JjLCBkc3QpIHtcbiAgcmV0dXJuIGxvYWQoc3JjKS50aGVuKCh6aXApID0+IHtcbiAgICBjb25zdCBwcm9taXNlZERpcnMgPSBuZXcgTWFwKClcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdXG5cbiAgICB6aXAuel8uZm9yRWFjaCgocmVsUGF0aCwgZmlsZSkgPT4ge1xuICAgICAgbGV0IHBcbiAgICAgIGlmIChmaWxlLmRpcikge1xuICAgICAgICBwID0gY3JlYXRlRGlyKHJlbFBhdGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGlybmFtZSA9IHBhdGguZGlybmFtZShyZWxQYXRoKVxuICAgICAgICBpZiAoZGlybmFtZSA9PT0gJy4nKSB7XG4gICAgICAgICAgcCA9IHdyaXRlRmlsZShyZWxQYXRoLCBmaWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAgPSBjcmVhdGVEaXIoZGlybmFtZSkudGhlbigoKSA9PiB3cml0ZUZpbGUocmVsUGF0aCwgZmlsZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb21pc2VzLnB1c2gocClcbiAgICB9KVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IGRzdClcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURpcihkaXIpIHtcbiAgICAgIGxldCBwID0gcHJvbWlzZWREaXJzLmdldChkaXIpXG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgcCA9IGlvLm1rZGlycChwYXRoLmpvaW4oZHN0LCBkaXIpKVxuICAgICAgICBwcm9taXNlZERpcnMuc2V0KGRpciwgcClcbiAgICAgIH1cbiAgICAgIHJldHVybiBwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JpdGVGaWxlKHJlbFBhdGgsIGZpbGUpIHtcbiAgICAgIHJldHVybiBmaWxlXG4gICAgICAgIC5hc3luYygnbm9kZWJ1ZmZlcicpXG4gICAgICAgIC50aGVuKChidWZmZXIpID0+IGlvLndyaXRlKHBhdGguam9pbihkc3QsIHJlbFBhdGgpLCBidWZmZXIpKVxuICAgIH1cbiAgfSlcbn1cblxuLy8gUFVCTElDIEFQSVxubW9kdWxlLmV4cG9ydHMgPSB7IFppcCwgbG9hZCwgdW56aXAgfVxuIiwiLy8gR0VORVJBVEVEIENPREUgLSBETyBOT1QgRURJVFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe3JldHVybiAoZnVuY3Rpb24oKXt2YXIgYWE9dGhpc3x8c2VsZjtmdW5jdGlvbiBiYShhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYX1mdW5jdGlvbiBjYShhLGIpe2E9YS5zcGxpdChcIi5cIik7dmFyIGM9YWE7YVswXWluIGN8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjLmV4ZWNTY3JpcHR8fGMuZXhlY1NjcmlwdChcInZhciBcIithWzBdKTtmb3IodmFyIGQ7YS5sZW5ndGgmJihkPWEuc2hpZnQoKSk7KWEubGVuZ3RofHx2b2lkIDA9PT1iP2NbZF0mJmNbZF0hPT1PYmplY3QucHJvdG90eXBlW2RdP2M9Y1tkXTpjPWNbZF09e306Y1tkXT1ifVxuZnVuY3Rpb24gZGEoYSl7dmFyIGI9dHlwZW9mIGE7aWYoXCJvYmplY3RcIj09YilpZihhKXtpZihhIGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuXCJhcnJheVwiO2lmKGEgaW5zdGFuY2VvZiBPYmplY3QpcmV0dXJuIGI7dmFyIGM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBXaW5kb3ddXCI9PWMpcmV0dXJuXCJvYmplY3RcIjtpZihcIltvYmplY3QgQXJyYXldXCI9PWN8fFwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuc3BsaWNlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpcmV0dXJuXCJhcnJheVwiO2lmKFwiW29iamVjdCBGdW5jdGlvbl1cIj09Y3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuY2FsbCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSlyZXR1cm5cImZ1bmN0aW9uXCJ9ZWxzZSByZXR1cm5cIm51bGxcIjtcbmVsc2UgaWYoXCJmdW5jdGlvblwiPT1iJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgYS5jYWxsKXJldHVyblwib2JqZWN0XCI7cmV0dXJuIGJ9ZnVuY3Rpb24gZWEoYSl7cmV0dXJuXCJmdW5jdGlvblwiPT1kYShhKX1mdW5jdGlvbiBoYShhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm5cIm9iamVjdFwiPT1iJiZudWxsIT1hfHxcImZ1bmN0aW9uXCI9PWJ9ZnVuY3Rpb24gaWEoYSxiLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9XG5mdW5jdGlvbiBqYShhLGIsYyl7aWYoIWEpdGhyb3cgRXJyb3IoKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0FycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGUsZCk7cmV0dXJuIGEuYXBwbHkoYixlKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBrYShhLGIsYyl7RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQmJi0xIT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKT9rYT1pYTprYT1qYTtyZXR1cm4ga2EuYXBwbHkobnVsbCxhcmd1bWVudHMpfVxuZnVuY3Rpb24gbGEoYSxiKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGQ9Yy5zbGljZSgpO2QucHVzaC5hcHBseShkLGFyZ3VtZW50cyk7cmV0dXJuIGEuYXBwbHkodGhpcyxkKX19ZnVuY3Rpb24gayhhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YX07LypcblxuIFRoZSBNSVQgTGljZW5zZVxuXG4gQ29weXJpZ2h0IChjKSAyMDA3IEN5Ym96dSBMYWJzLCBJbmMuXG4gQ29weXJpZ2h0IChjKSAyMDEyIEdvb2dsZSBJbmMuXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5mdW5jdGlvbiBtYShhLGIsYyl7dGhpcy5hPWE7dGhpcy5iPWJ8fDE7dGhpcy5mPWN8fDF9O3ZhciBuYTt2YXIgb2E9QXJyYXkucHJvdG90eXBlLmluZGV4T2Y/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhLGIsdm9pZCAwKX06ZnVuY3Rpb24oYSxiKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuXCJzdHJpbmdcIiE9PXR5cGVvZiBifHwxIT1iLmxlbmd0aD8tMTphLmluZGV4T2YoYiwwKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihjIGluIGEmJmFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSxsPUFycmF5LnByb3RvdHlwZS5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXtBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVwic3RyaW5nXCI9PT10eXBlb2YgYT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspZiBpbiBlJiZiLmNhbGwoYyxlW2ZdLGYsYSl9LHBhPUFycmF5LnByb3RvdHlwZS5maWx0ZXI/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGEsXG5iLHZvaWQgMCl9OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9W10sZT0wLGY9XCJzdHJpbmdcIj09PXR5cGVvZiBhP2Euc3BsaXQoXCJcIik6YSxnPTA7ZzxjO2crKylpZihnIGluIGYpe3ZhciBoPWZbZ107Yi5jYWxsKHZvaWQgMCxoLGcsYSkmJihkW2UrK109aCl9cmV0dXJuIGR9LHFhPUFycmF5LnByb3RvdHlwZS5tYXA/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGEsYix2b2lkIDApfTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1hLmxlbmd0aCxkPUFycmF5KGMpLGU9XCJzdHJpbmdcIj09PXR5cGVvZiBhP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxjO2YrKylmIGluIGUmJihkW2ZdPWIuY2FsbCh2b2lkIDAsZVtmXSxmLGEpKTtyZXR1cm4gZH0scmE9QXJyYXkucHJvdG90eXBlLnJlZHVjZT9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1jO2woYSxcbmZ1bmN0aW9uKGUsZil7ZD1iLmNhbGwodm9pZCAwLGQsZSxmLGEpfSk7cmV0dXJuIGR9LHNhPUFycmF5LnByb3RvdHlwZS5zb21lP2Z1bmN0aW9uKGEsYil7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwoYSxiLHZvaWQgMCl9OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9XCJzdHJpbmdcIj09PXR5cGVvZiBhP2Euc3BsaXQoXCJcIik6YSxlPTA7ZTxjO2UrKylpZihlIGluIGQmJmIuY2FsbCh2b2lkIDAsZFtlXSxlLGEpKXJldHVybiEwO3JldHVybiExfSx0YT1BcnJheS5wcm90b3R5cGUuZXZlcnk/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBBcnJheS5wcm90b3R5cGUuZXZlcnkuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1cInN0cmluZ1wiPT09dHlwZW9mIGE/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmIWIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4hMTtyZXR1cm4hMH07XG5mdW5jdGlvbiB1YShhLGIpe2E6e2Zvcih2YXIgYz1hLmxlbmd0aCxkPVwic3RyaW5nXCI9PT10eXBlb2YgYT9hLnNwbGl0KFwiXCIpOmEsZT0wO2U8YztlKyspaWYoZSBpbiBkJiZiLmNhbGwodm9pZCAwLGRbZV0sZSxhKSl7Yj1lO2JyZWFrIGF9Yj0tMX1yZXR1cm4gMD5iP251bGw6XCJzdHJpbmdcIj09PXR5cGVvZiBhP2EuY2hhckF0KGIpOmFbYl19ZnVuY3Rpb24gdmEoYSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sYXJndW1lbnRzKX1mdW5jdGlvbiB3YShhLGIsYyl7cmV0dXJuIDI+PWFyZ3VtZW50cy5sZW5ndGg/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSxiKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLGIsYyl9ZnVuY3Rpb24geGEoYSxiKXthLnNvcnQoYnx8eWEpfWZ1bmN0aW9uIHlhKGEsYil7cmV0dXJuIGE+Yj8xOmE8Yj8tMTowfTtmdW5jdGlvbiB6YShhKXt2YXIgYj1hLmxlbmd0aC0xO3JldHVybiAwPD1iJiZhLmluZGV4T2YoXCIgXCIsYik9PWJ9dmFyIEFhPVN0cmluZy5wcm90b3R5cGUudHJpbT9mdW5jdGlvbihhKXtyZXR1cm4gYS50cmltKCl9OmZ1bmN0aW9uKGEpe3JldHVybi9eW1xcc1xceGEwXSooW1xcc1xcU10qPylbXFxzXFx4YTBdKiQvLmV4ZWMoYSlbMV19O1xuZnVuY3Rpb24gQmEoYSxiKXt2YXIgYz0wO2E9QWEoU3RyaW5nKGEpKS5zcGxpdChcIi5cIik7Yj1BYShTdHJpbmcoYikpLnNwbGl0KFwiLlwiKTtmb3IodmFyIGQ9TWF0aC5tYXgoYS5sZW5ndGgsYi5sZW5ndGgpLGU9MDswPT1jJiZlPGQ7ZSsrKXt2YXIgZj1hW2VdfHxcIlwiLGc9YltlXXx8XCJcIjtkb3tmPS8oXFxkKikoXFxEKikoLiopLy5leGVjKGYpfHxbXCJcIixcIlwiLFwiXCIsXCJcIl07Zz0vKFxcZCopKFxcRCopKC4qKS8uZXhlYyhnKXx8W1wiXCIsXCJcIixcIlwiLFwiXCJdO2lmKDA9PWZbMF0ubGVuZ3RoJiYwPT1nWzBdLmxlbmd0aClicmVhaztjPUNhKDA9PWZbMV0ubGVuZ3RoPzA6cGFyc2VJbnQoZlsxXSwxMCksMD09Z1sxXS5sZW5ndGg/MDpwYXJzZUludChnWzFdLDEwKSl8fENhKDA9PWZbMl0ubGVuZ3RoLDA9PWdbMl0ubGVuZ3RoKXx8Q2EoZlsyXSxnWzJdKTtmPWZbM107Zz1nWzNdfXdoaWxlKDA9PWMpfXJldHVybiBjfWZ1bmN0aW9uIENhKGEsYil7cmV0dXJuIGE8Yj8tMTphPmI/MTowfTt2YXIgcTthOnt2YXIgRGE9YWEubmF2aWdhdG9yO2lmKERhKXt2YXIgRWE9RGEudXNlckFnZW50O2lmKEVhKXtxPUVhO2JyZWFrIGF9fXE9XCJcIn1mdW5jdGlvbiByKGEpe3JldHVybi0xIT1xLmluZGV4T2YoYSl9O2Z1bmN0aW9uIEZhKCl7cmV0dXJuIHIoXCJGaXJlZm94XCIpfHxyKFwiRnhpT1NcIil9ZnVuY3Rpb24gR2EoKXtyZXR1cm4ocihcIkNocm9tZVwiKXx8cihcIkNyaU9TXCIpKSYmIXIoXCJFZGdlXCIpfTtmdW5jdGlvbiBIYShhKXtyZXR1cm4gU3RyaW5nKGEpLnJlcGxhY2UoL1xcLShbYS16XSkvZyxmdW5jdGlvbihiLGMpe3JldHVybiBjLnRvVXBwZXJDYXNlKCl9KX07ZnVuY3Rpb24gSWEoKXtyZXR1cm4gcihcImlQaG9uZVwiKSYmIXIoXCJpUG9kXCIpJiYhcihcImlQYWRcIil9O2Z1bmN0aW9uIEphKGEsYil7dmFyIGM9S2E7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLGEpP2NbYV06Y1thXT1iKGEpfTt2YXIgTGE9cihcIk9wZXJhXCIpLHQ9cihcIlRyaWRlbnRcIil8fHIoXCJNU0lFXCIpLE1hPXIoXCJFZGdlXCIpLE5hPXIoXCJHZWNrb1wiKSYmISgtMSE9cS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ3ZWJraXRcIikmJiFyKFwiRWRnZVwiKSkmJiEocihcIlRyaWRlbnRcIil8fHIoXCJNU0lFXCIpKSYmIXIoXCJFZGdlXCIpLE9hPS0xIT1xLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKSYmIXIoXCJFZGdlXCIpO2Z1bmN0aW9uIFBhKCl7dmFyIGE9YWEuZG9jdW1lbnQ7cmV0dXJuIGE/YS5kb2N1bWVudE1vZGU6dm9pZCAwfXZhciBRYTtcbmE6e3ZhciBSYT1cIlwiLFNhPWZ1bmN0aW9uKCl7dmFyIGE9cTtpZihOYSlyZXR1cm4vcnY6KFteXFwpO10rKShcXCl8OykvLmV4ZWMoYSk7aWYoTWEpcmV0dXJuL0VkZ2VcXC8oW1xcZFxcLl0rKS8uZXhlYyhhKTtpZih0KXJldHVybi9cXGIoPzpNU0lFfHJ2KVs6IF0oW15cXCk7XSspKFxcKXw7KS8uZXhlYyhhKTtpZihPYSlyZXR1cm4vV2ViS2l0XFwvKFxcUyspLy5leGVjKGEpO2lmKExhKXJldHVybi8oPzpWZXJzaW9uKVsgXFwvXT8oXFxTKykvLmV4ZWMoYSl9KCk7U2EmJihSYT1TYT9TYVsxXTpcIlwiKTtpZih0KXt2YXIgVGE9UGEoKTtpZihudWxsIT1UYSYmVGE+cGFyc2VGbG9hdChSYSkpe1FhPVN0cmluZyhUYSk7YnJlYWsgYX19UWE9UmF9dmFyIEthPXt9O2Z1bmN0aW9uIFVhKGEpe3JldHVybiBKYShhLGZ1bmN0aW9uKCl7cmV0dXJuIDA8PUJhKFFhLGEpfSl9dmFyIHc7dz1hYS5kb2N1bWVudCYmdD9QYSgpOnZvaWQgMDt2YXIgeD10JiYhKDk8PU51bWJlcih3KSksVmE9dCYmISg4PD1OdW1iZXIodykpO2Z1bmN0aW9uIFdhKGEsYixjLGQpe3RoaXMuYT1hO3RoaXMubm9kZU5hbWU9Yzt0aGlzLm5vZGVWYWx1ZT1kO3RoaXMubm9kZVR5cGU9Mjt0aGlzLnBhcmVudE5vZGU9dGhpcy5vd25lckVsZW1lbnQ9Yn1mdW5jdGlvbiBYYShhLGIpe3ZhciBjPVZhJiZcImhyZWZcIj09Yi5ub2RlTmFtZT9hLmdldEF0dHJpYnV0ZShiLm5vZGVOYW1lLDIpOmIubm9kZVZhbHVlO3JldHVybiBuZXcgV2EoYixhLGIubm9kZU5hbWUsYyl9O2Z1bmN0aW9uIFlhKGEpe3RoaXMuYj1hO3RoaXMuYT0wfWZ1bmN0aW9uIFphKGEpe2E9YS5tYXRjaCgkYSk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspYWIudGVzdChhW2JdKSYmYS5zcGxpY2UoYiwxKTtyZXR1cm4gbmV3IFlhKGEpfXZhciAkYT0vXFwkPyg/Oig/IVswLTktXFwuXSkoPzpcXCp8W1xcdy1cXC5dKyk6KT8oPyFbMC05LVxcLl0pKD86XFwqfFtcXHctXFwuXSspfFxcL1xcL3xcXC5cXC58Ojp8XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrfFwiW15cIl0qXCJ8J1teJ10qJ3xbITw+XT18XFxzK3wuL2csYWI9L15cXHMvO2Z1bmN0aW9uIHkoYSxiKXtyZXR1cm4gYS5iW2EuYSsoYnx8MCldfWZ1bmN0aW9uIHooYSl7cmV0dXJuIGEuYlthLmErK119ZnVuY3Rpb24gYmIoYSl7cmV0dXJuIGEuYi5sZW5ndGg8PWEuYX07ZnVuY3Rpb24gY2IoYSxiKXt0aGlzLng9dm9pZCAwIT09YT9hOjA7dGhpcy55PXZvaWQgMCE9PWI/YjowfWNiLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKCl7dGhpcy54PU1hdGguY2VpbCh0aGlzLngpO3RoaXMueT1NYXRoLmNlaWwodGhpcy55KTtyZXR1cm4gdGhpc307Y2IucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7dGhpcy54PU1hdGguZmxvb3IodGhpcy54KTt0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpO3JldHVybiB0aGlzfTtjYi5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXt0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpO3RoaXMueT1NYXRoLnJvdW5kKHRoaXMueSk7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGRiKGEsYil7dGhpcy53aWR0aD1hO3RoaXMuaGVpZ2h0PWJ9ZGIucHJvdG90eXBlLmFzcGVjdFJhdGlvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2lkdGgvdGhpcy5oZWlnaHR9O2RiLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKCl7dGhpcy53aWR0aD1NYXRoLmNlaWwodGhpcy53aWR0aCk7dGhpcy5oZWlnaHQ9TWF0aC5jZWlsKHRoaXMuaGVpZ2h0KTtyZXR1cm4gdGhpc307ZGIucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7dGhpcy53aWR0aD1NYXRoLmZsb29yKHRoaXMud2lkdGgpO3RoaXMuaGVpZ2h0PU1hdGguZmxvb3IodGhpcy5oZWlnaHQpO3JldHVybiB0aGlzfTtkYi5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXt0aGlzLndpZHRoPU1hdGgucm91bmQodGhpcy53aWR0aCk7dGhpcy5oZWlnaHQ9TWF0aC5yb3VuZCh0aGlzLmhlaWdodCk7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGViKGEpe3JldHVybiBhP25ldyBmYihBKGEpKTpuYXx8KG5hPW5ldyBmYil9ZnVuY3Rpb24gZ2IoYSl7Zm9yKDthJiYxIT1hLm5vZGVUeXBlOylhPWEucHJldmlvdXNTaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGhiKGEsYil7aWYoIWF8fCFiKXJldHVybiExO2lmKGEuY29udGFpbnMmJjE9PWIubm9kZVR5cGUpcmV0dXJuIGE9PWJ8fGEuY29udGFpbnMoYik7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24pcmV0dXJuIGE9PWJ8fCEhKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikmMTYpO2Zvcig7YiYmYSE9YjspYj1iLnBhcmVudE5vZGU7cmV0dXJuIGI9PWF9XG5mdW5jdGlvbiBpYihhLGIpe2lmKGE9PWIpcmV0dXJuIDA7aWYoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbilyZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYyPzE6LTE7aWYodCYmISg5PD1OdW1iZXIodykpKXtpZig5PT1hLm5vZGVUeXBlKXJldHVybi0xO2lmKDk9PWIubm9kZVR5cGUpcmV0dXJuIDF9aWYoXCJzb3VyY2VJbmRleFwiaW4gYXx8YS5wYXJlbnROb2RlJiZcInNvdXJjZUluZGV4XCJpbiBhLnBhcmVudE5vZGUpe3ZhciBjPTE9PWEubm9kZVR5cGUsZD0xPT1iLm5vZGVUeXBlO2lmKGMmJmQpcmV0dXJuIGEuc291cmNlSW5kZXgtYi5zb3VyY2VJbmRleDt2YXIgZT1hLnBhcmVudE5vZGUsZj1iLnBhcmVudE5vZGU7cmV0dXJuIGU9PWY/amIoYSxiKTohYyYmaGIoZSxiKT8tMSprYihhLGIpOiFkJiZoYihmLGEpP2tiKGIsYSk6KGM/YS5zb3VyY2VJbmRleDplLnNvdXJjZUluZGV4KS0oZD9iLnNvdXJjZUluZGV4OmYuc291cmNlSW5kZXgpfWQ9QShhKTtjPWQuY3JlYXRlUmFuZ2UoKTtcbmMuc2VsZWN0Tm9kZShhKTtjLmNvbGxhcHNlKCEwKTthPWQuY3JlYXRlUmFuZ2UoKTthLnNlbGVjdE5vZGUoYik7YS5jb2xsYXBzZSghMCk7cmV0dXJuIGMuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKGFhLlJhbmdlLlNUQVJUX1RPX0VORCxhKX1mdW5jdGlvbiBrYihhLGIpe3ZhciBjPWEucGFyZW50Tm9kZTtpZihjPT1iKXJldHVybi0xO2Zvcig7Yi5wYXJlbnROb2RlIT1jOyliPWIucGFyZW50Tm9kZTtyZXR1cm4gamIoYixhKX1mdW5jdGlvbiBqYihhLGIpe2Zvcig7Yj1iLnByZXZpb3VzU2libGluZzspaWYoYj09YSlyZXR1cm4tMTtyZXR1cm4gMX1mdW5jdGlvbiBBKGEpe3JldHVybiA5PT1hLm5vZGVUeXBlP2E6YS5vd25lckRvY3VtZW50fHxhLmRvY3VtZW50fWZ1bmN0aW9uIGxiKGEsYil7YSYmKGE9YS5wYXJlbnROb2RlKTtmb3IodmFyIGM9MDthOyl7aWYoYihhKSlyZXR1cm4gYTthPWEucGFyZW50Tm9kZTtjKyt9cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBmYihhKXt0aGlzLmE9YXx8YWEuZG9jdW1lbnR8fGRvY3VtZW50fWZiLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1mdW5jdGlvbihhLGIpe3JldHVybihifHx0aGlzLmEpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFN0cmluZyhhKSl9O1xuZnVuY3Rpb24gbWIoYSxiLGMsZCl7YT1kfHxhLmE7dmFyIGU9YiYmXCIqXCIhPWI/U3RyaW5nKGIpLnRvVXBwZXJDYXNlKCk6XCJcIjtpZihhLnF1ZXJ5U2VsZWN0b3JBbGwmJmEucXVlcnlTZWxlY3RvciYmKGV8fGMpKWM9YS5xdWVyeVNlbGVjdG9yQWxsKGUrKGM/XCIuXCIrYzpcIlwiKSk7ZWxzZSBpZihjJiZhLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpaWYoYj1hLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYyksZSl7YT17fTtmb3IodmFyIGY9ZD0wLGc7Zz1iW2ZdO2YrKyllPT1nLm5vZGVOYW1lJiYoYVtkKytdPWcpO2EubGVuZ3RoPWQ7Yz1hfWVsc2UgYz1iO2Vsc2UgaWYoYj1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKGV8fFwiKlwiKSxjKXthPXt9O2ZvcihmPWQ9MDtnPWJbZl07ZisrKXtlPWcuY2xhc3NOYW1lO3ZhciBoO2lmKGg9XCJmdW5jdGlvblwiPT10eXBlb2YgZS5zcGxpdCloPTA8PW9hKGUuc3BsaXQoL1xccysvKSxjKTtoJiYoYVtkKytdPWcpfWEubGVuZ3RoPWQ7Yz1hfWVsc2UgYz1iO3JldHVybiBjfVxuO2Z1bmN0aW9uIEIoYSl7dmFyIGI9bnVsbCxjPWEubm9kZVR5cGU7MT09YyYmKGI9YS50ZXh0Q29udGVudCxiPXZvaWQgMD09Ynx8bnVsbD09Yj9hLmlubmVyVGV4dDpiLGI9dm9pZCAwPT1ifHxudWxsPT1iP1wiXCI6Yik7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGIpaWYoeCYmXCJ0aXRsZVwiPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJjE9PWMpYj1hLnRleHQ7ZWxzZSBpZig5PT1jfHwxPT1jKXthPTk9PWM/YS5kb2N1bWVudEVsZW1lbnQ6YS5maXJzdENoaWxkO2M9MDt2YXIgZD1bXTtmb3IoYj1cIlwiO2E7KXtkbyAxIT1hLm5vZGVUeXBlJiYoYis9YS5ub2RlVmFsdWUpLHgmJlwidGl0bGVcIj09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiYoYis9YS50ZXh0KSxkW2MrK109YTt3aGlsZShhPWEuZmlyc3RDaGlsZCk7Zm9yKDtjJiYhKGE9ZFstLWNdLm5leHRTaWJsaW5nKTspO319ZWxzZSBiPWEubm9kZVZhbHVlO3JldHVybiBifVxuZnVuY3Rpb24gbmIoYSxiLGMpe2lmKG51bGw9PT1iKXJldHVybiEwO3RyeXtpZighYS5nZXRBdHRyaWJ1dGUpcmV0dXJuITF9Y2F0Y2goZCl7cmV0dXJuITF9VmEmJlwiY2xhc3NcIj09YiYmKGI9XCJjbGFzc05hbWVcIik7cmV0dXJuIG51bGw9PWM/ISFhLmdldEF0dHJpYnV0ZShiKTphLmdldEF0dHJpYnV0ZShiLDIpPT1jfWZ1bmN0aW9uIG9iKGEsYixjLGQsZSl7cmV0dXJuKHg/cGI6cWIpLmNhbGwobnVsbCxhLGIsYmEoYyk/YzpudWxsLGJhKGQpP2Q6bnVsbCxlfHxuZXcgQyl9XG5mdW5jdGlvbiBwYihhLGIsYyxkLGUpe2lmKGEgaW5zdGFuY2VvZiByYnx8OD09YS5ifHxjJiZudWxsPT09YS5iKXt2YXIgZj1iLmFsbDtpZighZilyZXR1cm4gZTthPXNiKGEpO2lmKFwiKlwiIT1hJiYoZj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpLCFmKSlyZXR1cm4gZTtpZihjKXtmb3IodmFyIGc9W10saD0wO2I9ZltoKytdOyluYihiLGMsZCkmJmcucHVzaChiKTtmPWd9Zm9yKGg9MDtiPWZbaCsrXTspXCIqXCI9PWEmJlwiIVwiPT1iLnRhZ05hbWV8fGUuYWRkKGIpO3JldHVybiBlfXRiKGEsYixjLGQsZSk7cmV0dXJuIGV9XG5mdW5jdGlvbiBxYihhLGIsYyxkLGUpe2IuZ2V0RWxlbWVudHNCeU5hbWUmJmQmJlwibmFtZVwiPT1jJiYhdD8oYj1iLmdldEVsZW1lbnRzQnlOYW1lKGQpLGwoYixmdW5jdGlvbihmKXthLmEoZikmJmUuYWRkKGYpfSkpOmIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmZCYmXCJjbGFzc1wiPT1jPyhiPWIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkKSxsKGIsZnVuY3Rpb24oZil7Zi5jbGFzc05hbWU9PWQmJmEuYShmKSYmZS5hZGQoZil9KSk6YSBpbnN0YW5jZW9mIEQ/dGIoYSxiLGMsZCxlKTpiLmdldEVsZW1lbnRzQnlUYWdOYW1lJiYoYj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEuZigpKSxsKGIsZnVuY3Rpb24oZil7bmIoZixjLGQpJiZlLmFkZChmKX0pKTtyZXR1cm4gZX1cbmZ1bmN0aW9uIHViKGEsYixjLGQsZSl7dmFyIGY7aWYoKGEgaW5zdGFuY2VvZiByYnx8OD09YS5ifHxjJiZudWxsPT09YS5iKSYmKGY9Yi5jaGlsZE5vZGVzKSl7dmFyIGc9c2IoYSk7aWYoXCIqXCIhPWcmJihmPXBhKGYsZnVuY3Rpb24oaCl7cmV0dXJuIGgudGFnTmFtZSYmaC50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PWd9KSwhZikpcmV0dXJuIGU7YyYmKGY9cGEoZixmdW5jdGlvbihoKXtyZXR1cm4gbmIoaCxjLGQpfSkpO2woZixmdW5jdGlvbihoKXtcIipcIj09ZyYmKFwiIVwiPT1oLnRhZ05hbWV8fFwiKlwiPT1nJiYxIT1oLm5vZGVUeXBlKXx8ZS5hZGQoaCl9KTtyZXR1cm4gZX1yZXR1cm4gdmIoYSxiLGMsZCxlKX1mdW5jdGlvbiB2YihhLGIsYyxkLGUpe2ZvcihiPWIuZmlyc3RDaGlsZDtiO2I9Yi5uZXh0U2libGluZyluYihiLGMsZCkmJmEuYShiKSYmZS5hZGQoYik7cmV0dXJuIGV9XG5mdW5jdGlvbiB0YihhLGIsYyxkLGUpe2ZvcihiPWIuZmlyc3RDaGlsZDtiO2I9Yi5uZXh0U2libGluZyluYihiLGMsZCkmJmEuYShiKSYmZS5hZGQoYiksdGIoYSxiLGMsZCxlKX1mdW5jdGlvbiBzYihhKXtpZihhIGluc3RhbmNlb2YgRCl7aWYoOD09YS5iKXJldHVyblwiIVwiO2lmKG51bGw9PT1hLmIpcmV0dXJuXCIqXCJ9cmV0dXJuIGEuZigpfTtmdW5jdGlvbiBDKCl7dGhpcy5iPXRoaXMuYT1udWxsO3RoaXMubT0wfWZ1bmN0aW9uIHdiKGEpe3RoaXMuZj1hO3RoaXMuYT10aGlzLmI9bnVsbH1mdW5jdGlvbiB4YihhLGIpe2lmKCFhLmEpcmV0dXJuIGI7aWYoIWIuYSlyZXR1cm4gYTt2YXIgYz1hLmE7Yj1iLmE7Zm9yKHZhciBkPW51bGwsZSxmPTA7YyYmYjspe2U9Yy5mO3ZhciBnPWIuZjtlPT1nfHxlIGluc3RhbmNlb2YgV2EmJmcgaW5zdGFuY2VvZiBXYSYmZS5hPT1nLmE/KGU9YyxjPWMuYSxiPWIuYSk6MDxpYihjLmYsYi5mKT8oZT1iLGI9Yi5hKTooZT1jLGM9Yy5hKTsoZS5iPWQpP2QuYT1lOmEuYT1lO2Q9ZTtmKyt9Zm9yKGU9Y3x8YjtlOyllLmI9ZCxkPWQuYT1lLGYrKyxlPWUuYTthLmI9ZDthLm09ZjtyZXR1cm4gYX1mdW5jdGlvbiB5YihhLGIpe2I9bmV3IHdiKGIpO2IuYT1hLmE7YS5iP2EuYS5iPWI6YS5hPWEuYj1iO2EuYT1iO2EubSsrfVxuQy5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe2E9bmV3IHdiKGEpO2EuYj10aGlzLmI7dGhpcy5hP3RoaXMuYi5hPWE6dGhpcy5hPXRoaXMuYj1hO3RoaXMuYj1hO3RoaXMubSsrfTtmdW5jdGlvbiB6YihhKXtyZXR1cm4oYT1hLmEpP2EuZjpudWxsfWZ1bmN0aW9uIEJiKGEpe3JldHVybihhPXpiKGEpKT9CKGEpOlwiXCJ9ZnVuY3Rpb24gQ2IoYSxiKXtyZXR1cm4gbmV3IERiKGEsISFiKX1mdW5jdGlvbiBEYihhLGIpe3RoaXMuZj1hO3RoaXMuYj0odGhpcy5BPWIpP2EuYjphLmE7dGhpcy5hPW51bGx9ZnVuY3Rpb24gRShhKXt2YXIgYj1hLmI7aWYobnVsbD09YilyZXR1cm4gbnVsbDt2YXIgYz1hLmE9YjthLmI9YS5BP2IuYjpiLmE7cmV0dXJuIGMuZn07ZnVuY3Rpb24gRihhKXt0aGlzLmk9YTt0aGlzLmI9dGhpcy5nPSExO3RoaXMuZj1udWxsfWZ1bmN0aW9uIEgoYSl7cmV0dXJuXCJcXG4gIFwiK2EudG9TdHJpbmcoKS5zcGxpdChcIlxcblwiKS5qb2luKFwiXFxuICBcIil9ZnVuY3Rpb24gRWIoYSxiKXthLmc9Yn1mdW5jdGlvbiBGYihhLGIpe2EuYj1ifWZ1bmN0aW9uIEkoYSxiKXthPWEuYShiKTtyZXR1cm4gYSBpbnN0YW5jZW9mIEM/K0JiKGEpOithfWZ1bmN0aW9uIEooYSxiKXthPWEuYShiKTtyZXR1cm4gYSBpbnN0YW5jZW9mIEM/QmIoYSk6XCJcIithfWZ1bmN0aW9uIEdiKGEsYil7YT1hLmEoYik7cmV0dXJuIGEgaW5zdGFuY2VvZiBDPyEhYS5tOiEhYX07ZnVuY3Rpb24gSGIoYSxiLGMpe0YuY2FsbCh0aGlzLGEuaSk7dGhpcy5jPWE7dGhpcy5oPWI7dGhpcy52PWM7dGhpcy5nPWIuZ3x8Yy5nO3RoaXMuYj1iLmJ8fGMuYjt0aGlzLmM9PUliJiYoYy5ifHxjLmd8fDQ9PWMuaXx8MD09Yy5pfHwhYi5mP2IuYnx8Yi5nfHw0PT1iLml8fDA9PWIuaXx8IWMuZnx8KHRoaXMuZj17bmFtZTpjLmYubmFtZSxCOmJ9KTp0aGlzLmY9e25hbWU6Yi5mLm5hbWUsQjpjfSl9ayhIYixGKTtcbmZ1bmN0aW9uIEpiKGEsYixjLGQsZSl7Yj1iLmEoZCk7Yz1jLmEoZCk7dmFyIGY7aWYoYiBpbnN0YW5jZW9mIEMmJmMgaW5zdGFuY2VvZiBDKXtiPUNiKGIpO2ZvcihkPUUoYik7ZDtkPUUoYikpZm9yKGU9Q2IoYyksZj1FKGUpO2Y7Zj1FKGUpKWlmKGEoQihkKSxCKGYpKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihiIGluc3RhbmNlb2YgQ3x8YyBpbnN0YW5jZW9mIEMpe2IgaW5zdGFuY2VvZiBDPyhlPWIsZD1jKTooZT1jLGQ9Yik7Zj1DYihlKTtmb3IodmFyIGc9dHlwZW9mIGQsaD1FKGYpO2g7aD1FKGYpKXtzd2l0Y2goZyl7Y2FzZSBcIm51bWJlclwiOmg9K0IoaCk7YnJlYWs7Y2FzZSBcImJvb2xlYW5cIjpoPSEhQihoKTticmVhaztjYXNlIFwic3RyaW5nXCI6aD1CKGgpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHByaW1pdGl2ZSB0eXBlIGZvciBjb21wYXJpc29uLlwiKTt9aWYoZT09YiYmYShoLGQpfHxlPT1jJiZhKGQsaCkpcmV0dXJuITB9cmV0dXJuITF9cmV0dXJuIGU/XG5cImJvb2xlYW5cIj09dHlwZW9mIGJ8fFwiYm9vbGVhblwiPT10eXBlb2YgYz9hKCEhYiwhIWMpOlwibnVtYmVyXCI9PXR5cGVvZiBifHxcIm51bWJlclwiPT10eXBlb2YgYz9hKCtiLCtjKTphKGIsYyk6YSgrYiwrYyl9SGIucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYy5zKHRoaXMuaCx0aGlzLnYsYSl9O0hiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiQmluYXJ5IEV4cHJlc3Npb246IFwiK3RoaXMuYzthKz1IKHRoaXMuaCk7cmV0dXJuIGErPUgodGhpcy52KX07ZnVuY3Rpb24gS2IoYSxiLGMsZCl7dGhpcy4kPWE7dGhpcy5NPWI7dGhpcy5pPWM7dGhpcy5zPWR9S2IucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJH07dmFyIExiPXt9O1xuZnVuY3Rpb24gSyhhLGIsYyxkKXtpZihMYi5oYXNPd25Qcm9wZXJ0eShhKSl0aHJvdyBFcnJvcihcIkJpbmFyeSBvcGVyYXRvciBhbHJlYWR5IGNyZWF0ZWQ6IFwiK2EpO2E9bmV3IEtiKGEsYixjLGQpO3JldHVybiBMYlthLnRvU3RyaW5nKCldPWF9SyhcImRpdlwiLDYsMSxmdW5jdGlvbihhLGIsYyl7cmV0dXJuIEkoYSxjKS9JKGIsYyl9KTtLKFwibW9kXCIsNiwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gSShhLGMpJUkoYixjKX0pO0soXCIqXCIsNiwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gSShhLGMpKkkoYixjKX0pO0soXCIrXCIsNSwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gSShhLGMpK0koYixjKX0pO0soXCItXCIsNSwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gSShhLGMpLUkoYixjKX0pO0soXCI8XCIsNCwyLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gSmIoZnVuY3Rpb24oZCxlKXtyZXR1cm4gZDxlfSxhLGIsYyl9KTtcbksoXCI+XCIsNCwyLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gSmIoZnVuY3Rpb24oZCxlKXtyZXR1cm4gZD5lfSxhLGIsYyl9KTtLKFwiPD1cIiw0LDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKYihmdW5jdGlvbihkLGUpe3JldHVybiBkPD1lfSxhLGIsYyl9KTtLKFwiPj1cIiw0LDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKYihmdW5jdGlvbihkLGUpe3JldHVybiBkPj1lfSxhLGIsYyl9KTt2YXIgSWI9SyhcIj1cIiwzLDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKYihmdW5jdGlvbihkLGUpe3JldHVybiBkPT1lfSxhLGIsYywhMCl9KTtLKFwiIT1cIiwzLDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKYihmdW5jdGlvbihkLGUpe3JldHVybiBkIT1lfSxhLGIsYywhMCl9KTtLKFwiYW5kXCIsMiwyLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gR2IoYSxjKSYmR2IoYixjKX0pO0soXCJvclwiLDEsMixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIEdiKGEsYyl8fEdiKGIsYyl9KTtmdW5jdGlvbiBNYihhLGIpe2lmKGIuYS5sZW5ndGgmJjQhPWEuaSl0aHJvdyBFcnJvcihcIlByaW1hcnkgZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIG5vZGVzZXQgaWYgZmlsdGVyIGhhcyBwcmVkaWNhdGUocykuXCIpO0YuY2FsbCh0aGlzLGEuaSk7dGhpcy5jPWE7dGhpcy5oPWI7dGhpcy5nPWEuZzt0aGlzLmI9YS5ifWsoTWIsRik7TWIucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7YT10aGlzLmMuYShhKTtyZXR1cm4gTmIodGhpcy5oLGEpfTtNYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT1cIkZpbHRlcjpcIitIKHRoaXMuYyk7cmV0dXJuIGErPUgodGhpcy5oKX07ZnVuY3Rpb24gT2IoYSxiKXtpZihiLmxlbmd0aDxhLkwpdGhyb3cgRXJyb3IoXCJGdW5jdGlvbiBcIithLmwrXCIgZXhwZWN0cyBhdCBsZWFzdFwiK2EuTCtcIiBhcmd1bWVudHMsIFwiK2IubGVuZ3RoK1wiIGdpdmVuXCIpO2lmKG51bGwhPT1hLkgmJmIubGVuZ3RoPmEuSCl0aHJvdyBFcnJvcihcIkZ1bmN0aW9uIFwiK2EubCtcIiBleHBlY3RzIGF0IG1vc3QgXCIrYS5IK1wiIGFyZ3VtZW50cywgXCIrYi5sZW5ndGgrXCIgZ2l2ZW5cIik7YS5aJiZsKGIsZnVuY3Rpb24oYyxkKXtpZig0IT1jLmkpdGhyb3cgRXJyb3IoXCJBcmd1bWVudCBcIitkK1wiIHRvIGZ1bmN0aW9uIFwiK2EubCtcIiBpcyBub3Qgb2YgdHlwZSBOb2Rlc2V0OiBcIitjKTt9KTtGLmNhbGwodGhpcyxhLmkpO3RoaXMuRD1hO3RoaXMuYz1iO0ViKHRoaXMsYS5nfHxzYShiLGZ1bmN0aW9uKGMpe3JldHVybiBjLmd9KSk7RmIodGhpcyxhLlkmJiFiLmxlbmd0aHx8YS5YJiYhIWIubGVuZ3RofHxzYShiLGZ1bmN0aW9uKGMpe3JldHVybiBjLmJ9KSl9XG5rKE9iLEYpO09iLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLkQucy5hcHBseShudWxsLHZhKGEsdGhpcy5jKSl9O09iLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiRnVuY3Rpb246IFwiK3RoaXMuRDtpZih0aGlzLmMubGVuZ3RoKXt2YXIgYj1yYSh0aGlzLmMsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytIKGQpfSxcIkFyZ3VtZW50czpcIik7YSs9SChiKX1yZXR1cm4gYX07ZnVuY3Rpb24gUGIoYSxiLGMsZCxlLGYsZyxoKXt0aGlzLmw9YTt0aGlzLmk9Yjt0aGlzLmc9Yzt0aGlzLlk9ZDt0aGlzLlg9ITE7dGhpcy5zPWU7dGhpcy5MPWY7dGhpcy5IPXZvaWQgMCE9PWc/ZzpmO3RoaXMuWj0hIWh9UGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubH07dmFyIFFiPXt9O1xuZnVuY3Rpb24gTChhLGIsYyxkLGUsZixnLGgpe2lmKFFiLmhhc093blByb3BlcnR5KGEpKXRocm93IEVycm9yKFwiRnVuY3Rpb24gYWxyZWFkeSBjcmVhdGVkOiBcIithK1wiLlwiKTtRYlthXT1uZXcgUGIoYSxiLGMsZCxlLGYsZyxoKX1MKFwiYm9vbGVhblwiLDIsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gR2IoYixhKX0sMSk7TChcImNlaWxpbmdcIiwxLCExLCExLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGguY2VpbChJKGIsYSkpfSwxKTtMKFwiY29uY2F0XCIsMywhMSwhMSxmdW5jdGlvbihhLGIpe3JldHVybiByYSh3YShhcmd1bWVudHMsMSksZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytKKGQsYSl9LFwiXCIpfSwyLG51bGwpO0woXCJjb250YWluc1wiLDIsITEsITEsZnVuY3Rpb24oYSxiLGMpe2I9SihiLGEpO2E9SihjLGEpO3JldHVybiBhPS0xIT1iLmluZGV4T2YoYSl9LDIpO0woXCJjb3VudFwiLDEsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5hKGEpLm19LDEsMSwhMCk7XG5MKFwiZmFsc2VcIiwyLCExLCExLGZ1bmN0aW9uKCl7cmV0dXJuITF9LDApO0woXCJmbG9vclwiLDEsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gTWF0aC5mbG9vcihJKGIsYSkpfSwxKTtMKFwiaWRcIiw0LCExLCExLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhoKXtpZih4KXt2YXIgbj1lLmFsbFtoXTtpZihuKXtpZihuLm5vZGVUeXBlJiZoPT1uLmlkKXJldHVybiBuO2lmKG4ubGVuZ3RoKXJldHVybiB1YShuLGZ1bmN0aW9uKHUpe3JldHVybiBoPT11LmlkfSl9cmV0dXJuIG51bGx9cmV0dXJuIGUuZ2V0RWxlbWVudEJ5SWQoaCl9dmFyIGQ9YS5hLGU9OT09ZC5ub2RlVHlwZT9kOmQub3duZXJEb2N1bWVudDthPUooYixhKS5zcGxpdCgvXFxzKy8pO3ZhciBmPVtdO2woYSxmdW5jdGlvbihoKXtoPWMoaCk7IWh8fDA8PW9hKGYsaCl8fGYucHVzaChoKX0pO2Yuc29ydChpYik7dmFyIGc9bmV3IEM7bChmLGZ1bmN0aW9uKGgpe2cuYWRkKGgpfSk7cmV0dXJuIGd9LDEpO1xuTChcImxhbmdcIiwyLCExLCExLGZ1bmN0aW9uKCl7cmV0dXJuITF9LDEpO0woXCJsYXN0XCIsMSwhMCwhMSxmdW5jdGlvbihhKXtpZigxIT1hcmd1bWVudHMubGVuZ3RoKXRocm93IEVycm9yKFwiRnVuY3Rpb24gbGFzdCBleHBlY3RzICgpXCIpO3JldHVybiBhLmZ9LDApO0woXCJsb2NhbC1uYW1lXCIsMywhMSwhMCxmdW5jdGlvbihhLGIpe3JldHVybihhPWI/emIoYi5hKGEpKTphLmEpP2EubG9jYWxOYW1lfHxhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk6XCJcIn0sMCwxLCEwKTtMKFwibmFtZVwiLDMsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4oYT1iP3piKGIuYShhKSk6YS5hKT9hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk6XCJcIn0sMCwxLCEwKTtMKFwibmFtZXNwYWNlLXVyaVwiLDMsITAsITEsZnVuY3Rpb24oKXtyZXR1cm5cIlwifSwwLDEsITApO1xuTChcIm5vcm1hbGl6ZS1zcGFjZVwiLDMsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4oYj9KKGIsYSk6QihhLmEpKS5yZXBsYWNlKC9bXFxzXFx4YTBdKy9nLFwiIFwiKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSwwLDEpO0woXCJub3RcIiwyLCExLCExLGZ1bmN0aW9uKGEsYil7cmV0dXJuIUdiKGIsYSl9LDEpO0woXCJudW1iZXJcIiwxLCExLCEwLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGI/SShiLGEpOitCKGEuYSl9LDAsMSk7TChcInBvc2l0aW9uXCIsMSwhMCwhMSxmdW5jdGlvbihhKXtyZXR1cm4gYS5ifSwwKTtMKFwicm91bmRcIiwxLCExLCExLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGgucm91bmQoSShiLGEpKX0sMSk7TChcInN0YXJ0cy13aXRoXCIsMiwhMSwhMSxmdW5jdGlvbihhLGIsYyl7Yj1KKGIsYSk7YT1KKGMsYSk7cmV0dXJuIDA9PWIubGFzdEluZGV4T2YoYSwwKX0sMik7TChcInN0cmluZ1wiLDMsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9KKGIsYSk6QihhLmEpfSwwLDEpO1xuTChcInN0cmluZy1sZW5ndGhcIiwxLCExLCEwLGZ1bmN0aW9uKGEsYil7cmV0dXJuKGI/SihiLGEpOkIoYS5hKSkubGVuZ3RofSwwLDEpO0woXCJzdWJzdHJpbmdcIiwzLCExLCExLGZ1bmN0aW9uKGEsYixjLGQpe2M9SShjLGEpO2lmKGlzTmFOKGMpfHxJbmZpbml0eT09Y3x8LUluZmluaXR5PT1jKXJldHVyblwiXCI7ZD1kP0koZCxhKTpJbmZpbml0eTtpZihpc05hTihkKXx8LUluZmluaXR5PT09ZClyZXR1cm5cIlwiO2M9TWF0aC5yb3VuZChjKS0xO3ZhciBlPU1hdGgubWF4KGMsMCk7YT1KKGIsYSk7cmV0dXJuIEluZmluaXR5PT1kP2Euc3Vic3RyaW5nKGUpOmEuc3Vic3RyaW5nKGUsYytNYXRoLnJvdW5kKGQpKX0sMiwzKTtMKFwic3Vic3RyaW5nLWFmdGVyXCIsMywhMSwhMSxmdW5jdGlvbihhLGIsYyl7Yj1KKGIsYSk7YT1KKGMsYSk7Yz1iLmluZGV4T2YoYSk7cmV0dXJuLTE9PWM/XCJcIjpiLnN1YnN0cmluZyhjK2EubGVuZ3RoKX0sMik7XG5MKFwic3Vic3RyaW5nLWJlZm9yZVwiLDMsITEsITEsZnVuY3Rpb24oYSxiLGMpe2I9SihiLGEpO2E9SihjLGEpO2E9Yi5pbmRleE9mKGEpO3JldHVybi0xPT1hP1wiXCI6Yi5zdWJzdHJpbmcoMCxhKX0sMik7TChcInN1bVwiLDEsITEsITEsZnVuY3Rpb24oYSxiKXthPUNiKGIuYShhKSk7Yj0wO2Zvcih2YXIgYz1FKGEpO2M7Yz1FKGEpKWIrPStCKGMpO3JldHVybiBifSwxLDEsITApO0woXCJ0cmFuc2xhdGVcIiwzLCExLCExLGZ1bmN0aW9uKGEsYixjLGQpe2I9SihiLGEpO2M9SihjLGEpO3ZhciBlPUooZCxhKTthPXt9O2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBmPWMuY2hhckF0KGQpO2YgaW4gYXx8KGFbZl09ZS5jaGFyQXQoZCkpfWM9XCJcIjtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWY9Yi5jaGFyQXQoZCksYys9ZiBpbiBhP2FbZl06ZjtyZXR1cm4gY30sMyk7TChcInRydWVcIiwyLCExLCExLGZ1bmN0aW9uKCl7cmV0dXJuITB9LDApO2Z1bmN0aW9uIEQoYSxiKXt0aGlzLmg9YTt0aGlzLmM9dm9pZCAwIT09Yj9iOm51bGw7dGhpcy5iPW51bGw7c3dpdGNoKGEpe2Nhc2UgXCJjb21tZW50XCI6dGhpcy5iPTg7YnJlYWs7Y2FzZSBcInRleHRcIjp0aGlzLmI9MzticmVhaztjYXNlIFwicHJvY2Vzc2luZy1pbnN0cnVjdGlvblwiOnRoaXMuYj03O2JyZWFrO2Nhc2UgXCJub2RlXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRcIik7fX1mdW5jdGlvbiBSYihhKXtyZXR1cm5cImNvbW1lbnRcIj09YXx8XCJ0ZXh0XCI9PWF8fFwicHJvY2Vzc2luZy1pbnN0cnVjdGlvblwiPT1hfHxcIm5vZGVcIj09YX1ELnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT09dGhpcy5ifHx0aGlzLmI9PWEubm9kZVR5cGV9O0QucHJvdG90eXBlLmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ofTtcbkQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9XCJLaW5kIFRlc3Q6IFwiK3RoaXMuaDtudWxsPT09dGhpcy5jfHwoYSs9SCh0aGlzLmMpKTtyZXR1cm4gYX07ZnVuY3Rpb24gU2IoYSl7Ri5jYWxsKHRoaXMsMyk7dGhpcy5jPWEuc3Vic3RyaW5nKDEsYS5sZW5ndGgtMSl9ayhTYixGKTtTYi5wcm90b3R5cGUuYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN9O1NiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTGl0ZXJhbDogXCIrdGhpcy5jfTtmdW5jdGlvbiByYihhLGIpe3RoaXMubD1hLnRvTG93ZXJDYXNlKCk7YT1cIipcIj09dGhpcy5sP1wiKlwiOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO3RoaXMuYz1iP2IudG9Mb3dlckNhc2UoKTphfXJiLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZVR5cGU7aWYoMSE9YiYmMiE9YilyZXR1cm4hMTtiPXZvaWQgMCE9PWEubG9jYWxOYW1lP2EubG9jYWxOYW1lOmEubm9kZU5hbWU7cmV0dXJuXCIqXCIhPXRoaXMubCYmdGhpcy5sIT1iLnRvTG93ZXJDYXNlKCk/ITE6XCIqXCI9PXRoaXMuYz8hMDp0aGlzLmM9PShhLm5hbWVzcGFjZVVSST9hLm5hbWVzcGFjZVVSSS50b0xvd2VyQ2FzZSgpOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKX07cmIucHJvdG90eXBlLmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sfTtcbnJiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTmFtZSBUZXN0OiBcIisoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PXRoaXMuYz9cIlwiOnRoaXMuYytcIjpcIikrdGhpcy5sfTtmdW5jdGlvbiBUYihhKXtGLmNhbGwodGhpcywxKTt0aGlzLmM9YX1rKFRiLEYpO1RiLnByb3RvdHlwZS5hPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY307VGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOdW1iZXI6IFwiK3RoaXMuY307ZnVuY3Rpb24gVWIoYSxiKXtGLmNhbGwodGhpcyxhLmkpO3RoaXMuaD1hO3RoaXMuYz1iO3RoaXMuZz1hLmc7dGhpcy5iPWEuYjsxPT10aGlzLmMubGVuZ3RoJiYoYT10aGlzLmNbMF0sYS5HfHxhLmMhPVZifHwoYT1hLnYsXCIqXCIhPWEuZigpJiYodGhpcy5mPXtuYW1lOmEuZigpLEI6bnVsbH0pKSl9ayhVYixGKTtmdW5jdGlvbiBXYigpe0YuY2FsbCh0aGlzLDQpfWsoV2IsRik7V2IucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IEM7YT1hLmE7OT09YS5ub2RlVHlwZT9iLmFkZChhKTpiLmFkZChhLm93bmVyRG9jdW1lbnQpO3JldHVybiBifTtXYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlJvb3QgSGVscGVyIEV4cHJlc3Npb25cIn07ZnVuY3Rpb24gWGIoKXtGLmNhbGwodGhpcyw0KX1rKFhiLEYpO1hiLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBDO2IuYWRkKGEuYSk7cmV0dXJuIGJ9O1hiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiQ29udGV4dCBIZWxwZXIgRXhwcmVzc2lvblwifTtcbmZ1bmN0aW9uIFliKGEpe3JldHVyblwiL1wiPT1hfHxcIi8vXCI9PWF9VWIucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5oLmEoYSk7aWYoIShiIGluc3RhbmNlb2YgQykpdGhyb3cgRXJyb3IoXCJGaWx0ZXIgZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIG5vZGVzZXQuXCIpO2E9dGhpcy5jO2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkJiZiLm07YysrKXt2YXIgZT1hW2NdLGY9Q2IoYixlLmMuQSk7aWYoZS5nfHxlLmMhPVpiKWlmKGUuZ3x8ZS5jIT0kYil7dmFyIGc9RShmKTtmb3IoYj1lLmEobmV3IG1hKGcpKTtudWxsIT0oZz1FKGYpKTspZz1lLmEobmV3IG1hKGcpKSxiPXhiKGIsZyl9ZWxzZSBnPUUoZiksYj1lLmEobmV3IG1hKGcpKTtlbHNle2ZvcihnPUUoZik7KGI9RShmKSkmJighZy5jb250YWluc3x8Zy5jb250YWlucyhiKSkmJmIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZykmODtnPWIpO2I9ZS5hKG5ldyBtYShnKSl9fXJldHVybiBifTtcblViLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiUGF0aCBFeHByZXNzaW9uOlwiK0godGhpcy5oKTtpZih0aGlzLmMubGVuZ3RoKXt2YXIgYj1yYSh0aGlzLmMsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytIKGQpfSxcIlN0ZXBzOlwiKTthKz1IKGIpfXJldHVybiBhfTtmdW5jdGlvbiBhYyhhLGIpe3RoaXMuYT1hO3RoaXMuQT0hIWJ9XG5mdW5jdGlvbiBOYihhLGIsYyl7Zm9yKGM9Y3x8MDtjPGEuYS5sZW5ndGg7YysrKWZvcih2YXIgZD1hLmFbY10sZT1DYihiKSxmPWIubSxnLGg9MDtnPUUoZSk7aCsrKXt2YXIgbj1hLkE/Zi1oOmgrMTtnPWQuYShuZXcgbWEoZyxuLGYpKTtpZihcIm51bWJlclwiPT10eXBlb2YgZyluPW49PWc7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgZ3x8XCJib29sZWFuXCI9PXR5cGVvZiBnKW49ISFnO2Vsc2UgaWYoZyBpbnN0YW5jZW9mIEMpbj0wPGcubTtlbHNlIHRocm93IEVycm9yKFwiUHJlZGljYXRlLmV2YWx1YXRlIHJldHVybmVkIGFuIHVuZXhwZWN0ZWQgdHlwZS5cIik7aWYoIW4pe249ZTtnPW4uZjt2YXIgdT1uLmE7aWYoIXUpdGhyb3cgRXJyb3IoXCJOZXh0IG11c3QgYmUgY2FsbGVkIGF0IGxlYXN0IG9uY2UgYmVmb3JlIHJlbW92ZS5cIik7dmFyIHA9dS5iO3U9dS5hO3A/cC5hPXU6Zy5hPXU7dT91LmI9cDpnLmI9cDtnLm0tLTtuLmE9bnVsbH19cmV0dXJuIGJ9XG5hYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcmEodGhpcy5hLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGErSChiKX0sXCJQcmVkaWNhdGVzOlwiKX07ZnVuY3Rpb24gYmMoYSxiLGMsZCl7Ri5jYWxsKHRoaXMsNCk7dGhpcy5jPWE7dGhpcy52PWI7dGhpcy5oPWN8fG5ldyBhYyhbXSk7dGhpcy5HPSEhZDtiPXRoaXMuaDtiPTA8Yi5hLmxlbmd0aD9iLmFbMF0uZjpudWxsO2EuY2EmJmImJihhPWIubmFtZSxhPXg/YS50b0xvd2VyQ2FzZSgpOmEsdGhpcy5mPXtuYW1lOmEsQjpiLkJ9KTthOnthPXRoaXMuaDtmb3IoYj0wO2I8YS5hLmxlbmd0aDtiKyspaWYoYz1hLmFbYl0sYy5nfHwxPT1jLml8fDA9PWMuaSl7YT0hMDticmVhayBhfWE9ITF9dGhpcy5nPWF9ayhiYyxGKTtcbmJjLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPWEuYSxjPXRoaXMuZixkPW51bGwsZT1udWxsLGY9MDtjJiYoZD1jLm5hbWUsZT1jLkI/SihjLkIsYSk6bnVsbCxmPTEpO2lmKHRoaXMuRylpZih0aGlzLmd8fHRoaXMuYyE9Y2MpaWYoYj1DYigobmV3IGJjKGRjLG5ldyBEKFwibm9kZVwiKSkpLmEoYSkpLGM9RShiKSlmb3IoYT10aGlzLnMoYyxkLGUsZik7bnVsbCE9KGM9RShiKSk7KWE9eGIoYSx0aGlzLnMoYyxkLGUsZikpO2Vsc2UgYT1uZXcgQztlbHNlIGE9b2IodGhpcy52LGIsZCxlKSxhPU5iKHRoaXMuaCxhLGYpO2Vsc2UgYT10aGlzLnMoYS5hLGQsZSxmKTtyZXR1cm4gYX07YmMucHJvdG90eXBlLnM9ZnVuY3Rpb24oYSxiLGMsZCl7YT10aGlzLmMuRCh0aGlzLnYsYSxiLGMpO3JldHVybiBhPU5iKHRoaXMuaCxhLGQpfTtcbmJjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiU3RlcDpcIitIKFwiT3BlcmF0b3I6IFwiKyh0aGlzLkc/XCIvL1wiOlwiL1wiKSk7dGhpcy5jLmwmJihhKz1IKFwiQXhpczogXCIrdGhpcy5jKSk7YSs9SCh0aGlzLnYpO2lmKHRoaXMuaC5hLmxlbmd0aCl7dmFyIGI9cmEodGhpcy5oLmEsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytIKGQpfSxcIlByZWRpY2F0ZXM6XCIpO2ErPUgoYil9cmV0dXJuIGF9O2Z1bmN0aW9uIGVjKGEsYixjLGQpe3RoaXMubD1hO3RoaXMuRD1iO3RoaXMuQT1jO3RoaXMuY2E9ZH1lYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sfTt2YXIgZmM9e307ZnVuY3Rpb24gTShhLGIsYyxkKXtpZihmYy5oYXNPd25Qcm9wZXJ0eShhKSl0aHJvdyBFcnJvcihcIkF4aXMgYWxyZWFkeSBjcmVhdGVkOiBcIithKTtiPW5ldyBlYyhhLGIsYywhIWQpO3JldHVybiBmY1thXT1ifVxuTShcImFuY2VzdG9yXCIsZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9bmV3IEM7Yj1iLnBhcmVudE5vZGU7KWEuYShiKSYmeWIoYyxiKTtyZXR1cm4gY30sITApO00oXCJhbmNlc3Rvci1vci1zZWxmXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgQztkbyBhLmEoYikmJnliKGMsYik7d2hpbGUoYj1iLnBhcmVudE5vZGUpO3JldHVybiBjfSwhMCk7XG52YXIgVmI9TShcImF0dHJpYnV0ZVwiLGZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IEMsZD1hLmYoKTtpZihcInN0eWxlXCI9PWQmJngmJmIuc3R5bGUpcmV0dXJuIGMuYWRkKG5ldyBXYShiLnN0eWxlLGIsXCJzdHlsZVwiLGIuc3R5bGUuY3NzVGV4dCkpLGM7dmFyIGU9Yi5hdHRyaWJ1dGVzO2lmKGUpaWYoYSBpbnN0YW5jZW9mIEQmJm51bGw9PT1hLmJ8fFwiKlwiPT1kKWZvcihhPTA7ZD1lW2FdO2ErKyl4P2Qubm9kZVZhbHVlJiZjLmFkZChYYShiLGQpKTpjLmFkZChkKTtlbHNlKGQ9ZS5nZXROYW1lZEl0ZW0oZCkpJiYoeD9kLm5vZGVWYWx1ZSYmYy5hZGQoWGEoYixkKSk6Yy5hZGQoZCkpO3JldHVybiBjfSwhMSksY2M9TShcImNoaWxkXCIsZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4oeD91Yjp2YikuY2FsbChudWxsLGEsYixiYShjKT9jOm51bGwsYmEoZCk/ZDpudWxsLGV8fG5ldyBDKX0sITEsITApO00oXCJkZXNjZW5kYW50XCIsb2IsITEsITApO1xudmFyIGRjPU0oXCJkZXNjZW5kYW50LW9yLXNlbGZcIixmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgQztuYihiLGMsZCkmJmEuYShiKSYmZS5hZGQoYik7cmV0dXJuIG9iKGEsYixjLGQsZSl9LCExLCEwKSxaYj1NKFwiZm9sbG93aW5nXCIsZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bmV3IEM7ZG8gZm9yKHZhciBmPWI7Zj1mLm5leHRTaWJsaW5nOyluYihmLGMsZCkmJmEuYShmKSYmZS5hZGQoZiksZT1vYihhLGYsYyxkLGUpO3doaWxlKGI9Yi5wYXJlbnROb2RlKTtyZXR1cm4gZX0sITEsITApO00oXCJmb2xsb3dpbmctc2libGluZ1wiLGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPW5ldyBDO2I9Yi5uZXh0U2libGluZzspYS5hKGIpJiZjLmFkZChiKTtyZXR1cm4gY30sITEpO00oXCJuYW1lc3BhY2VcIixmdW5jdGlvbigpe3JldHVybiBuZXcgQ30sITEpO1xudmFyIGdjPU0oXCJwYXJlbnRcIixmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBDO2lmKDk9PWIubm9kZVR5cGUpcmV0dXJuIGM7aWYoMj09Yi5ub2RlVHlwZSlyZXR1cm4gYy5hZGQoYi5vd25lckVsZW1lbnQpLGM7Yj1iLnBhcmVudE5vZGU7YS5hKGIpJiZjLmFkZChiKTtyZXR1cm4gY30sITEpLCRiPU0oXCJwcmVjZWRpbmdcIixmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgQyxmPVtdO2RvIGYudW5zaGlmdChiKTt3aGlsZShiPWIucGFyZW50Tm9kZSk7Zm9yKHZhciBnPTEsaD1mLmxlbmd0aDtnPGg7ZysrKXt2YXIgbj1bXTtmb3IoYj1mW2ddO2I9Yi5wcmV2aW91c1NpYmxpbmc7KW4udW5zaGlmdChiKTtmb3IodmFyIHU9MCxwPW4ubGVuZ3RoO3U8cDt1KyspYj1uW3VdLG5iKGIsYyxkKSYmYS5hKGIpJiZlLmFkZChiKSxlPW9iKGEsYixjLGQsZSl9cmV0dXJuIGV9LCEwLCEwKTtcbk0oXCJwcmVjZWRpbmctc2libGluZ1wiLGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPW5ldyBDO2I9Yi5wcmV2aW91c1NpYmxpbmc7KWEuYShiKSYmeWIoYyxiKTtyZXR1cm4gY30sITApO3ZhciBoYz1NKFwic2VsZlwiLGZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IEM7YS5hKGIpJiZjLmFkZChiKTtyZXR1cm4gY30sITEpO2Z1bmN0aW9uIGljKGEpe0YuY2FsbCh0aGlzLDEpO3RoaXMuYz1hO3RoaXMuZz1hLmc7dGhpcy5iPWEuYn1rKGljLEYpO2ljLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3JldHVybi1JKHRoaXMuYyxhKX07aWMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJVbmFyeSBFeHByZXNzaW9uOiAtXCIrSCh0aGlzLmMpfTtmdW5jdGlvbiBqYyhhKXtGLmNhbGwodGhpcyw0KTt0aGlzLmM9YTtFYih0aGlzLHNhKHRoaXMuYyxmdW5jdGlvbihiKXtyZXR1cm4gYi5nfSkpO0ZiKHRoaXMsc2EodGhpcy5jLGZ1bmN0aW9uKGIpe3JldHVybiBiLmJ9KSl9ayhqYyxGKTtqYy5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgQztsKHRoaXMuYyxmdW5jdGlvbihjKXtjPWMuYShhKTtpZighKGMgaW5zdGFuY2VvZiBDKSl0aHJvdyBFcnJvcihcIlBhdGggZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIE5vZGVTZXQuXCIpO2I9eGIoYixjKX0pO3JldHVybiBifTtqYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcmEodGhpcy5jLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGErSChiKX0sXCJVbmlvbiBFeHByZXNzaW9uOlwiKX07ZnVuY3Rpb24ga2MoYSxiKXt0aGlzLmE9YTt0aGlzLmI9Yn1mdW5jdGlvbiBsYyhhKXtmb3IodmFyIGIsYz1bXTs7KXtOKGEsXCJNaXNzaW5nIHJpZ2h0IGhhbmQgc2lkZSBvZiBiaW5hcnkgZXhwcmVzc2lvbi5cIik7Yj1tYyhhKTt2YXIgZD16KGEuYSk7aWYoIWQpYnJlYWs7dmFyIGU9KGQ9TGJbZF18fG51bGwpJiZkLk07aWYoIWUpe2EuYS5hLS07YnJlYWt9Zm9yKDtjLmxlbmd0aCYmZTw9Y1tjLmxlbmd0aC0xXS5NOyliPW5ldyBIYihjLnBvcCgpLGMucG9wKCksYik7Yy5wdXNoKGIsZCl9Zm9yKDtjLmxlbmd0aDspYj1uZXcgSGIoYy5wb3AoKSxjLnBvcCgpLGIpO3JldHVybiBifWZ1bmN0aW9uIE4oYSxiKXtpZihiYihhLmEpKXRocm93IEVycm9yKGIpO31mdW5jdGlvbiBuYyhhLGIpe2E9eihhLmEpO2lmKGEhPWIpdGhyb3cgRXJyb3IoXCJCYWQgdG9rZW4sIGV4cGVjdGVkOiBcIitiK1wiIGdvdDogXCIrYSk7fVxuZnVuY3Rpb24gb2MoYSl7YT16KGEuYSk7aWYoXCIpXCIhPWEpdGhyb3cgRXJyb3IoXCJCYWQgdG9rZW46IFwiK2EpO31mdW5jdGlvbiByYyhhKXthPXooYS5hKTtpZigyPmEubGVuZ3RoKXRocm93IEVycm9yKFwiVW5jbG9zZWQgbGl0ZXJhbCBzdHJpbmdcIik7cmV0dXJuIG5ldyBTYihhKX1cbmZ1bmN0aW9uIHNjKGEpe3ZhciBiPVtdO2lmKFliKHkoYS5hKSkpe3ZhciBjPXooYS5hKTt2YXIgZD15KGEuYSk7aWYoXCIvXCI9PWMmJihiYihhLmEpfHxcIi5cIiE9ZCYmXCIuLlwiIT1kJiZcIkBcIiE9ZCYmXCIqXCIhPWQmJiEvKD8hWzAtOV0pW1xcd10vLnRlc3QoZCkpKXJldHVybiBuZXcgV2I7ZD1uZXcgV2I7TihhLFwiTWlzc2luZyBuZXh0IGxvY2F0aW9uIHN0ZXAuXCIpO2M9dGMoYSxjKTtiLnB1c2goYyl9ZWxzZXthOntjPXkoYS5hKTtkPWMuY2hhckF0KDApO3N3aXRjaChkKXtjYXNlIFwiJFwiOnRocm93IEVycm9yKFwiVmFyaWFibGUgcmVmZXJlbmNlIG5vdCBhbGxvd2VkIGluIEhUTUwgWFBhdGhcIik7Y2FzZSBcIihcIjp6KGEuYSk7Yz1sYyhhKTtOKGEsJ3VuY2xvc2VkIFwiKFwiJyk7bmMoYSxcIilcIik7YnJlYWs7Y2FzZSAnXCInOmNhc2UgXCInXCI6Yz1yYyhhKTticmVhaztkZWZhdWx0OmlmKGlzTmFOKCtjKSlpZighUmIoYykmJi8oPyFbMC05XSlbXFx3XS8udGVzdChkKSYmXCIoXCI9PXkoYS5hLDEpKXtjPXooYS5hKTtcbmM9UWJbY118fG51bGw7eihhLmEpO2ZvcihkPVtdO1wiKVwiIT15KGEuYSk7KXtOKGEsXCJNaXNzaW5nIGZ1bmN0aW9uIGFyZ3VtZW50IGxpc3QuXCIpO2QucHVzaChsYyhhKSk7aWYoXCIsXCIhPXkoYS5hKSlicmVhazt6KGEuYSl9TihhLFwiVW5jbG9zZWQgZnVuY3Rpb24gYXJndW1lbnQgbGlzdC5cIik7b2MoYSk7Yz1uZXcgT2IoYyxkKX1lbHNle2M9bnVsbDticmVhayBhfWVsc2UgYz1uZXcgVGIoK3ooYS5hKSl9XCJbXCI9PXkoYS5hKSYmKGQ9bmV3IGFjKHVjKGEpKSxjPW5ldyBNYihjLGQpKX1pZihjKWlmKFliKHkoYS5hKSkpZD1jO2Vsc2UgcmV0dXJuIGM7ZWxzZSBjPXRjKGEsXCIvXCIpLGQ9bmV3IFhiLGIucHVzaChjKX1mb3IoO1liKHkoYS5hKSk7KWM9eihhLmEpLE4oYSxcIk1pc3NpbmcgbmV4dCBsb2NhdGlvbiBzdGVwLlwiKSxjPXRjKGEsYyksYi5wdXNoKGMpO3JldHVybiBuZXcgVWIoZCxiKX1cbmZ1bmN0aW9uIHRjKGEsYil7aWYoXCIvXCIhPWImJlwiLy9cIiE9Yil0aHJvdyBFcnJvcignU3RlcCBvcCBzaG91bGQgYmUgXCIvXCIgb3IgXCIvL1wiJyk7aWYoXCIuXCI9PXkoYS5hKSl7dmFyIGM9bmV3IGJjKGhjLG5ldyBEKFwibm9kZVwiKSk7eihhLmEpO3JldHVybiBjfWlmKFwiLi5cIj09eShhLmEpKXJldHVybiBjPW5ldyBiYyhnYyxuZXcgRChcIm5vZGVcIikpLHooYS5hKSxjO2lmKFwiQFwiPT15KGEuYSkpe3ZhciBkPVZiO3ooYS5hKTtOKGEsXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lXCIpfWVsc2UgaWYoXCI6OlwiPT15KGEuYSwxKSl7aWYoIS8oPyFbMC05XSlbXFx3XS8udGVzdCh5KGEuYSkuY2hhckF0KDApKSl0aHJvdyBFcnJvcihcIkJhZCB0b2tlbjogXCIreihhLmEpKTt2YXIgZT16KGEuYSk7ZD1mY1tlXXx8bnVsbDtpZighZCl0aHJvdyBFcnJvcihcIk5vIGF4aXMgd2l0aCBuYW1lOiBcIitlKTt6KGEuYSk7TihhLFwiTWlzc2luZyBub2RlIG5hbWVcIil9ZWxzZSBkPWNjO2U9eShhLmEpO2lmKC8oPyFbMC05XSlbXFx3XFwqXS8udGVzdChlLmNoYXJBdCgwKSkpaWYoXCIoXCI9PVxueShhLmEsMSkpe2lmKCFSYihlKSl0aHJvdyBFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIitlKTtlPXooYS5hKTtpZighUmIoZSkpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHR5cGUgbmFtZTogXCIrZSk7bmMoYSxcIihcIik7TihhLFwiQmFkIG5vZGV0eXBlXCIpO3ZhciBmPXkoYS5hKS5jaGFyQXQoMCksZz1udWxsO2lmKCdcIic9PWZ8fFwiJ1wiPT1mKWc9cmMoYSk7TihhLFwiQmFkIG5vZGV0eXBlXCIpO29jKGEpO2U9bmV3IEQoZSxnKX1lbHNlIGlmKGU9eihhLmEpLGY9ZS5pbmRleE9mKFwiOlwiKSwtMT09ZillPW5ldyByYihlKTtlbHNle2c9ZS5zdWJzdHJpbmcoMCxmKTtpZihcIipcIj09Zyl2YXIgaD1cIipcIjtlbHNlIGlmKGg9YS5iKGcpLCFoKXRocm93IEVycm9yKFwiTmFtZXNwYWNlIHByZWZpeCBub3QgZGVjbGFyZWQ6IFwiK2cpO2U9ZS5zdWJzdHIoZisxKTtlPW5ldyByYihlLGgpfWVsc2UgdGhyb3cgRXJyb3IoXCJCYWQgdG9rZW46IFwiK3ooYS5hKSk7YT1uZXcgYWModWMoYSksZC5BKTtyZXR1cm4gY3x8XG5uZXcgYmMoZCxlLGEsXCIvL1wiPT1iKX1mdW5jdGlvbiB1YyhhKXtmb3IodmFyIGI9W107XCJbXCI9PXkoYS5hKTspe3ooYS5hKTtOKGEsXCJNaXNzaW5nIHByZWRpY2F0ZSBleHByZXNzaW9uLlwiKTt2YXIgYz1sYyhhKTtiLnB1c2goYyk7TihhLFwiVW5jbG9zZWQgcHJlZGljYXRlIGV4cHJlc3Npb24uXCIpO25jKGEsXCJdXCIpfXJldHVybiBifWZ1bmN0aW9uIG1jKGEpe2lmKFwiLVwiPT15KGEuYSkpcmV0dXJuIHooYS5hKSxuZXcgaWMobWMoYSkpO3ZhciBiPXNjKGEpO2lmKFwifFwiIT15KGEuYSkpYT1iO2Vsc2V7Zm9yKGI9W2JdO1wifFwiPT16KGEuYSk7KU4oYSxcIk1pc3NpbmcgbmV4dCB1bmlvbiBsb2NhdGlvbiBwYXRoLlwiKSxiLnB1c2goc2MoYSkpO2EuYS5hLS07YT1uZXcgamMoYil9cmV0dXJuIGF9O2Z1bmN0aW9uIHZjKGEpe3N3aXRjaChhLm5vZGVUeXBlKXtjYXNlIDE6cmV0dXJuIGxhKHdjLGEpO2Nhc2UgOTpyZXR1cm4gdmMoYS5kb2N1bWVudEVsZW1lbnQpO2Nhc2UgMTE6Y2FzZSAxMDpjYXNlIDY6Y2FzZSAxMjpyZXR1cm4geGM7ZGVmYXVsdDpyZXR1cm4gYS5wYXJlbnROb2RlP3ZjKGEucGFyZW50Tm9kZSk6eGN9fWZ1bmN0aW9uIHhjKCl7cmV0dXJuIG51bGx9ZnVuY3Rpb24gd2MoYSxiKXtpZihhLnByZWZpeD09YilyZXR1cm4gYS5uYW1lc3BhY2VVUkl8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO3ZhciBjPWEuZ2V0QXR0cmlidXRlTm9kZShcInhtbG5zOlwiK2IpO3JldHVybiBjJiZjLnNwZWNpZmllZD9jLnZhbHVlfHxudWxsOmEucGFyZW50Tm9kZSYmOSE9YS5wYXJlbnROb2RlLm5vZGVUeXBlP3djKGEucGFyZW50Tm9kZSxiKTpudWxsfTtmdW5jdGlvbiB5YyhhLGIpe2lmKCFhLmxlbmd0aCl0aHJvdyBFcnJvcihcIkVtcHR5IFhQYXRoIGV4cHJlc3Npb24uXCIpO2E9WmEoYSk7aWYoYmIoYSkpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFhQYXRoIGV4cHJlc3Npb24uXCIpO2I/ZWEoYil8fChiPWthKGIubG9va3VwTmFtZXNwYWNlVVJJLGIpKTpiPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3ZhciBjPWxjKG5ldyBrYyhhLGIpKTtpZighYmIoYSkpdGhyb3cgRXJyb3IoXCJCYWQgdG9rZW46IFwiK3ooYSkpO3RoaXMuZXZhbHVhdGU9ZnVuY3Rpb24oZCxlKXtkPWMuYShuZXcgbWEoZCkpO3JldHVybiBuZXcgTyhkLGUpfX1cbmZ1bmN0aW9uIE8oYSxiKXtpZigwPT1iKWlmKGEgaW5zdGFuY2VvZiBDKWI9NDtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhKWI9MjtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBhKWI9MTtlbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYSliPTM7ZWxzZSB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgZXZhbHVhdGlvbiByZXN1bHQuXCIpO2lmKDIhPWImJjEhPWImJjMhPWImJiEoYSBpbnN0YW5jZW9mIEMpKXRocm93IEVycm9yKFwidmFsdWUgY291bGQgbm90IGJlIGNvbnZlcnRlZCB0byB0aGUgc3BlY2lmaWVkIHR5cGVcIik7dGhpcy5yZXN1bHRUeXBlPWI7c3dpdGNoKGIpe2Nhc2UgMjp0aGlzLnN0cmluZ1ZhbHVlPWEgaW5zdGFuY2VvZiBDP0JiKGEpOlwiXCIrYTticmVhaztjYXNlIDE6dGhpcy5udW1iZXJWYWx1ZT1hIGluc3RhbmNlb2YgQz8rQmIoYSk6K2E7YnJlYWs7Y2FzZSAzOnRoaXMuYm9vbGVhblZhbHVlPWEgaW5zdGFuY2VvZiBDPzA8YS5tOiEhYTticmVhaztjYXNlIDQ6Y2FzZSA1OmNhc2UgNjpjYXNlIDc6dmFyIGM9XG5DYihhKTt2YXIgZD1bXTtmb3IodmFyIGU9RShjKTtlO2U9RShjKSlkLnB1c2goZSBpbnN0YW5jZW9mIFdhP2UuYTplKTt0aGlzLnNuYXBzaG90TGVuZ3RoPWEubTt0aGlzLmludmFsaWRJdGVyYXRvclN0YXRlPSExO2JyZWFrO2Nhc2UgODpjYXNlIDk6YT16YihhKTt0aGlzLnNpbmdsZU5vZGVWYWx1ZT1hIGluc3RhbmNlb2YgV2E/YS5hOmE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVua25vd24gWFBhdGhSZXN1bHQgdHlwZS5cIik7fXZhciBmPTA7dGhpcy5pdGVyYXRlTmV4dD1mdW5jdGlvbigpe2lmKDQhPWImJjUhPWIpdGhyb3cgRXJyb3IoXCJpdGVyYXRlTmV4dCBjYWxsZWQgd2l0aCB3cm9uZyByZXN1bHQgdHlwZVwiKTtyZXR1cm4gZj49ZC5sZW5ndGg/bnVsbDpkW2YrK119O3RoaXMuc25hcHNob3RJdGVtPWZ1bmN0aW9uKGcpe2lmKDYhPWImJjchPWIpdGhyb3cgRXJyb3IoXCJzbmFwc2hvdEl0ZW0gY2FsbGVkIHdpdGggd3JvbmcgcmVzdWx0IHR5cGVcIik7cmV0dXJuIGc+PWQubGVuZ3RofHxcbjA+Zz9udWxsOmRbZ119fU8uQU5ZX1RZUEU9MDtPLk5VTUJFUl9UWVBFPTE7Ty5TVFJJTkdfVFlQRT0yO08uQk9PTEVBTl9UWVBFPTM7Ty5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFPTQ7Ty5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRT01O08uVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRT02O08uT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU9NztPLkFOWV9VTk9SREVSRURfTk9ERV9UWVBFPTg7Ty5GSVJTVF9PUkRFUkVEX05PREVfVFlQRT05O2Z1bmN0aW9uIHpjKGEpe3RoaXMubG9va3VwTmFtZXNwYWNlVVJJPXZjKGEpfVxuZnVuY3Rpb24gQWMoYSxiKXthPWF8fGFhO3ZhciBjPWEuRG9jdW1lbnQmJmEuRG9jdW1lbnQucHJvdG90eXBlfHxhLmRvY3VtZW50O2lmKCFjLmV2YWx1YXRlfHxiKWEuWFBhdGhSZXN1bHQ9TyxjLmV2YWx1YXRlPWZ1bmN0aW9uKGQsZSxmLGcpe3JldHVybihuZXcgeWMoZCxmKSkuZXZhbHVhdGUoZSxnKX0sYy5jcmVhdGVFeHByZXNzaW9uPWZ1bmN0aW9uKGQsZSl7cmV0dXJuIG5ldyB5YyhkLGUpfSxjLmNyZWF0ZU5TUmVzb2x2ZXI9ZnVuY3Rpb24oZCl7cmV0dXJuIG5ldyB6YyhkKX19Y2EoXCJ3Z3hwYXRoLmluc3RhbGxcIixBYyk7Y2EoXCJ3Z3hwYXRoLmluc3RhbGxcIixBYyk7dmFyIEJjPXdpbmRvdztmdW5jdGlvbiBQKGEsYil7dGhpcy5jb2RlPWE7dGhpcy5hPVFbYV18fENjO3RoaXMubWVzc2FnZT1ifHxcIlwiO2E9dGhpcy5hLnJlcGxhY2UoLygoPzpefFxccyspW2Etel0pL2csZnVuY3Rpb24oYyl7cmV0dXJuIGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9eW1xcc1xceGEwXSsvZyxcIlwiKX0pO2I9YS5sZW5ndGgtNTtpZigwPmJ8fGEuaW5kZXhPZihcIkVycm9yXCIsYikhPWIpYSs9XCJFcnJvclwiO3RoaXMubmFtZT1hO2E9RXJyb3IodGhpcy5tZXNzYWdlKTthLm5hbWU9dGhpcy5uYW1lO3RoaXMuc3RhY2s9YS5zdGFja3x8XCJcIn1rKFAsRXJyb3IpO3ZhciBDYz1cInVua25vd24gZXJyb3JcIixRPXsxNTpcImVsZW1lbnQgbm90IHNlbGVjdGFibGVcIiwxMTpcImVsZW1lbnQgbm90IHZpc2libGVcIn07UVszMV09Q2M7UVszMF09Q2M7UVsyNF09XCJpbnZhbGlkIGNvb2tpZSBkb21haW5cIjtRWzI5XT1cImludmFsaWQgZWxlbWVudCBjb29yZGluYXRlc1wiO1FbMTJdPVwiaW52YWxpZCBlbGVtZW50IHN0YXRlXCI7XG5RWzMyXT1cImludmFsaWQgc2VsZWN0b3JcIjtRWzUxXT1cImludmFsaWQgc2VsZWN0b3JcIjtRWzUyXT1cImludmFsaWQgc2VsZWN0b3JcIjtRWzE3XT1cImphdmFzY3JpcHQgZXJyb3JcIjtRWzQwNV09XCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIjtRWzM0XT1cIm1vdmUgdGFyZ2V0IG91dCBvZiBib3VuZHNcIjtRWzI3XT1cIm5vIHN1Y2ggYWxlcnRcIjtRWzddPVwibm8gc3VjaCBlbGVtZW50XCI7UVs4XT1cIm5vIHN1Y2ggZnJhbWVcIjtRWzIzXT1cIm5vIHN1Y2ggd2luZG93XCI7UVsyOF09XCJzY3JpcHQgdGltZW91dFwiO1FbMzNdPVwic2Vzc2lvbiBub3QgY3JlYXRlZFwiO1FbMTBdPVwic3RhbGUgZWxlbWVudCByZWZlcmVuY2VcIjtRWzIxXT1cInRpbWVvdXRcIjtRWzI1XT1cInVuYWJsZSB0byBzZXQgY29va2llXCI7UVsyNl09XCJ1bmV4cGVjdGVkIGFsZXJ0IG9wZW5cIjtRWzEzXT1DYztRWzldPVwidW5rbm93biBjb21tYW5kXCI7dmFyIERjPXtDOmZ1bmN0aW9uKGEpe3JldHVybiEoIWEucXVlcnlTZWxlY3RvckFsbHx8IWEucXVlcnlTZWxlY3Rvcil9LG86ZnVuY3Rpb24oYSxiKXtpZighYSl0aHJvdyBuZXcgUCgzMixcIk5vIGNsYXNzIG5hbWUgc3BlY2lmaWVkXCIpO2E9QWEoYSk7aWYoLTEhPT1hLmluZGV4T2YoXCIgXCIpKXRocm93IG5ldyBQKDMyLFwiQ29tcG91bmQgY2xhc3MgbmFtZXMgbm90IHBlcm1pdHRlZFwiKTtpZihEYy5DKGIpKXRyeXtyZXR1cm4gYi5xdWVyeVNlbGVjdG9yKFwiLlwiK2EucmVwbGFjZSgvXFwuL2csXCJcXFxcLlwiKSl8fG51bGx9Y2F0Y2goYyl7dGhyb3cgbmV3IFAoMzIsXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgY2xhc3MgbmFtZSB3YXMgc3BlY2lmaWVkXCIpO31hPW1iKGViKGIpLFwiKlwiLGEsYik7cmV0dXJuIGEubGVuZ3RoP2FbMF06bnVsbH0sajpmdW5jdGlvbihhLGIpe2lmKCFhKXRocm93IG5ldyBQKDMyLFwiTm8gY2xhc3MgbmFtZSBzcGVjaWZpZWRcIik7YT1BYShhKTtpZigtMSE9PWEuaW5kZXhPZihcIiBcIikpdGhyb3cgbmV3IFAoMzIsXG5cIkNvbXBvdW5kIGNsYXNzIG5hbWVzIG5vdCBwZXJtaXR0ZWRcIik7aWYoRGMuQyhiKSl0cnl7cmV0dXJuIGIucXVlcnlTZWxlY3RvckFsbChcIi5cIithLnJlcGxhY2UoL1xcLi9nLFwiXFxcXC5cIikpfWNhdGNoKGMpe3Rocm93IG5ldyBQKDMyLFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIGNsYXNzIG5hbWUgd2FzIHNwZWNpZmllZFwiKTt9cmV0dXJuIG1iKGViKGIpLFwiKlwiLGEsYil9fTt2YXIgRWM9RmEoKSxGYz1JYSgpfHxyKFwiaVBvZFwiKSxHYz1yKFwiaVBhZFwiKSxIYz1yKFwiQW5kcm9pZFwiKSYmIShHYSgpfHxGYSgpfHxyKFwiT3BlcmFcIil8fHIoXCJTaWxrXCIpKSxJYz1HYSgpLEpjPXIoXCJTYWZhcmlcIikmJiEoR2EoKXx8cihcIkNvYXN0XCIpfHxyKFwiT3BlcmFcIil8fHIoXCJFZGdlXCIpfHxyKFwiRWRnL1wiKXx8cihcIk9QUlwiKXx8RmEoKXx8cihcIlNpbGtcIil8fHIoXCJBbmRyb2lkXCIpKSYmIShJYSgpfHxyKFwiaVBhZFwiKXx8cihcImlQb2RcIikpO2Z1bmN0aW9uIEtjKGEpe3JldHVybihhPWEuZXhlYyhxKSk/YVsxXTpcIlwifShmdW5jdGlvbigpe2lmKEVjKXJldHVybiBLYygvRmlyZWZveFxcLyhbMC05Ll0rKS8pO2lmKHR8fE1hfHxMYSlyZXR1cm4gUWE7aWYoSWMpcmV0dXJuIElhKCl8fHIoXCJpUGFkXCIpfHxyKFwiaVBvZFwiKT9LYygvQ3JpT1NcXC8oWzAtOS5dKykvKTpLYygvQ2hyb21lXFwvKFswLTkuXSspLyk7aWYoSmMmJiEoSWEoKXx8cihcImlQYWRcIil8fHIoXCJpUG9kXCIpKSlyZXR1cm4gS2MoL1ZlcnNpb25cXC8oWzAtOS5dKykvKTtpZihGY3x8R2Mpe3ZhciBhPS9WZXJzaW9uXFwvKFxcUyspLipNb2JpbGVcXC8oXFxTKykvLmV4ZWMocSk7aWYoYSlyZXR1cm4gYVsxXStcIi5cIithWzJdfWVsc2UgaWYoSGMpcmV0dXJuKGE9S2MoL0FuZHJvaWRcXHMrKFswLTkuXSspLykpP2E6S2MoL1ZlcnNpb25cXC8oWzAtOS5dKykvKTtyZXR1cm5cIlwifSkoKTt2YXIgTGM9dCYmISg4PD1OdW1iZXIodykpLE1jPXQmJiEoOTw9TnVtYmVyKHcpKTt2YXIgTmM9e286ZnVuY3Rpb24oYSxiKXtpZighZWEoYi5xdWVyeVNlbGVjdG9yKSYmdCYmKHQ/MDw9QmEodyw4KTpVYSg4KSkmJiFoYShiLnF1ZXJ5U2VsZWN0b3IpKXRocm93IEVycm9yKFwiQ1NTIHNlbGVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKCFhKXRocm93IG5ldyBQKDMyLFwiTm8gc2VsZWN0b3Igc3BlY2lmaWVkXCIpO2E9QWEoYSk7dHJ5e3ZhciBjPWIucXVlcnlTZWxlY3RvcihhKX1jYXRjaChkKXt0aHJvdyBuZXcgUCgzMixcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzZWxlY3RvciB3YXMgc3BlY2lmaWVkXCIpO31yZXR1cm4gYyYmMT09Yy5ub2RlVHlwZT9jOm51bGx9LGo6ZnVuY3Rpb24oYSxiKXtpZighZWEoYi5xdWVyeVNlbGVjdG9yQWxsKSYmdCYmKHQ/MDw9QmEodyw4KTpVYSg4KSkmJiFoYShiLnF1ZXJ5U2VsZWN0b3IpKXRocm93IEVycm9yKFwiQ1NTIHNlbGVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKCFhKXRocm93IG5ldyBQKDMyLFwiTm8gc2VsZWN0b3Igc3BlY2lmaWVkXCIpO1xuYT1BYShhKTt0cnl7cmV0dXJuIGIucXVlcnlTZWxlY3RvckFsbChhKX1jYXRjaChjKXt0aHJvdyBuZXcgUCgzMixcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzZWxlY3RvciB3YXMgc3BlY2lmaWVkXCIpO319fTt2YXIgT2M9e2FsaWNlYmx1ZTpcIiNmMGY4ZmZcIixhbnRpcXVld2hpdGU6XCIjZmFlYmQ3XCIsYXF1YTpcIiMwMGZmZmZcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGF6dXJlOlwiI2YwZmZmZlwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGJpc3F1ZTpcIiNmZmU0YzRcIixibGFjazpcIiMwMDAwMDBcIixibGFuY2hlZGFsbW9uZDpcIiNmZmViY2RcIixibHVlOlwiIzAwMDBmZlwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsYnJvd246XCIjYTUyYTJhXCIsYnVybHl3b29kOlwiI2RlYjg4N1wiLGNhZGV0Ymx1ZTpcIiM1ZjllYTBcIixjaGFydHJldXNlOlwiIzdmZmYwMFwiLGNob2NvbGF0ZTpcIiNkMjY5MWVcIixjb3JhbDpcIiNmZjdmNTBcIixjb3JuZmxvd2VyYmx1ZTpcIiM2NDk1ZWRcIixjb3Juc2lsazpcIiNmZmY4ZGNcIixjcmltc29uOlwiI2RjMTQzY1wiLGN5YW46XCIjMDBmZmZmXCIsZGFya2JsdWU6XCIjMDAwMDhiXCIsZGFya2N5YW46XCIjMDA4YjhiXCIsZGFya2dvbGRlbnJvZDpcIiNiODg2MGJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsXG5kYXJrZ3JleTpcIiNhOWE5YTlcIixkYXJra2hha2k6XCIjYmRiNzZiXCIsZGFya21hZ2VudGE6XCIjOGIwMDhiXCIsZGFya29saXZlZ3JlZW46XCIjNTU2YjJmXCIsZGFya29yYW5nZTpcIiNmZjhjMDBcIixkYXJrb3JjaGlkOlwiIzk5MzJjY1wiLGRhcmtyZWQ6XCIjOGIwMDAwXCIsZGFya3NhbG1vbjpcIiNlOTk2N2FcIixkYXJrc2VhZ3JlZW46XCIjOGZiYzhmXCIsZGFya3NsYXRlYmx1ZTpcIiM0ODNkOGJcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGRhcmtzbGF0ZWdyZXk6XCIjMmY0ZjRmXCIsZGFya3R1cnF1b2lzZTpcIiMwMGNlZDFcIixkYXJrdmlvbGV0OlwiIzk0MDBkM1wiLGRlZXBwaW5rOlwiI2ZmMTQ5M1wiLGRlZXBza3libHVlOlwiIzAwYmZmZlwiLGRpbWdyYXk6XCIjNjk2OTY5XCIsZGltZ3JleTpcIiM2OTY5NjlcIixkb2RnZXJibHVlOlwiIzFlOTBmZlwiLGZpcmVicmljazpcIiNiMjIyMjJcIixmbG9yYWx3aGl0ZTpcIiNmZmZhZjBcIixmb3Jlc3RncmVlbjpcIiMyMjhiMjJcIixmdWNoc2lhOlwiI2ZmMDBmZlwiLGdhaW5zYm9ybzpcIiNkY2RjZGNcIixcbmdob3N0d2hpdGU6XCIjZjhmOGZmXCIsZ29sZDpcIiNmZmQ3MDBcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZ3JheTpcIiM4MDgwODBcIixncmVlbjpcIiMwMDgwMDBcIixncmVlbnllbGxvdzpcIiNhZGZmMmZcIixncmV5OlwiIzgwODA4MFwiLGhvbmV5ZGV3OlwiI2YwZmZmMFwiLGhvdHBpbms6XCIjZmY2OWI0XCIsaW5kaWFucmVkOlwiI2NkNWM1Y1wiLGluZGlnbzpcIiM0YjAwODJcIixpdm9yeTpcIiNmZmZmZjBcIixraGFraTpcIiNmMGU2OGNcIixsYXZlbmRlcjpcIiNlNmU2ZmFcIixsYXZlbmRlcmJsdXNoOlwiI2ZmZjBmNVwiLGxhd25ncmVlbjpcIiM3Y2ZjMDBcIixsZW1vbmNoaWZmb246XCIjZmZmYWNkXCIsbGlnaHRibHVlOlwiI2FkZDhlNlwiLGxpZ2h0Y29yYWw6XCIjZjA4MDgwXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGxpZ2h0Z29sZGVucm9keWVsbG93OlwiI2ZhZmFkMlwiLGxpZ2h0Z3JheTpcIiNkM2QzZDNcIixsaWdodGdyZWVuOlwiIzkwZWU5MFwiLGxpZ2h0Z3JleTpcIiNkM2QzZDNcIixsaWdodHBpbms6XCIjZmZiNmMxXCIsbGlnaHRzYWxtb246XCIjZmZhMDdhXCIsXG5saWdodHNlYWdyZWVuOlwiIzIwYjJhYVwiLGxpZ2h0c2t5Ymx1ZTpcIiM4N2NlZmFcIixsaWdodHNsYXRlZ3JheTpcIiM3Nzg4OTlcIixsaWdodHNsYXRlZ3JleTpcIiM3Nzg4OTlcIixsaWdodHN0ZWVsYmx1ZTpcIiNiMGM0ZGVcIixsaWdodHllbGxvdzpcIiNmZmZmZTBcIixsaW1lOlwiIzAwZmYwMFwiLGxpbWVncmVlbjpcIiMzMmNkMzJcIixsaW5lbjpcIiNmYWYwZTZcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLG1hcm9vbjpcIiM4MDAwMDBcIixtZWRpdW1hcXVhbWFyaW5lOlwiIzY2Y2RhYVwiLG1lZGl1bWJsdWU6XCIjMDAwMGNkXCIsbWVkaXVtb3JjaGlkOlwiI2JhNTVkM1wiLG1lZGl1bXB1cnBsZTpcIiM5MzcwZGJcIixtZWRpdW1zZWFncmVlbjpcIiMzY2IzNzFcIixtZWRpdW1zbGF0ZWJsdWU6XCIjN2I2OGVlXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBmYTlhXCIsbWVkaXVtdHVycXVvaXNlOlwiIzQ4ZDFjY1wiLG1lZGl1bXZpb2xldHJlZDpcIiNjNzE1ODVcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbWludGNyZWFtOlwiI2Y1ZmZmYVwiLG1pc3R5cm9zZTpcIiNmZmU0ZTFcIixcbm1vY2Nhc2luOlwiI2ZmZTRiNVwiLG5hdmFqb3doaXRlOlwiI2ZmZGVhZFwiLG5hdnk6XCIjMDAwMDgwXCIsb2xkbGFjZTpcIiNmZGY1ZTZcIixvbGl2ZTpcIiM4MDgwMDBcIixvbGl2ZWRyYWI6XCIjNmI4ZTIzXCIsb3JhbmdlOlwiI2ZmYTUwMFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixvcmNoaWQ6XCIjZGE3MGQ2XCIscGFsZWdvbGRlbnJvZDpcIiNlZWU4YWFcIixwYWxlZ3JlZW46XCIjOThmYjk4XCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixwYWxldmlvbGV0cmVkOlwiI2RiNzA5M1wiLHBhcGF5YXdoaXA6XCIjZmZlZmQ1XCIscGVhY2hwdWZmOlwiI2ZmZGFiOVwiLHBlcnU6XCIjY2Q4NTNmXCIscGluazpcIiNmZmMwY2JcIixwbHVtOlwiI2RkYTBkZFwiLHBvd2RlcmJsdWU6XCIjYjBlMGU2XCIscHVycGxlOlwiIzgwMDA4MFwiLHJlZDpcIiNmZjAwMDBcIixyb3N5YnJvd246XCIjYmM4ZjhmXCIscm95YWxibHVlOlwiIzQxNjllMVwiLHNhZGRsZWJyb3duOlwiIzhiNDUxM1wiLHNhbG1vbjpcIiNmYTgwNzJcIixzYW5keWJyb3duOlwiI2Y0YTQ2MFwiLHNlYWdyZWVuOlwiIzJlOGI1N1wiLFxuc2Vhc2hlbGw6XCIjZmZmNWVlXCIsc2llbm5hOlwiI2EwNTIyZFwiLHNpbHZlcjpcIiNjMGMwYzBcIixza3libHVlOlwiIzg3Y2VlYlwiLHNsYXRlYmx1ZTpcIiM2YTVhY2RcIixzbGF0ZWdyYXk6XCIjNzA4MDkwXCIsc2xhdGVncmV5OlwiIzcwODA5MFwiLHNub3c6XCIjZmZmYWZhXCIsc3ByaW5nZ3JlZW46XCIjMDBmZjdmXCIsc3RlZWxibHVlOlwiIzQ2ODJiNFwiLHRhbjpcIiNkMmI0OGNcIix0ZWFsOlwiIzAwODA4MFwiLHRoaXN0bGU6XCIjZDhiZmQ4XCIsdG9tYXRvOlwiI2ZmNjM0N1wiLHR1cnF1b2lzZTpcIiM0MGUwZDBcIix2aW9sZXQ6XCIjZWU4MmVlXCIsd2hlYXQ6XCIjZjVkZWIzXCIsd2hpdGU6XCIjZmZmZmZmXCIsd2hpdGVzbW9rZTpcIiNmNWY1ZjVcIix5ZWxsb3c6XCIjZmZmZjAwXCIseWVsbG93Z3JlZW46XCIjOWFjZDMyXCJ9O3ZhciBQYz1cImJhY2tncm91bmRDb2xvciBib3JkZXJUb3BDb2xvciBib3JkZXJSaWdodENvbG9yIGJvcmRlckJvdHRvbUNvbG9yIGJvcmRlckxlZnRDb2xvciBjb2xvciBvdXRsaW5lQ29sb3JcIi5zcGxpdChcIiBcIiksUWM9LyMoWzAtOWEtZkEtRl0pKFswLTlhLWZBLUZdKShbMC05YS1mQS1GXSkvLFJjPS9eIyg/OlswLTlhLWZdezN9KXsxLDJ9JC9pLFNjPS9eKD86cmdiYSk/XFwoKFxcZHsxLDN9KSxcXHM/KFxcZHsxLDN9KSxcXHM/KFxcZHsxLDN9KSxcXHM/KDB8MXwwXFwuXFxkKilcXCkkL2ksVGM9L14oPzpyZ2IpP1xcKCgwfFsxLTldXFxkezAsMn0pLFxccz8oMHxbMS05XVxcZHswLDJ9KSxcXHM/KDB8WzEtOV1cXGR7MCwyfSlcXCkkL2k7ZnVuY3Rpb24gVWMoYSxiKXtiPWIudG9Mb3dlckNhc2UoKTtyZXR1cm5cInN0eWxlXCI9PWI/VmMoYS5zdHlsZS5jc3NUZXh0KTpMYyYmXCJ2YWx1ZVwiPT1iJiZTKGEsXCJJTlBVVFwiKT9hLnZhbHVlOk1jJiYhMD09PWFbYl0/U3RyaW5nKGEuZ2V0QXR0cmlidXRlKGIpKTooYT1hLmdldEF0dHJpYnV0ZU5vZGUoYikpJiZhLnNwZWNpZmllZD9hLnZhbHVlOm51bGx9dmFyIFdjPS9bO10rKD89KD86KD86W15cIl0qXCIpezJ9KSpbXlwiXSokKSg/PSg/Oig/OlteJ10qJyl7Mn0pKlteJ10qJCkoPz0oPzpbXigpXSpcXChbXigpXSpcXCkpKlteKCldKiQpLztcbmZ1bmN0aW9uIFZjKGEpe3ZhciBiPVtdO2woYS5zcGxpdChXYyksZnVuY3Rpb24oYyl7dmFyIGQ9Yy5pbmRleE9mKFwiOlwiKTswPGQmJihjPVtjLnNsaWNlKDAsZCksYy5zbGljZShkKzEpXSwyPT1jLmxlbmd0aCYmYi5wdXNoKGNbMF0udG9Mb3dlckNhc2UoKSxcIjpcIixjWzFdLFwiO1wiKSl9KTtiPWIuam9pbihcIlwiKTtyZXR1cm4gYj1cIjtcIj09Yi5jaGFyQXQoYi5sZW5ndGgtMSk/YjpiK1wiO1wifWZ1bmN0aW9uIFMoYSxiKXtiJiZcInN0cmluZ1wiIT09dHlwZW9mIGImJihiPWIudG9TdHJpbmcoKSk7cmV0dXJuISFhJiYxPT1hLm5vZGVUeXBlJiYoIWJ8fGEudGFnTmFtZS50b1VwcGVyQ2FzZSgpPT1iKX07dmFyIFQ9e307VC5JPWZ1bmN0aW9uKCl7dmFyIGE9e2RhOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn07cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiBhW2JdfHxudWxsfX0oKTtcblQucz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9QShhKTtpZighZC5kb2N1bWVudEVsZW1lbnQpcmV0dXJuIG51bGw7KHR8fEhjKSYmQWMoZD9kLnBhcmVudFdpbmRvd3x8ZC5kZWZhdWx0Vmlldzp3aW5kb3cpO3RyeXt2YXIgZT1kLmNyZWF0ZU5TUmVzb2x2ZXI/ZC5jcmVhdGVOU1Jlc29sdmVyKGQuZG9jdW1lbnRFbGVtZW50KTpULkk7aWYodCYmIVVhKDcpKXJldHVybiBkLmV2YWx1YXRlLmNhbGwoZCxiLGEsZSxjLG51bGwpO2lmKCF0fHw5PD1OdW1iZXIodykpe2Zvcih2YXIgZj17fSxnPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLGg9MDtoPGcubGVuZ3RoOysraCl7dmFyIG49Z1toXSx1PW4ubmFtZXNwYWNlVVJJO2lmKHUmJiFmW3VdKXt2YXIgcD1uLmxvb2t1cFByZWZpeCh1KTtpZighcCl7dmFyIEc9dS5tYXRjaChcIi4qLyhcXFxcdyspLz8kXCIpO3A9Rz9HWzFdOlwieGh0bWxcIn1mW3VdPXB9fXZhciBSPXt9LGZhO2ZvcihmYSBpbiBmKVJbZltmYV1dPWZhO2U9ZnVuY3Rpb24obSl7cmV0dXJuIFJbbV18fFxubnVsbH19dHJ5e3JldHVybiBkLmV2YWx1YXRlKGIsYSxlLGMsbnVsbCl9Y2F0Y2gobSl7aWYoXCJUeXBlRXJyb3JcIj09PW0ubmFtZSlyZXR1cm4gZT1kLmNyZWF0ZU5TUmVzb2x2ZXI/ZC5jcmVhdGVOU1Jlc29sdmVyKGQuZG9jdW1lbnRFbGVtZW50KTpULkksZC5ldmFsdWF0ZShiLGEsZSxjLG51bGwpO3Rocm93IG07fX1jYXRjaChtKXtpZighTmF8fFwiTlNfRVJST1JfSUxMRUdBTF9WQUxVRVwiIT1tLm5hbWUpdGhyb3cgbmV3IFAoMzIsXCJVbmFibGUgdG8gbG9jYXRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgeHBhdGggZXhwcmVzc2lvbiBcIitiK1wiIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcjpcXG5cIittKTt9fTtULko9ZnVuY3Rpb24oYSxiKXtpZighYXx8MSE9YS5ub2RlVHlwZSl0aHJvdyBuZXcgUCgzMiwnVGhlIHJlc3VsdCBvZiB0aGUgeHBhdGggZXhwcmVzc2lvbiBcIicrYisnXCIgaXM6ICcrYStcIi4gSXQgc2hvdWxkIGJlIGFuIGVsZW1lbnQuXCIpO307XG5ULm89ZnVuY3Rpb24oYSxiKXt2YXIgYz1mdW5jdGlvbigpe3ZhciBkPVQucyhiLGEsOSk7cmV0dXJuIGQ/ZC5zaW5nbGVOb2RlVmFsdWV8fG51bGw6Yi5zZWxlY3RTaW5nbGVOb2RlPyhkPUEoYiksZC5zZXRQcm9wZXJ0eSYmZC5zZXRQcm9wZXJ0eShcIlNlbGVjdGlvbkxhbmd1YWdlXCIsXCJYUGF0aFwiKSxiLnNlbGVjdFNpbmdsZU5vZGUoYSkpOm51bGx9KCk7bnVsbD09PWN8fFQuSihjLGEpO3JldHVybiBjfTtcblQuaj1mdW5jdGlvbihhLGIpe3ZhciBjPWZ1bmN0aW9uKCl7dmFyIGQ9VC5zKGIsYSw3KTtpZihkKXtmb3IodmFyIGU9ZC5zbmFwc2hvdExlbmd0aCxmPVtdLGc9MDtnPGU7KytnKWYucHVzaChkLnNuYXBzaG90SXRlbShnKSk7cmV0dXJuIGZ9cmV0dXJuIGIuc2VsZWN0Tm9kZXM/KGQ9QShiKSxkLnNldFByb3BlcnR5JiZkLnNldFByb3BlcnR5KFwiU2VsZWN0aW9uTGFuZ3VhZ2VcIixcIlhQYXRoXCIpLGIuc2VsZWN0Tm9kZXMoYSkpOltdfSgpO2woYyxmdW5jdGlvbihkKXtULkooZCxhKX0pO3JldHVybiBjfTtmdW5jdGlvbiBYYyhhLGIsYyxkKXt0aGlzLmM9YTt0aGlzLmE9Yjt0aGlzLmI9Yzt0aGlzLmY9ZH1YYy5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3RoaXMuYz1NYXRoLmNlaWwodGhpcy5jKTt0aGlzLmE9TWF0aC5jZWlsKHRoaXMuYSk7dGhpcy5iPU1hdGguY2VpbCh0aGlzLmIpO3RoaXMuZj1NYXRoLmNlaWwodGhpcy5mKTtyZXR1cm4gdGhpc307WGMucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7dGhpcy5jPU1hdGguZmxvb3IodGhpcy5jKTt0aGlzLmE9TWF0aC5mbG9vcih0aGlzLmEpO3RoaXMuYj1NYXRoLmZsb29yKHRoaXMuYik7dGhpcy5mPU1hdGguZmxvb3IodGhpcy5mKTtyZXR1cm4gdGhpc307WGMucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKCl7dGhpcy5jPU1hdGgucm91bmQodGhpcy5jKTt0aGlzLmE9TWF0aC5yb3VuZCh0aGlzLmEpO3RoaXMuYj1NYXRoLnJvdW5kKHRoaXMuYik7dGhpcy5mPU1hdGgucm91bmQodGhpcy5mKTtyZXR1cm4gdGhpc307ZnVuY3Rpb24gVShhLGIsYyxkKXt0aGlzLmE9YTt0aGlzLmI9Yjt0aGlzLndpZHRoPWM7dGhpcy5oZWlnaHQ9ZH1VLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKCl7dGhpcy5hPU1hdGguY2VpbCh0aGlzLmEpO3RoaXMuYj1NYXRoLmNlaWwodGhpcy5iKTt0aGlzLndpZHRoPU1hdGguY2VpbCh0aGlzLndpZHRoKTt0aGlzLmhlaWdodD1NYXRoLmNlaWwodGhpcy5oZWlnaHQpO3JldHVybiB0aGlzfTtVLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3RoaXMuYT1NYXRoLmZsb29yKHRoaXMuYSk7dGhpcy5iPU1hdGguZmxvb3IodGhpcy5iKTt0aGlzLndpZHRoPU1hdGguZmxvb3IodGhpcy53aWR0aCk7dGhpcy5oZWlnaHQ9TWF0aC5mbG9vcih0aGlzLmhlaWdodCk7cmV0dXJuIHRoaXN9O1xuVS5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXt0aGlzLmE9TWF0aC5yb3VuZCh0aGlzLmEpO3RoaXMuYj1NYXRoLnJvdW5kKHRoaXMuYik7dGhpcy53aWR0aD1NYXRoLnJvdW5kKHRoaXMud2lkdGgpO3RoaXMuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5oZWlnaHQpO3JldHVybiB0aGlzfTt2YXIgWWM9XCJmdW5jdGlvblwiPT09dHlwZW9mIFNoYWRvd1Jvb3Q7ZnVuY3Rpb24gWmMoYSl7Zm9yKGE9YS5wYXJlbnROb2RlO2EmJjEhPWEubm9kZVR5cGUmJjkhPWEubm9kZVR5cGUmJjExIT1hLm5vZGVUeXBlOylhPWEucGFyZW50Tm9kZTtyZXR1cm4gUyhhKT9hOm51bGx9XG5mdW5jdGlvbiBWKGEsYil7Yj1IYShiKTtpZihcImZsb2F0XCI9PWJ8fFwiY3NzRmxvYXRcIj09Ynx8XCJzdHlsZUZsb2F0XCI9PWIpYj1NYz9cInN0eWxlRmxvYXRcIjpcImNzc0Zsb2F0XCI7YTp7dmFyIGM9Yjt2YXIgZD1BKGEpO2lmKGQuZGVmYXVsdFZpZXcmJmQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSYmKGQ9ZC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGEsbnVsbCkpKXtjPWRbY118fGQuZ2V0UHJvcGVydHlWYWx1ZShjKXx8XCJcIjticmVhayBhfWM9XCJcIn1hPWN8fCRjKGEsYik7aWYobnVsbD09PWEpYT1udWxsO2Vsc2UgaWYoMDw9b2EoUGMsYikpe2I6e3ZhciBlPWEubWF0Y2goU2MpO2lmKGUmJihiPU51bWJlcihlWzFdKSxjPU51bWJlcihlWzJdKSxkPU51bWJlcihlWzNdKSxlPU51bWJlcihlWzRdKSwwPD1iJiYyNTU+PWImJjA8PWMmJjI1NT49YyYmMDw9ZCYmMjU1Pj1kJiYwPD1lJiYxPj1lKSl7Yj1bYixjLGQsZV07YnJlYWsgYn1iPW51bGx9aWYoIWIpYjp7aWYoZD1hLm1hdGNoKFRjKSlpZihiPVxuTnVtYmVyKGRbMV0pLGM9TnVtYmVyKGRbMl0pLGQ9TnVtYmVyKGRbM10pLDA8PWImJjI1NT49YiYmMDw9YyYmMjU1Pj1jJiYwPD1kJiYyNTU+PWQpe2I9W2IsYyxkLDFdO2JyZWFrIGJ9Yj1udWxsfWlmKCFiKWI6e2I9YS50b0xvd2VyQ2FzZSgpO2M9T2NbYi50b0xvd2VyQ2FzZSgpXTtpZighYyYmKGM9XCIjXCI9PWIuY2hhckF0KDApP2I6XCIjXCIrYiw0PT1jLmxlbmd0aCYmKGM9Yy5yZXBsYWNlKFFjLFwiIyQxJDEkMiQyJDMkM1wiKSksIVJjLnRlc3QoYykpKXtiPW51bGw7YnJlYWsgYn1iPVtwYXJzZUludChjLnN1YnN0cigxLDIpLDE2KSxwYXJzZUludChjLnN1YnN0cigzLDIpLDE2KSxwYXJzZUludChjLnN1YnN0cig1LDIpLDE2KSwxXX1hPWI/XCJyZ2JhKFwiK2Iuam9pbihcIiwgXCIpK1wiKVwiOmF9cmV0dXJuIGF9XG5mdW5jdGlvbiAkYyhhLGIpe3ZhciBjPWEuY3VycmVudFN0eWxlfHxhLnN0eWxlLGQ9Y1tiXTt2b2lkIDA9PT1kJiZlYShjLmdldFByb3BlcnR5VmFsdWUpJiYoZD1jLmdldFByb3BlcnR5VmFsdWUoYikpO3JldHVyblwiaW5oZXJpdFwiIT1kP3ZvaWQgMCE9PWQ/ZDpudWxsOihhPVpjKGEpKT8kYyhhLGIpOm51bGx9XG5mdW5jdGlvbiBhZChhLGIsYyl7ZnVuY3Rpb24gZChnKXt2YXIgaD1XKGcpO3JldHVybiAwPGguaGVpZ2h0JiYwPGgud2lkdGg/ITA6UyhnLFwiUEFUSFwiKSYmKDA8aC5oZWlnaHR8fDA8aC53aWR0aCk/KGc9VihnLFwic3Ryb2tlLXdpZHRoXCIpLCEhZyYmMDxwYXJzZUludChnLDEwKSk6XCJoaWRkZW5cIiE9VihnLFwib3ZlcmZsb3dcIikmJnNhKGcuY2hpbGROb2RlcyxmdW5jdGlvbihuKXtyZXR1cm4gMz09bi5ub2RlVHlwZXx8UyhuKSYmZChuKX0pfWZ1bmN0aW9uIGUoZyl7cmV0dXJuIGJkKGcpPT1YJiZ0YShnLmNoaWxkTm9kZXMsZnVuY3Rpb24oaCl7cmV0dXJuIVMoaCl8fGUoaCl8fCFkKGgpfSl9aWYoIVMoYSkpdGhyb3cgRXJyb3IoXCJBcmd1bWVudCB0byBpc1Nob3duIG11c3QgYmUgb2YgdHlwZSBFbGVtZW50XCIpO2lmKFMoYSxcIkJPRFlcIikpcmV0dXJuITA7aWYoUyhhLFwiT1BUSU9OXCIpfHxTKGEsXCJPUFRHUk9VUFwiKSlyZXR1cm4gYT1sYihhLGZ1bmN0aW9uKGcpe3JldHVybiBTKGcsXCJTRUxFQ1RcIil9KSxcbiEhYSYmYWQoYSwhMCxjKTt2YXIgZj1jZChhKTtpZihmKXJldHVybiEhZi5pbWFnZSYmMDxmLnJlY3Qud2lkdGgmJjA8Zi5yZWN0LmhlaWdodCYmYWQoZi5pbWFnZSxiLGMpO2lmKFMoYSxcIklOUFVUXCIpJiZcImhpZGRlblwiPT1hLnR5cGUudG9Mb3dlckNhc2UoKXx8UyhhLFwiTk9TQ1JJUFRcIikpcmV0dXJuITE7Zj1WKGEsXCJ2aXNpYmlsaXR5XCIpO3JldHVyblwiY29sbGFwc2VcIiE9ZiYmXCJoaWRkZW5cIiE9ZiYmYyhhKSYmKGJ8fDAhPWRkKGEpKSYmZChhKT8hZShhKTohMX1cbmZ1bmN0aW9uIGVkKGEpe2Z1bmN0aW9uIGIoYyl7aWYoUyhjKSYmXCJub25lXCI9PVYoYyxcImRpc3BsYXlcIikpcmV0dXJuITE7dmFyIGQ7aWYoKGQ9Yy5wYXJlbnROb2RlKSYmZC5zaGFkb3dSb290JiZ2b2lkIDAhPT1jLmFzc2lnbmVkU2xvdClkPWMuYXNzaWduZWRTbG90P2MuYXNzaWduZWRTbG90LnBhcmVudE5vZGU6bnVsbDtlbHNlIGlmKGMuZ2V0RGVzdGluYXRpb25JbnNlcnRpb25Qb2ludHMpe3ZhciBlPWMuZ2V0RGVzdGluYXRpb25JbnNlcnRpb25Qb2ludHMoKTswPGUubGVuZ3RoJiYoZD1lW2UubGVuZ3RoLTFdKX1pZihZYyYmZCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Qpe2lmKGQuaG9zdC5zaGFkb3dSb290IT09ZClyZXR1cm4hMTtkPWQuaG9zdH1yZXR1cm4hZHx8OSE9ZC5ub2RlVHlwZSYmMTEhPWQubm9kZVR5cGU/ZCYmUyhkLFwiREVUQUlMU1wiKSYmIWQub3BlbiYmIVMoYyxcIlNVTU1BUllcIik/ITE6ISFkJiZiKGQpOiEwfXJldHVybiBhZChhLCExLGIpfXZhciBYPVwiaGlkZGVuXCI7XG5mdW5jdGlvbiBiZChhKXtmdW5jdGlvbiBiKG0pe2Z1bmN0aW9uIHYoQWIpe2lmKEFiPT1nKXJldHVybiEwO3ZhciBwYz1WKEFiLFwiZGlzcGxheVwiKTtyZXR1cm4gMD09cGMubGFzdEluZGV4T2YoXCJpbmxpbmVcIiwwKXx8XCJjb250ZW50c1wiPT1wY3x8XCJhYnNvbHV0ZVwiPT1xYyYmXCJzdGF0aWNcIj09VihBYixcInBvc2l0aW9uXCIpPyExOiEwfXZhciBxYz1WKG0sXCJwb3NpdGlvblwiKTtpZihcImZpeGVkXCI9PXFjKXJldHVybiB1PSEwLG09PWc/bnVsbDpnO2ZvcihtPVpjKG0pO20mJiF2KG0pOyltPVpjKG0pO3JldHVybiBtfWZ1bmN0aW9uIGMobSl7dmFyIHY9bTtpZihcInZpc2libGVcIj09bilpZihtPT1nJiZoKXY9aDtlbHNlIGlmKG09PWgpcmV0dXJue3g6XCJ2aXNpYmxlXCIseTpcInZpc2libGVcIn07dj17eDpWKHYsXCJvdmVyZmxvdy14XCIpLHk6Vih2LFwib3ZlcmZsb3cteVwiKX07bT09ZyYmKHYueD1cInZpc2libGVcIj09di54P1wiYXV0b1wiOnYueCx2Lnk9XCJ2aXNpYmxlXCI9PXYueT9cImF1dG9cIjp2LnkpO3JldHVybiB2fVxuZnVuY3Rpb24gZChtKXtpZihtPT1nKXt2YXIgdj0obmV3IGZiKGYpKS5hO209di5zY3JvbGxpbmdFbGVtZW50P3Yuc2Nyb2xsaW5nRWxlbWVudDpPYXx8XCJDU1MxQ29tcGF0XCIhPXYuY29tcGF0TW9kZT92LmJvZHl8fHYuZG9jdW1lbnRFbGVtZW50OnYuZG9jdW1lbnRFbGVtZW50O3Y9di5wYXJlbnRXaW5kb3d8fHYuZGVmYXVsdFZpZXc7bT10JiZVYShcIjEwXCIpJiZ2LnBhZ2VZT2Zmc2V0IT1tLnNjcm9sbFRvcD9uZXcgY2IobS5zY3JvbGxMZWZ0LG0uc2Nyb2xsVG9wKTpuZXcgY2Iodi5wYWdlWE9mZnNldHx8bS5zY3JvbGxMZWZ0LHYucGFnZVlPZmZzZXR8fG0uc2Nyb2xsVG9wKX1lbHNlIG09bmV3IGNiKG0uc2Nyb2xsTGVmdCxtLnNjcm9sbFRvcCk7cmV0dXJuIG19dmFyIGU9ZmQoYSksZj1BKGEpLGc9Zi5kb2N1bWVudEVsZW1lbnQsaD1mLmJvZHksbj1WKGcsXCJvdmVyZmxvd1wiKSx1O2ZvcihhPWIoYSk7YTthPWIoYSkpe3ZhciBwPWMoYSk7aWYoXCJ2aXNpYmxlXCIhPXAueHx8XCJ2aXNpYmxlXCIhPVxucC55KXt2YXIgRz1XKGEpO2lmKDA9PUcud2lkdGh8fDA9PUcuaGVpZ2h0KXJldHVybiBYO3ZhciBSPWUuYTxHLmEsZmE9ZS5iPEcuYjtpZihSJiZcImhpZGRlblwiPT1wLnh8fGZhJiZcImhpZGRlblwiPT1wLnkpcmV0dXJuIFg7aWYoUiYmXCJ2aXNpYmxlXCIhPXAueHx8ZmEmJlwidmlzaWJsZVwiIT1wLnkpe1I9ZChhKTtmYT1lLmI8Ry5iLVIueTtpZihlLmE8Ry5hLVIueCYmXCJ2aXNpYmxlXCIhPXAueHx8ZmEmJlwidmlzaWJsZVwiIT1wLngpcmV0dXJuIFg7ZT1iZChhKTtyZXR1cm4gZT09WD9YOlwic2Nyb2xsXCJ9Uj1lLmY+PUcuYStHLndpZHRoO0c9ZS5jPj1HLmIrRy5oZWlnaHQ7aWYoUiYmXCJoaWRkZW5cIj09cC54fHxHJiZcImhpZGRlblwiPT1wLnkpcmV0dXJuIFg7aWYoUiYmXCJ2aXNpYmxlXCIhPXAueHx8RyYmXCJ2aXNpYmxlXCIhPXAueSl7aWYodSYmKHA9ZChhKSxlLmY+PWcuc2Nyb2xsV2lkdGgtcC54fHxlLmE+PWcuc2Nyb2xsSGVpZ2h0LXAueSkpcmV0dXJuIFg7ZT1iZChhKTtyZXR1cm4gZT09WD9YOlxuXCJzY3JvbGxcIn19fXJldHVyblwibm9uZVwifVxuZnVuY3Rpb24gVyhhKXt2YXIgYj1jZChhKTtpZihiKXJldHVybiBiLnJlY3Q7aWYoUyhhLFwiSFRNTFwiKSlyZXR1cm4gYT1BKGEpLGE9KChhP2EucGFyZW50V2luZG93fHxhLmRlZmF1bHRWaWV3OndpbmRvdyl8fHdpbmRvdykuZG9jdW1lbnQsYT1cIkNTUzFDb21wYXRcIj09YS5jb21wYXRNb2RlP2EuZG9jdW1lbnRFbGVtZW50OmEuYm9keSxhPW5ldyBkYihhLmNsaWVudFdpZHRoLGEuY2xpZW50SGVpZ2h0KSxuZXcgVSgwLDAsYS53aWR0aCxhLmhlaWdodCk7dHJ5e3ZhciBjPWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9Y2F0Y2goZCl7cmV0dXJuIG5ldyBVKDAsMCwwLDApfWI9bmV3IFUoYy5sZWZ0LGMudG9wLGMucmlnaHQtYy5sZWZ0LGMuYm90dG9tLWMudG9wKTt0JiZhLm93bmVyRG9jdW1lbnQuYm9keSYmKGE9QShhKSxiLmEtPWEuZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnQrYS5ib2R5LmNsaWVudExlZnQsYi5iLT1hLmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3ArYS5ib2R5LmNsaWVudFRvcCk7XG5yZXR1cm4gYn1mdW5jdGlvbiBjZChhKXt2YXIgYj1TKGEsXCJNQVBcIik7aWYoIWImJiFTKGEsXCJBUkVBXCIpKXJldHVybiBudWxsO3ZhciBjPWI/YTpTKGEucGFyZW50Tm9kZSxcIk1BUFwiKT9hLnBhcmVudE5vZGU6bnVsbCxkPW51bGwsZT1udWxsO2MmJmMubmFtZSYmKGQ9VC5vKCcvZGVzY2VuZGFudDo6KltAdXNlbWFwID0gXCIjJytjLm5hbWUrJ1wiXScsQShjKSkpJiYoZT1XKGQpLGJ8fFwiZGVmYXVsdFwiPT1hLnNoYXBlLnRvTG93ZXJDYXNlKCl8fChhPWdkKGEpLGI9TWF0aC5taW4oTWF0aC5tYXgoYS5hLDApLGUud2lkdGgpLGM9TWF0aC5taW4oTWF0aC5tYXgoYS5iLDApLGUuaGVpZ2h0KSxlPW5ldyBVKGIrZS5hLGMrZS5iLE1hdGgubWluKGEud2lkdGgsZS53aWR0aC1iKSxNYXRoLm1pbihhLmhlaWdodCxlLmhlaWdodC1jKSkpKTtyZXR1cm57aW1hZ2U6ZCxyZWN0OmV8fG5ldyBVKDAsMCwwLDApfX1cbmZ1bmN0aW9uIGdkKGEpe3ZhciBiPWEuc2hhcGUudG9Mb3dlckNhc2UoKTthPWEuY29vcmRzLnNwbGl0KFwiLFwiKTtpZihcInJlY3RcIj09YiYmND09YS5sZW5ndGgpe2I9YVswXTt2YXIgYz1hWzFdO3JldHVybiBuZXcgVShiLGMsYVsyXS1iLGFbM10tYyl9aWYoXCJjaXJjbGVcIj09YiYmMz09YS5sZW5ndGgpcmV0dXJuIGI9YVsyXSxuZXcgVShhWzBdLWIsYVsxXS1iLDIqYiwyKmIpO2lmKFwicG9seVwiPT1iJiYyPGEubGVuZ3RoKXtiPWFbMF07Yz1hWzFdO2Zvcih2YXIgZD1iLGU9YyxmPTI7ZisxPGEubGVuZ3RoO2YrPTIpYj1NYXRoLm1pbihiLGFbZl0pLGQ9TWF0aC5tYXgoZCxhW2ZdKSxjPU1hdGgubWluKGMsYVtmKzFdKSxlPU1hdGgubWF4KGUsYVtmKzFdKTtyZXR1cm4gbmV3IFUoYixjLGQtYixlLWMpfXJldHVybiBuZXcgVSgwLDAsMCwwKX1mdW5jdGlvbiBmZChhKXthPVcoYSk7cmV0dXJuIG5ldyBYYyhhLmIsYS5hK2Eud2lkdGgsYS5iK2EuaGVpZ2h0LGEuYSl9XG5mdW5jdGlvbiBoZChhKXtyZXR1cm4gYS5yZXBsYWNlKC9eW15cXFNcXHhhMF0rfFteXFxTXFx4YTBdKyQvZyxcIlwiKX1mdW5jdGlvbiBpZChhKXt2YXIgYj1bXTtZYz9qZChhLGIpOmtkKGEsYik7YT1xYShiLGhkKTtyZXR1cm4gaGQoYS5qb2luKFwiXFxuXCIpKS5yZXBsYWNlKC9cXHhhMC9nLFwiIFwiKX1cbmZ1bmN0aW9uIGxkKGEsYixjKXtpZihTKGEsXCJCUlwiKSliLnB1c2goXCJcIik7ZWxzZXt2YXIgZD1TKGEsXCJURFwiKSxlPVYoYSxcImRpc3BsYXlcIiksZj0hZCYmISgwPD1vYShtZCxlKSksZz12b2lkIDAhPT1hLnByZXZpb3VzRWxlbWVudFNpYmxpbmc/YS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOmdiKGEucHJldmlvdXNTaWJsaW5nKTtnPWc/VihnLFwiZGlzcGxheVwiKTpcIlwiO3ZhciBoPVYoYSxcImZsb2F0XCIpfHxWKGEsXCJjc3NGbG9hdFwiKXx8VihhLFwic3R5bGVGbG9hdFwiKTshZnx8XCJydW4taW5cIj09ZyYmXCJub25lXCI9PWh8fC9eW1xcc1xceGEwXSokLy50ZXN0KGJbYi5sZW5ndGgtMV18fFwiXCIpfHxiLnB1c2goXCJcIik7dmFyIG49ZWQoYSksdT1udWxsLHA9bnVsbDtuJiYodT1WKGEsXCJ3aGl0ZS1zcGFjZVwiKSxwPVYoYSxcInRleHQtdHJhbnNmb3JtXCIpKTtsKGEuY2hpbGROb2RlcyxmdW5jdGlvbihHKXtjKEcsYixuLHUscCl9KTthPWJbYi5sZW5ndGgtMV18fFwiXCI7IWQmJlwidGFibGUtY2VsbFwiIT1lfHwhYXx8XG56YShhKXx8KGJbYi5sZW5ndGgtMV0rPVwiIFwiKTtmJiZcInJ1bi1pblwiIT1lJiYhL15bXFxzXFx4YTBdKiQvLnRlc3QoYSkmJmIucHVzaChcIlwiKX19ZnVuY3Rpb24ga2QoYSxiKXtsZChhLGIsZnVuY3Rpb24oYyxkLGUsZixnKXszPT1jLm5vZGVUeXBlJiZlP25kKGMsZCxmLGcpOlMoYykmJmtkKGMsZCl9KX12YXIgbWQ9XCJpbmxpbmUgaW5saW5lLWJsb2NrIGlubGluZS10YWJsZSBub25lIHRhYmxlLWNlbGwgdGFibGUtY29sdW1uIHRhYmxlLWNvbHVtbi1ncm91cFwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIG5kKGEsYixjLGQpe2E9YS5ub2RlVmFsdWUucmVwbGFjZSgvW1xcdTIwMGJcXHUyMDBlXFx1MjAwZl0vZyxcIlwiKTthPWEucmVwbGFjZSgvKFxcclxcbnxcXHJ8XFxuKS9nLFwiXFxuXCIpO2lmKFwibm9ybWFsXCI9PWN8fFwibm93cmFwXCI9PWMpYT1hLnJlcGxhY2UoL1xcbi9nLFwiIFwiKTthPVwicHJlXCI9PWN8fFwicHJlLXdyYXBcIj09Yz9hLnJlcGxhY2UoL1sgXFxmXFx0XFx2XFx1MjAyOFxcdTIwMjldL2csXCJcXHUwMGEwXCIpOmEucmVwbGFjZSgvWyBcXGZcXHRcXHZcXHUyMDI4XFx1MjAyOV0rL2csXCIgXCIpO1wiY2FwaXRhbGl6ZVwiPT1kP2E9YS5yZXBsYWNlKHQ/LyhefFxcc3xcXGIpKFxcUykvZzovKF58W15cXGRcXHB7TH1cXHB7U31dKShbXFxwe0xsfXxcXHB7U31dKS9ndSxmdW5jdGlvbihlLGYsZyl7cmV0dXJuIGYrZy50b1VwcGVyQ2FzZSgpfSk6XCJ1cHBlcmNhc2VcIj09ZD9hPWEudG9VcHBlckNhc2UoKTpcImxvd2VyY2FzZVwiPT1kJiYoYT1hLnRvTG93ZXJDYXNlKCkpO2M9Yi5wb3AoKXx8XCJcIjt6YShjKSYmMD09YS5sYXN0SW5kZXhPZihcIiBcIixcbjApJiYoYT1hLnN1YnN0cigxKSk7Yi5wdXNoKGMrYSl9ZnVuY3Rpb24gZGQoYSl7aWYoTWMpe2lmKFwicmVsYXRpdmVcIj09VihhLFwicG9zaXRpb25cIikpcmV0dXJuIDE7YT1WKGEsXCJmaWx0ZXJcIik7cmV0dXJuKGE9YS5tYXRjaCgvXmFscGhhXFwob3BhY2l0eT0oXFxkKilcXCkvKXx8YS5tYXRjaCgvXnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYVxcKE9wYWNpdHk9KFxcZCopXFwpLykpP051bWJlcihhWzFdKS8xMDA6MX1yZXR1cm4gb2QoYSl9ZnVuY3Rpb24gb2QoYSl7dmFyIGI9MSxjPVYoYSxcIm9wYWNpdHlcIik7YyYmKGI9TnVtYmVyKGMpKTsoYT1aYyhhKSkmJihiKj1vZChhKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBwZChhLGIsYyxkLGUpe2lmKDM9PWEubm9kZVR5cGUmJmMpbmQoYSxiLGQsZSk7ZWxzZSBpZihTKGEpKWlmKFMoYSxcIkNPTlRFTlRcIil8fFMoYSxcIlNMT1RcIikpe2Zvcih2YXIgZj1hO2YucGFyZW50Tm9kZTspZj1mLnBhcmVudE5vZGU7ZiBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q/KGE9UyhhLFwiQ09OVEVOVFwiKT9hLmdldERpc3RyaWJ1dGVkTm9kZXMoKTphLmFzc2lnbmVkTm9kZXMoKSxsKGEsZnVuY3Rpb24oZyl7cGQoZyxiLGMsZCxlKX0pKTpqZChhLGIpfWVsc2UgaWYoUyhhLFwiU0hBRE9XXCIpKXtmb3IoZj1hO2YucGFyZW50Tm9kZTspZj1mLnBhcmVudE5vZGU7aWYoZiBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QmJihhPWYpKWZvcihhPWEub2xkZXJTaGFkb3dSb290O2E7KWwoYS5jaGlsZE5vZGVzLGZ1bmN0aW9uKGcpe3BkKGcsYixjLGQsZSl9KSxhPWEub2xkZXJTaGFkb3dSb290fWVsc2UgamQoYSxiKX1cbmZ1bmN0aW9uIGpkKGEsYil7YS5zaGFkb3dSb290JiZsKGEuc2hhZG93Um9vdC5jaGlsZE5vZGVzLGZ1bmN0aW9uKGMpe3BkKGMsYiwhMCxudWxsLG51bGwpfSk7bGQoYSxiLGZ1bmN0aW9uKGMsZCxlLGYsZyl7dmFyIGg9bnVsbDsxPT1jLm5vZGVUeXBlP2g9YzozPT1jLm5vZGVUeXBlJiYoaD1jKTtudWxsIT1oJiYobnVsbCE9aC5hc3NpZ25lZFNsb3R8fGguZ2V0RGVzdGluYXRpb25JbnNlcnRpb25Qb2ludHMmJjA8aC5nZXREZXN0aW5hdGlvbkluc2VydGlvblBvaW50cygpLmxlbmd0aCl8fHBkKGMsZCxlLGYsZyl9KX07dmFyIHFkPXtDOmZ1bmN0aW9uKGEsYil7cmV0dXJuISghYS5xdWVyeVNlbGVjdG9yQWxsfHwhYS5xdWVyeVNlbGVjdG9yKSYmIS9eXFxkLiovLnRlc3QoYil9LG86ZnVuY3Rpb24oYSxiKXt2YXIgYz1lYihiKSxkPVwic3RyaW5nXCI9PT10eXBlb2YgYT9jLmEuZ2V0RWxlbWVudEJ5SWQoYSk6YTtyZXR1cm4gZD9VYyhkLFwiaWRcIik9PWEmJmIhPWQmJmhiKGIsZCk/ZDp1YShtYihjLFwiKlwiKSxmdW5jdGlvbihlKXtyZXR1cm4gVWMoZSxcImlkXCIpPT1hJiZiIT1lJiZoYihiLGUpfSk6bnVsbH0sajpmdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybltdO2lmKHFkLkMoYixhKSl0cnl7cmV0dXJuIGIucXVlcnlTZWxlY3RvckFsbChcIiNcIitxZC5UKGEpKX1jYXRjaChjKXtyZXR1cm5bXX1iPW1iKGViKGIpLFwiKlwiLG51bGwsYik7cmV0dXJuIHBhKGIsZnVuY3Rpb24oYyl7cmV0dXJuIFVjKGMsXCJpZFwiKT09YX0pfSxUOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoLyhbXFxzJ1wiXFxcXCMuOjssIT8rPD49fipeJHwlJkBge31cXC1cXC9cXFtcXF1cXChcXCldKS9nLFxuXCJcXFxcJDFcIil9fTt2YXIgWT17fSxyZD17fTtZLk49ZnVuY3Rpb24oYSxiLGMpe3RyeXt2YXIgZD1OYy5qKFwiYVwiLGIpfWNhdGNoKGUpe2Q9bWIoZWIoYiksXCJBXCIsbnVsbCxiKX1yZXR1cm4gdWEoZCxmdW5jdGlvbihlKXtlPWlkKGUpO2U9ZS5yZXBsYWNlKC9eW1xcc10rfFtcXHNdKyQvZyxcIlwiKTtyZXR1cm4gYyYmLTEhPWUuaW5kZXhPZihhKXx8ZT09YX0pfTtZLks9ZnVuY3Rpb24oYSxiLGMpe3RyeXt2YXIgZD1OYy5qKFwiYVwiLGIpfWNhdGNoKGUpe2Q9bWIoZWIoYiksXCJBXCIsbnVsbCxiKX1yZXR1cm4gcGEoZCxmdW5jdGlvbihlKXtlPWlkKGUpO2U9ZS5yZXBsYWNlKC9eW1xcc10rfFtcXHNdKyQvZyxcIlwiKTtyZXR1cm4gYyYmLTEhPWUuaW5kZXhPZihhKXx8ZT09YX0pfTtZLm89ZnVuY3Rpb24oYSxiKXtyZXR1cm4gWS5OKGEsYiwhMSl9O1kuaj1mdW5jdGlvbihhLGIpe3JldHVybiBZLksoYSxiLCExKX07cmQubz1mdW5jdGlvbihhLGIpe3JldHVybiBZLk4oYSxiLCEwKX07XG5yZC5qPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFkuSyhhLGIsITApfTt2YXIgWj17RjpmdW5jdGlvbihhLGIpe3JldHVybiBmdW5jdGlvbihjKXt2YXIgZD1aLnUoYSk7ZD1XKGQpO2M9VyhjKTtyZXR1cm4gYi5jYWxsKG51bGwsZCxjKX19LFI6ZnVuY3Rpb24oYSl7cmV0dXJuIFouRihhLGZ1bmN0aW9uKGIsYyl7cmV0dXJuIGMuYitjLmhlaWdodDxiLmJ9KX0sUzpmdW5jdGlvbihhKXtyZXR1cm4gWi5GKGEsZnVuY3Rpb24oYixjKXtyZXR1cm4gYi5iK2IuaGVpZ2h0PGMuYn0pfSxWOmZ1bmN0aW9uKGEpe3JldHVybiBaLkYoYSxmdW5jdGlvbihiLGMpe3JldHVybiBjLmErYy53aWR0aDxiLmF9KX0sYWE6ZnVuY3Rpb24oYSl7cmV0dXJuIFouRihhLGZ1bmN0aW9uKGIsYyl7cmV0dXJuIGIuYStiLndpZHRoPGMuYX0pfSxXOmZ1bmN0aW9uKGEsYil7dmFyIGM7Yj9jPWI6XCJudW1iZXJcIj09dHlwZW9mIGEuZGlzdGFuY2UmJihjPWEuZGlzdGFuY2UpO2N8fChjPTUwKTtyZXR1cm4gZnVuY3Rpb24oZCl7dmFyIGU9Wi51KGEpO2lmKGU9PT1kKXJldHVybiExO2U9VyhlKTtcbmQ9VyhkKTtlPW5ldyBVKGUuYS1jLGUuYi1jLGUud2lkdGgrMipjLGUuaGVpZ2h0KzIqYyk7cmV0dXJuIGUuYTw9ZC5hK2Qud2lkdGgmJmQuYTw9ZS5hK2Uud2lkdGgmJmUuYjw9ZC5iK2QuaGVpZ2h0JiZkLmI8PWUuYitlLmhlaWdodH19LHU6ZnVuY3Rpb24oYSl7aWYoaGEoYSkmJjE9PWEubm9kZVR5cGUpcmV0dXJuIGE7aWYoZWEoYSkpcmV0dXJuIFoudShhLmNhbGwobnVsbCkpO2lmKGhhKGEpKXt2YXIgYjthOntpZihiPXNkKGEpKXt2YXIgYz10ZFtiXTtpZihjJiZlYShjLm8pKXtiPWMubyhhW2JdLEJjLmRvY3VtZW50KTticmVhayBhfX10aHJvdyBuZXcgUCg2MSxcIlVuc3VwcG9ydGVkIGxvY2F0b3Igc3RyYXRlZ3k6IFwiK2IpO31pZighYil0aHJvdyBuZXcgUCg3LFwiTm8gZWxlbWVudCBoYXMgYmVlbiBmb3VuZCBieSBcIitKU09OLnN0cmluZ2lmeShhKSk7cmV0dXJuIGJ9dGhyb3cgbmV3IFAoNjEsXCJTZWxlY3RvciBpcyBvZiB3cm9uZyB0eXBlOiBcIitKU09OLnN0cmluZ2lmeShhKSk7XG59fTtaLlA9e2xlZnQ6Wi5WLHJpZ2h0OlouYWEsYWJvdmU6Wi5SLGJlbG93OlouUyxuZWFyOlouV307Wi5PPXtsZWZ0OloudSxyaWdodDpaLnUsYWJvdmU6Wi51LGJlbG93OloudSxuZWFyOloudX07Wi5VPWZ1bmN0aW9uKGEsYil7dmFyIGM9W107bChhLGZ1bmN0aW9uKGUpe2UmJnRhKGIsZnVuY3Rpb24oZil7dmFyIGc9Zi5raW5kLGg9Wi5QW2ddO2lmKCFoKXRocm93IG5ldyBQKDYxLFwiQ2Fubm90IGZpbmQgZmlsdGVyIHN1aXRhYmxlIGZvciBcIitnKTtyZXR1cm4gaC5hcHBseShudWxsLGYuYXJncykoZSl9LG51bGwpJiZjLnB1c2goZSl9LG51bGwpO2E9YltiLmxlbmd0aC0xXTt2YXIgZD1aLk9bYT9hLmtpbmQ6XCJ1bmtub3duXCJdO3JldHVybiBkPyhhPWQuYXBwbHkobnVsbCxhLmFyZ3MpKT9aLmJhKGEsYyk6YzpjfTtcblouYmE9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGYpe2Y9VyhmKTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGQtKGYuYStNYXRoLm1heCgxLGYud2lkdGgpLzIpLDIpK01hdGgucG93KGUtKGYuYitNYXRoLm1heCgxLGYuaGVpZ2h0KS8yKSwyKSl9YT1XKGEpO3ZhciBkPWEuYStNYXRoLm1heCgxLGEud2lkdGgpLzIsZT1hLmIrTWF0aC5tYXgoMSxhLmhlaWdodCkvMjt4YShiLGZ1bmN0aW9uKGYsZyl7cmV0dXJuIGMoZiktYyhnKX0pO3JldHVybiBifTtaLm89ZnVuY3Rpb24oYSxiKXthPVouaihhLGIpO3JldHVybiAwPT1hLmxlbmd0aD9udWxsOmFbMF19O1xuWi5qPWZ1bmN0aW9uKGEsYil7aWYoIWEuaGFzT3duUHJvcGVydHkoXCJyb290XCIpfHwhYS5oYXNPd25Qcm9wZXJ0eShcImZpbHRlcnNcIikpdGhyb3cgbmV3IFAoNjEsXCJMb2NhdG9yIG5vdCBzdWl0YWJsZSBmb3IgcmVsYXRpdmUgbG9jYXRvcnM6IFwiK0pTT04uc3RyaW5naWZ5KGEpKTt2YXIgYz1hLmZpbHRlcnMsZD1kYShjKTtpZihcImFycmF5XCIhPWQmJihcIm9iamVjdFwiIT1kfHxcIm51bWJlclwiIT10eXBlb2YgYy5sZW5ndGgpKXRocm93IG5ldyBQKDYxLFwiVGFyZ2V0cyBzaG91bGQgYmUgYW4gYXJyYXk6IFwiK0pTT04uc3RyaW5naWZ5KGEpKTt2YXIgZTtTKGEucm9vdCk/ZT1bYS5yb290XTplPXVkKGEucm9vdCxiKTtyZXR1cm4gMD09ZS5sZW5ndGg/W106Wi5VKGUsYS5maWx0ZXJzKX07dmFyIHZkPXtvOmZ1bmN0aW9uKGEsYil7aWYoXCJcIj09PWEpdGhyb3cgbmV3IFAoMzIsJ1VuYWJsZSB0byBsb2NhdGUgYW4gZWxlbWVudCB3aXRoIHRoZSB0YWdOYW1lIFwiXCInKTtyZXR1cm4gYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKVswXXx8bnVsbH0sajpmdW5jdGlvbihhLGIpe2lmKFwiXCI9PT1hKXRocm93IG5ldyBQKDMyLCdVbmFibGUgdG8gbG9jYXRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgdGFnTmFtZSBcIlwiJyk7cmV0dXJuIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSl9fTt2YXIgdGQ9e2NsYXNzTmFtZTpEYyxcImNsYXNzIG5hbWVcIjpEYyxjc3M6TmMsXCJjc3Mgc2VsZWN0b3JcIjpOYyxyZWxhdGl2ZTpaLGlkOnFkLGxpbmtUZXh0OlksXCJsaW5rIHRleHRcIjpZLG5hbWU6e286ZnVuY3Rpb24oYSxiKXtiPW1iKGViKGIpLFwiKlwiLG51bGwsYik7cmV0dXJuIHVhKGIsZnVuY3Rpb24oYyl7cmV0dXJuIFVjKGMsXCJuYW1lXCIpPT1hfSl9LGo6ZnVuY3Rpb24oYSxiKXtiPW1iKGViKGIpLFwiKlwiLG51bGwsYik7cmV0dXJuIHBhKGIsZnVuY3Rpb24oYyl7cmV0dXJuIFVjKGMsXCJuYW1lXCIpPT1hfSl9fSxwYXJ0aWFsTGlua1RleHQ6cmQsXCJwYXJ0aWFsIGxpbmsgdGV4dFwiOnJkLHRhZ05hbWU6dmQsXCJ0YWcgbmFtZVwiOnZkLHhwYXRoOlR9O2Z1bmN0aW9uIHNkKGEpe2Zvcih2YXIgYiBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYikpcmV0dXJuIGI7cmV0dXJuIG51bGx9XG5mdW5jdGlvbiB1ZChhLGIpe3ZhciBjPXNkKGEpO2lmKGMpe3ZhciBkPXRkW2NdO2lmKGQmJmVhKGQuaikpcmV0dXJuIGQuaihhW2NdLGJ8fEJjLmRvY3VtZW50KX10aHJvdyBuZXcgUCg2MSxcIlVuc3VwcG9ydGVkIGxvY2F0b3Igc3RyYXRlZ3k6IFwiK2MpO307Y2EoXCJfXCIsdWQpOzsgcmV0dXJuIHRoaXMuXy5hcHBseShudWxsLGFyZ3VtZW50cyk7fSkuYXBwbHkoe25hdmlnYXRvcjp0eXBlb2Ygd2luZG93IT0ndW5kZWZpbmVkJz93aW5kb3cubmF2aWdhdG9yOm51bGwsZG9jdW1lbnQ6dHlwZW9mIHdpbmRvdyE9J3VuZGVmaW5lZCc/d2luZG93LmRvY3VtZW50Om51bGx9LCBhcmd1bWVudHMpO307XG4iLCIvLyBHRU5FUkFURUQgQ09ERSAtIERPIE5PVCBFRElUXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7cmV0dXJuIChmdW5jdGlvbigpe3ZhciBoPXRoaXN8fHNlbGY7ZnVuY3Rpb24gYWEoYSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGF9ZnVuY3Rpb24gYmEoYSxiKXthPWEuc3BsaXQoXCIuXCIpO3ZhciBjPWg7YVswXWluIGN8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjLmV4ZWNTY3JpcHR8fGMuZXhlY1NjcmlwdChcInZhciBcIithWzBdKTtmb3IodmFyIGQ7YS5sZW5ndGgmJihkPWEuc2hpZnQoKSk7KWEubGVuZ3RofHx2b2lkIDA9PT1iP2NbZF0mJmNbZF0hPT1PYmplY3QucHJvdG90eXBlW2RdP2M9Y1tkXTpjPWNbZF09e306Y1tkXT1ifVxuZnVuY3Rpb24gY2EoYSl7dmFyIGI9dHlwZW9mIGE7aWYoXCJvYmplY3RcIj09YilpZihhKXtpZihhIGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuXCJhcnJheVwiO2lmKGEgaW5zdGFuY2VvZiBPYmplY3QpcmV0dXJuIGI7dmFyIGM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBXaW5kb3ddXCI9PWMpcmV0dXJuXCJvYmplY3RcIjtpZihcIltvYmplY3QgQXJyYXldXCI9PWN8fFwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuc3BsaWNlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpcmV0dXJuXCJhcnJheVwiO2lmKFwiW29iamVjdCBGdW5jdGlvbl1cIj09Y3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuY2FsbCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSlyZXR1cm5cImZ1bmN0aW9uXCJ9ZWxzZSByZXR1cm5cIm51bGxcIjtcbmVsc2UgaWYoXCJmdW5jdGlvblwiPT1iJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgYS5jYWxsKXJldHVyblwib2JqZWN0XCI7cmV0dXJuIGJ9ZnVuY3Rpb24gZGEoYSl7dmFyIGI9dHlwZW9mIGE7cmV0dXJuXCJvYmplY3RcIj09YiYmbnVsbCE9YXx8XCJmdW5jdGlvblwiPT1ifWZ1bmN0aW9uIGVhKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfWZ1bmN0aW9uIGZhKGEsYixjKXtpZighYSl0aHJvdyBFcnJvcigpO2lmKDI8YXJndW1lbnRzLmxlbmd0aCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoZSxkKTtyZXR1cm4gYS5hcHBseShiLGUpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fVxuZnVuY3Rpb24gaGEoYSxiLGMpe0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/aGE9ZWE6aGE9ZmE7cmV0dXJuIGhhLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBpYShhLGIpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZD1jLnNsaWNlKCk7ZC5wdXNoLmFwcGx5KGQsYXJndW1lbnRzKTtyZXR1cm4gYS5hcHBseSh0aGlzLGQpfX1mdW5jdGlvbiBtKGEsYil7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT1iLnByb3RvdHlwZTthLkg9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YX1cbmZ1bmN0aW9uIGphKGEsYixjKXt2YXIgZD1hcmd1bWVudHMuY2FsbGVlLmNhbGxlcjtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGQuSCl7Zm9yKHZhciBlPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksZj0xO2Y8YXJndW1lbnRzLmxlbmd0aDtmKyspZVtmLTFdPWFyZ3VtZW50c1tmXTtkLkguY29uc3RydWN0b3IuYXBwbHkoYSxlKX1lbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBiJiZcInN5bWJvbFwiIT10eXBlb2YgYil0aHJvdyBFcnJvcihcIm1ldGhvZCBuYW1lcyBwcm92aWRlZCB0byBnb29nLmJhc2UgbXVzdCBiZSBhIHN0cmluZyBvciBhIHN5bWJvbFwiKTtlPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMik7Zm9yKGY9MjtmPGFyZ3VtZW50cy5sZW5ndGg7ZisrKWVbZi0yXT1hcmd1bWVudHNbZl07Zj0hMTtmb3IodmFyIGc9YS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7ZztnPU9iamVjdC5nZXRQcm90b3R5cGVPZihnKSlpZihnW2JdPT09ZClmPSEwO2Vsc2UgaWYoZil7Z1tiXS5hcHBseShhLFxuZSk7cmV0dXJufWlmKGFbYl09PT1kKWEuY29uc3RydWN0b3IucHJvdG90eXBlW2JdLmFwcGx5KGEsZSk7ZWxzZSB0aHJvdyBFcnJvcihcImdvb2cuYmFzZSBjYWxsZWQgZnJvbSBhIG1ldGhvZCBvZiBvbmUgbmFtZSB0byBhIG1ldGhvZCBvZiBhIGRpZmZlcmVudCBuYW1lXCIpO319Oy8qXG5cbiBUaGUgTUlUIExpY2Vuc2VcblxuIENvcHlyaWdodCAoYykgMjAwNyBDeWJvenUgTGFicywgSW5jLlxuIENvcHlyaWdodCAoYykgMjAxMiBHb29nbGUgSW5jLlxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiBJTiBUSEUgU09GVFdBUkUuXG4qL1xuZnVuY3Rpb24ga2EoYSxiLGMpe3RoaXMuYT1hO3RoaXMuYj1ifHwxO3RoaXMuZj1jfHwxfTt2YXIgbGE7dmFyIG1hPUFycmF5LnByb3RvdHlwZS5pbmRleE9mP2Z1bmN0aW9uKGEsYil7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYSxiLHZvaWQgMCl9OmZ1bmN0aW9uKGEsYil7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXJldHVyblwic3RyaW5nXCIhPT10eXBlb2YgYnx8MSE9Yi5sZW5ndGg/LTE6YS5pbmRleE9mKGIsMCk7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYoYyBpbiBhJiZhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sbj1BcnJheS5wcm90b3R5cGUuZm9yRWFjaD9mdW5jdGlvbihhLGIpe0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYSxiLHZvaWQgMCl9OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9XCJzdHJpbmdcIj09PXR5cGVvZiBhP2Euc3BsaXQoXCJcIik6YSxlPTA7ZTxjO2UrKyllIGluIGQmJmIuY2FsbCh2b2lkIDAsZFtlXSxlLGEpfSxuYT1BcnJheS5wcm90b3R5cGUuZmlsdGVyP2Z1bmN0aW9uKGEsYil7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChhLFxuYix2b2lkIDApfTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1hLmxlbmd0aCxkPVtdLGU9MCxmPVwic3RyaW5nXCI9PT10eXBlb2YgYT9hLnNwbGl0KFwiXCIpOmEsZz0wO2c8YztnKyspaWYoZyBpbiBmKXt2YXIgaz1mW2ddO2IuY2FsbCh2b2lkIDAsayxnLGEpJiYoZFtlKytdPWspfXJldHVybiBkfSxvYT1BcnJheS5wcm90b3R5cGUubWFwP2Z1bmN0aW9uKGEsYil7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhLGIsdm9pZCAwKX06ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9YS5sZW5ndGgsZD1BcnJheShjKSxlPVwic3RyaW5nXCI9PT10eXBlb2YgYT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8YztmKyspZiBpbiBlJiYoZFtmXT1iLmNhbGwodm9pZCAwLGVbZl0sZixhKSk7cmV0dXJuIGR9LHBhPUFycmF5LnByb3RvdHlwZS5yZWR1Y2U/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9YztuKGEsXG5mdW5jdGlvbihlLGYpe2Q9Yi5jYWxsKHZvaWQgMCxkLGUsZixhKX0pO3JldHVybiBkfSxxYT1BcnJheS5wcm90b3R5cGUuc29tZT9mdW5jdGlvbihhLGIpe3JldHVybiBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGEsYix2b2lkIDApfTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1hLmxlbmd0aCxkPVwic3RyaW5nXCI9PT10eXBlb2YgYT9hLnNwbGl0KFwiXCIpOmEsZT0wO2U8YztlKyspaWYoZSBpbiBkJiZiLmNhbGwodm9pZCAwLGRbZV0sZSxhKSlyZXR1cm4hMDtyZXR1cm4hMX07ZnVuY3Rpb24gcmEoYSxiKXthOntmb3IodmFyIGM9YS5sZW5ndGgsZD1cInN0cmluZ1wiPT09dHlwZW9mIGE/YS5zcGxpdChcIlwiKTphLGU9MDtlPGM7ZSsrKWlmKGUgaW4gZCYmYi5jYWxsKHZvaWQgMCxkW2VdLGUsYSkpe2I9ZTticmVhayBhfWI9LTF9cmV0dXJuIDA+Yj9udWxsOlwic3RyaW5nXCI9PT10eXBlb2YgYT9hLmNoYXJBdChiKTphW2JdfVxuZnVuY3Rpb24gc2EoYSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sYXJndW1lbnRzKX1mdW5jdGlvbiB0YShhLGIsYyl7cmV0dXJuIDI+PWFyZ3VtZW50cy5sZW5ndGg/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSxiKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLGIsYyl9O3ZhciB1YT1TdHJpbmcucHJvdG90eXBlLnRyaW0/ZnVuY3Rpb24oYSl7cmV0dXJuIGEudHJpbSgpfTpmdW5jdGlvbihhKXtyZXR1cm4vXltcXHNcXHhhMF0qKFtcXHNcXFNdKj8pW1xcc1xceGEwXSokLy5leGVjKGEpWzFdfTtcbmZ1bmN0aW9uIHZhKGEsYil7dmFyIGM9MDthPXVhKFN0cmluZyhhKSkuc3BsaXQoXCIuXCIpO2I9dWEoU3RyaW5nKGIpKS5zcGxpdChcIi5cIik7Zm9yKHZhciBkPU1hdGgubWF4KGEubGVuZ3RoLGIubGVuZ3RoKSxlPTA7MD09YyYmZTxkO2UrKyl7dmFyIGY9YVtlXXx8XCJcIixnPWJbZV18fFwiXCI7ZG97Zj0vKFxcZCopKFxcRCopKC4qKS8uZXhlYyhmKXx8W1wiXCIsXCJcIixcIlwiLFwiXCJdO2c9LyhcXGQqKShcXEQqKSguKikvLmV4ZWMoZyl8fFtcIlwiLFwiXCIsXCJcIixcIlwiXTtpZigwPT1mWzBdLmxlbmd0aCYmMD09Z1swXS5sZW5ndGgpYnJlYWs7Yz13YSgwPT1mWzFdLmxlbmd0aD8wOnBhcnNlSW50KGZbMV0sMTApLDA9PWdbMV0ubGVuZ3RoPzA6cGFyc2VJbnQoZ1sxXSwxMCkpfHx3YSgwPT1mWzJdLmxlbmd0aCwwPT1nWzJdLmxlbmd0aCl8fHdhKGZbMl0sZ1syXSk7Zj1mWzNdO2c9Z1szXX13aGlsZSgwPT1jKX1yZXR1cm4gY31mdW5jdGlvbiB3YShhLGIpe3JldHVybiBhPGI/LTE6YT5iPzE6MH07dmFyIHA7YTp7dmFyIHhhPWgubmF2aWdhdG9yO2lmKHhhKXt2YXIgeWE9eGEudXNlckFnZW50O2lmKHlhKXtwPXlhO2JyZWFrIGF9fXA9XCJcIn1mdW5jdGlvbiBxKGEpe3JldHVybi0xIT1wLmluZGV4T2YoYSl9O2Z1bmN0aW9uIHphKCl7cmV0dXJuIHEoXCJGaXJlZm94XCIpfHxxKFwiRnhpT1NcIil9ZnVuY3Rpb24gQWEoKXtyZXR1cm4ocShcIkNocm9tZVwiKXx8cShcIkNyaU9TXCIpKSYmIXEoXCJFZGdlXCIpfTtmdW5jdGlvbiBCYSgpe3JldHVybiBxKFwiaVBob25lXCIpJiYhcShcImlQb2RcIikmJiFxKFwiaVBhZFwiKX07ZnVuY3Rpb24gQ2EoYSxiKXt2YXIgYz1EYTtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMsYSk/Y1thXTpjW2FdPWIoYSl9O3ZhciBFYT1xKFwiT3BlcmFcIikscj1xKFwiVHJpZGVudFwiKXx8cShcIk1TSUVcIiksRmE9cShcIkVkZ2VcIiksdD1xKFwiR2Vja29cIikmJiEoLTEhPXAudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpJiYhcShcIkVkZ2VcIikpJiYhKHEoXCJUcmlkZW50XCIpfHxxKFwiTVNJRVwiKSkmJiFxKFwiRWRnZVwiKSxHYT0tMSE9cC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ3ZWJraXRcIikmJiFxKFwiRWRnZVwiKSxIYT1xKFwiTWFjaW50b3NoXCIpLElhPXEoXCJXaW5kb3dzXCIpO2Z1bmN0aW9uIEphKCl7dmFyIGE9aC5kb2N1bWVudDtyZXR1cm4gYT9hLmRvY3VtZW50TW9kZTp2b2lkIDB9dmFyIEthO1xuYTp7dmFyIExhPVwiXCIsTWE9ZnVuY3Rpb24oKXt2YXIgYT1wO2lmKHQpcmV0dXJuL3J2OihbXlxcKTtdKykoXFwpfDspLy5leGVjKGEpO2lmKEZhKXJldHVybi9FZGdlXFwvKFtcXGRcXC5dKykvLmV4ZWMoYSk7aWYocilyZXR1cm4vXFxiKD86TVNJRXxydilbOiBdKFteXFwpO10rKShcXCl8OykvLmV4ZWMoYSk7aWYoR2EpcmV0dXJuL1dlYktpdFxcLyhcXFMrKS8uZXhlYyhhKTtpZihFYSlyZXR1cm4vKD86VmVyc2lvbilbIFxcL10/KFxcUyspLy5leGVjKGEpfSgpO01hJiYoTGE9TWE/TWFbMV06XCJcIik7aWYocil7dmFyIE5hPUphKCk7aWYobnVsbCE9TmEmJk5hPnBhcnNlRmxvYXQoTGEpKXtLYT1TdHJpbmcoTmEpO2JyZWFrIGF9fUthPUxhfXZhciBEYT17fTtmdW5jdGlvbiBPYShhKXtyZXR1cm4gQ2EoYSxmdW5jdGlvbigpe3JldHVybiAwPD12YShLYSxhKX0pfXZhciB3O3c9aC5kb2N1bWVudCYmcj9KYSgpOnZvaWQgMDt2YXIgeD1yJiYhKDk8PU51bWJlcih3KSksUGE9ciYmISg4PD1OdW1iZXIodykpO2Z1bmN0aW9uIFFhKGEsYixjLGQpe3RoaXMuYT1hO3RoaXMubm9kZU5hbWU9Yzt0aGlzLm5vZGVWYWx1ZT1kO3RoaXMubm9kZVR5cGU9Mjt0aGlzLnBhcmVudE5vZGU9dGhpcy5vd25lckVsZW1lbnQ9Yn1mdW5jdGlvbiBTYShhLGIpe3ZhciBjPVBhJiZcImhyZWZcIj09Yi5ub2RlTmFtZT9hLmdldEF0dHJpYnV0ZShiLm5vZGVOYW1lLDIpOmIubm9kZVZhbHVlO3JldHVybiBuZXcgUWEoYixhLGIubm9kZU5hbWUsYyl9O2Z1bmN0aW9uIFRhKGEpe3RoaXMuYj1hO3RoaXMuYT0wfWZ1bmN0aW9uIFVhKGEpe2E9YS5tYXRjaChWYSk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspV2EudGVzdChhW2JdKSYmYS5zcGxpY2UoYiwxKTtyZXR1cm4gbmV3IFRhKGEpfXZhciBWYT0vXFwkPyg/Oig/IVswLTktXFwuXSkoPzpcXCp8W1xcdy1cXC5dKyk6KT8oPyFbMC05LVxcLl0pKD86XFwqfFtcXHctXFwuXSspfFxcL1xcL3xcXC5cXC58Ojp8XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrfFwiW15cIl0qXCJ8J1teJ10qJ3xbITw+XT18XFxzK3wuL2csV2E9L15cXHMvO2Z1bmN0aW9uIHkoYSxiKXtyZXR1cm4gYS5iW2EuYSsoYnx8MCldfWZ1bmN0aW9uIHooYSl7cmV0dXJuIGEuYlthLmErK119ZnVuY3Rpb24gWGEoYSl7cmV0dXJuIGEuYi5sZW5ndGg8PWEuYX07ZnVuY3Rpb24gWWEoYSl7cmV0dXJuIGEuc2Nyb2xsaW5nRWxlbWVudD9hLnNjcm9sbGluZ0VsZW1lbnQ6R2F8fFwiQ1NTMUNvbXBhdFwiIT1hLmNvbXBhdE1vZGU/YS5ib2R5fHxhLmRvY3VtZW50RWxlbWVudDphLmRvY3VtZW50RWxlbWVudH1mdW5jdGlvbiBaYShhLGIpe2lmKCFhfHwhYilyZXR1cm4hMTtpZihhLmNvbnRhaW5zJiYxPT1iLm5vZGVUeXBlKXJldHVybiBhPT1ifHxhLmNvbnRhaW5zKGIpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKXJldHVybiBhPT1ifHwhIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpJjE2KTtmb3IoO2ImJmEhPWI7KWI9Yi5wYXJlbnROb2RlO3JldHVybiBiPT1hfVxuZnVuY3Rpb24gJGEoYSxiKXtpZihhPT1iKXJldHVybiAwO2lmKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24pcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikmMj8xOi0xO2lmKHImJiEoOTw9TnVtYmVyKHcpKSl7aWYoOT09YS5ub2RlVHlwZSlyZXR1cm4tMTtpZig5PT1iLm5vZGVUeXBlKXJldHVybiAxfWlmKFwic291cmNlSW5kZXhcImluIGF8fGEucGFyZW50Tm9kZSYmXCJzb3VyY2VJbmRleFwiaW4gYS5wYXJlbnROb2RlKXt2YXIgYz0xPT1hLm5vZGVUeXBlLGQ9MT09Yi5ub2RlVHlwZTtpZihjJiZkKXJldHVybiBhLnNvdXJjZUluZGV4LWIuc291cmNlSW5kZXg7dmFyIGU9YS5wYXJlbnROb2RlLGY9Yi5wYXJlbnROb2RlO3JldHVybiBlPT1mP2FiKGEsYik6IWMmJlphKGUsYik/LTEqYmIoYSxiKTohZCYmWmEoZixhKT9iYihiLGEpOihjP2Euc291cmNlSW5kZXg6ZS5zb3VyY2VJbmRleCktKGQ/Yi5zb3VyY2VJbmRleDpmLnNvdXJjZUluZGV4KX1kPUEoYSk7Yz1kLmNyZWF0ZVJhbmdlKCk7XG5jLnNlbGVjdE5vZGUoYSk7Yy5jb2xsYXBzZSghMCk7YT1kLmNyZWF0ZVJhbmdlKCk7YS5zZWxlY3ROb2RlKGIpO2EuY29sbGFwc2UoITApO3JldHVybiBjLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhoLlJhbmdlLlNUQVJUX1RPX0VORCxhKX1mdW5jdGlvbiBiYihhLGIpe3ZhciBjPWEucGFyZW50Tm9kZTtpZihjPT1iKXJldHVybi0xO2Zvcig7Yi5wYXJlbnROb2RlIT1jOyliPWIucGFyZW50Tm9kZTtyZXR1cm4gYWIoYixhKX1mdW5jdGlvbiBhYihhLGIpe2Zvcig7Yj1iLnByZXZpb3VzU2libGluZzspaWYoYj09YSlyZXR1cm4tMTtyZXR1cm4gMX1mdW5jdGlvbiBBKGEpe3JldHVybiA5PT1hLm5vZGVUeXBlP2E6YS5vd25lckRvY3VtZW50fHxhLmRvY3VtZW50fXZhciBjYj17U0NSSVBUOjEsU1RZTEU6MSxIRUFEOjEsSUZSQU1FOjEsT0JKRUNUOjF9LGRiPXtJTUc6XCIgXCIsQlI6XCJcXG5cIn07XG5mdW5jdGlvbiBlYihhLGIsYyl7aWYoIShhLm5vZGVOYW1lIGluIGNiKSlpZigzPT1hLm5vZGVUeXBlKWM/Yi5wdXNoKFN0cmluZyhhLm5vZGVWYWx1ZSkucmVwbGFjZSgvKFxcclxcbnxcXHJ8XFxuKS9nLFwiXCIpKTpiLnB1c2goYS5ub2RlVmFsdWUpO2Vsc2UgaWYoYS5ub2RlTmFtZSBpbiBkYiliLnB1c2goZGJbYS5ub2RlTmFtZV0pO2Vsc2UgZm9yKGE9YS5maXJzdENoaWxkO2E7KWViKGEsYixjKSxhPWEubmV4dFNpYmxpbmd9ZnVuY3Rpb24gZmIoYSl7dGhpcy5hPWF8fGguZG9jdW1lbnR8fGRvY3VtZW50fWZiLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1mdW5jdGlvbihhLGIpe3JldHVybihifHx0aGlzLmEpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFN0cmluZyhhKSl9O2Z1bmN0aW9uIEIoYSl7dmFyIGI9bnVsbCxjPWEubm9kZVR5cGU7MT09YyYmKGI9YS50ZXh0Q29udGVudCxiPXZvaWQgMD09Ynx8bnVsbD09Yj9hLmlubmVyVGV4dDpiLGI9dm9pZCAwPT1ifHxudWxsPT1iP1wiXCI6Yik7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGIpaWYoeCYmXCJ0aXRsZVwiPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJjE9PWMpYj1hLnRleHQ7ZWxzZSBpZig5PT1jfHwxPT1jKXthPTk9PWM/YS5kb2N1bWVudEVsZW1lbnQ6YS5maXJzdENoaWxkO2M9MDt2YXIgZD1bXTtmb3IoYj1cIlwiO2E7KXtkbyAxIT1hLm5vZGVUeXBlJiYoYis9YS5ub2RlVmFsdWUpLHgmJlwidGl0bGVcIj09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiYoYis9YS50ZXh0KSxkW2MrK109YTt3aGlsZShhPWEuZmlyc3RDaGlsZCk7Zm9yKDtjJiYhKGE9ZFstLWNdLm5leHRTaWJsaW5nKTspO319ZWxzZSBiPWEubm9kZVZhbHVlO3JldHVybiBifVxuZnVuY3Rpb24gQyhhLGIsYyl7aWYobnVsbD09PWIpcmV0dXJuITA7dHJ5e2lmKCFhLmdldEF0dHJpYnV0ZSlyZXR1cm4hMX1jYXRjaChkKXtyZXR1cm4hMX1QYSYmXCJjbGFzc1wiPT1iJiYoYj1cImNsYXNzTmFtZVwiKTtyZXR1cm4gbnVsbD09Yz8hIWEuZ2V0QXR0cmlidXRlKGIpOmEuZ2V0QXR0cmlidXRlKGIsMik9PWN9ZnVuY3Rpb24gZ2IoYSxiLGMsZCxlKXtyZXR1cm4oeD9oYjppYikuY2FsbChudWxsLGEsYixhYShjKT9jOm51bGwsYWEoZCk/ZDpudWxsLGV8fG5ldyBEKX1cbmZ1bmN0aW9uIGhiKGEsYixjLGQsZSl7aWYoYSBpbnN0YW5jZW9mIGpifHw4PT1hLmJ8fGMmJm51bGw9PT1hLmIpe3ZhciBmPWIuYWxsO2lmKCFmKXJldHVybiBlO2E9a2IoYSk7aWYoXCIqXCIhPWEmJihmPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSksIWYpKXJldHVybiBlO2lmKGMpe2Zvcih2YXIgZz1bXSxrPTA7Yj1mW2srK107KUMoYixjLGQpJiZnLnB1c2goYik7Zj1nfWZvcihrPTA7Yj1mW2srK107KVwiKlwiPT1hJiZcIiFcIj09Yi50YWdOYW1lfHxlLmFkZChiKTtyZXR1cm4gZX1sYihhLGIsYyxkLGUpO3JldHVybiBlfVxuZnVuY3Rpb24gaWIoYSxiLGMsZCxlKXtiLmdldEVsZW1lbnRzQnlOYW1lJiZkJiZcIm5hbWVcIj09YyYmIXI/KGI9Yi5nZXRFbGVtZW50c0J5TmFtZShkKSxuKGIsZnVuY3Rpb24oZil7YS5hKGYpJiZlLmFkZChmKX0pKTpiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJmQmJlwiY2xhc3NcIj09Yz8oYj1iLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZCksbihiLGZ1bmN0aW9uKGYpe2YuY2xhc3NOYW1lPT1kJiZhLmEoZikmJmUuYWRkKGYpfSkpOmEgaW5zdGFuY2VvZiBFP2xiKGEsYixjLGQsZSk6Yi5nZXRFbGVtZW50c0J5VGFnTmFtZSYmKGI9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZShhLmYoKSksbihiLGZ1bmN0aW9uKGYpe0MoZixjLGQpJiZlLmFkZChmKX0pKTtyZXR1cm4gZX1cbmZ1bmN0aW9uIG1iKGEsYixjLGQsZSl7dmFyIGY7aWYoKGEgaW5zdGFuY2VvZiBqYnx8OD09YS5ifHxjJiZudWxsPT09YS5iKSYmKGY9Yi5jaGlsZE5vZGVzKSl7dmFyIGc9a2IoYSk7aWYoXCIqXCIhPWcmJihmPW5hKGYsZnVuY3Rpb24oayl7cmV0dXJuIGsudGFnTmFtZSYmay50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PWd9KSwhZikpcmV0dXJuIGU7YyYmKGY9bmEoZixmdW5jdGlvbihrKXtyZXR1cm4gQyhrLGMsZCl9KSk7bihmLGZ1bmN0aW9uKGspe1wiKlwiPT1nJiYoXCIhXCI9PWsudGFnTmFtZXx8XCIqXCI9PWcmJjEhPWsubm9kZVR5cGUpfHxlLmFkZChrKX0pO3JldHVybiBlfXJldHVybiBuYihhLGIsYyxkLGUpfWZ1bmN0aW9uIG5iKGEsYixjLGQsZSl7Zm9yKGI9Yi5maXJzdENoaWxkO2I7Yj1iLm5leHRTaWJsaW5nKUMoYixjLGQpJiZhLmEoYikmJmUuYWRkKGIpO3JldHVybiBlfVxuZnVuY3Rpb24gbGIoYSxiLGMsZCxlKXtmb3IoYj1iLmZpcnN0Q2hpbGQ7YjtiPWIubmV4dFNpYmxpbmcpQyhiLGMsZCkmJmEuYShiKSYmZS5hZGQoYiksbGIoYSxiLGMsZCxlKX1mdW5jdGlvbiBrYihhKXtpZihhIGluc3RhbmNlb2YgRSl7aWYoOD09YS5iKXJldHVyblwiIVwiO2lmKG51bGw9PT1hLmIpcmV0dXJuXCIqXCJ9cmV0dXJuIGEuZigpfTtmdW5jdGlvbiBEKCl7dGhpcy5iPXRoaXMuYT1udWxsO3RoaXMubz0wfWZ1bmN0aW9uIG9iKGEpe3RoaXMuZj1hO3RoaXMuYT10aGlzLmI9bnVsbH1mdW5jdGlvbiBwYihhLGIpe2lmKCFhLmEpcmV0dXJuIGI7aWYoIWIuYSlyZXR1cm4gYTt2YXIgYz1hLmE7Yj1iLmE7Zm9yKHZhciBkPW51bGwsZSxmPTA7YyYmYjspe2U9Yy5mO3ZhciBnPWIuZjtlPT1nfHxlIGluc3RhbmNlb2YgUWEmJmcgaW5zdGFuY2VvZiBRYSYmZS5hPT1nLmE/KGU9YyxjPWMuYSxiPWIuYSk6MDwkYShjLmYsYi5mKT8oZT1iLGI9Yi5hKTooZT1jLGM9Yy5hKTsoZS5iPWQpP2QuYT1lOmEuYT1lO2Q9ZTtmKyt9Zm9yKGU9Y3x8YjtlOyllLmI9ZCxkPWQuYT1lLGYrKyxlPWUuYTthLmI9ZDthLm89ZjtyZXR1cm4gYX1mdW5jdGlvbiBxYihhLGIpe2I9bmV3IG9iKGIpO2IuYT1hLmE7YS5iP2EuYS5iPWI6YS5hPWEuYj1iO2EuYT1iO2EubysrfVxuRC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe2E9bmV3IG9iKGEpO2EuYj10aGlzLmI7dGhpcy5hP3RoaXMuYi5hPWE6dGhpcy5hPXRoaXMuYj1hO3RoaXMuYj1hO3RoaXMubysrfTtmdW5jdGlvbiByYihhKXtyZXR1cm4oYT1hLmEpP2EuZjpudWxsfWZ1bmN0aW9uIHNiKGEpe3JldHVybihhPXJiKGEpKT9CKGEpOlwiXCJ9ZnVuY3Rpb24gRihhLGIpe3JldHVybiBuZXcgdGIoYSwhIWIpfWZ1bmN0aW9uIHRiKGEsYil7dGhpcy5mPWE7dGhpcy5iPSh0aGlzLnY9Yik/YS5iOmEuYTt0aGlzLmE9bnVsbH1mdW5jdGlvbiBHKGEpe3ZhciBiPWEuYjtpZihudWxsPT1iKXJldHVybiBudWxsO3ZhciBjPWEuYT1iO2EuYj1hLnY/Yi5iOmIuYTtyZXR1cm4gYy5mfTtmdW5jdGlvbiBIKGEpe3RoaXMubD1hO3RoaXMuYj10aGlzLmk9ITE7dGhpcy5mPW51bGx9ZnVuY3Rpb24gSShhKXtyZXR1cm5cIlxcbiAgXCIrYS50b1N0cmluZygpLnNwbGl0KFwiXFxuXCIpLmpvaW4oXCJcXG4gIFwiKX1mdW5jdGlvbiB1YihhLGIpe2EuaT1ifWZ1bmN0aW9uIHZiKGEsYil7YS5iPWJ9ZnVuY3Rpb24gSihhLGIpe2E9YS5hKGIpO3JldHVybiBhIGluc3RhbmNlb2YgRD8rc2IoYSk6K2F9ZnVuY3Rpb24gTChhLGIpe2E9YS5hKGIpO3JldHVybiBhIGluc3RhbmNlb2YgRD9zYihhKTpcIlwiK2F9ZnVuY3Rpb24gd2IoYSxiKXthPWEuYShiKTtyZXR1cm4gYSBpbnN0YW5jZW9mIEQ/ISFhLm86ISFhfTtmdW5jdGlvbiB4YihhLGIsYyl7SC5jYWxsKHRoaXMsYS5sKTt0aGlzLmM9YTt0aGlzLmo9Yjt0aGlzLnU9Yzt0aGlzLmk9Yi5pfHxjLmk7dGhpcy5iPWIuYnx8Yy5iO3RoaXMuYz09eWImJihjLmJ8fGMuaXx8ND09Yy5sfHwwPT1jLmx8fCFiLmY/Yi5ifHxiLml8fDQ9PWIubHx8MD09Yi5sfHwhYy5mfHwodGhpcy5mPXtuYW1lOmMuZi5uYW1lLEE6Yn0pOnRoaXMuZj17bmFtZTpiLmYubmFtZSxBOmN9KX1tKHhiLEgpO1xuZnVuY3Rpb24gemIoYSxiLGMsZCxlKXtiPWIuYShkKTtjPWMuYShkKTt2YXIgZjtpZihiIGluc3RhbmNlb2YgRCYmYyBpbnN0YW5jZW9mIEQpe2I9RihiKTtmb3IoZD1HKGIpO2Q7ZD1HKGIpKWZvcihlPUYoYyksZj1HKGUpO2Y7Zj1HKGUpKWlmKGEoQihkKSxCKGYpKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihiIGluc3RhbmNlb2YgRHx8YyBpbnN0YW5jZW9mIEQpe2IgaW5zdGFuY2VvZiBEPyhlPWIsZD1jKTooZT1jLGQ9Yik7Zj1GKGUpO2Zvcih2YXIgZz10eXBlb2YgZCxrPUcoZik7aztrPUcoZikpe3N3aXRjaChnKXtjYXNlIFwibnVtYmVyXCI6az0rQihrKTticmVhaztjYXNlIFwiYm9vbGVhblwiOms9ISFCKGspO2JyZWFrO2Nhc2UgXCJzdHJpbmdcIjprPUIoayk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIklsbGVnYWwgcHJpbWl0aXZlIHR5cGUgZm9yIGNvbXBhcmlzb24uXCIpO31pZihlPT1iJiZhKGssZCl8fGU9PWMmJmEoZCxrKSlyZXR1cm4hMH1yZXR1cm4hMX1yZXR1cm4gZT9cImJvb2xlYW5cIj09XG50eXBlb2YgYnx8XCJib29sZWFuXCI9PXR5cGVvZiBjP2EoISFiLCEhYyk6XCJudW1iZXJcIj09dHlwZW9mIGJ8fFwibnVtYmVyXCI9PXR5cGVvZiBjP2EoK2IsK2MpOmEoYixjKTphKCtiLCtjKX14Yi5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jLnModGhpcy5qLHRoaXMudSxhKX07eGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9XCJCaW5hcnkgRXhwcmVzc2lvbjogXCIrdGhpcy5jO2ErPUkodGhpcy5qKTtyZXR1cm4gYSs9SSh0aGlzLnUpfTtmdW5jdGlvbiBBYihhLGIsYyxkKXt0aGlzLkw9YTt0aGlzLkc9Yjt0aGlzLmw9Yzt0aGlzLnM9ZH1BYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5MfTt2YXIgQmI9e307XG5mdW5jdGlvbiBNKGEsYixjLGQpe2lmKEJiLmhhc093blByb3BlcnR5KGEpKXRocm93IEVycm9yKFwiQmluYXJ5IG9wZXJhdG9yIGFscmVhZHkgY3JlYXRlZDogXCIrYSk7YT1uZXcgQWIoYSxiLGMsZCk7cmV0dXJuIEJiW2EudG9TdHJpbmcoKV09YX1NKFwiZGl2XCIsNiwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gSihhLGMpL0ooYixjKX0pO00oXCJtb2RcIiw2LDEsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKKGEsYyklSihiLGMpfSk7TShcIipcIiw2LDEsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKKGEsYykqSihiLGMpfSk7TShcIitcIiw1LDEsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKKGEsYykrSihiLGMpfSk7TShcIi1cIiw1LDEsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBKKGEsYyktSihiLGMpfSk7TShcIjxcIiw0LDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiB6YihmdW5jdGlvbihkLGUpe3JldHVybiBkPGV9LGEsYixjKX0pO1xuTShcIj5cIiw0LDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiB6YihmdW5jdGlvbihkLGUpe3JldHVybiBkPmV9LGEsYixjKX0pO00oXCI8PVwiLDQsMixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHpiKGZ1bmN0aW9uKGQsZSl7cmV0dXJuIGQ8PWV9LGEsYixjKX0pO00oXCI+PVwiLDQsMixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHpiKGZ1bmN0aW9uKGQsZSl7cmV0dXJuIGQ+PWV9LGEsYixjKX0pO3ZhciB5Yj1NKFwiPVwiLDMsMixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHpiKGZ1bmN0aW9uKGQsZSl7cmV0dXJuIGQ9PWV9LGEsYixjLCEwKX0pO00oXCIhPVwiLDMsMixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHpiKGZ1bmN0aW9uKGQsZSl7cmV0dXJuIGQhPWV9LGEsYixjLCEwKX0pO00oXCJhbmRcIiwyLDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3YihhLGMpJiZ3YihiLGMpfSk7TShcIm9yXCIsMSwyLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gd2IoYSxjKXx8d2IoYixjKX0pO2Z1bmN0aW9uIENiKGEsYil7aWYoYi5hLmxlbmd0aCYmNCE9YS5sKXRocm93IEVycm9yKFwiUHJpbWFyeSBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gbm9kZXNldCBpZiBmaWx0ZXIgaGFzIHByZWRpY2F0ZShzKS5cIik7SC5jYWxsKHRoaXMsYS5sKTt0aGlzLmM9YTt0aGlzLmo9Yjt0aGlzLmk9YS5pO3RoaXMuYj1hLmJ9bShDYixIKTtDYi5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXthPXRoaXMuYy5hKGEpO3JldHVybiBEYih0aGlzLmosYSl9O0NiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiRmlsdGVyOlwiK0kodGhpcy5jKTtyZXR1cm4gYSs9SSh0aGlzLmopfTtmdW5jdGlvbiBFYihhLGIpe2lmKGIubGVuZ3RoPGEuRil0aHJvdyBFcnJvcihcIkZ1bmN0aW9uIFwiK2EubStcIiBleHBlY3RzIGF0IGxlYXN0XCIrYS5GK1wiIGFyZ3VtZW50cywgXCIrYi5sZW5ndGgrXCIgZ2l2ZW5cIik7aWYobnVsbCE9PWEuRCYmYi5sZW5ndGg+YS5EKXRocm93IEVycm9yKFwiRnVuY3Rpb24gXCIrYS5tK1wiIGV4cGVjdHMgYXQgbW9zdCBcIithLkQrXCIgYXJndW1lbnRzLCBcIitiLmxlbmd0aCtcIiBnaXZlblwiKTthLksmJm4oYixmdW5jdGlvbihjLGQpe2lmKDQhPWMubCl0aHJvdyBFcnJvcihcIkFyZ3VtZW50IFwiK2QrXCIgdG8gZnVuY3Rpb24gXCIrYS5tK1wiIGlzIG5vdCBvZiB0eXBlIE5vZGVzZXQ6IFwiK2MpO30pO0guY2FsbCh0aGlzLGEubCk7dGhpcy5CPWE7dGhpcy5jPWI7dWIodGhpcyxhLml8fHFhKGIsZnVuY3Rpb24oYyl7cmV0dXJuIGMuaX0pKTt2Yih0aGlzLGEuSiYmIWIubGVuZ3RofHxhLkkmJiEhYi5sZW5ndGh8fHFhKGIsZnVuY3Rpb24oYyl7cmV0dXJuIGMuYn0pKX1cbm0oRWIsSCk7RWIucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuQi5zLmFwcGx5KG51bGwsc2EoYSx0aGlzLmMpKX07RWIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9XCJGdW5jdGlvbjogXCIrdGhpcy5CO2lmKHRoaXMuYy5sZW5ndGgpe3ZhciBiPXBhKHRoaXMuYyxmdW5jdGlvbihjLGQpe3JldHVybiBjK0koZCl9LFwiQXJndW1lbnRzOlwiKTthKz1JKGIpfXJldHVybiBhfTtmdW5jdGlvbiBGYihhLGIsYyxkLGUsZixnLGspe3RoaXMubT1hO3RoaXMubD1iO3RoaXMuaT1jO3RoaXMuSj1kO3RoaXMuST0hMTt0aGlzLnM9ZTt0aGlzLkY9Zjt0aGlzLkQ9dm9pZCAwIT09Zz9nOmY7dGhpcy5LPSEha31GYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tfTt2YXIgR2I9e307XG5mdW5jdGlvbiBOKGEsYixjLGQsZSxmLGcsayl7aWYoR2IuaGFzT3duUHJvcGVydHkoYSkpdGhyb3cgRXJyb3IoXCJGdW5jdGlvbiBhbHJlYWR5IGNyZWF0ZWQ6IFwiK2ErXCIuXCIpO0diW2FdPW5ldyBGYihhLGIsYyxkLGUsZixnLGspfU4oXCJib29sZWFuXCIsMiwhMSwhMSxmdW5jdGlvbihhLGIpe3JldHVybiB3YihiLGEpfSwxKTtOKFwiY2VpbGluZ1wiLDEsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gTWF0aC5jZWlsKEooYixhKSl9LDEpO04oXCJjb25jYXRcIiwzLCExLCExLGZ1bmN0aW9uKGEsYil7cmV0dXJuIHBhKHRhKGFyZ3VtZW50cywxKSxmdW5jdGlvbihjLGQpe3JldHVybiBjK0woZCxhKX0sXCJcIil9LDIsbnVsbCk7TihcImNvbnRhaW5zXCIsMiwhMSwhMSxmdW5jdGlvbihhLGIsYyl7Yj1MKGIsYSk7YT1MKGMsYSk7cmV0dXJuLTEhPWIuaW5kZXhPZihhKX0sMik7TihcImNvdW50XCIsMSwhMSwhMSxmdW5jdGlvbihhLGIpe3JldHVybiBiLmEoYSkub30sMSwxLCEwKTtcbk4oXCJmYWxzZVwiLDIsITEsITEsZnVuY3Rpb24oKXtyZXR1cm4hMX0sMCk7TihcImZsb29yXCIsMSwhMSwhMSxmdW5jdGlvbihhLGIpe3JldHVybiBNYXRoLmZsb29yKEooYixhKSl9LDEpO04oXCJpZFwiLDQsITEsITEsZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGspe2lmKHgpe3ZhciBsPWUuYWxsW2tdO2lmKGwpe2lmKGwubm9kZVR5cGUmJms9PWwuaWQpcmV0dXJuIGw7aWYobC5sZW5ndGgpcmV0dXJuIHJhKGwsZnVuY3Rpb24odSl7cmV0dXJuIGs9PXUuaWR9KX1yZXR1cm4gbnVsbH1yZXR1cm4gZS5nZXRFbGVtZW50QnlJZChrKX12YXIgZD1hLmEsZT05PT1kLm5vZGVUeXBlP2Q6ZC5vd25lckRvY3VtZW50O2E9TChiLGEpLnNwbGl0KC9cXHMrLyk7dmFyIGY9W107bihhLGZ1bmN0aW9uKGspe2s9YyhrKTsha3x8MDw9bWEoZixrKXx8Zi5wdXNoKGspfSk7Zi5zb3J0KCRhKTt2YXIgZz1uZXcgRDtuKGYsZnVuY3Rpb24oayl7Zy5hZGQoayl9KTtyZXR1cm4gZ30sMSk7XG5OKFwibGFuZ1wiLDIsITEsITEsZnVuY3Rpb24oKXtyZXR1cm4hMX0sMSk7TihcImxhc3RcIiwxLCEwLCExLGZ1bmN0aW9uKGEpe2lmKDEhPWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgRXJyb3IoXCJGdW5jdGlvbiBsYXN0IGV4cGVjdHMgKClcIik7cmV0dXJuIGEuZn0sMCk7TihcImxvY2FsLW5hbWVcIiwzLCExLCEwLGZ1bmN0aW9uKGEsYil7cmV0dXJuKGE9Yj9yYihiLmEoYSkpOmEuYSk/YS5sb2NhbE5hbWV8fGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTpcIlwifSwwLDEsITApO04oXCJuYW1lXCIsMywhMSwhMCxmdW5jdGlvbihhLGIpe3JldHVybihhPWI/cmIoYi5hKGEpKTphLmEpP2Eubm9kZU5hbWUudG9Mb3dlckNhc2UoKTpcIlwifSwwLDEsITApO04oXCJuYW1lc3BhY2UtdXJpXCIsMywhMCwhMSxmdW5jdGlvbigpe3JldHVyblwiXCJ9LDAsMSwhMCk7XG5OKFwibm9ybWFsaXplLXNwYWNlXCIsMywhMSwhMCxmdW5jdGlvbihhLGIpe3JldHVybihiP0woYixhKTpCKGEuYSkpLnJlcGxhY2UoL1tcXHNcXHhhMF0rL2csXCIgXCIpLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9LDAsMSk7TihcIm5vdFwiLDIsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4hd2IoYixhKX0sMSk7TihcIm51bWJlclwiLDEsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9KKGIsYSk6K0IoYS5hKX0sMCwxKTtOKFwicG9zaXRpb25cIiwxLCEwLCExLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJ9LDApO04oXCJyb3VuZFwiLDEsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gTWF0aC5yb3VuZChKKGIsYSkpfSwxKTtOKFwic3RhcnRzLXdpdGhcIiwyLCExLCExLGZ1bmN0aW9uKGEsYixjKXtiPUwoYixhKTthPUwoYyxhKTtyZXR1cm4gMD09Yi5sYXN0SW5kZXhPZihhLDApfSwyKTtOKFwic3RyaW5nXCIsMywhMSwhMCxmdW5jdGlvbihhLGIpe3JldHVybiBiP0woYixhKTpCKGEuYSl9LDAsMSk7XG5OKFwic3RyaW5nLWxlbmd0aFwiLDEsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4oYj9MKGIsYSk6QihhLmEpKS5sZW5ndGh9LDAsMSk7TihcInN1YnN0cmluZ1wiLDMsITEsITEsZnVuY3Rpb24oYSxiLGMsZCl7Yz1KKGMsYSk7aWYoaXNOYU4oYyl8fEluZmluaXR5PT1jfHwtSW5maW5pdHk9PWMpcmV0dXJuXCJcIjtkPWQ/SihkLGEpOkluZmluaXR5O2lmKGlzTmFOKGQpfHwtSW5maW5pdHk9PT1kKXJldHVyblwiXCI7Yz1NYXRoLnJvdW5kKGMpLTE7dmFyIGU9TWF0aC5tYXgoYywwKTthPUwoYixhKTtyZXR1cm4gSW5maW5pdHk9PWQ/YS5zdWJzdHJpbmcoZSk6YS5zdWJzdHJpbmcoZSxjK01hdGgucm91bmQoZCkpfSwyLDMpO04oXCJzdWJzdHJpbmctYWZ0ZXJcIiwzLCExLCExLGZ1bmN0aW9uKGEsYixjKXtiPUwoYixhKTthPUwoYyxhKTtjPWIuaW5kZXhPZihhKTtyZXR1cm4tMT09Yz9cIlwiOmIuc3Vic3RyaW5nKGMrYS5sZW5ndGgpfSwyKTtcbk4oXCJzdWJzdHJpbmctYmVmb3JlXCIsMywhMSwhMSxmdW5jdGlvbihhLGIsYyl7Yj1MKGIsYSk7YT1MKGMsYSk7YT1iLmluZGV4T2YoYSk7cmV0dXJuLTE9PWE/XCJcIjpiLnN1YnN0cmluZygwLGEpfSwyKTtOKFwic3VtXCIsMSwhMSwhMSxmdW5jdGlvbihhLGIpe2E9RihiLmEoYSkpO2I9MDtmb3IodmFyIGM9RyhhKTtjO2M9RyhhKSliKz0rQihjKTtyZXR1cm4gYn0sMSwxLCEwKTtOKFwidHJhbnNsYXRlXCIsMywhMSwhMSxmdW5jdGlvbihhLGIsYyxkKXtiPUwoYixhKTtjPUwoYyxhKTt2YXIgZT1MKGQsYSk7YT17fTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZj1jLmNoYXJBdChkKTtmIGluIGF8fChhW2ZdPWUuY2hhckF0KGQpKX1jPVwiXCI7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylmPWIuY2hhckF0KGQpLGMrPWYgaW4gYT9hW2ZdOmY7cmV0dXJuIGN9LDMpO04oXCJ0cnVlXCIsMiwhMSwhMSxmdW5jdGlvbigpe3JldHVybiEwfSwwKTtmdW5jdGlvbiBFKGEsYil7dGhpcy5qPWE7dGhpcy5jPXZvaWQgMCE9PWI/YjpudWxsO3RoaXMuYj1udWxsO3N3aXRjaChhKXtjYXNlIFwiY29tbWVudFwiOnRoaXMuYj04O2JyZWFrO2Nhc2UgXCJ0ZXh0XCI6dGhpcy5iPTM7YnJlYWs7Y2FzZSBcInByb2Nlc3NpbmctaW5zdHJ1Y3Rpb25cIjp0aGlzLmI9NzticmVhaztjYXNlIFwibm9kZVwiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50XCIpO319ZnVuY3Rpb24gSGIoYSl7cmV0dXJuXCJjb21tZW50XCI9PWF8fFwidGV4dFwiPT1hfHxcInByb2Nlc3NpbmctaW5zdHJ1Y3Rpb25cIj09YXx8XCJub2RlXCI9PWF9RS5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09PXRoaXMuYnx8dGhpcy5iPT1hLm5vZGVUeXBlfTtFLnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuan07XG5FLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiS2luZCBUZXN0OiBcIit0aGlzLmo7bnVsbD09PXRoaXMuY3x8KGErPUkodGhpcy5jKSk7cmV0dXJuIGF9O2Z1bmN0aW9uIEliKGEpe0guY2FsbCh0aGlzLDMpO3RoaXMuYz1hLnN1YnN0cmluZygxLGEubGVuZ3RoLTEpfW0oSWIsSCk7SWIucHJvdG90eXBlLmE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jfTtJYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkxpdGVyYWw6IFwiK3RoaXMuY307ZnVuY3Rpb24gamIoYSxiKXt0aGlzLm09YS50b0xvd2VyQ2FzZSgpO2E9XCIqXCI9PXRoaXMubT9cIipcIjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjt0aGlzLmM9Yj9iLnRvTG93ZXJDYXNlKCk6YX1qYi5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVUeXBlO2lmKDEhPWImJjIhPWIpcmV0dXJuITE7Yj12b2lkIDAhPT1hLmxvY2FsTmFtZT9hLmxvY2FsTmFtZTphLm5vZGVOYW1lO3JldHVyblwiKlwiIT10aGlzLm0mJnRoaXMubSE9Yi50b0xvd2VyQ2FzZSgpPyExOlwiKlwiPT10aGlzLmM/ITA6dGhpcy5jPT0oYS5uYW1lc3BhY2VVUkk/YS5uYW1lc3BhY2VVUkkudG9Mb3dlckNhc2UoKTpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIil9O2piLnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubX07XG5qYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5hbWUgVGVzdDogXCIrKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT10aGlzLmM/XCJcIjp0aGlzLmMrXCI6XCIpK3RoaXMubX07ZnVuY3Rpb24gSmIoYSl7SC5jYWxsKHRoaXMsMSk7dGhpcy5jPWF9bShKYixIKTtKYi5wcm90b3R5cGUuYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN9O0piLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTnVtYmVyOiBcIit0aGlzLmN9O2Z1bmN0aW9uIEtiKGEsYil7SC5jYWxsKHRoaXMsYS5sKTt0aGlzLmo9YTt0aGlzLmM9Yjt0aGlzLmk9YS5pO3RoaXMuYj1hLmI7MT09dGhpcy5jLmxlbmd0aCYmKGE9dGhpcy5jWzBdLGEuQ3x8YS5jIT1MYnx8KGE9YS51LFwiKlwiIT1hLmYoKSYmKHRoaXMuZj17bmFtZTphLmYoKSxBOm51bGx9KSkpfW0oS2IsSCk7ZnVuY3Rpb24gTWIoKXtILmNhbGwodGhpcyw0KX1tKE1iLEgpO01iLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBEO2E9YS5hOzk9PWEubm9kZVR5cGU/Yi5hZGQoYSk6Yi5hZGQoYS5vd25lckRvY3VtZW50KTtyZXR1cm4gYn07TWIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJSb290IEhlbHBlciBFeHByZXNzaW9uXCJ9O2Z1bmN0aW9uIE5iKCl7SC5jYWxsKHRoaXMsNCl9bShOYixIKTtOYi5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgRDtiLmFkZChhLmEpO3JldHVybiBifTtOYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkNvbnRleHQgSGVscGVyIEV4cHJlc3Npb25cIn07XG5mdW5jdGlvbiBPYihhKXtyZXR1cm5cIi9cIj09YXx8XCIvL1wiPT1hfUtiLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuai5hKGEpO2lmKCEoYiBpbnN0YW5jZW9mIEQpKXRocm93IEVycm9yKFwiRmlsdGVyIGV4cHJlc3Npb24gbXVzdCBldmFsdWF0ZSB0byBub2Rlc2V0LlwiKTthPXRoaXMuYztmb3IodmFyIGM9MCxkPWEubGVuZ3RoO2M8ZCYmYi5vO2MrKyl7dmFyIGU9YVtjXSxmPUYoYixlLmMudik7aWYoZS5pfHxlLmMhPVBiKWlmKGUuaXx8ZS5jIT1RYil7dmFyIGc9RyhmKTtmb3IoYj1lLmEobmV3IGthKGcpKTtudWxsIT0oZz1HKGYpKTspZz1lLmEobmV3IGthKGcpKSxiPXBiKGIsZyl9ZWxzZSBnPUcoZiksYj1lLmEobmV3IGthKGcpKTtlbHNle2ZvcihnPUcoZik7KGI9RyhmKSkmJighZy5jb250YWluc3x8Zy5jb250YWlucyhiKSkmJmIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZykmODtnPWIpO2I9ZS5hKG5ldyBrYShnKSl9fXJldHVybiBifTtcbktiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiUGF0aCBFeHByZXNzaW9uOlwiK0kodGhpcy5qKTtpZih0aGlzLmMubGVuZ3RoKXt2YXIgYj1wYSh0aGlzLmMsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytJKGQpfSxcIlN0ZXBzOlwiKTthKz1JKGIpfXJldHVybiBhfTtmdW5jdGlvbiBSYihhLGIpe3RoaXMuYT1hO3RoaXMudj0hIWJ9XG5mdW5jdGlvbiBEYihhLGIsYyl7Zm9yKGM9Y3x8MDtjPGEuYS5sZW5ndGg7YysrKWZvcih2YXIgZD1hLmFbY10sZT1GKGIpLGY9Yi5vLGcsaz0wO2c9RyhlKTtrKyspe3ZhciBsPWEudj9mLWs6aysxO2c9ZC5hKG5ldyBrYShnLGwsZikpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBnKWw9bD09ZztlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBnfHxcImJvb2xlYW5cIj09dHlwZW9mIGcpbD0hIWc7ZWxzZSBpZihnIGluc3RhbmNlb2YgRClsPTA8Zy5vO2Vsc2UgdGhyb3cgRXJyb3IoXCJQcmVkaWNhdGUuZXZhbHVhdGUgcmV0dXJuZWQgYW4gdW5leHBlY3RlZCB0eXBlLlwiKTtpZighbCl7bD1lO2c9bC5mO3ZhciB1PWwuYTtpZighdSl0aHJvdyBFcnJvcihcIk5leHQgbXVzdCBiZSBjYWxsZWQgYXQgbGVhc3Qgb25jZSBiZWZvcmUgcmVtb3ZlLlwiKTt2YXIgSz11LmI7dT11LmE7Sz9LLmE9dTpnLmE9dTt1P3UuYj1LOmcuYj1LO2cuby0tO2wuYT1udWxsfX1yZXR1cm4gYn1cblJiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBwYSh0aGlzLmEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYStJKGIpfSxcIlByZWRpY2F0ZXM6XCIpfTtmdW5jdGlvbiBPKGEsYixjLGQpe0guY2FsbCh0aGlzLDQpO3RoaXMuYz1hO3RoaXMudT1iO3RoaXMuaj1jfHxuZXcgUmIoW10pO3RoaXMuQz0hIWQ7Yj10aGlzLmo7Yj0wPGIuYS5sZW5ndGg/Yi5hWzBdLmY6bnVsbDthLk0mJmImJihhPWIubmFtZSxhPXg/YS50b0xvd2VyQ2FzZSgpOmEsdGhpcy5mPXtuYW1lOmEsQTpiLkF9KTthOnthPXRoaXMuajtmb3IoYj0wO2I8YS5hLmxlbmd0aDtiKyspaWYoYz1hLmFbYl0sYy5pfHwxPT1jLmx8fDA9PWMubCl7YT0hMDticmVhayBhfWE9ITF9dGhpcy5pPWF9bShPLEgpO1xuTy5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXt2YXIgYj1hLmEsYz10aGlzLmYsZD1udWxsLGU9bnVsbCxmPTA7YyYmKGQ9Yy5uYW1lLGU9Yy5BP0woYy5BLGEpOm51bGwsZj0xKTtpZih0aGlzLkMpaWYodGhpcy5pfHx0aGlzLmMhPVNiKWlmKGI9RigobmV3IE8oVGIsbmV3IEUoXCJub2RlXCIpKSkuYShhKSksYz1HKGIpKWZvcihhPXRoaXMucyhjLGQsZSxmKTtudWxsIT0oYz1HKGIpKTspYT1wYihhLHRoaXMucyhjLGQsZSxmKSk7ZWxzZSBhPW5ldyBEO2Vsc2UgYT1nYih0aGlzLnUsYixkLGUpLGE9RGIodGhpcy5qLGEsZik7ZWxzZSBhPXRoaXMucyhhLmEsZCxlLGYpO3JldHVybiBhfTtPLnByb3RvdHlwZS5zPWZ1bmN0aW9uKGEsYixjLGQpe2E9dGhpcy5jLkIodGhpcy51LGEsYixjKTtyZXR1cm4gYT1EYih0aGlzLmosYSxkKX07XG5PLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiU3RlcDpcIitJKFwiT3BlcmF0b3I6IFwiKyh0aGlzLkM/XCIvL1wiOlwiL1wiKSk7dGhpcy5jLm0mJihhKz1JKFwiQXhpczogXCIrdGhpcy5jKSk7YSs9SSh0aGlzLnUpO2lmKHRoaXMuai5hLmxlbmd0aCl7dmFyIGI9cGEodGhpcy5qLmEsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytJKGQpfSxcIlByZWRpY2F0ZXM6XCIpO2ErPUkoYil9cmV0dXJuIGF9O2Z1bmN0aW9uIFViKGEsYixjLGQpe3RoaXMubT1hO3RoaXMuQj1iO3RoaXMudj1jO3RoaXMuTT1kfVViLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm19O3ZhciBWYj17fTtmdW5jdGlvbiBQKGEsYixjLGQpe2lmKFZiLmhhc093blByb3BlcnR5KGEpKXRocm93IEVycm9yKFwiQXhpcyBhbHJlYWR5IGNyZWF0ZWQ6IFwiK2EpO2I9bmV3IFViKGEsYixjLCEhZCk7cmV0dXJuIFZiW2FdPWJ9XG5QKFwiYW5jZXN0b3JcIixmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1uZXcgRDtiPWIucGFyZW50Tm9kZTspYS5hKGIpJiZxYihjLGIpO3JldHVybiBjfSwhMCk7UChcImFuY2VzdG9yLW9yLXNlbGZcIixmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBEO2RvIGEuYShiKSYmcWIoYyxiKTt3aGlsZShiPWIucGFyZW50Tm9kZSk7cmV0dXJuIGN9LCEwKTtcbnZhciBMYj1QKFwiYXR0cmlidXRlXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgRCxkPWEuZigpO2lmKFwic3R5bGVcIj09ZCYmeCYmYi5zdHlsZSlyZXR1cm4gYy5hZGQobmV3IFFhKGIuc3R5bGUsYixcInN0eWxlXCIsYi5zdHlsZS5jc3NUZXh0KSksYzt2YXIgZT1iLmF0dHJpYnV0ZXM7aWYoZSlpZihhIGluc3RhbmNlb2YgRSYmbnVsbD09PWEuYnx8XCIqXCI9PWQpZm9yKGE9MDtkPWVbYV07YSsrKXg/ZC5ub2RlVmFsdWUmJmMuYWRkKFNhKGIsZCkpOmMuYWRkKGQpO2Vsc2UoZD1lLmdldE5hbWVkSXRlbShkKSkmJih4P2Qubm9kZVZhbHVlJiZjLmFkZChTYShiLGQpKTpjLmFkZChkKSk7cmV0dXJuIGN9LCExKSxTYj1QKFwiY2hpbGRcIixmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybih4P21iOm5iKS5jYWxsKG51bGwsYSxiLGFhKGMpP2M6bnVsbCxhYShkKT9kOm51bGwsZXx8bmV3IEQpfSwhMSwhMCk7UChcImRlc2NlbmRhbnRcIixnYiwhMSwhMCk7XG52YXIgVGI9UChcImRlc2NlbmRhbnQtb3Itc2VsZlwiLGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBEO0MoYixjLGQpJiZhLmEoYikmJmUuYWRkKGIpO3JldHVybiBnYihhLGIsYyxkLGUpfSwhMSwhMCksUGI9UChcImZvbGxvd2luZ1wiLGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBEO2RvIGZvcih2YXIgZj1iO2Y9Zi5uZXh0U2libGluZzspQyhmLGMsZCkmJmEuYShmKSYmZS5hZGQoZiksZT1nYihhLGYsYyxkLGUpO3doaWxlKGI9Yi5wYXJlbnROb2RlKTtyZXR1cm4gZX0sITEsITApO1AoXCJmb2xsb3dpbmctc2libGluZ1wiLGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPW5ldyBEO2I9Yi5uZXh0U2libGluZzspYS5hKGIpJiZjLmFkZChiKTtyZXR1cm4gY30sITEpO1AoXCJuYW1lc3BhY2VcIixmdW5jdGlvbigpe3JldHVybiBuZXcgRH0sITEpO1xudmFyIFdiPVAoXCJwYXJlbnRcIixmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBEO2lmKDk9PWIubm9kZVR5cGUpcmV0dXJuIGM7aWYoMj09Yi5ub2RlVHlwZSlyZXR1cm4gYy5hZGQoYi5vd25lckVsZW1lbnQpLGM7Yj1iLnBhcmVudE5vZGU7YS5hKGIpJiZjLmFkZChiKTtyZXR1cm4gY30sITEpLFFiPVAoXCJwcmVjZWRpbmdcIixmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgRCxmPVtdO2RvIGYudW5zaGlmdChiKTt3aGlsZShiPWIucGFyZW50Tm9kZSk7Zm9yKHZhciBnPTEsaz1mLmxlbmd0aDtnPGs7ZysrKXt2YXIgbD1bXTtmb3IoYj1mW2ddO2I9Yi5wcmV2aW91c1NpYmxpbmc7KWwudW5zaGlmdChiKTtmb3IodmFyIHU9MCxLPWwubGVuZ3RoO3U8Szt1KyspYj1sW3VdLEMoYixjLGQpJiZhLmEoYikmJmUuYWRkKGIpLGU9Z2IoYSxiLGMsZCxlKX1yZXR1cm4gZX0sITAsITApO1xuUChcInByZWNlZGluZy1zaWJsaW5nXCIsZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9bmV3IEQ7Yj1iLnByZXZpb3VzU2libGluZzspYS5hKGIpJiZxYihjLGIpO3JldHVybiBjfSwhMCk7dmFyIFhiPVAoXCJzZWxmXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgRDthLmEoYikmJmMuYWRkKGIpO3JldHVybiBjfSwhMSk7ZnVuY3Rpb24gWWIoYSl7SC5jYWxsKHRoaXMsMSk7dGhpcy5jPWE7dGhpcy5pPWEuaTt0aGlzLmI9YS5ifW0oWWIsSCk7WWIucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuLUoodGhpcy5jLGEpfTtZYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlVuYXJ5IEV4cHJlc3Npb246IC1cIitJKHRoaXMuYyl9O2Z1bmN0aW9uIFpiKGEpe0guY2FsbCh0aGlzLDQpO3RoaXMuYz1hO3ViKHRoaXMscWEodGhpcy5jLGZ1bmN0aW9uKGIpe3JldHVybiBiLml9KSk7dmIodGhpcyxxYSh0aGlzLmMsZnVuY3Rpb24oYil7cmV0dXJuIGIuYn0pKX1tKFpiLEgpO1piLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBEO24odGhpcy5jLGZ1bmN0aW9uKGMpe2M9Yy5hKGEpO2lmKCEoYyBpbnN0YW5jZW9mIEQpKXRocm93IEVycm9yKFwiUGF0aCBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gTm9kZVNldC5cIik7Yj1wYihiLGMpfSk7cmV0dXJuIGJ9O1piLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBwYSh0aGlzLmMsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYStJKGIpfSxcIlVuaW9uIEV4cHJlc3Npb246XCIpfTtmdW5jdGlvbiAkYihhLGIpe3RoaXMuYT1hO3RoaXMuYj1ifWZ1bmN0aW9uIGFjKGEpe2Zvcih2YXIgYixjPVtdOzspe1EoYSxcIk1pc3NpbmcgcmlnaHQgaGFuZCBzaWRlIG9mIGJpbmFyeSBleHByZXNzaW9uLlwiKTtiPWJjKGEpO3ZhciBkPXooYS5hKTtpZighZClicmVhazt2YXIgZT0oZD1CYltkXXx8bnVsbCkmJmQuRztpZighZSl7YS5hLmEtLTticmVha31mb3IoO2MubGVuZ3RoJiZlPD1jW2MubGVuZ3RoLTFdLkc7KWI9bmV3IHhiKGMucG9wKCksYy5wb3AoKSxiKTtjLnB1c2goYixkKX1mb3IoO2MubGVuZ3RoOyliPW5ldyB4YihjLnBvcCgpLGMucG9wKCksYik7cmV0dXJuIGJ9ZnVuY3Rpb24gUShhLGIpe2lmKFhhKGEuYSkpdGhyb3cgRXJyb3IoYik7fWZ1bmN0aW9uIGNjKGEsYil7YT16KGEuYSk7aWYoYSE9Yil0aHJvdyBFcnJvcihcIkJhZCB0b2tlbiwgZXhwZWN0ZWQ6IFwiK2IrXCIgZ290OiBcIithKTt9XG5mdW5jdGlvbiBkYyhhKXthPXooYS5hKTtpZihcIilcIiE9YSl0aHJvdyBFcnJvcihcIkJhZCB0b2tlbjogXCIrYSk7fWZ1bmN0aW9uIGVjKGEpe2E9eihhLmEpO2lmKDI+YS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJVbmNsb3NlZCBsaXRlcmFsIHN0cmluZ1wiKTtyZXR1cm4gbmV3IEliKGEpfVxuZnVuY3Rpb24gZmMoYSl7dmFyIGI9W107aWYoT2IoeShhLmEpKSl7dmFyIGM9eihhLmEpO3ZhciBkPXkoYS5hKTtpZihcIi9cIj09YyYmKFhhKGEuYSl8fFwiLlwiIT1kJiZcIi4uXCIhPWQmJlwiQFwiIT1kJiZcIipcIiE9ZCYmIS8oPyFbMC05XSlbXFx3XS8udGVzdChkKSkpcmV0dXJuIG5ldyBNYjtkPW5ldyBNYjtRKGEsXCJNaXNzaW5nIG5leHQgbG9jYXRpb24gc3RlcC5cIik7Yz1nYyhhLGMpO2IucHVzaChjKX1lbHNle2E6e2M9eShhLmEpO2Q9Yy5jaGFyQXQoMCk7c3dpdGNoKGQpe2Nhc2UgXCIkXCI6dGhyb3cgRXJyb3IoXCJWYXJpYWJsZSByZWZlcmVuY2Ugbm90IGFsbG93ZWQgaW4gSFRNTCBYUGF0aFwiKTtjYXNlIFwiKFwiOnooYS5hKTtjPWFjKGEpO1EoYSwndW5jbG9zZWQgXCIoXCInKTtjYyhhLFwiKVwiKTticmVhaztjYXNlICdcIic6Y2FzZSBcIidcIjpjPWVjKGEpO2JyZWFrO2RlZmF1bHQ6aWYoaXNOYU4oK2MpKWlmKCFIYihjKSYmLyg/IVswLTldKVtcXHddLy50ZXN0KGQpJiZcIihcIj09eShhLmEsMSkpe2M9eihhLmEpO1xuYz1HYltjXXx8bnVsbDt6KGEuYSk7Zm9yKGQ9W107XCIpXCIhPXkoYS5hKTspe1EoYSxcIk1pc3NpbmcgZnVuY3Rpb24gYXJndW1lbnQgbGlzdC5cIik7ZC5wdXNoKGFjKGEpKTtpZihcIixcIiE9eShhLmEpKWJyZWFrO3ooYS5hKX1RKGEsXCJVbmNsb3NlZCBmdW5jdGlvbiBhcmd1bWVudCBsaXN0LlwiKTtkYyhhKTtjPW5ldyBFYihjLGQpfWVsc2V7Yz1udWxsO2JyZWFrIGF9ZWxzZSBjPW5ldyBKYigreihhLmEpKX1cIltcIj09eShhLmEpJiYoZD1uZXcgUmIoaGMoYSkpLGM9bmV3IENiKGMsZCkpfWlmKGMpaWYoT2IoeShhLmEpKSlkPWM7ZWxzZSByZXR1cm4gYztlbHNlIGM9Z2MoYSxcIi9cIiksZD1uZXcgTmIsYi5wdXNoKGMpfWZvcig7T2IoeShhLmEpKTspYz16KGEuYSksUShhLFwiTWlzc2luZyBuZXh0IGxvY2F0aW9uIHN0ZXAuXCIpLGM9Z2MoYSxjKSxiLnB1c2goYyk7cmV0dXJuIG5ldyBLYihkLGIpfVxuZnVuY3Rpb24gZ2MoYSxiKXtpZihcIi9cIiE9YiYmXCIvL1wiIT1iKXRocm93IEVycm9yKCdTdGVwIG9wIHNob3VsZCBiZSBcIi9cIiBvciBcIi8vXCInKTtpZihcIi5cIj09eShhLmEpKXt2YXIgYz1uZXcgTyhYYixuZXcgRShcIm5vZGVcIikpO3ooYS5hKTtyZXR1cm4gY31pZihcIi4uXCI9PXkoYS5hKSlyZXR1cm4gYz1uZXcgTyhXYixuZXcgRShcIm5vZGVcIikpLHooYS5hKSxjO2lmKFwiQFwiPT15KGEuYSkpe3ZhciBkPUxiO3ooYS5hKTtRKGEsXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lXCIpfWVsc2UgaWYoXCI6OlwiPT15KGEuYSwxKSl7aWYoIS8oPyFbMC05XSlbXFx3XS8udGVzdCh5KGEuYSkuY2hhckF0KDApKSl0aHJvdyBFcnJvcihcIkJhZCB0b2tlbjogXCIreihhLmEpKTt2YXIgZT16KGEuYSk7ZD1WYltlXXx8bnVsbDtpZighZCl0aHJvdyBFcnJvcihcIk5vIGF4aXMgd2l0aCBuYW1lOiBcIitlKTt6KGEuYSk7UShhLFwiTWlzc2luZyBub2RlIG5hbWVcIil9ZWxzZSBkPVNiO2U9eShhLmEpO2lmKC8oPyFbMC05XSlbXFx3XFwqXS8udGVzdChlLmNoYXJBdCgwKSkpaWYoXCIoXCI9PVxueShhLmEsMSkpe2lmKCFIYihlKSl0aHJvdyBFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIitlKTtlPXooYS5hKTtpZighSGIoZSkpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHR5cGUgbmFtZTogXCIrZSk7Y2MoYSxcIihcIik7UShhLFwiQmFkIG5vZGV0eXBlXCIpO3ZhciBmPXkoYS5hKS5jaGFyQXQoMCksZz1udWxsO2lmKCdcIic9PWZ8fFwiJ1wiPT1mKWc9ZWMoYSk7UShhLFwiQmFkIG5vZGV0eXBlXCIpO2RjKGEpO2U9bmV3IEUoZSxnKX1lbHNlIGlmKGU9eihhLmEpLGY9ZS5pbmRleE9mKFwiOlwiKSwtMT09ZillPW5ldyBqYihlKTtlbHNle2c9ZS5zdWJzdHJpbmcoMCxmKTtpZihcIipcIj09Zyl2YXIgaz1cIipcIjtlbHNlIGlmKGs9YS5iKGcpLCFrKXRocm93IEVycm9yKFwiTmFtZXNwYWNlIHByZWZpeCBub3QgZGVjbGFyZWQ6IFwiK2cpO2U9ZS5zdWJzdHIoZisxKTtlPW5ldyBqYihlLGspfWVsc2UgdGhyb3cgRXJyb3IoXCJCYWQgdG9rZW46IFwiK3ooYS5hKSk7YT1uZXcgUmIoaGMoYSksZC52KTtyZXR1cm4gY3x8XG5uZXcgTyhkLGUsYSxcIi8vXCI9PWIpfWZ1bmN0aW9uIGhjKGEpe2Zvcih2YXIgYj1bXTtcIltcIj09eShhLmEpOyl7eihhLmEpO1EoYSxcIk1pc3NpbmcgcHJlZGljYXRlIGV4cHJlc3Npb24uXCIpO3ZhciBjPWFjKGEpO2IucHVzaChjKTtRKGEsXCJVbmNsb3NlZCBwcmVkaWNhdGUgZXhwcmVzc2lvbi5cIik7Y2MoYSxcIl1cIil9cmV0dXJuIGJ9ZnVuY3Rpb24gYmMoYSl7aWYoXCItXCI9PXkoYS5hKSlyZXR1cm4geihhLmEpLG5ldyBZYihiYyhhKSk7dmFyIGI9ZmMoYSk7aWYoXCJ8XCIhPXkoYS5hKSlhPWI7ZWxzZXtmb3IoYj1bYl07XCJ8XCI9PXooYS5hKTspUShhLFwiTWlzc2luZyBuZXh0IHVuaW9uIGxvY2F0aW9uIHBhdGguXCIpLGIucHVzaChmYyhhKSk7YS5hLmEtLTthPW5ldyBaYihiKX1yZXR1cm4gYX07ZnVuY3Rpb24gaWMoYSl7c3dpdGNoKGEubm9kZVR5cGUpe2Nhc2UgMTpyZXR1cm4gaWEoamMsYSk7Y2FzZSA5OnJldHVybiBpYyhhLmRvY3VtZW50RWxlbWVudCk7Y2FzZSAxMTpjYXNlIDEwOmNhc2UgNjpjYXNlIDEyOnJldHVybiBrYztkZWZhdWx0OnJldHVybiBhLnBhcmVudE5vZGU/aWMoYS5wYXJlbnROb2RlKTprY319ZnVuY3Rpb24ga2MoKXtyZXR1cm4gbnVsbH1mdW5jdGlvbiBqYyhhLGIpe2lmKGEucHJlZml4PT1iKXJldHVybiBhLm5hbWVzcGFjZVVSSXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7dmFyIGM9YS5nZXRBdHRyaWJ1dGVOb2RlKFwieG1sbnM6XCIrYik7cmV0dXJuIGMmJmMuc3BlY2lmaWVkP2MudmFsdWV8fG51bGw6YS5wYXJlbnROb2RlJiY5IT1hLnBhcmVudE5vZGUubm9kZVR5cGU/amMoYS5wYXJlbnROb2RlLGIpOm51bGx9O2Z1bmN0aW9uIGxjKGEsYil7aWYoIWEubGVuZ3RoKXRocm93IEVycm9yKFwiRW1wdHkgWFBhdGggZXhwcmVzc2lvbi5cIik7YT1VYShhKTtpZihYYShhKSl0aHJvdyBFcnJvcihcIkludmFsaWQgWFBhdGggZXhwcmVzc2lvbi5cIik7Yj9cImZ1bmN0aW9uXCI9PWNhKGIpfHwoYj1oYShiLmxvb2t1cE5hbWVzcGFjZVVSSSxiKSk6Yj1mdW5jdGlvbigpe3JldHVybiBudWxsfTt2YXIgYz1hYyhuZXcgJGIoYSxiKSk7aWYoIVhhKGEpKXRocm93IEVycm9yKFwiQmFkIHRva2VuOiBcIit6KGEpKTt0aGlzLmV2YWx1YXRlPWZ1bmN0aW9uKGQsZSl7ZD1jLmEobmV3IGthKGQpKTtyZXR1cm4gbmV3IFQoZCxlKX19XG5mdW5jdGlvbiBUKGEsYil7aWYoMD09YilpZihhIGluc3RhbmNlb2YgRCliPTQ7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYSliPTI7ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgYSliPTE7ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIGEpYj0zO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIGV2YWx1YXRpb24gcmVzdWx0LlwiKTtpZigyIT1iJiYxIT1iJiYzIT1iJiYhKGEgaW5zdGFuY2VvZiBEKSl0aHJvdyBFcnJvcihcInZhbHVlIGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gdGhlIHNwZWNpZmllZCB0eXBlXCIpO3RoaXMucmVzdWx0VHlwZT1iO3N3aXRjaChiKXtjYXNlIDI6dGhpcy5zdHJpbmdWYWx1ZT1hIGluc3RhbmNlb2YgRD9zYihhKTpcIlwiK2E7YnJlYWs7Y2FzZSAxOnRoaXMubnVtYmVyVmFsdWU9YSBpbnN0YW5jZW9mIEQ/K3NiKGEpOithO2JyZWFrO2Nhc2UgMzp0aGlzLmJvb2xlYW5WYWx1ZT1hIGluc3RhbmNlb2YgRD8wPGEubzohIWE7YnJlYWs7Y2FzZSA0OmNhc2UgNTpjYXNlIDY6Y2FzZSA3OnZhciBjPVxuRihhKTt2YXIgZD1bXTtmb3IodmFyIGU9RyhjKTtlO2U9RyhjKSlkLnB1c2goZSBpbnN0YW5jZW9mIFFhP2UuYTplKTt0aGlzLnNuYXBzaG90TGVuZ3RoPWEubzt0aGlzLmludmFsaWRJdGVyYXRvclN0YXRlPSExO2JyZWFrO2Nhc2UgODpjYXNlIDk6YT1yYihhKTt0aGlzLnNpbmdsZU5vZGVWYWx1ZT1hIGluc3RhbmNlb2YgUWE/YS5hOmE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVua25vd24gWFBhdGhSZXN1bHQgdHlwZS5cIik7fXZhciBmPTA7dGhpcy5pdGVyYXRlTmV4dD1mdW5jdGlvbigpe2lmKDQhPWImJjUhPWIpdGhyb3cgRXJyb3IoXCJpdGVyYXRlTmV4dCBjYWxsZWQgd2l0aCB3cm9uZyByZXN1bHQgdHlwZVwiKTtyZXR1cm4gZj49ZC5sZW5ndGg/bnVsbDpkW2YrK119O3RoaXMuc25hcHNob3RJdGVtPWZ1bmN0aW9uKGcpe2lmKDYhPWImJjchPWIpdGhyb3cgRXJyb3IoXCJzbmFwc2hvdEl0ZW0gY2FsbGVkIHdpdGggd3JvbmcgcmVzdWx0IHR5cGVcIik7cmV0dXJuIGc+PWQubGVuZ3RofHxcbjA+Zz9udWxsOmRbZ119fVQuQU5ZX1RZUEU9MDtULk5VTUJFUl9UWVBFPTE7VC5TVFJJTkdfVFlQRT0yO1QuQk9PTEVBTl9UWVBFPTM7VC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFPTQ7VC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRT01O1QuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRT02O1QuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU9NztULkFOWV9VTk9SREVSRURfTk9ERV9UWVBFPTg7VC5GSVJTVF9PUkRFUkVEX05PREVfVFlQRT05O2Z1bmN0aW9uIG1jKGEpe3RoaXMubG9va3VwTmFtZXNwYWNlVVJJPWljKGEpfVxuZnVuY3Rpb24gbmMoYSxiKXthPWF8fGg7dmFyIGM9YS5Eb2N1bWVudCYmYS5Eb2N1bWVudC5wcm90b3R5cGV8fGEuZG9jdW1lbnQ7aWYoIWMuZXZhbHVhdGV8fGIpYS5YUGF0aFJlc3VsdD1ULGMuZXZhbHVhdGU9ZnVuY3Rpb24oZCxlLGYsZyl7cmV0dXJuKG5ldyBsYyhkLGYpKS5ldmFsdWF0ZShlLGcpfSxjLmNyZWF0ZUV4cHJlc3Npb249ZnVuY3Rpb24oZCxlKXtyZXR1cm4gbmV3IGxjKGQsZSl9LGMuY3JlYXRlTlNSZXNvbHZlcj1mdW5jdGlvbihkKXtyZXR1cm4gbmV3IG1jKGQpfX1iYShcIndneHBhdGguaW5zdGFsbFwiLG5jKTtiYShcIndneHBhdGguaW5zdGFsbFwiLG5jKTt2YXIgb2M9d2luZG93O2Z1bmN0aW9uIFUoYSxiKXt0aGlzLmNvZGU9YTt0aGlzLmE9VlthXXx8cGM7dGhpcy5tZXNzYWdlPWJ8fFwiXCI7YT10aGlzLmEucmVwbGFjZSgvKCg/Ol58XFxzKylbYS16XSkvZyxmdW5jdGlvbihjKXtyZXR1cm4gYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL15bXFxzXFx4YTBdKy9nLFwiXCIpfSk7Yj1hLmxlbmd0aC01O2lmKDA+Ynx8YS5pbmRleE9mKFwiRXJyb3JcIixiKSE9YilhKz1cIkVycm9yXCI7dGhpcy5uYW1lPWE7YT1FcnJvcih0aGlzLm1lc3NhZ2UpO2EubmFtZT10aGlzLm5hbWU7dGhpcy5zdGFjaz1hLnN0YWNrfHxcIlwifW0oVSxFcnJvcik7dmFyIHBjPVwidW5rbm93biBlcnJvclwiLFY9ezE1OlwiZWxlbWVudCBub3Qgc2VsZWN0YWJsZVwiLDExOlwiZWxlbWVudCBub3QgdmlzaWJsZVwifTtWWzMxXT1wYztWWzMwXT1wYztWWzI0XT1cImludmFsaWQgY29va2llIGRvbWFpblwiO1ZbMjldPVwiaW52YWxpZCBlbGVtZW50IGNvb3JkaW5hdGVzXCI7VlsxMl09XCJpbnZhbGlkIGVsZW1lbnQgc3RhdGVcIjtcblZbMzJdPVwiaW52YWxpZCBzZWxlY3RvclwiO1ZbNTFdPVwiaW52YWxpZCBzZWxlY3RvclwiO1ZbNTJdPVwiaW52YWxpZCBzZWxlY3RvclwiO1ZbMTddPVwiamF2YXNjcmlwdCBlcnJvclwiO1ZbNDA1XT1cInVuc3VwcG9ydGVkIG9wZXJhdGlvblwiO1ZbMzRdPVwibW92ZSB0YXJnZXQgb3V0IG9mIGJvdW5kc1wiO1ZbMjddPVwibm8gc3VjaCBhbGVydFwiO1ZbN109XCJubyBzdWNoIGVsZW1lbnRcIjtWWzhdPVwibm8gc3VjaCBmcmFtZVwiO1ZbMjNdPVwibm8gc3VjaCB3aW5kb3dcIjtWWzI4XT1cInNjcmlwdCB0aW1lb3V0XCI7VlszM109XCJzZXNzaW9uIG5vdCBjcmVhdGVkXCI7VlsxMF09XCJzdGFsZSBlbGVtZW50IHJlZmVyZW5jZVwiO1ZbMjFdPVwidGltZW91dFwiO1ZbMjVdPVwidW5hYmxlIHRvIHNldCBjb29raWVcIjtWWzI2XT1cInVuZXhwZWN0ZWQgYWxlcnQgb3BlblwiO1ZbMTNdPXBjO1ZbOV09XCJ1bmtub3duIGNvbW1hbmRcIjt2YXIgcWM9emEoKSxyYz1CYSgpfHxxKFwiaVBvZFwiKSxzYz1xKFwiaVBhZFwiKSx0Yz1xKFwiQW5kcm9pZFwiKSYmIShBYSgpfHx6YSgpfHxxKFwiT3BlcmFcIil8fHEoXCJTaWxrXCIpKSx1Yz1BYSgpLHZjPXEoXCJTYWZhcmlcIikmJiEoQWEoKXx8cShcIkNvYXN0XCIpfHxxKFwiT3BlcmFcIil8fHEoXCJFZGdlXCIpfHxxKFwiRWRnL1wiKXx8cShcIk9QUlwiKXx8emEoKXx8cShcIlNpbGtcIil8fHEoXCJBbmRyb2lkXCIpKSYmIShCYSgpfHxxKFwiaVBhZFwiKXx8cShcImlQb2RcIikpO2Z1bmN0aW9uIHdjKGEpe3JldHVybihhPWEuZXhlYyhwKSk/YVsxXTpcIlwifXZhciB4Yz1mdW5jdGlvbigpe2lmKHFjKXJldHVybiB3YygvRmlyZWZveFxcLyhbMC05Ll0rKS8pO2lmKHJ8fEZhfHxFYSlyZXR1cm4gS2E7aWYodWMpcmV0dXJuIEJhKCl8fHEoXCJpUGFkXCIpfHxxKFwiaVBvZFwiKT93YygvQ3JpT1NcXC8oWzAtOS5dKykvKTp3YygvQ2hyb21lXFwvKFswLTkuXSspLyk7aWYodmMmJiEoQmEoKXx8cShcImlQYWRcIil8fHEoXCJpUG9kXCIpKSlyZXR1cm4gd2MoL1ZlcnNpb25cXC8oWzAtOS5dKykvKTtpZihyY3x8c2Mpe3ZhciBhPS9WZXJzaW9uXFwvKFxcUyspLipNb2JpbGVcXC8oXFxTKykvLmV4ZWMocCk7aWYoYSlyZXR1cm4gYVsxXStcIi5cIithWzJdfWVsc2UgaWYodGMpcmV0dXJuKGE9d2MoL0FuZHJvaWRcXHMrKFswLTkuXSspLykpP2E6d2MoL1ZlcnNpb25cXC8oWzAtOS5dKykvKTtyZXR1cm5cIlwifSgpO3ZhciB5Yz1zY3x8cmMsemM7aWYodGMpe3ZhciBBYz0vQW5kcm9pZFxccysoWzAtOVxcLl0rKS8uZXhlYyhwKTt6Yz1BYz9BY1sxXTpcIjBcIn1lbHNlIHpjPVwiMFwiO3ZhciBCYz16YyxDYz1yJiYhKDg8PU51bWJlcih3KSksRGM9ciYmISg5PD1OdW1iZXIodykpO2Z1bmN0aW9uIEVjKGEsYil7Yj1iLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJzdHlsZVwiPT1iP0ZjKGEuc3R5bGUuY3NzVGV4dCk6Q2MmJlwidmFsdWVcIj09YiYmR2MoYSxcIklOUFVUXCIpP2EudmFsdWU6RGMmJiEwPT09YVtiXT9TdHJpbmcoYS5nZXRBdHRyaWJ1dGUoYikpOihhPWEuZ2V0QXR0cmlidXRlTm9kZShiKSkmJmEuc3BlY2lmaWVkP2EudmFsdWU6bnVsbH12YXIgSGM9L1s7XSsoPz0oPzooPzpbXlwiXSpcIil7Mn0pKlteXCJdKiQpKD89KD86KD86W14nXSonKXsyfSkqW14nXSokKSg/PSg/OlteKCldKlxcKFteKCldKlxcKSkqW14oKV0qJCkvO1xuZnVuY3Rpb24gRmMoYSl7dmFyIGI9W107bihhLnNwbGl0KEhjKSxmdW5jdGlvbihjKXt2YXIgZD1jLmluZGV4T2YoXCI6XCIpOzA8ZCYmKGM9W2Muc2xpY2UoMCxkKSxjLnNsaWNlKGQrMSldLDI9PWMubGVuZ3RoJiZiLnB1c2goY1swXS50b0xvd2VyQ2FzZSgpLFwiOlwiLGNbMV0sXCI7XCIpKX0pO2I9Yi5qb2luKFwiXCIpO3JldHVybiBiPVwiO1wiPT1iLmNoYXJBdChiLmxlbmd0aC0xKT9iOmIrXCI7XCJ9ZnVuY3Rpb24gSWMoYSxiKXtDYyYmXCJ2YWx1ZVwiPT1iJiZHYyhhLFwiT1BUSU9OXCIpJiZudWxsPT09RWMoYSxcInZhbHVlXCIpPyhiPVtdLGViKGEsYiwhMSksYT1iLmpvaW4oXCJcIikpOmE9YVtiXTtyZXR1cm4gYX1mdW5jdGlvbiBHYyhhLGIpe2ImJlwic3RyaW5nXCIhPT10eXBlb2YgYiYmKGI9Yi50b1N0cmluZygpKTtyZXR1cm4hIWEmJjE9PWEubm9kZVR5cGUmJighYnx8YS50YWdOYW1lLnRvVXBwZXJDYXNlKCk9PWIpfVxuZnVuY3Rpb24gSmMoYSl7cmV0dXJuIEdjKGEsXCJPUFRJT05cIik/ITA6R2MoYSxcIklOUFVUXCIpPyhhPWEudHlwZS50b0xvd2VyQ2FzZSgpLFwiY2hlY2tib3hcIj09YXx8XCJyYWRpb1wiPT1hKTohMX07ZnVuY3Rpb24gS2MoYSl7YT1hP0EoYSk6ZG9jdW1lbnQ7cmV0dXJuIXJ8fDk8PU51bWJlcih3KXx8XCJDU1MxQ29tcGF0XCI9PShhP25ldyBmYihBKGEpKTpsYXx8KGxhPW5ldyBmYikpLmEuY29tcGF0TW9kZT9hLmRvY3VtZW50RWxlbWVudDphLmJvZHl9O3ZhciBMYz0hKHImJiEocj8wPD12YSh3LDEwKTpPYSgxMCkpKSxNYz10Yz8hKHRjPzA8PXZhKEJjLDQpOjA8PXZhKHhjLDQpKToheWMsTmM9ciYmb2MubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7ZnVuY3Rpb24gT2MoYSxiLGMpe3RoaXMuYT1hO3RoaXMuYj1iO3RoaXMuZj1jfU9jLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oYSl7YT1BKGEpLmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKTthLmluaXRFdmVudCh0aGlzLmEsdGhpcy5iLHRoaXMuZik7cmV0dXJuIGF9O09jLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF9O2Z1bmN0aW9uIFcoYSxiLGMpe2phKHRoaXMsYSxiLGMpfW0oVyxPYyk7XG5XLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oYSxiKXtpZighdCYmdGhpcz09UGMpdGhyb3cgbmV3IFUoOSxcIkJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhIG1vdXNlIHBpeGVsIHNjcm9sbCBldmVudC5cIik7dmFyIGM9QShhKSxkPWM/Yy5wYXJlbnRXaW5kb3d8fGMuZGVmYXVsdFZpZXc6d2luZG93O3ZhciBlPWMuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTt2YXIgZj0xO3RoaXM9PVFjJiYodHx8KGUud2hlZWxEZWx0YT1iLndoZWVsRGVsdGEpLHQmJihmPWIud2hlZWxEZWx0YS8tNDApKTt0JiZ0aGlzPT1QYyYmKGY9Yi53aGVlbERlbHRhKTtlLmluaXRNb3VzZUV2ZW50KHRoaXMuYSx0aGlzLmIsdGhpcy5mLGQsZixiLmNsaWVudFgsYi5jbGllbnRZLGIuY2xpZW50WCxiLmNsaWVudFksYi5jdHJsS2V5LGIuYWx0S2V5LGIuc2hpZnRLZXksYi5tZXRhS2V5LGIuYnV0dG9uLGIucmVsYXRlZFRhcmdldCk7aWYociYmMD09PWUucGFnZVgmJjA9PT1lLnBhZ2VZJiZPYmplY3QuZGVmaW5lUHJvcGVydHkpe2E9XG5ZYSgoYT9uZXcgZmIoQShhKSk6bGF8fChsYT1uZXcgZmIpKS5hKTtjPUtjKGMpO3ZhciBnPWIuY2xpZW50WCthLnNjcm9sbExlZnQtYy5jbGllbnRMZWZ0LGs9Yi5jbGllbnRZK2Euc2Nyb2xsVG9wLWMuY2xpZW50VG9wO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicGFnZVhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGd9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwYWdlWVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4ga319KX1yZXR1cm4gZX07ZnVuY3Rpb24gUmMoYSxiLGMpe2phKHRoaXMsYSxiLGMpfW0oUmMsT2MpO1xuUmMucHJvdG90eXBlLmNyZWF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPUEoYSk7aWYodCYmIShyPzA8PXZhKHcsOTMpOk9hKDkzKSkpe2E9Yz9jLnBhcmVudFdpbmRvd3x8Yy5kZWZhdWx0Vmlldzp3aW5kb3c7dmFyIGQ9Yi5jaGFyQ29kZT8wOmIua2V5Q29kZTtjPWMuY3JlYXRlRXZlbnQoXCJLZXlib2FyZEV2ZW50XCIpO2MuaW5pdEtleUV2ZW50KHRoaXMuYSx0aGlzLmIsdGhpcy5mLGEsYi5jdHJsS2V5LGIuYWx0S2V5LGIuc2hpZnRLZXksYi5tZXRhS2V5LGQsYi5jaGFyQ29kZSk7dGhpcy5hPT1TYyYmYi5wcmV2ZW50RGVmYXVsdCYmYy5wcmV2ZW50RGVmYXVsdCgpfWVsc2UgaWYoYz1jLmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpLGMuaW5pdEV2ZW50KHRoaXMuYSx0aGlzLmIsdGhpcy5mKSxjLmFsdEtleT1iLmFsdEtleSxjLmN0cmxLZXk9Yi5jdHJsS2V5LGMubWV0YUtleT1iLm1ldGFLZXksYy5zaGlmdEtleT1iLnNoaWZ0S2V5LGMua2V5Q29kZT1iLmNoYXJDb2RlfHxiLmtleUNvZGUsR2F8fFxuRmEpYy5jaGFyQ29kZT10aGlzPT1TYz9jLmtleUNvZGU6MDtyZXR1cm4gY307ZnVuY3Rpb24gVGMoYSxiLGMpe2phKHRoaXMsYSxiLGMpfW0oVGMsT2MpO1xuVGMucHJvdG90eXBlLmNyZWF0ZT1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoUil7Uj1vYShSLGZ1bmN0aW9uKHYpe3JldHVybiBnLmNyZWF0ZVRvdWNoKGssYSx2LmlkZW50aWZpZXIsdi5wYWdlWCx2LnBhZ2VZLHYuc2NyZWVuWCx2LnNjcmVlblkpfSk7cmV0dXJuIGcuY3JlYXRlVG91Y2hMaXN0LmFwcGx5KGcsUil9ZnVuY3Rpb24gZChSKXt2YXIgdj1vYShSLGZ1bmN0aW9uKFMpe3JldHVybntpZGVudGlmaWVyOlMuaWRlbnRpZmllcixzY3JlZW5YOlMuc2NyZWVuWCxzY3JlZW5ZOlMuc2NyZWVuWSxjbGllbnRYOlMuY2xpZW50WCxjbGllbnRZOlMuY2xpZW50WSxwYWdlWDpTLnBhZ2VYLHBhZ2VZOlMucGFnZVksdGFyZ2V0OmF9fSk7di5pdGVtPWZ1bmN0aW9uKFMpe3JldHVybiB2W1NdfTtyZXR1cm4gdn1mdW5jdGlvbiBlKFIpe3JldHVybiBvYShSLGZ1bmN0aW9uKHYpe3JldHVybiBuZXcgVG91Y2goe2lkZW50aWZpZXI6di5pZGVudGlmaWVyLHNjcmVlblg6di5zY3JlZW5YLHNjcmVlblk6di5zY3JlZW5ZLFxuY2xpZW50WDp2LmNsaWVudFgsY2xpZW50WTp2LmNsaWVudFkscGFnZVg6di5wYWdlWCxwYWdlWTp2LnBhZ2VZLHRhcmdldDphfSl9KX1mdW5jdGlvbiBmKFIsdil7c3dpdGNoKFIpe2Nhc2UgMTpyZXR1cm4gZCh2KTtjYXNlIDI6cmV0dXJuIGModik7Y2FzZSAzOnJldHVybiBlKHYpfXJldHVybiBudWxsfWlmKCFMYyl0aHJvdyBuZXcgVSg5LFwiQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGZpcmluZyB0b3VjaCBldmVudHMuXCIpO3ZhciBnPUEoYSksaz1nP2cucGFyZW50V2luZG93fHxnLmRlZmF1bHRWaWV3OndpbmRvdztpZihNYyl2YXIgbD0xO2Vsc2UgaWYoVG91Y2hFdmVudC5wcm90b3R5cGUuaW5pdFRvdWNoRXZlbnQpbD0yO2Vsc2UgaWYoVG91Y2hFdmVudCYmMDxUb3VjaEV2ZW50Lmxlbmd0aClsPTM7ZWxzZSB0aHJvdyBuZXcgVSg5LFwiTm90IGFibGUgdG8gY3JlYXRlIHRvdWNoIGV2ZW50cyBpbiB0aGlzIGJyb3dzZXJcIik7dmFyIHU9ZihsLGIuY2hhbmdlZFRvdWNoZXMpLEs9Yi50b3VjaGVzPT1cbmIuY2hhbmdlZFRvdWNoZXM/dTpmKGwsYi50b3VjaGVzKSxSYT1iLnRhcmdldFRvdWNoZXM9PWIuY2hhbmdlZFRvdWNoZXM/dTpmKGwsYi50YXJnZXRUb3VjaGVzKTtpZigxPT1sKWw9Zy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpLGwuaW5pdE1vdXNlRXZlbnQodGhpcy5hLHRoaXMuYix0aGlzLmYsaywxLDAsMCxiLmNsaWVudFgsYi5jbGllbnRZLGIuY3RybEtleSxiLmFsdEtleSxiLnNoaWZ0S2V5LGIubWV0YUtleSwwLGIucmVsYXRlZFRhcmdldCksbC50b3VjaGVzPUssbC50YXJnZXRUb3VjaGVzPVJhLGwuY2hhbmdlZFRvdWNoZXM9dSxsLnNjYWxlPWIuc2NhbGUsbC5yb3RhdGlvbj1iLnJvdGF0aW9uO2Vsc2UgaWYoMj09bClsPWcuY3JlYXRlRXZlbnQoXCJUb3VjaEV2ZW50XCIpLDA9PWwuaW5pdFRvdWNoRXZlbnQubGVuZ3RoP2wuaW5pdFRvdWNoRXZlbnQoSyxSYSx1LHRoaXMuYSxrLDAsMCxiLmNsaWVudFgsYi5jbGllbnRZLGIuY3RybEtleSxiLmFsdEtleSxiLnNoaWZ0S2V5LFxuYi5tZXRhS2V5KTpsLmluaXRUb3VjaEV2ZW50KHRoaXMuYSx0aGlzLmIsdGhpcy5mLGssMSwwLDAsYi5jbGllbnRYLGIuY2xpZW50WSxiLmN0cmxLZXksYi5hbHRLZXksYi5zaGlmdEtleSxiLm1ldGFLZXksSyxSYSx1LGIuc2NhbGUsYi5yb3RhdGlvbiksbC5yZWxhdGVkVGFyZ2V0PWIucmVsYXRlZFRhcmdldDtlbHNlIGlmKDM9PWwpbD1uZXcgVG91Y2hFdmVudCh0aGlzLmEse3RvdWNoZXM6Syx0YXJnZXRUb3VjaGVzOlJhLGNoYW5nZWRUb3VjaGVzOnUsYnViYmxlczp0aGlzLmIsY2FuY2VsYWJsZTp0aGlzLmYsY3RybEtleTpiLmN0cmxLZXksc2hpZnRLZXk6Yi5zaGlmdEtleSxhbHRLZXk6Yi5hbHRLZXksbWV0YUtleTpiLm1ldGFLZXl9KTtlbHNlIHRocm93IG5ldyBVKDksXCJJbGxlZ2FsIFRvdWNoRXZlbnRTdHJhdGVneV8gdmFsdWUgKHRoaXMgaXMgYSBidWcpXCIpO3JldHVybiBsfTtmdW5jdGlvbiBYKGEsYixjKXtqYSh0aGlzLGEsYixjKX1tKFgsT2MpO1xuWC5wcm90b3R5cGUuY3JlYXRlPWZ1bmN0aW9uKGEsYil7aWYoIU5jKXRocm93IG5ldyBVKDksXCJCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTVNHZXN0dXJlIGV2ZW50cy5cIik7dmFyIGM9QShhKTthPWM/Yy5wYXJlbnRXaW5kb3d8fGMuZGVmYXVsdFZpZXc6d2luZG93O2M9Yy5jcmVhdGVFdmVudChcIk1TR2VzdHVyZUV2ZW50XCIpO2MuaW5pdEdlc3R1cmVFdmVudCh0aGlzLmEsdGhpcy5iLHRoaXMuZixhLDEsMCwwLGIuY2xpZW50WCxiLmNsaWVudFksMCwwLGIudHJhbnNsYXRpb25YLGIudHJhbnNsYXRpb25ZLGIuc2NhbGUsYi5leHBhbnNpb24sYi5yb3RhdGlvbixiLnZlbG9jaXR5WCxiLnZlbG9jaXR5WSxiLnZlbG9jaXR5RXhwYW5zaW9uLGIudmVsb2NpdHlBbmd1bGFyLChuZXcgRGF0ZSkuZ2V0VGltZSgpLGIucmVsYXRlZFRhcmdldCk7cmV0dXJuIGN9O2Z1bmN0aW9uIFkoYSxiLGMpe2phKHRoaXMsYSxiLGMpfW0oWSxPYyk7XG5ZLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oYSxiKXtpZighTmMpdGhyb3cgbmV3IFUoOSxcIkJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNU1BvaW50ZXIgZXZlbnRzLlwiKTt2YXIgYz1BKGEpO2E9Yz9jLnBhcmVudFdpbmRvd3x8Yy5kZWZhdWx0Vmlldzp3aW5kb3c7Yz1jLmNyZWF0ZUV2ZW50KFwiTVNQb2ludGVyRXZlbnRcIik7Yy5pbml0UG9pbnRlckV2ZW50KHRoaXMuYSx0aGlzLmIsdGhpcy5mLGEsMCwwLDAsYi5jbGllbnRYLGIuY2xpZW50WSxiLmN0cmxLZXksYi5hbHRLZXksYi5zaGlmdEtleSxiLm1ldGFLZXksYi5idXR0b24sYi5yZWxhdGVkVGFyZ2V0LDAsMCxiLndpZHRoLGIuaGVpZ2h0LGIucHJlc3N1cmUsYi5yb3RhdGlvbixiLnRpbHRYLGIudGlsdFksYi5wb2ludGVySWQsYi5wb2ludGVyVHlwZSwwLGIuaXNQcmltYXJ5KTtyZXR1cm4gY307bmV3IFcoXCJjbGlja1wiLCEwLCEwKTtuZXcgVyhcImNvbnRleHRtZW51XCIsITAsITApO25ldyBXKFwiZGJsY2xpY2tcIiwhMCwhMCk7XG5uZXcgVyhcIm1vdXNlZG93blwiLCEwLCEwKTtuZXcgVyhcIm1vdXNlbW92ZVwiLCEwLCExKTtuZXcgVyhcIm1vdXNlb3V0XCIsITAsITApO25ldyBXKFwibW91c2VvdmVyXCIsITAsITApO25ldyBXKFwibW91c2V1cFwiLCEwLCEwKTt2YXIgUWM9bmV3IFcodD9cIkRPTU1vdXNlU2Nyb2xsXCI6XCJtb3VzZXdoZWVsXCIsITAsITApLFBjPW5ldyBXKFwiTW96TW91c2VQaXhlbFNjcm9sbFwiLCEwLCEwKTtuZXcgUmMoXCJrZXlkb3duXCIsITAsITApO3ZhciBTYz1uZXcgUmMoXCJrZXlwcmVzc1wiLCEwLCEwKTtuZXcgUmMoXCJrZXl1cFwiLCEwLCEwKTtuZXcgVGMoXCJ0b3VjaGVuZFwiLCEwLCEwKTtuZXcgVGMoXCJ0b3VjaG1vdmVcIiwhMCwhMCk7bmV3IFRjKFwidG91Y2hzdGFydFwiLCEwLCEwKTtuZXcgWChcIk1TR2VzdHVyZUNoYW5nZVwiLCEwLCEwKTtuZXcgWChcIk1TR2VzdHVyZUVuZFwiLCEwLCEwKTtuZXcgWChcIk1TR2VzdHVyZUhvbGRcIiwhMCwhMCk7bmV3IFgoXCJNU0dlc3R1cmVTdGFydFwiLCEwLCEwKTtcbm5ldyBYKFwiTVNHZXN0dXJlVGFwXCIsITAsITApO25ldyBYKFwiTVNJbmVydGlhU3RhcnRcIiwhMCwhMCk7bmV3IFkoXCJNU0dvdFBvaW50ZXJDYXB0dXJlXCIsITAsITEpO25ldyBZKFwiTVNMb3N0UG9pbnRlckNhcHR1cmVcIiwhMCwhMSk7bmV3IFkoXCJNU1BvaW50ZXJDYW5jZWxcIiwhMCwhMCk7bmV3IFkoXCJNU1BvaW50ZXJEb3duXCIsITAsITApO25ldyBZKFwiTVNQb2ludGVyTW92ZVwiLCEwLCEwKTtuZXcgWShcIk1TUG9pbnRlck92ZXJcIiwhMCwhMCk7bmV3IFkoXCJNU1BvaW50ZXJPdXRcIiwhMCwhMCk7bmV3IFkoXCJNU1BvaW50ZXJVcFwiLCEwLCEwKTtmdW5jdGlvbiBVYyhhLGIpe3RoaXMuYj17fTt0aGlzLmE9W107dGhpcy5mPTA7dmFyIGM9YXJndW1lbnRzLmxlbmd0aDtpZigxPGMpe2lmKGMlMil0aHJvdyBFcnJvcihcIlVuZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzXCIpO2Zvcih2YXIgZD0wO2Q8YztkKz0yKXRoaXMuc2V0KGFyZ3VtZW50c1tkXSxhcmd1bWVudHNbZCsxXSl9ZWxzZSBpZihhKWlmKGEgaW5zdGFuY2VvZiBVYylmb3IoYz1WYyhhKSxkPTA7ZDxjLmxlbmd0aDtkKyspdGhpcy5zZXQoY1tkXSxhLmdldChjW2RdKSk7ZWxzZSBmb3IoZCBpbiBhKXRoaXMuc2V0KGQsYVtkXSl9XG5mdW5jdGlvbiBWYyhhKXtpZihhLmYhPWEuYS5sZW5ndGgpe2Zvcih2YXIgYj0wLGM9MDtiPGEuYS5sZW5ndGg7KXt2YXIgZD1hLmFbYl07T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEuYixkKSYmKGEuYVtjKytdPWQpO2IrK31hLmEubGVuZ3RoPWN9aWYoYS5mIT1hLmEubGVuZ3RoKXt2YXIgZT17fTtmb3IoYz1iPTA7YjxhLmEubGVuZ3RoOylkPWEuYVtiXSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxkKXx8KGEuYVtjKytdPWQsZVtkXT0xKSxiKys7YS5hLmxlbmd0aD1jfXJldHVybiBhLmEuY29uY2F0KCl9VWMucHJvdG90eXBlLmdldD1mdW5jdGlvbihhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5iLGEpP3RoaXMuYlthXTpifTtcblVjLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5iLGEpfHwodGhpcy5mKyssdGhpcy5hLnB1c2goYSkpO3RoaXMuYlthXT1ifTt2YXIgV2M9e307ZnVuY3Rpb24gWihhLGIsYyl7ZGEoYSkmJihhPXQ/YS5nOmEuaCk7YT1uZXcgWGMoYSk7IWJ8fGIgaW4gV2MmJiFjfHwoV2NbYl09e2tleTphLHNoaWZ0OiExfSxjJiYoV2NbY109e2tleTphLHNoaWZ0OiEwfSkpO3JldHVybiBhfWZ1bmN0aW9uIFhjKGEpe3RoaXMuY29kZT1hfVooOCk7Wig5KTtaKDEzKTt2YXIgWWM9WigxNiksWmM9WigxNyksJGM9WigxOCk7WigxOSk7WigyMCk7WigyNyk7WigzMixcIiBcIik7WigzMyk7WigzNCk7WigzNSk7WigzNik7WigzNyk7WigzOCk7WigzOSk7Wig0MCk7Wig0NCk7Wig0NSk7Wig0Nik7Wig0OCxcIjBcIixcIilcIik7Wig0OSxcIjFcIixcIiFcIik7Wig1MCxcIjJcIixcIkBcIik7Wig1MSxcIjNcIixcIiNcIik7Wig1MixcIjRcIixcIiRcIik7Wig1MyxcIjVcIixcIiVcIik7Wig1NCxcIjZcIixcIl5cIik7Wig1NSxcIjdcIixcIiZcIik7Wig1NixcIjhcIixcIipcIik7Wig1NyxcIjlcIixcIihcIik7Wig2NSxcImFcIixcIkFcIik7Wig2NixcImJcIixcIkJcIik7Wig2NyxcImNcIixcIkNcIik7Wig2OCxcImRcIixcIkRcIik7XG5aKDY5LFwiZVwiLFwiRVwiKTtaKDcwLFwiZlwiLFwiRlwiKTtaKDcxLFwiZ1wiLFwiR1wiKTtaKDcyLFwiaFwiLFwiSFwiKTtaKDczLFwiaVwiLFwiSVwiKTtaKDc0LFwialwiLFwiSlwiKTtaKDc1LFwia1wiLFwiS1wiKTtaKDc2LFwibFwiLFwiTFwiKTtaKDc3LFwibVwiLFwiTVwiKTtaKDc4LFwiblwiLFwiTlwiKTtaKDc5LFwib1wiLFwiT1wiKTtaKDgwLFwicFwiLFwiUFwiKTtaKDgxLFwicVwiLFwiUVwiKTtaKDgyLFwiclwiLFwiUlwiKTtaKDgzLFwic1wiLFwiU1wiKTtaKDg0LFwidFwiLFwiVFwiKTtaKDg1LFwidVwiLFwiVVwiKTtaKDg2LFwidlwiLFwiVlwiKTtaKDg3LFwid1wiLFwiV1wiKTtaKDg4LFwieFwiLFwiWFwiKTtaKDg5LFwieVwiLFwiWVwiKTtaKDkwLFwielwiLFwiWlwiKTt2YXIgYWQ9WihJYT97Zzo5MSxoOjkxfTpIYT97ZzoyMjQsaDo5MX06e2c6MCxoOjkxfSk7WihJYT97Zzo5MixoOjkyfTpIYT97ZzoyMjQsaDo5M306e2c6MCxoOjkyfSk7WihJYT97Zzo5MyxoOjkzfTpIYT97ZzowLGg6MH06e2c6OTMsaDpudWxsfSk7Wih7Zzo5NixoOjk2fSxcIjBcIik7Wih7Zzo5NyxoOjk3fSxcIjFcIik7XG5aKHtnOjk4LGg6OTh9LFwiMlwiKTtaKHtnOjk5LGg6OTl9LFwiM1wiKTtaKHtnOjEwMCxoOjEwMH0sXCI0XCIpO1ooe2c6MTAxLGg6MTAxfSxcIjVcIik7Wih7ZzoxMDIsaDoxMDJ9LFwiNlwiKTtaKHtnOjEwMyxoOjEwM30sXCI3XCIpO1ooe2c6MTA0LGg6MTA0fSxcIjhcIik7Wih7ZzoxMDUsaDoxMDV9LFwiOVwiKTtaKHtnOjEwNixoOjEwNn0sXCIqXCIpO1ooe2c6MTA3LGg6MTA3fSxcIitcIik7Wih7ZzoxMDksaDoxMDl9LFwiLVwiKTtaKHtnOjExMCxoOjExMH0sXCIuXCIpO1ooe2c6MTExLGg6MTExfSxcIi9cIik7WigxNDQpO1ooMTEyKTtaKDExMyk7WigxMTQpO1ooMTE1KTtaKDExNik7WigxMTcpO1ooMTE4KTtaKDExOSk7WigxMjApO1ooMTIxKTtaKDEyMik7WigxMjMpO1ooe2c6MTA3LGg6MTg3fSxcIj1cIixcIitcIik7WigxMDgsXCIsXCIpO1ooe2c6MTA5LGg6MTg5fSxcIi1cIixcIl9cIik7WigxODgsXCIsXCIsXCI8XCIpO1ooMTkwLFwiLlwiLFwiPlwiKTtaKDE5MSxcIi9cIixcIj9cIik7WigxOTIsXCJgXCIsXCJ+XCIpO1ooMjE5LFwiW1wiLFwie1wiKTtcblooMjIwLFwiXFxcXFwiLFwifFwiKTtaKDIyMSxcIl1cIixcIn1cIik7Wih7Zzo1OSxoOjE4Nn0sXCI7XCIsXCI6XCIpO1ooMjIyLFwiJ1wiLCdcIicpO3ZhciBiZD1uZXcgVWM7YmQuc2V0KDEsWWMpO2JkLnNldCgyLFpjKTtiZC5zZXQoNCwkYyk7YmQuc2V0KDgsYWQpOyhmdW5jdGlvbihhKXt2YXIgYj1uZXcgVWM7bihWYyhhKSxmdW5jdGlvbihjKXtiLnNldChhLmdldChjKS5jb2RlLGMpfSk7cmV0dXJuIGJ9KShiZCk7dmFyIGNkPXtcImNsYXNzXCI6XCJjbGFzc05hbWVcIixyZWFkb25seTpcInJlYWRPbmx5XCJ9LGRkPVwiYWxsb3dmdWxsc2NyZWVuIGFsbG93cGF5bWVudHJlcXVlc3QgYWxsb3d1c2VybWVkaWEgYXN5bmMgYXV0b2ZvY3VzIGF1dG9wbGF5IGNoZWNrZWQgY29tcGFjdCBjb21wbGV0ZSBjb250cm9scyBkZWNsYXJlIGRlZmF1bHQgZGVmYXVsdGNoZWNrZWQgZGVmYXVsdHNlbGVjdGVkIGRlZmVyIGRpc2FibGVkIGVuZGVkIGZvcm1ub3ZhbGlkYXRlIGhpZGRlbiBpbmRldGVybWluYXRlIGlzY29udGVudGVkaXRhYmxlIGlzbWFwIGl0ZW1zY29wZSBsb29wIG11bHRpcGxlIG11dGVkIG5vaHJlZiBub21vZHVsZSBub3Jlc2l6ZSBub3NoYWRlIG5vdmFsaWRhdGUgbm93cmFwIG9wZW4gcGF1c2VkIHBsYXlzaW5saW5lIHB1YmRhdGUgcmVhZG9ubHkgcmVxdWlyZWQgcmV2ZXJzZWQgc2NvcGVkIHNlYW1sZXNzIHNlZWtpbmcgc2VsZWN0ZWQgdHJ1ZXNwZWVkIHR5cGVtdXN0bWF0Y2ggd2lsbHZhbGlkYXRlXCIuc3BsaXQoXCIgXCIpO2JhKFwiX1wiLGZ1bmN0aW9uKGEsYil7dmFyIGM9bnVsbCxkPWIudG9Mb3dlckNhc2UoKTtpZihcInN0eWxlXCI9PWQpcmV0dXJuKGM9YS5zdHlsZSkmJiFhYShjKSYmKGM9Yy5jc3NUZXh0KSxjO2lmKChcInNlbGVjdGVkXCI9PWR8fFwiY2hlY2tlZFwiPT1kKSYmSmMoYSkpe2lmKCFKYyhhKSl0aHJvdyBuZXcgVSgxNSxcIkVsZW1lbnQgaXMgbm90IHNlbGVjdGFibGVcIik7Yj1cInNlbGVjdGVkXCI7Yz1hLnR5cGUmJmEudHlwZS50b0xvd2VyQ2FzZSgpO2lmKFwiY2hlY2tib3hcIj09Y3x8XCJyYWRpb1wiPT1jKWI9XCJjaGVja2VkXCI7cmV0dXJuIEljKGEsYik/XCJ0cnVlXCI6bnVsbH12YXIgZT1HYyhhLFwiQVwiKTtpZihHYyhhLFwiSU1HXCIpJiZcInNyY1wiPT1kfHxlJiZcImhyZWZcIj09ZClyZXR1cm4oYz1FYyhhLGQpKSYmKGM9SWMoYSxkKSksYztpZihcInNwZWxsY2hlY2tcIj09ZCl7Yz1FYyhhLGQpO2lmKG51bGwhPT1jKXtpZihcImZhbHNlXCI9PWMudG9Mb3dlckNhc2UoKSlyZXR1cm5cImZhbHNlXCI7aWYoXCJ0cnVlXCI9PWMudG9Mb3dlckNhc2UoKSlyZXR1cm5cInRydWVcIn1yZXR1cm4gSWMoYSxcbmQpK1wiXCJ9ZT1jZFtiXXx8YjtpZigwPD1tYShkZCxkKSlyZXR1cm4oYz1udWxsIT09RWMoYSxiKXx8SWMoYSxlKSk/XCJ0cnVlXCI6bnVsbDt0cnl7dmFyIGY9SWMoYSxlKX1jYXRjaChnKXt9bnVsbD09Znx8ZGEoZik/Yz1FYyhhLGIpOmM9ZjtyZXR1cm4gbnVsbCE9Yz9jLnRvU3RyaW5nKCk6bnVsbH0pOzsgcmV0dXJuIHRoaXMuXy5hcHBseShudWxsLGFyZ3VtZW50cyk7fSkuYXBwbHkoe25hdmlnYXRvcjp0eXBlb2Ygd2luZG93IT0ndW5kZWZpbmVkJz93aW5kb3cubmF2aWdhdG9yOm51bGwsZG9jdW1lbnQ6dHlwZW9mIHdpbmRvdyE9J3VuZGVmaW5lZCc/d2luZG93LmRvY3VtZW50Om51bGx9LCBhcmd1bWVudHMpO307XG4iLCIvLyBHRU5FUkFURUQgQ09ERSAtIERPIE5PVCBFRElUXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7cmV0dXJuIChmdW5jdGlvbigpe3ZhciBrPXRoaXN8fHNlbGY7ZnVuY3Rpb24gYWEoYSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGF9ZnVuY3Rpb24gYmEoYSxiKXthPWEuc3BsaXQoXCIuXCIpO3ZhciBjPWs7YVswXWluIGN8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjLmV4ZWNTY3JpcHR8fGMuZXhlY1NjcmlwdChcInZhciBcIithWzBdKTtmb3IodmFyIGQ7YS5sZW5ndGgmJihkPWEuc2hpZnQoKSk7KWEubGVuZ3RofHx2b2lkIDA9PT1iP2NbZF0mJmNbZF0hPT1PYmplY3QucHJvdG90eXBlW2RdP2M9Y1tkXTpjPWNbZF09e306Y1tkXT1ifVxuZnVuY3Rpb24gY2EoYSl7dmFyIGI9dHlwZW9mIGE7aWYoXCJvYmplY3RcIj09YilpZihhKXtpZihhIGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuXCJhcnJheVwiO2lmKGEgaW5zdGFuY2VvZiBPYmplY3QpcmV0dXJuIGI7dmFyIGM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBXaW5kb3ddXCI9PWMpcmV0dXJuXCJvYmplY3RcIjtpZihcIltvYmplY3QgQXJyYXldXCI9PWN8fFwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuc3BsaWNlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpcmV0dXJuXCJhcnJheVwiO2lmKFwiW29iamVjdCBGdW5jdGlvbl1cIj09Y3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuY2FsbCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSlyZXR1cm5cImZ1bmN0aW9uXCJ9ZWxzZSByZXR1cm5cIm51bGxcIjtcbmVsc2UgaWYoXCJmdW5jdGlvblwiPT1iJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgYS5jYWxsKXJldHVyblwib2JqZWN0XCI7cmV0dXJuIGJ9ZnVuY3Rpb24gZGEoYSxiLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9ZnVuY3Rpb24gZWEoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShlLGQpO3JldHVybiBhLmFwcGx5KGIsZSl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19XG5mdW5jdGlvbiBmYShhLGIsYyl7RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQmJi0xIT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKT9mYT1kYTpmYT1lYTtyZXR1cm4gZmEuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIGhhKGEsYil7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBmdW5jdGlvbigpe3ZhciBkPWMuc2xpY2UoKTtkLnB1c2guYXBwbHkoZCxhcmd1bWVudHMpO3JldHVybiBhLmFwcGx5KHRoaXMsZCl9fWZ1bmN0aW9uIGwoYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBjO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWF9Oy8qXG5cbiBUaGUgTUlUIExpY2Vuc2VcblxuIENvcHlyaWdodCAoYykgMjAwNyBDeWJvenUgTGFicywgSW5jLlxuIENvcHlyaWdodCAoYykgMjAxMiBHb29nbGUgSW5jLlxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiBJTiBUSEUgU09GVFdBUkUuXG4qL1xuZnVuY3Rpb24gaWEoYSxiLGMpe3RoaXMuYT1hO3RoaXMuYj1ifHwxO3RoaXMuZj1jfHwxfTt2YXIgamE9QXJyYXkucHJvdG90eXBlLmluZGV4T2Y/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhLGIsdm9pZCAwKX06ZnVuY3Rpb24oYSxiKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuXCJzdHJpbmdcIiE9PXR5cGVvZiBifHwxIT1iLmxlbmd0aD8tMTphLmluZGV4T2YoYiwwKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihjIGluIGEmJmFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSxuPUFycmF5LnByb3RvdHlwZS5mb3JFYWNoP2Z1bmN0aW9uKGEsYil7QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhLGIsdm9pZCAwKX06ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9YS5sZW5ndGgsZD1cInN0cmluZ1wiPT09dHlwZW9mIGE/YS5zcGxpdChcIlwiKTphLGU9MDtlPGM7ZSsrKWUgaW4gZCYmYi5jYWxsKHZvaWQgMCxkW2VdLGUsYSl9LGthPUFycmF5LnByb3RvdHlwZS5maWx0ZXI/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGEsXG5iLHZvaWQgMCl9OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9W10sZT0wLGY9XCJzdHJpbmdcIj09PXR5cGVvZiBhP2Euc3BsaXQoXCJcIik6YSxnPTA7ZzxjO2crKylpZihnIGluIGYpe3ZhciBoPWZbZ107Yi5jYWxsKHZvaWQgMCxoLGcsYSkmJihkW2UrK109aCl9cmV0dXJuIGR9LGxhPUFycmF5LnByb3RvdHlwZS5yZWR1Y2U/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9YztuKGEsZnVuY3Rpb24oZSxmKXtkPWIuY2FsbCh2b2lkIDAsZCxlLGYsYSl9KTtyZXR1cm4gZH0sbWE9QXJyYXkucHJvdG90eXBlLnNvbWU/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhLGIsdm9pZCAwKX06ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9YS5sZW5ndGgsZD1cInN0cmluZ1wiPT09dHlwZW9mIGE/YS5zcGxpdChcIlwiKTphLGU9MDtlPGM7ZSsrKWlmKGUgaW5cbmQmJmIuY2FsbCh2b2lkIDAsZFtlXSxlLGEpKXJldHVybiEwO3JldHVybiExfSxuYT1BcnJheS5wcm90b3R5cGUuZXZlcnk/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmV2ZXJ5LmNhbGwoYSxiLHZvaWQgMCl9OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9XCJzdHJpbmdcIj09PXR5cGVvZiBhP2Euc3BsaXQoXCJcIik6YSxlPTA7ZTxjO2UrKylpZihlIGluIGQmJiFiLmNhbGwodm9pZCAwLGRbZV0sZSxhKSlyZXR1cm4hMTtyZXR1cm4hMH07ZnVuY3Rpb24gb2EoYSxiKXthOntmb3IodmFyIGM9YS5sZW5ndGgsZD1cInN0cmluZ1wiPT09dHlwZW9mIGE/YS5zcGxpdChcIlwiKTphLGU9MDtlPGM7ZSsrKWlmKGUgaW4gZCYmYi5jYWxsKHZvaWQgMCxkW2VdLGUsYSkpe2I9ZTticmVhayBhfWI9LTF9cmV0dXJuIDA+Yj9udWxsOlwic3RyaW5nXCI9PT10eXBlb2YgYT9hLmNoYXJBdChiKTphW2JdfVxuZnVuY3Rpb24gcGEoYSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sYXJndW1lbnRzKX1mdW5jdGlvbiBxYShhLGIsYyl7cmV0dXJuIDI+PWFyZ3VtZW50cy5sZW5ndGg/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSxiKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLGIsYyl9O3ZhciByYT1TdHJpbmcucHJvdG90eXBlLnRyaW0/ZnVuY3Rpb24oYSl7cmV0dXJuIGEudHJpbSgpfTpmdW5jdGlvbihhKXtyZXR1cm4vXltcXHNcXHhhMF0qKFtcXHNcXFNdKj8pW1xcc1xceGEwXSokLy5leGVjKGEpWzFdfTtmdW5jdGlvbiBzYShhLGIpe3JldHVybiBhPGI/LTE6YT5iPzE6MH07dmFyIHQ7YTp7dmFyIHRhPWsubmF2aWdhdG9yO2lmKHRhKXt2YXIgdWE9dGEudXNlckFnZW50O2lmKHVhKXt0PXVhO2JyZWFrIGF9fXQ9XCJcIn1mdW5jdGlvbiB1KGEpe3JldHVybi0xIT10LmluZGV4T2YoYSl9O2Z1bmN0aW9uIHZhKCl7cmV0dXJuIHUoXCJGaXJlZm94XCIpfHx1KFwiRnhpT1NcIil9ZnVuY3Rpb24gd2EoKXtyZXR1cm4odShcIkNocm9tZVwiKXx8dShcIkNyaU9TXCIpKSYmIXUoXCJFZGdlXCIpfTtmdW5jdGlvbiB4YShhKXtyZXR1cm4gU3RyaW5nKGEpLnJlcGxhY2UoL1xcLShbYS16XSkvZyxmdW5jdGlvbihiLGMpe3JldHVybiBjLnRvVXBwZXJDYXNlKCl9KX07ZnVuY3Rpb24geWEoKXtyZXR1cm4gdShcImlQaG9uZVwiKSYmIXUoXCJpUG9kXCIpJiYhdShcImlQYWRcIil9O2Z1bmN0aW9uIHphKGEsYil7dmFyIGM9QWE7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLGEpP2NbYV06Y1thXT1iKGEpfTt2YXIgQmE9dShcIk9wZXJhXCIpLHY9dShcIlRyaWRlbnRcIil8fHUoXCJNU0lFXCIpLENhPXUoXCJFZGdlXCIpLERhPXUoXCJHZWNrb1wiKSYmISgtMSE9dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ3ZWJraXRcIikmJiF1KFwiRWRnZVwiKSkmJiEodShcIlRyaWRlbnRcIil8fHUoXCJNU0lFXCIpKSYmIXUoXCJFZGdlXCIpLEVhPS0xIT10LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKSYmIXUoXCJFZGdlXCIpO2Z1bmN0aW9uIEZhKCl7dmFyIGE9ay5kb2N1bWVudDtyZXR1cm4gYT9hLmRvY3VtZW50TW9kZTp2b2lkIDB9dmFyIEdhO1xuYTp7dmFyIEhhPVwiXCIsSWE9ZnVuY3Rpb24oKXt2YXIgYT10O2lmKERhKXJldHVybi9ydjooW15cXCk7XSspKFxcKXw7KS8uZXhlYyhhKTtpZihDYSlyZXR1cm4vRWRnZVxcLyhbXFxkXFwuXSspLy5leGVjKGEpO2lmKHYpcmV0dXJuL1xcYig/Ok1TSUV8cnYpWzogXShbXlxcKTtdKykoXFwpfDspLy5leGVjKGEpO2lmKEVhKXJldHVybi9XZWJLaXRcXC8oXFxTKykvLmV4ZWMoYSk7aWYoQmEpcmV0dXJuLyg/OlZlcnNpb24pWyBcXC9dPyhcXFMrKS8uZXhlYyhhKX0oKTtJYSYmKEhhPUlhP0lhWzFdOlwiXCIpO2lmKHYpe3ZhciBKYT1GYSgpO2lmKG51bGwhPUphJiZKYT5wYXJzZUZsb2F0KEhhKSl7R2E9U3RyaW5nKEphKTticmVhayBhfX1HYT1IYX12YXIgQWE9e307XG5mdW5jdGlvbiBLYShhKXtyZXR1cm4gemEoYSxmdW5jdGlvbigpe2Zvcih2YXIgYj0wLGM9cmEoU3RyaW5nKEdhKSkuc3BsaXQoXCIuXCIpLGQ9cmEoU3RyaW5nKGEpKS5zcGxpdChcIi5cIiksZT1NYXRoLm1heChjLmxlbmd0aCxkLmxlbmd0aCksZj0wOzA9PWImJmY8ZTtmKyspe3ZhciBnPWNbZl18fFwiXCIsaD1kW2ZdfHxcIlwiO2Rve2c9LyhcXGQqKShcXEQqKSguKikvLmV4ZWMoZyl8fFtcIlwiLFwiXCIsXCJcIixcIlwiXTtoPS8oXFxkKikoXFxEKikoLiopLy5leGVjKGgpfHxbXCJcIixcIlwiLFwiXCIsXCJcIl07aWYoMD09Z1swXS5sZW5ndGgmJjA9PWhbMF0ubGVuZ3RoKWJyZWFrO2I9c2EoMD09Z1sxXS5sZW5ndGg/MDpwYXJzZUludChnWzFdLDEwKSwwPT1oWzFdLmxlbmd0aD8wOnBhcnNlSW50KGhbMV0sMTApKXx8c2EoMD09Z1syXS5sZW5ndGgsMD09aFsyXS5sZW5ndGgpfHxzYShnWzJdLGhbMl0pO2c9Z1szXTtoPWhbM119d2hpbGUoMD09Yil9cmV0dXJuIDA8PWJ9KX12YXIgTGE7XG5MYT1rLmRvY3VtZW50JiZ2P0ZhKCk6dm9pZCAwO3ZhciB4PXYmJiEoOTw9TnVtYmVyKExhKSksTWE9diYmISg4PD1OdW1iZXIoTGEpKTtmdW5jdGlvbiBOYShhLGIsYyxkKXt0aGlzLmE9YTt0aGlzLm5vZGVOYW1lPWM7dGhpcy5ub2RlVmFsdWU9ZDt0aGlzLm5vZGVUeXBlPTI7dGhpcy5wYXJlbnROb2RlPXRoaXMub3duZXJFbGVtZW50PWJ9ZnVuY3Rpb24gT2EoYSxiKXt2YXIgYz1NYSYmXCJocmVmXCI9PWIubm9kZU5hbWU/YS5nZXRBdHRyaWJ1dGUoYi5ub2RlTmFtZSwyKTpiLm5vZGVWYWx1ZTtyZXR1cm4gbmV3IE5hKGIsYSxiLm5vZGVOYW1lLGMpfTtmdW5jdGlvbiBQYShhKXt0aGlzLmI9YTt0aGlzLmE9MH1mdW5jdGlvbiBRYShhKXthPWEubWF0Y2goUmEpO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKVNhLnRlc3QoYVtiXSkmJmEuc3BsaWNlKGIsMSk7cmV0dXJuIG5ldyBQYShhKX12YXIgUmE9L1xcJD8oPzooPyFbMC05LVxcLl0pKD86XFwqfFtcXHctXFwuXSspOik/KD8hWzAtOS1cXC5dKSg/OlxcKnxbXFx3LVxcLl0rKXxcXC9cXC98XFwuXFwufDo6fFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkK3xcIlteXCJdKlwifCdbXiddKid8WyE8Pl09fFxccyt8Li9nLFNhPS9eXFxzLztmdW5jdGlvbiB5KGEsYil7cmV0dXJuIGEuYlthLmErKGJ8fDApXX1mdW5jdGlvbiB6KGEpe3JldHVybiBhLmJbYS5hKytdfWZ1bmN0aW9uIFRhKGEpe3JldHVybiBhLmIubGVuZ3RoPD1hLmF9O2Z1bmN0aW9uIFVhKGEsYil7dGhpcy54PXZvaWQgMCE9PWE/YTowO3RoaXMueT12b2lkIDAhPT1iP2I6MH1VYS5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3RoaXMueD1NYXRoLmNlaWwodGhpcy54KTt0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSk7cmV0dXJuIHRoaXN9O1VhLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3RoaXMueD1NYXRoLmZsb29yKHRoaXMueCk7dGhpcy55PU1hdGguZmxvb3IodGhpcy55KTtyZXR1cm4gdGhpc307VWEucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKCl7dGhpcy54PU1hdGgucm91bmQodGhpcy54KTt0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpO3JldHVybiB0aGlzfTtmdW5jdGlvbiBWYShhLGIpe3RoaXMud2lkdGg9YTt0aGlzLmhlaWdodD1ifVZhLnByb3RvdHlwZS5hc3BlY3RSYXRpbz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndpZHRoL3RoaXMuaGVpZ2h0fTtWYS5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3RoaXMud2lkdGg9TWF0aC5jZWlsKHRoaXMud2lkdGgpO3RoaXMuaGVpZ2h0PU1hdGguY2VpbCh0aGlzLmhlaWdodCk7cmV0dXJuIHRoaXN9O1ZhLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3RoaXMud2lkdGg9TWF0aC5mbG9vcih0aGlzLndpZHRoKTt0aGlzLmhlaWdodD1NYXRoLmZsb29yKHRoaXMuaGVpZ2h0KTtyZXR1cm4gdGhpc307VmEucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKCl7dGhpcy53aWR0aD1NYXRoLnJvdW5kKHRoaXMud2lkdGgpO3RoaXMuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5oZWlnaHQpO3JldHVybiB0aGlzfTtmdW5jdGlvbiBXYShhLGIpe2lmKCFhfHwhYilyZXR1cm4hMTtpZihhLmNvbnRhaW5zJiYxPT1iLm5vZGVUeXBlKXJldHVybiBhPT1ifHxhLmNvbnRhaW5zKGIpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKXJldHVybiBhPT1ifHwhIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpJjE2KTtmb3IoO2ImJmEhPWI7KWI9Yi5wYXJlbnROb2RlO3JldHVybiBiPT1hfVxuZnVuY3Rpb24gWGEoYSxiKXtpZihhPT1iKXJldHVybiAwO2lmKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24pcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikmMj8xOi0xO2lmKHYmJiEoOTw9TnVtYmVyKExhKSkpe2lmKDk9PWEubm9kZVR5cGUpcmV0dXJuLTE7aWYoOT09Yi5ub2RlVHlwZSlyZXR1cm4gMX1pZihcInNvdXJjZUluZGV4XCJpbiBhfHxhLnBhcmVudE5vZGUmJlwic291cmNlSW5kZXhcImluIGEucGFyZW50Tm9kZSl7dmFyIGM9MT09YS5ub2RlVHlwZSxkPTE9PWIubm9kZVR5cGU7aWYoYyYmZClyZXR1cm4gYS5zb3VyY2VJbmRleC1iLnNvdXJjZUluZGV4O3ZhciBlPWEucGFyZW50Tm9kZSxmPWIucGFyZW50Tm9kZTtyZXR1cm4gZT09Zj9ZYShhLGIpOiFjJiZXYShlLGIpPy0xKlphKGEsYik6IWQmJldhKGYsYSk/WmEoYixhKTooYz9hLnNvdXJjZUluZGV4OmUuc291cmNlSW5kZXgpLShkP2Iuc291cmNlSW5kZXg6Zi5zb3VyY2VJbmRleCl9ZD1BKGEpO2M9ZC5jcmVhdGVSYW5nZSgpO1xuYy5zZWxlY3ROb2RlKGEpO2MuY29sbGFwc2UoITApO2E9ZC5jcmVhdGVSYW5nZSgpO2Euc2VsZWN0Tm9kZShiKTthLmNvbGxhcHNlKCEwKTtyZXR1cm4gYy5jb21wYXJlQm91bmRhcnlQb2ludHMoay5SYW5nZS5TVEFSVF9UT19FTkQsYSl9ZnVuY3Rpb24gWmEoYSxiKXt2YXIgYz1hLnBhcmVudE5vZGU7aWYoYz09YilyZXR1cm4tMTtmb3IoO2IucGFyZW50Tm9kZSE9YzspYj1iLnBhcmVudE5vZGU7cmV0dXJuIFlhKGIsYSl9ZnVuY3Rpb24gWWEoYSxiKXtmb3IoO2I9Yi5wcmV2aW91c1NpYmxpbmc7KWlmKGI9PWEpcmV0dXJuLTE7cmV0dXJuIDF9ZnVuY3Rpb24gQShhKXtyZXR1cm4gOT09YS5ub2RlVHlwZT9hOmEub3duZXJEb2N1bWVudHx8YS5kb2N1bWVudH1mdW5jdGlvbiAkYShhLGIpe2EmJihhPWEucGFyZW50Tm9kZSk7Zm9yKHZhciBjPTA7YTspe2lmKGIoYSkpcmV0dXJuIGE7YT1hLnBhcmVudE5vZGU7YysrfXJldHVybiBudWxsfVxuZnVuY3Rpb24gYWIoYSl7dGhpcy5hPWF8fGsuZG9jdW1lbnR8fGRvY3VtZW50fWFiLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1mdW5jdGlvbihhLGIpe3JldHVybihifHx0aGlzLmEpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFN0cmluZyhhKSl9O2Z1bmN0aW9uIEIoYSl7dmFyIGI9bnVsbCxjPWEubm9kZVR5cGU7MT09YyYmKGI9YS50ZXh0Q29udGVudCxiPXZvaWQgMD09Ynx8bnVsbD09Yj9hLmlubmVyVGV4dDpiLGI9dm9pZCAwPT1ifHxudWxsPT1iP1wiXCI6Yik7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGIpaWYoeCYmXCJ0aXRsZVwiPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJjE9PWMpYj1hLnRleHQ7ZWxzZSBpZig5PT1jfHwxPT1jKXthPTk9PWM/YS5kb2N1bWVudEVsZW1lbnQ6YS5maXJzdENoaWxkO2M9MDt2YXIgZD1bXTtmb3IoYj1cIlwiO2E7KXtkbyAxIT1hLm5vZGVUeXBlJiYoYis9YS5ub2RlVmFsdWUpLHgmJlwidGl0bGVcIj09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiYoYis9YS50ZXh0KSxkW2MrK109YTt3aGlsZShhPWEuZmlyc3RDaGlsZCk7Zm9yKDtjJiYhKGE9ZFstLWNdLm5leHRTaWJsaW5nKTspO319ZWxzZSBiPWEubm9kZVZhbHVlO3JldHVybiBifVxuZnVuY3Rpb24gQyhhLGIsYyl7aWYobnVsbD09PWIpcmV0dXJuITA7dHJ5e2lmKCFhLmdldEF0dHJpYnV0ZSlyZXR1cm4hMX1jYXRjaChkKXtyZXR1cm4hMX1NYSYmXCJjbGFzc1wiPT1iJiYoYj1cImNsYXNzTmFtZVwiKTtyZXR1cm4gbnVsbD09Yz8hIWEuZ2V0QXR0cmlidXRlKGIpOmEuZ2V0QXR0cmlidXRlKGIsMik9PWN9ZnVuY3Rpb24gYmIoYSxiLGMsZCxlKXtyZXR1cm4oeD9jYjpkYikuY2FsbChudWxsLGEsYixhYShjKT9jOm51bGwsYWEoZCk/ZDpudWxsLGV8fG5ldyBFKX1cbmZ1bmN0aW9uIGNiKGEsYixjLGQsZSl7aWYoYSBpbnN0YW5jZW9mIEZ8fDg9PWEuYnx8YyYmbnVsbD09PWEuYil7dmFyIGY9Yi5hbGw7aWYoIWYpcmV0dXJuIGU7YT1lYihhKTtpZihcIipcIiE9YSYmKGY9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKSwhZikpcmV0dXJuIGU7aWYoYyl7Zm9yKHZhciBnPVtdLGg9MDtiPWZbaCsrXTspQyhiLGMsZCkmJmcucHVzaChiKTtmPWd9Zm9yKGg9MDtiPWZbaCsrXTspXCIqXCI9PWEmJlwiIVwiPT1iLnRhZ05hbWV8fGUuYWRkKGIpO3JldHVybiBlfWdiKGEsYixjLGQsZSk7cmV0dXJuIGV9XG5mdW5jdGlvbiBkYihhLGIsYyxkLGUpe2IuZ2V0RWxlbWVudHNCeU5hbWUmJmQmJlwibmFtZVwiPT1jJiYhdj8oYj1iLmdldEVsZW1lbnRzQnlOYW1lKGQpLG4oYixmdW5jdGlvbihmKXthLmEoZikmJmUuYWRkKGYpfSkpOmIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmZCYmXCJjbGFzc1wiPT1jPyhiPWIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkKSxuKGIsZnVuY3Rpb24oZil7Zi5jbGFzc05hbWU9PWQmJmEuYShmKSYmZS5hZGQoZil9KSk6YSBpbnN0YW5jZW9mIEc/Z2IoYSxiLGMsZCxlKTpiLmdldEVsZW1lbnRzQnlUYWdOYW1lJiYoYj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEuZigpKSxuKGIsZnVuY3Rpb24oZil7QyhmLGMsZCkmJmUuYWRkKGYpfSkpO3JldHVybiBlfVxuZnVuY3Rpb24gaGIoYSxiLGMsZCxlKXt2YXIgZjtpZigoYSBpbnN0YW5jZW9mIEZ8fDg9PWEuYnx8YyYmbnVsbD09PWEuYikmJihmPWIuY2hpbGROb2Rlcykpe3ZhciBnPWViKGEpO2lmKFwiKlwiIT1nJiYoZj1rYShmLGZ1bmN0aW9uKGgpe3JldHVybiBoLnRhZ05hbWUmJmgudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT1nfSksIWYpKXJldHVybiBlO2MmJihmPWthKGYsZnVuY3Rpb24oaCl7cmV0dXJuIEMoaCxjLGQpfSkpO24oZixmdW5jdGlvbihoKXtcIipcIj09ZyYmKFwiIVwiPT1oLnRhZ05hbWV8fFwiKlwiPT1nJiYxIT1oLm5vZGVUeXBlKXx8ZS5hZGQoaCl9KTtyZXR1cm4gZX1yZXR1cm4gaWIoYSxiLGMsZCxlKX1mdW5jdGlvbiBpYihhLGIsYyxkLGUpe2ZvcihiPWIuZmlyc3RDaGlsZDtiO2I9Yi5uZXh0U2libGluZylDKGIsYyxkKSYmYS5hKGIpJiZlLmFkZChiKTtyZXR1cm4gZX1cbmZ1bmN0aW9uIGdiKGEsYixjLGQsZSl7Zm9yKGI9Yi5maXJzdENoaWxkO2I7Yj1iLm5leHRTaWJsaW5nKUMoYixjLGQpJiZhLmEoYikmJmUuYWRkKGIpLGdiKGEsYixjLGQsZSl9ZnVuY3Rpb24gZWIoYSl7aWYoYSBpbnN0YW5jZW9mIEcpe2lmKDg9PWEuYilyZXR1cm5cIiFcIjtpZihudWxsPT09YS5iKXJldHVyblwiKlwifXJldHVybiBhLmYoKX07ZnVuY3Rpb24gRSgpe3RoaXMuYj10aGlzLmE9bnVsbDt0aGlzLmw9MH1mdW5jdGlvbiBqYihhKXt0aGlzLmY9YTt0aGlzLmE9dGhpcy5iPW51bGx9ZnVuY3Rpb24ga2IoYSxiKXtpZighYS5hKXJldHVybiBiO2lmKCFiLmEpcmV0dXJuIGE7dmFyIGM9YS5hO2I9Yi5hO2Zvcih2YXIgZD1udWxsLGUsZj0wO2MmJmI7KXtlPWMuZjt2YXIgZz1iLmY7ZT09Z3x8ZSBpbnN0YW5jZW9mIE5hJiZnIGluc3RhbmNlb2YgTmEmJmUuYT09Zy5hPyhlPWMsYz1jLmEsYj1iLmEpOjA8WGEoYy5mLGIuZik/KGU9YixiPWIuYSk6KGU9YyxjPWMuYSk7KGUuYj1kKT9kLmE9ZTphLmE9ZTtkPWU7ZisrfWZvcihlPWN8fGI7ZTspZS5iPWQsZD1kLmE9ZSxmKyssZT1lLmE7YS5iPWQ7YS5sPWY7cmV0dXJuIGF9ZnVuY3Rpb24gbGIoYSxiKXtiPW5ldyBqYihiKTtiLmE9YS5hO2EuYj9hLmEuYj1iOmEuYT1hLmI9YjthLmE9YjthLmwrK31cbkUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhKXthPW5ldyBqYihhKTthLmI9dGhpcy5iO3RoaXMuYT90aGlzLmIuYT1hOnRoaXMuYT10aGlzLmI9YTt0aGlzLmI9YTt0aGlzLmwrK307ZnVuY3Rpb24gbWIoYSl7cmV0dXJuKGE9YS5hKT9hLmY6bnVsbH1mdW5jdGlvbiBuYihhKXtyZXR1cm4oYT1tYihhKSk/QihhKTpcIlwifWZ1bmN0aW9uIEgoYSxiKXtyZXR1cm4gbmV3IG9iKGEsISFiKX1mdW5jdGlvbiBvYihhLGIpe3RoaXMuZj1hO3RoaXMuYj0odGhpcy5zPWIpP2EuYjphLmE7dGhpcy5hPW51bGx9ZnVuY3Rpb24gSShhKXt2YXIgYj1hLmI7aWYobnVsbD09YilyZXR1cm4gbnVsbDt2YXIgYz1hLmE9YjthLmI9YS5zP2IuYjpiLmE7cmV0dXJuIGMuZn07ZnVuY3Rpb24gSihhKXt0aGlzLmk9YTt0aGlzLmI9dGhpcy5nPSExO3RoaXMuZj1udWxsfWZ1bmN0aW9uIEsoYSl7cmV0dXJuXCJcXG4gIFwiK2EudG9TdHJpbmcoKS5zcGxpdChcIlxcblwiKS5qb2luKFwiXFxuICBcIil9ZnVuY3Rpb24gcGIoYSxiKXthLmc9Yn1mdW5jdGlvbiBxYihhLGIpe2EuYj1ifWZ1bmN0aW9uIE4oYSxiKXthPWEuYShiKTtyZXR1cm4gYSBpbnN0YW5jZW9mIEU/K25iKGEpOithfWZ1bmN0aW9uIE8oYSxiKXthPWEuYShiKTtyZXR1cm4gYSBpbnN0YW5jZW9mIEU/bmIoYSk6XCJcIithfWZ1bmN0aW9uIHJiKGEsYil7YT1hLmEoYik7cmV0dXJuIGEgaW5zdGFuY2VvZiBFPyEhYS5sOiEhYX07ZnVuY3Rpb24gc2IoYSxiLGMpe0ouY2FsbCh0aGlzLGEuaSk7dGhpcy5jPWE7dGhpcy5oPWI7dGhpcy5vPWM7dGhpcy5nPWIuZ3x8Yy5nO3RoaXMuYj1iLmJ8fGMuYjt0aGlzLmM9PXRiJiYoYy5ifHxjLmd8fDQ9PWMuaXx8MD09Yy5pfHwhYi5mP2IuYnx8Yi5nfHw0PT1iLml8fDA9PWIuaXx8IWMuZnx8KHRoaXMuZj17bmFtZTpjLmYubmFtZSx1OmJ9KTp0aGlzLmY9e25hbWU6Yi5mLm5hbWUsdTpjfSl9bChzYixKKTtcbmZ1bmN0aW9uIHViKGEsYixjLGQsZSl7Yj1iLmEoZCk7Yz1jLmEoZCk7dmFyIGY7aWYoYiBpbnN0YW5jZW9mIEUmJmMgaW5zdGFuY2VvZiBFKXtiPUgoYik7Zm9yKGQ9SShiKTtkO2Q9SShiKSlmb3IoZT1IKGMpLGY9SShlKTtmO2Y9SShlKSlpZihhKEIoZCksQihmKSkpcmV0dXJuITA7cmV0dXJuITF9aWYoYiBpbnN0YW5jZW9mIEV8fGMgaW5zdGFuY2VvZiBFKXtiIGluc3RhbmNlb2YgRT8oZT1iLGQ9Yyk6KGU9YyxkPWIpO2Y9SChlKTtmb3IodmFyIGc9dHlwZW9mIGQsaD1JKGYpO2g7aD1JKGYpKXtzd2l0Y2goZyl7Y2FzZSBcIm51bWJlclwiOmg9K0IoaCk7YnJlYWs7Y2FzZSBcImJvb2xlYW5cIjpoPSEhQihoKTticmVhaztjYXNlIFwic3RyaW5nXCI6aD1CKGgpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHByaW1pdGl2ZSB0eXBlIGZvciBjb21wYXJpc29uLlwiKTt9aWYoZT09YiYmYShoLGQpfHxlPT1jJiZhKGQsaCkpcmV0dXJuITB9cmV0dXJuITF9cmV0dXJuIGU/XCJib29sZWFuXCI9PVxudHlwZW9mIGJ8fFwiYm9vbGVhblwiPT10eXBlb2YgYz9hKCEhYiwhIWMpOlwibnVtYmVyXCI9PXR5cGVvZiBifHxcIm51bWJlclwiPT10eXBlb2YgYz9hKCtiLCtjKTphKGIsYyk6YSgrYiwrYyl9c2IucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYy5tKHRoaXMuaCx0aGlzLm8sYSl9O3NiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiQmluYXJ5IEV4cHJlc3Npb246IFwiK3RoaXMuYzthKz1LKHRoaXMuaCk7cmV0dXJuIGErPUsodGhpcy5vKX07ZnVuY3Rpb24gdmIoYSxiLGMsZCl7dGhpcy5JPWE7dGhpcy5EPWI7dGhpcy5pPWM7dGhpcy5tPWR9dmIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuSX07dmFyIHdiPXt9O1xuZnVuY3Rpb24gUChhLGIsYyxkKXtpZih3Yi5oYXNPd25Qcm9wZXJ0eShhKSl0aHJvdyBFcnJvcihcIkJpbmFyeSBvcGVyYXRvciBhbHJlYWR5IGNyZWF0ZWQ6IFwiK2EpO2E9bmV3IHZiKGEsYixjLGQpO3JldHVybiB3YlthLnRvU3RyaW5nKCldPWF9UChcImRpdlwiLDYsMSxmdW5jdGlvbihhLGIsYyl7cmV0dXJuIE4oYSxjKS9OKGIsYyl9KTtQKFwibW9kXCIsNiwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gTihhLGMpJU4oYixjKX0pO1AoXCIqXCIsNiwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gTihhLGMpKk4oYixjKX0pO1AoXCIrXCIsNSwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gTihhLGMpK04oYixjKX0pO1AoXCItXCIsNSwxLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gTihhLGMpLU4oYixjKX0pO1AoXCI8XCIsNCwyLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdWIoZnVuY3Rpb24oZCxlKXtyZXR1cm4gZDxlfSxhLGIsYyl9KTtcblAoXCI+XCIsNCwyLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdWIoZnVuY3Rpb24oZCxlKXtyZXR1cm4gZD5lfSxhLGIsYyl9KTtQKFwiPD1cIiw0LDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1YihmdW5jdGlvbihkLGUpe3JldHVybiBkPD1lfSxhLGIsYyl9KTtQKFwiPj1cIiw0LDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1YihmdW5jdGlvbihkLGUpe3JldHVybiBkPj1lfSxhLGIsYyl9KTt2YXIgdGI9UChcIj1cIiwzLDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1YihmdW5jdGlvbihkLGUpe3JldHVybiBkPT1lfSxhLGIsYywhMCl9KTtQKFwiIT1cIiwzLDIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1YihmdW5jdGlvbihkLGUpe3JldHVybiBkIT1lfSxhLGIsYywhMCl9KTtQKFwiYW5kXCIsMiwyLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gcmIoYSxjKSYmcmIoYixjKX0pO1AoXCJvclwiLDEsMixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHJiKGEsYyl8fHJiKGIsYyl9KTtmdW5jdGlvbiB4YihhLGIpe2lmKGIuYS5sZW5ndGgmJjQhPWEuaSl0aHJvdyBFcnJvcihcIlByaW1hcnkgZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIG5vZGVzZXQgaWYgZmlsdGVyIGhhcyBwcmVkaWNhdGUocykuXCIpO0ouY2FsbCh0aGlzLGEuaSk7dGhpcy5jPWE7dGhpcy5oPWI7dGhpcy5nPWEuZzt0aGlzLmI9YS5ifWwoeGIsSik7eGIucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7YT10aGlzLmMuYShhKTtyZXR1cm4geWIodGhpcy5oLGEpfTt4Yi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT1cIkZpbHRlcjpcIitLKHRoaXMuYyk7cmV0dXJuIGErPUsodGhpcy5oKX07ZnVuY3Rpb24gemIoYSxiKXtpZihiLmxlbmd0aDxhLkMpdGhyb3cgRXJyb3IoXCJGdW5jdGlvbiBcIithLmorXCIgZXhwZWN0cyBhdCBsZWFzdFwiK2EuQytcIiBhcmd1bWVudHMsIFwiK2IubGVuZ3RoK1wiIGdpdmVuXCIpO2lmKG51bGwhPT1hLkImJmIubGVuZ3RoPmEuQil0aHJvdyBFcnJvcihcIkZ1bmN0aW9uIFwiK2EuaitcIiBleHBlY3RzIGF0IG1vc3QgXCIrYS5CK1wiIGFyZ3VtZW50cywgXCIrYi5sZW5ndGgrXCIgZ2l2ZW5cIik7YS5IJiZuKGIsZnVuY3Rpb24oYyxkKXtpZig0IT1jLmkpdGhyb3cgRXJyb3IoXCJBcmd1bWVudCBcIitkK1wiIHRvIGZ1bmN0aW9uIFwiK2EuaitcIiBpcyBub3Qgb2YgdHlwZSBOb2Rlc2V0OiBcIitjKTt9KTtKLmNhbGwodGhpcyxhLmkpO3RoaXMudj1hO3RoaXMuYz1iO3BiKHRoaXMsYS5nfHxtYShiLGZ1bmN0aW9uKGMpe3JldHVybiBjLmd9KSk7cWIodGhpcyxhLkcmJiFiLmxlbmd0aHx8YS5GJiYhIWIubGVuZ3RofHxtYShiLGZ1bmN0aW9uKGMpe3JldHVybiBjLmJ9KSl9XG5sKHpiLEopO3piLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnYubS5hcHBseShudWxsLHBhKGEsdGhpcy5jKSl9O3piLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiRnVuY3Rpb246IFwiK3RoaXMudjtpZih0aGlzLmMubGVuZ3RoKXt2YXIgYj1sYSh0aGlzLmMsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytLKGQpfSxcIkFyZ3VtZW50czpcIik7YSs9SyhiKX1yZXR1cm4gYX07ZnVuY3Rpb24gQWIoYSxiLGMsZCxlLGYsZyxoKXt0aGlzLmo9YTt0aGlzLmk9Yjt0aGlzLmc9Yzt0aGlzLkc9ZDt0aGlzLkY9ITE7dGhpcy5tPWU7dGhpcy5DPWY7dGhpcy5CPXZvaWQgMCE9PWc/ZzpmO3RoaXMuSD0hIWh9QWIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuan07dmFyIEJiPXt9O1xuZnVuY3Rpb24gUShhLGIsYyxkLGUsZixnLGgpe2lmKEJiLmhhc093blByb3BlcnR5KGEpKXRocm93IEVycm9yKFwiRnVuY3Rpb24gYWxyZWFkeSBjcmVhdGVkOiBcIithK1wiLlwiKTtCYlthXT1uZXcgQWIoYSxiLGMsZCxlLGYsZyxoKX1RKFwiYm9vbGVhblwiLDIsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gcmIoYixhKX0sMSk7UShcImNlaWxpbmdcIiwxLCExLCExLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGguY2VpbChOKGIsYSkpfSwxKTtRKFwiY29uY2F0XCIsMywhMSwhMSxmdW5jdGlvbihhLGIpe3JldHVybiBsYShxYShhcmd1bWVudHMsMSksZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytPKGQsYSl9LFwiXCIpfSwyLG51bGwpO1EoXCJjb250YWluc1wiLDIsITEsITEsZnVuY3Rpb24oYSxiLGMpe2I9TyhiLGEpO2E9TyhjLGEpO3JldHVybi0xIT1iLmluZGV4T2YoYSl9LDIpO1EoXCJjb3VudFwiLDEsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5hKGEpLmx9LDEsMSwhMCk7XG5RKFwiZmFsc2VcIiwyLCExLCExLGZ1bmN0aW9uKCl7cmV0dXJuITF9LDApO1EoXCJmbG9vclwiLDEsITEsITEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gTWF0aC5mbG9vcihOKGIsYSkpfSwxKTtRKFwiaWRcIiw0LCExLCExLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhoKXtpZih4KXt2YXIgbT1lLmFsbFtoXTtpZihtKXtpZihtLm5vZGVUeXBlJiZoPT1tLmlkKXJldHVybiBtO2lmKG0ubGVuZ3RoKXJldHVybiBvYShtLGZ1bmN0aW9uKHcpe3JldHVybiBoPT13LmlkfSl9cmV0dXJuIG51bGx9cmV0dXJuIGUuZ2V0RWxlbWVudEJ5SWQoaCl9dmFyIGQ9YS5hLGU9OT09ZC5ub2RlVHlwZT9kOmQub3duZXJEb2N1bWVudDthPU8oYixhKS5zcGxpdCgvXFxzKy8pO3ZhciBmPVtdO24oYSxmdW5jdGlvbihoKXtoPWMoaCk7IWh8fDA8PWphKGYsaCl8fGYucHVzaChoKX0pO2Yuc29ydChYYSk7dmFyIGc9bmV3IEU7bihmLGZ1bmN0aW9uKGgpe2cuYWRkKGgpfSk7cmV0dXJuIGd9LDEpO1xuUShcImxhbmdcIiwyLCExLCExLGZ1bmN0aW9uKCl7cmV0dXJuITF9LDEpO1EoXCJsYXN0XCIsMSwhMCwhMSxmdW5jdGlvbihhKXtpZigxIT1hcmd1bWVudHMubGVuZ3RoKXRocm93IEVycm9yKFwiRnVuY3Rpb24gbGFzdCBleHBlY3RzICgpXCIpO3JldHVybiBhLmZ9LDApO1EoXCJsb2NhbC1uYW1lXCIsMywhMSwhMCxmdW5jdGlvbihhLGIpe3JldHVybihhPWI/bWIoYi5hKGEpKTphLmEpP2EubG9jYWxOYW1lfHxhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk6XCJcIn0sMCwxLCEwKTtRKFwibmFtZVwiLDMsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4oYT1iP21iKGIuYShhKSk6YS5hKT9hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk6XCJcIn0sMCwxLCEwKTtRKFwibmFtZXNwYWNlLXVyaVwiLDMsITAsITEsZnVuY3Rpb24oKXtyZXR1cm5cIlwifSwwLDEsITApO1xuUShcIm5vcm1hbGl6ZS1zcGFjZVwiLDMsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4oYj9PKGIsYSk6QihhLmEpKS5yZXBsYWNlKC9bXFxzXFx4YTBdKy9nLFwiIFwiKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSwwLDEpO1EoXCJub3RcIiwyLCExLCExLGZ1bmN0aW9uKGEsYil7cmV0dXJuIXJiKGIsYSl9LDEpO1EoXCJudW1iZXJcIiwxLCExLCEwLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGI/TihiLGEpOitCKGEuYSl9LDAsMSk7UShcInBvc2l0aW9uXCIsMSwhMCwhMSxmdW5jdGlvbihhKXtyZXR1cm4gYS5ifSwwKTtRKFwicm91bmRcIiwxLCExLCExLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGgucm91bmQoTihiLGEpKX0sMSk7UShcInN0YXJ0cy13aXRoXCIsMiwhMSwhMSxmdW5jdGlvbihhLGIsYyl7Yj1PKGIsYSk7YT1PKGMsYSk7cmV0dXJuIDA9PWIubGFzdEluZGV4T2YoYSwwKX0sMik7UShcInN0cmluZ1wiLDMsITEsITAsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9PKGIsYSk6QihhLmEpfSwwLDEpO1xuUShcInN0cmluZy1sZW5ndGhcIiwxLCExLCEwLGZ1bmN0aW9uKGEsYil7cmV0dXJuKGI/TyhiLGEpOkIoYS5hKSkubGVuZ3RofSwwLDEpO1EoXCJzdWJzdHJpbmdcIiwzLCExLCExLGZ1bmN0aW9uKGEsYixjLGQpe2M9TihjLGEpO2lmKGlzTmFOKGMpfHxJbmZpbml0eT09Y3x8LUluZmluaXR5PT1jKXJldHVyblwiXCI7ZD1kP04oZCxhKTpJbmZpbml0eTtpZihpc05hTihkKXx8LUluZmluaXR5PT09ZClyZXR1cm5cIlwiO2M9TWF0aC5yb3VuZChjKS0xO3ZhciBlPU1hdGgubWF4KGMsMCk7YT1PKGIsYSk7cmV0dXJuIEluZmluaXR5PT1kP2Euc3Vic3RyaW5nKGUpOmEuc3Vic3RyaW5nKGUsYytNYXRoLnJvdW5kKGQpKX0sMiwzKTtRKFwic3Vic3RyaW5nLWFmdGVyXCIsMywhMSwhMSxmdW5jdGlvbihhLGIsYyl7Yj1PKGIsYSk7YT1PKGMsYSk7Yz1iLmluZGV4T2YoYSk7cmV0dXJuLTE9PWM/XCJcIjpiLnN1YnN0cmluZyhjK2EubGVuZ3RoKX0sMik7XG5RKFwic3Vic3RyaW5nLWJlZm9yZVwiLDMsITEsITEsZnVuY3Rpb24oYSxiLGMpe2I9TyhiLGEpO2E9TyhjLGEpO2E9Yi5pbmRleE9mKGEpO3JldHVybi0xPT1hP1wiXCI6Yi5zdWJzdHJpbmcoMCxhKX0sMik7UShcInN1bVwiLDEsITEsITEsZnVuY3Rpb24oYSxiKXthPUgoYi5hKGEpKTtiPTA7Zm9yKHZhciBjPUkoYSk7YztjPUkoYSkpYis9K0IoYyk7cmV0dXJuIGJ9LDEsMSwhMCk7UShcInRyYW5zbGF0ZVwiLDMsITEsITEsZnVuY3Rpb24oYSxiLGMsZCl7Yj1PKGIsYSk7Yz1PKGMsYSk7dmFyIGU9TyhkLGEpO2E9e307Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGY9Yy5jaGFyQXQoZCk7ZiBpbiBhfHwoYVtmXT1lLmNoYXJBdChkKSl9Yz1cIlwiO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspZj1iLmNoYXJBdChkKSxjKz1mIGluIGE/YVtmXTpmO3JldHVybiBjfSwzKTtRKFwidHJ1ZVwiLDIsITEsITEsZnVuY3Rpb24oKXtyZXR1cm4hMH0sMCk7ZnVuY3Rpb24gRyhhLGIpe3RoaXMuaD1hO3RoaXMuYz12b2lkIDAhPT1iP2I6bnVsbDt0aGlzLmI9bnVsbDtzd2l0Y2goYSl7Y2FzZSBcImNvbW1lbnRcIjp0aGlzLmI9ODticmVhaztjYXNlIFwidGV4dFwiOnRoaXMuYj0zO2JyZWFrO2Nhc2UgXCJwcm9jZXNzaW5nLWluc3RydWN0aW9uXCI6dGhpcy5iPTc7YnJlYWs7Y2FzZSBcIm5vZGVcIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFwiKTt9fWZ1bmN0aW9uIENiKGEpe3JldHVyblwiY29tbWVudFwiPT1hfHxcInRleHRcIj09YXx8XCJwcm9jZXNzaW5nLWluc3RydWN0aW9uXCI9PWF8fFwibm9kZVwiPT1hfUcucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PT10aGlzLmJ8fHRoaXMuYj09YS5ub2RlVHlwZX07Ry5wcm90b3R5cGUuZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmh9O1xuRy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT1cIktpbmQgVGVzdDogXCIrdGhpcy5oO251bGw9PT10aGlzLmN8fChhKz1LKHRoaXMuYykpO3JldHVybiBhfTtmdW5jdGlvbiBEYihhKXtKLmNhbGwodGhpcywzKTt0aGlzLmM9YS5zdWJzdHJpbmcoMSxhLmxlbmd0aC0xKX1sKERiLEopO0RiLnByb3RvdHlwZS5hPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY307RGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJMaXRlcmFsOiBcIit0aGlzLmN9O2Z1bmN0aW9uIEYoYSxiKXt0aGlzLmo9YS50b0xvd2VyQ2FzZSgpO2E9XCIqXCI9PXRoaXMuaj9cIipcIjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjt0aGlzLmM9Yj9iLnRvTG93ZXJDYXNlKCk6YX1GLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZVR5cGU7aWYoMSE9YiYmMiE9YilyZXR1cm4hMTtiPXZvaWQgMCE9PWEubG9jYWxOYW1lP2EubG9jYWxOYW1lOmEubm9kZU5hbWU7cmV0dXJuXCIqXCIhPXRoaXMuaiYmdGhpcy5qIT1iLnRvTG93ZXJDYXNlKCk/ITE6XCIqXCI9PXRoaXMuYz8hMDp0aGlzLmM9PShhLm5hbWVzcGFjZVVSST9hLm5hbWVzcGFjZVVSSS50b0xvd2VyQ2FzZSgpOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKX07Ri5wcm90b3R5cGUuZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmp9O1xuRi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5hbWUgVGVzdDogXCIrKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT10aGlzLmM/XCJcIjp0aGlzLmMrXCI6XCIpK3RoaXMuan07ZnVuY3Rpb24gRWIoYSl7Si5jYWxsKHRoaXMsMSk7dGhpcy5jPWF9bChFYixKKTtFYi5wcm90b3R5cGUuYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN9O0ViLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTnVtYmVyOiBcIit0aGlzLmN9O2Z1bmN0aW9uIEZiKGEsYil7Si5jYWxsKHRoaXMsYS5pKTt0aGlzLmg9YTt0aGlzLmM9Yjt0aGlzLmc9YS5nO3RoaXMuYj1hLmI7MT09dGhpcy5jLmxlbmd0aCYmKGE9dGhpcy5jWzBdLGEuQXx8YS5jIT1HYnx8KGE9YS5vLFwiKlwiIT1hLmYoKSYmKHRoaXMuZj17bmFtZTphLmYoKSx1Om51bGx9KSkpfWwoRmIsSik7ZnVuY3Rpb24gSGIoKXtKLmNhbGwodGhpcyw0KX1sKEhiLEopO0hiLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBFO2E9YS5hOzk9PWEubm9kZVR5cGU/Yi5hZGQoYSk6Yi5hZGQoYS5vd25lckRvY3VtZW50KTtyZXR1cm4gYn07SGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJSb290IEhlbHBlciBFeHByZXNzaW9uXCJ9O2Z1bmN0aW9uIEliKCl7Si5jYWxsKHRoaXMsNCl9bChJYixKKTtJYi5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgRTtiLmFkZChhLmEpO3JldHVybiBifTtJYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkNvbnRleHQgSGVscGVyIEV4cHJlc3Npb25cIn07XG5mdW5jdGlvbiBKYihhKXtyZXR1cm5cIi9cIj09YXx8XCIvL1wiPT1hfUZiLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaC5hKGEpO2lmKCEoYiBpbnN0YW5jZW9mIEUpKXRocm93IEVycm9yKFwiRmlsdGVyIGV4cHJlc3Npb24gbXVzdCBldmFsdWF0ZSB0byBub2Rlc2V0LlwiKTthPXRoaXMuYztmb3IodmFyIGM9MCxkPWEubGVuZ3RoO2M8ZCYmYi5sO2MrKyl7dmFyIGU9YVtjXSxmPUgoYixlLmMucyk7aWYoZS5nfHxlLmMhPUtiKWlmKGUuZ3x8ZS5jIT1MYil7dmFyIGc9SShmKTtmb3IoYj1lLmEobmV3IGlhKGcpKTtudWxsIT0oZz1JKGYpKTspZz1lLmEobmV3IGlhKGcpKSxiPWtiKGIsZyl9ZWxzZSBnPUkoZiksYj1lLmEobmV3IGlhKGcpKTtlbHNle2ZvcihnPUkoZik7KGI9SShmKSkmJighZy5jb250YWluc3x8Zy5jb250YWlucyhiKSkmJmIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZykmODtnPWIpO2I9ZS5hKG5ldyBpYShnKSl9fXJldHVybiBifTtcbkZiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiUGF0aCBFeHByZXNzaW9uOlwiK0sodGhpcy5oKTtpZih0aGlzLmMubGVuZ3RoKXt2YXIgYj1sYSh0aGlzLmMsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytLKGQpfSxcIlN0ZXBzOlwiKTthKz1LKGIpfXJldHVybiBhfTtmdW5jdGlvbiBNYihhLGIpe3RoaXMuYT1hO3RoaXMucz0hIWJ9XG5mdW5jdGlvbiB5YihhLGIsYyl7Zm9yKGM9Y3x8MDtjPGEuYS5sZW5ndGg7YysrKWZvcih2YXIgZD1hLmFbY10sZT1IKGIpLGY9Yi5sLGcsaD0wO2c9SShlKTtoKyspe3ZhciBtPWEucz9mLWg6aCsxO2c9ZC5hKG5ldyBpYShnLG0sZikpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBnKW09bT09ZztlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBnfHxcImJvb2xlYW5cIj09dHlwZW9mIGcpbT0hIWc7ZWxzZSBpZihnIGluc3RhbmNlb2YgRSltPTA8Zy5sO2Vsc2UgdGhyb3cgRXJyb3IoXCJQcmVkaWNhdGUuZXZhbHVhdGUgcmV0dXJuZWQgYW4gdW5leHBlY3RlZCB0eXBlLlwiKTtpZighbSl7bT1lO2c9bS5mO3ZhciB3PW0uYTtpZighdyl0aHJvdyBFcnJvcihcIk5leHQgbXVzdCBiZSBjYWxsZWQgYXQgbGVhc3Qgb25jZSBiZWZvcmUgcmVtb3ZlLlwiKTt2YXIgcj13LmI7dz13LmE7cj9yLmE9dzpnLmE9dzt3P3cuYj1yOmcuYj1yO2cubC0tO20uYT1udWxsfX1yZXR1cm4gYn1cbk1iLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBsYSh0aGlzLmEsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYStLKGIpfSxcIlByZWRpY2F0ZXM6XCIpfTtmdW5jdGlvbiBSKGEsYixjLGQpe0ouY2FsbCh0aGlzLDQpO3RoaXMuYz1hO3RoaXMubz1iO3RoaXMuaD1jfHxuZXcgTWIoW10pO3RoaXMuQT0hIWQ7Yj10aGlzLmg7Yj0wPGIuYS5sZW5ndGg/Yi5hWzBdLmY6bnVsbDthLkomJmImJihhPWIubmFtZSxhPXg/YS50b0xvd2VyQ2FzZSgpOmEsdGhpcy5mPXtuYW1lOmEsdTpiLnV9KTthOnthPXRoaXMuaDtmb3IoYj0wO2I8YS5hLmxlbmd0aDtiKyspaWYoYz1hLmFbYl0sYy5nfHwxPT1jLml8fDA9PWMuaSl7YT0hMDticmVhayBhfWE9ITF9dGhpcy5nPWF9bChSLEopO1xuUi5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXt2YXIgYj1hLmEsYz10aGlzLmYsZD1udWxsLGU9bnVsbCxmPTA7YyYmKGQ9Yy5uYW1lLGU9Yy51P08oYy51LGEpOm51bGwsZj0xKTtpZih0aGlzLkEpaWYodGhpcy5nfHx0aGlzLmMhPU5iKWlmKGI9SCgobmV3IFIoT2IsbmV3IEcoXCJub2RlXCIpKSkuYShhKSksYz1JKGIpKWZvcihhPXRoaXMubShjLGQsZSxmKTtudWxsIT0oYz1JKGIpKTspYT1rYihhLHRoaXMubShjLGQsZSxmKSk7ZWxzZSBhPW5ldyBFO2Vsc2UgYT1iYih0aGlzLm8sYixkLGUpLGE9eWIodGhpcy5oLGEsZik7ZWxzZSBhPXRoaXMubShhLmEsZCxlLGYpO3JldHVybiBhfTtSLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEsYixjLGQpe2E9dGhpcy5jLnYodGhpcy5vLGEsYixjKTtyZXR1cm4gYT15Yih0aGlzLmgsYSxkKX07XG5SLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVwiU3RlcDpcIitLKFwiT3BlcmF0b3I6IFwiKyh0aGlzLkE/XCIvL1wiOlwiL1wiKSk7dGhpcy5jLmomJihhKz1LKFwiQXhpczogXCIrdGhpcy5jKSk7YSs9Syh0aGlzLm8pO2lmKHRoaXMuaC5hLmxlbmd0aCl7dmFyIGI9bGEodGhpcy5oLmEsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYytLKGQpfSxcIlByZWRpY2F0ZXM6XCIpO2ErPUsoYil9cmV0dXJuIGF9O2Z1bmN0aW9uIFBiKGEsYixjLGQpe3RoaXMuaj1hO3RoaXMudj1iO3RoaXMucz1jO3RoaXMuSj1kfVBiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmp9O3ZhciBRYj17fTtmdW5jdGlvbiBTKGEsYixjLGQpe2lmKFFiLmhhc093blByb3BlcnR5KGEpKXRocm93IEVycm9yKFwiQXhpcyBhbHJlYWR5IGNyZWF0ZWQ6IFwiK2EpO2I9bmV3IFBiKGEsYixjLCEhZCk7cmV0dXJuIFFiW2FdPWJ9XG5TKFwiYW5jZXN0b3JcIixmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1uZXcgRTtiPWIucGFyZW50Tm9kZTspYS5hKGIpJiZsYihjLGIpO3JldHVybiBjfSwhMCk7UyhcImFuY2VzdG9yLW9yLXNlbGZcIixmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBFO2RvIGEuYShiKSYmbGIoYyxiKTt3aGlsZShiPWIucGFyZW50Tm9kZSk7cmV0dXJuIGN9LCEwKTtcbnZhciBHYj1TKFwiYXR0cmlidXRlXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgRSxkPWEuZigpO2lmKFwic3R5bGVcIj09ZCYmeCYmYi5zdHlsZSlyZXR1cm4gYy5hZGQobmV3IE5hKGIuc3R5bGUsYixcInN0eWxlXCIsYi5zdHlsZS5jc3NUZXh0KSksYzt2YXIgZT1iLmF0dHJpYnV0ZXM7aWYoZSlpZihhIGluc3RhbmNlb2YgRyYmbnVsbD09PWEuYnx8XCIqXCI9PWQpZm9yKGE9MDtkPWVbYV07YSsrKXg/ZC5ub2RlVmFsdWUmJmMuYWRkKE9hKGIsZCkpOmMuYWRkKGQpO2Vsc2UoZD1lLmdldE5hbWVkSXRlbShkKSkmJih4P2Qubm9kZVZhbHVlJiZjLmFkZChPYShiLGQpKTpjLmFkZChkKSk7cmV0dXJuIGN9LCExKSxOYj1TKFwiY2hpbGRcIixmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybih4P2hiOmliKS5jYWxsKG51bGwsYSxiLGFhKGMpP2M6bnVsbCxhYShkKT9kOm51bGwsZXx8bmV3IEUpfSwhMSwhMCk7UyhcImRlc2NlbmRhbnRcIixiYiwhMSwhMCk7XG52YXIgT2I9UyhcImRlc2NlbmRhbnQtb3Itc2VsZlwiLGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBFO0MoYixjLGQpJiZhLmEoYikmJmUuYWRkKGIpO3JldHVybiBiYihhLGIsYyxkLGUpfSwhMSwhMCksS2I9UyhcImZvbGxvd2luZ1wiLGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBFO2RvIGZvcih2YXIgZj1iO2Y9Zi5uZXh0U2libGluZzspQyhmLGMsZCkmJmEuYShmKSYmZS5hZGQoZiksZT1iYihhLGYsYyxkLGUpO3doaWxlKGI9Yi5wYXJlbnROb2RlKTtyZXR1cm4gZX0sITEsITApO1MoXCJmb2xsb3dpbmctc2libGluZ1wiLGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPW5ldyBFO2I9Yi5uZXh0U2libGluZzspYS5hKGIpJiZjLmFkZChiKTtyZXR1cm4gY30sITEpO1MoXCJuYW1lc3BhY2VcIixmdW5jdGlvbigpe3JldHVybiBuZXcgRX0sITEpO1xudmFyIFJiPVMoXCJwYXJlbnRcIixmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBFO2lmKDk9PWIubm9kZVR5cGUpcmV0dXJuIGM7aWYoMj09Yi5ub2RlVHlwZSlyZXR1cm4gYy5hZGQoYi5vd25lckVsZW1lbnQpLGM7Yj1iLnBhcmVudE5vZGU7YS5hKGIpJiZjLmFkZChiKTtyZXR1cm4gY30sITEpLExiPVMoXCJwcmVjZWRpbmdcIixmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgRSxmPVtdO2RvIGYudW5zaGlmdChiKTt3aGlsZShiPWIucGFyZW50Tm9kZSk7Zm9yKHZhciBnPTEsaD1mLmxlbmd0aDtnPGg7ZysrKXt2YXIgbT1bXTtmb3IoYj1mW2ddO2I9Yi5wcmV2aW91c1NpYmxpbmc7KW0udW5zaGlmdChiKTtmb3IodmFyIHc9MCxyPW0ubGVuZ3RoO3c8cjt3KyspYj1tW3ddLEMoYixjLGQpJiZhLmEoYikmJmUuYWRkKGIpLGU9YmIoYSxiLGMsZCxlKX1yZXR1cm4gZX0sITAsITApO1xuUyhcInByZWNlZGluZy1zaWJsaW5nXCIsZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9bmV3IEU7Yj1iLnByZXZpb3VzU2libGluZzspYS5hKGIpJiZsYihjLGIpO3JldHVybiBjfSwhMCk7dmFyIFNiPVMoXCJzZWxmXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgRTthLmEoYikmJmMuYWRkKGIpO3JldHVybiBjfSwhMSk7ZnVuY3Rpb24gVGIoYSl7Si5jYWxsKHRoaXMsMSk7dGhpcy5jPWE7dGhpcy5nPWEuZzt0aGlzLmI9YS5ifWwoVGIsSik7VGIucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuLU4odGhpcy5jLGEpfTtUYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlVuYXJ5IEV4cHJlc3Npb246IC1cIitLKHRoaXMuYyl9O2Z1bmN0aW9uIFViKGEpe0ouY2FsbCh0aGlzLDQpO3RoaXMuYz1hO3BiKHRoaXMsbWEodGhpcy5jLGZ1bmN0aW9uKGIpe3JldHVybiBiLmd9KSk7cWIodGhpcyxtYSh0aGlzLmMsZnVuY3Rpb24oYil7cmV0dXJuIGIuYn0pKX1sKFViLEopO1ViLnByb3RvdHlwZS5hPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBFO24odGhpcy5jLGZ1bmN0aW9uKGMpe2M9Yy5hKGEpO2lmKCEoYyBpbnN0YW5jZW9mIEUpKXRocm93IEVycm9yKFwiUGF0aCBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gTm9kZVNldC5cIik7Yj1rYihiLGMpfSk7cmV0dXJuIGJ9O1ViLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBsYSh0aGlzLmMsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYStLKGIpfSxcIlVuaW9uIEV4cHJlc3Npb246XCIpfTtmdW5jdGlvbiBWYihhLGIpe3RoaXMuYT1hO3RoaXMuYj1ifWZ1bmN0aW9uIFliKGEpe2Zvcih2YXIgYixjPVtdOzspe1QoYSxcIk1pc3NpbmcgcmlnaHQgaGFuZCBzaWRlIG9mIGJpbmFyeSBleHByZXNzaW9uLlwiKTtiPVpiKGEpO3ZhciBkPXooYS5hKTtpZighZClicmVhazt2YXIgZT0oZD13YltkXXx8bnVsbCkmJmQuRDtpZighZSl7YS5hLmEtLTticmVha31mb3IoO2MubGVuZ3RoJiZlPD1jW2MubGVuZ3RoLTFdLkQ7KWI9bmV3IHNiKGMucG9wKCksYy5wb3AoKSxiKTtjLnB1c2goYixkKX1mb3IoO2MubGVuZ3RoOyliPW5ldyBzYihjLnBvcCgpLGMucG9wKCksYik7cmV0dXJuIGJ9ZnVuY3Rpb24gVChhLGIpe2lmKFRhKGEuYSkpdGhyb3cgRXJyb3IoYik7fWZ1bmN0aW9uICRiKGEsYil7YT16KGEuYSk7aWYoYSE9Yil0aHJvdyBFcnJvcihcIkJhZCB0b2tlbiwgZXhwZWN0ZWQ6IFwiK2IrXCIgZ290OiBcIithKTt9XG5mdW5jdGlvbiBhYyhhKXthPXooYS5hKTtpZihcIilcIiE9YSl0aHJvdyBFcnJvcihcIkJhZCB0b2tlbjogXCIrYSk7fWZ1bmN0aW9uIGJjKGEpe2E9eihhLmEpO2lmKDI+YS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJVbmNsb3NlZCBsaXRlcmFsIHN0cmluZ1wiKTtyZXR1cm4gbmV3IERiKGEpfVxuZnVuY3Rpb24gY2MoYSl7dmFyIGI9W107aWYoSmIoeShhLmEpKSl7dmFyIGM9eihhLmEpO3ZhciBkPXkoYS5hKTtpZihcIi9cIj09YyYmKFRhKGEuYSl8fFwiLlwiIT1kJiZcIi4uXCIhPWQmJlwiQFwiIT1kJiZcIipcIiE9ZCYmIS8oPyFbMC05XSlbXFx3XS8udGVzdChkKSkpcmV0dXJuIG5ldyBIYjtkPW5ldyBIYjtUKGEsXCJNaXNzaW5nIG5leHQgbG9jYXRpb24gc3RlcC5cIik7Yz1kYyhhLGMpO2IucHVzaChjKX1lbHNle2E6e2M9eShhLmEpO2Q9Yy5jaGFyQXQoMCk7c3dpdGNoKGQpe2Nhc2UgXCIkXCI6dGhyb3cgRXJyb3IoXCJWYXJpYWJsZSByZWZlcmVuY2Ugbm90IGFsbG93ZWQgaW4gSFRNTCBYUGF0aFwiKTtjYXNlIFwiKFwiOnooYS5hKTtjPVliKGEpO1QoYSwndW5jbG9zZWQgXCIoXCInKTskYihhLFwiKVwiKTticmVhaztjYXNlICdcIic6Y2FzZSBcIidcIjpjPWJjKGEpO2JyZWFrO2RlZmF1bHQ6aWYoaXNOYU4oK2MpKWlmKCFDYihjKSYmLyg/IVswLTldKVtcXHddLy50ZXN0KGQpJiZcIihcIj09eShhLmEsMSkpe2M9eihhLmEpO1xuYz1CYltjXXx8bnVsbDt6KGEuYSk7Zm9yKGQ9W107XCIpXCIhPXkoYS5hKTspe1QoYSxcIk1pc3NpbmcgZnVuY3Rpb24gYXJndW1lbnQgbGlzdC5cIik7ZC5wdXNoKFliKGEpKTtpZihcIixcIiE9eShhLmEpKWJyZWFrO3ooYS5hKX1UKGEsXCJVbmNsb3NlZCBmdW5jdGlvbiBhcmd1bWVudCBsaXN0LlwiKTthYyhhKTtjPW5ldyB6YihjLGQpfWVsc2V7Yz1udWxsO2JyZWFrIGF9ZWxzZSBjPW5ldyBFYigreihhLmEpKX1cIltcIj09eShhLmEpJiYoZD1uZXcgTWIoZWMoYSkpLGM9bmV3IHhiKGMsZCkpfWlmKGMpaWYoSmIoeShhLmEpKSlkPWM7ZWxzZSByZXR1cm4gYztlbHNlIGM9ZGMoYSxcIi9cIiksZD1uZXcgSWIsYi5wdXNoKGMpfWZvcig7SmIoeShhLmEpKTspYz16KGEuYSksVChhLFwiTWlzc2luZyBuZXh0IGxvY2F0aW9uIHN0ZXAuXCIpLGM9ZGMoYSxjKSxiLnB1c2goYyk7cmV0dXJuIG5ldyBGYihkLGIpfVxuZnVuY3Rpb24gZGMoYSxiKXtpZihcIi9cIiE9YiYmXCIvL1wiIT1iKXRocm93IEVycm9yKCdTdGVwIG9wIHNob3VsZCBiZSBcIi9cIiBvciBcIi8vXCInKTtpZihcIi5cIj09eShhLmEpKXt2YXIgYz1uZXcgUihTYixuZXcgRyhcIm5vZGVcIikpO3ooYS5hKTtyZXR1cm4gY31pZihcIi4uXCI9PXkoYS5hKSlyZXR1cm4gYz1uZXcgUihSYixuZXcgRyhcIm5vZGVcIikpLHooYS5hKSxjO2lmKFwiQFwiPT15KGEuYSkpe3ZhciBkPUdiO3ooYS5hKTtUKGEsXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lXCIpfWVsc2UgaWYoXCI6OlwiPT15KGEuYSwxKSl7aWYoIS8oPyFbMC05XSlbXFx3XS8udGVzdCh5KGEuYSkuY2hhckF0KDApKSl0aHJvdyBFcnJvcihcIkJhZCB0b2tlbjogXCIreihhLmEpKTt2YXIgZT16KGEuYSk7ZD1RYltlXXx8bnVsbDtpZighZCl0aHJvdyBFcnJvcihcIk5vIGF4aXMgd2l0aCBuYW1lOiBcIitlKTt6KGEuYSk7VChhLFwiTWlzc2luZyBub2RlIG5hbWVcIil9ZWxzZSBkPU5iO2U9eShhLmEpO2lmKC8oPyFbMC05XSlbXFx3XFwqXS8udGVzdChlLmNoYXJBdCgwKSkpaWYoXCIoXCI9PVxueShhLmEsMSkpe2lmKCFDYihlKSl0aHJvdyBFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIitlKTtlPXooYS5hKTtpZighQ2IoZSkpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHR5cGUgbmFtZTogXCIrZSk7JGIoYSxcIihcIik7VChhLFwiQmFkIG5vZGV0eXBlXCIpO3ZhciBmPXkoYS5hKS5jaGFyQXQoMCksZz1udWxsO2lmKCdcIic9PWZ8fFwiJ1wiPT1mKWc9YmMoYSk7VChhLFwiQmFkIG5vZGV0eXBlXCIpO2FjKGEpO2U9bmV3IEcoZSxnKX1lbHNlIGlmKGU9eihhLmEpLGY9ZS5pbmRleE9mKFwiOlwiKSwtMT09ZillPW5ldyBGKGUpO2Vsc2V7Zz1lLnN1YnN0cmluZygwLGYpO2lmKFwiKlwiPT1nKXZhciBoPVwiKlwiO2Vsc2UgaWYoaD1hLmIoZyksIWgpdGhyb3cgRXJyb3IoXCJOYW1lc3BhY2UgcHJlZml4IG5vdCBkZWNsYXJlZDogXCIrZyk7ZT1lLnN1YnN0cihmKzEpO2U9bmV3IEYoZSxoKX1lbHNlIHRocm93IEVycm9yKFwiQmFkIHRva2VuOiBcIit6KGEuYSkpO2E9bmV3IE1iKGVjKGEpLGQucyk7cmV0dXJuIGN8fG5ldyBSKGQsXG5lLGEsXCIvL1wiPT1iKX1mdW5jdGlvbiBlYyhhKXtmb3IodmFyIGI9W107XCJbXCI9PXkoYS5hKTspe3ooYS5hKTtUKGEsXCJNaXNzaW5nIHByZWRpY2F0ZSBleHByZXNzaW9uLlwiKTt2YXIgYz1ZYihhKTtiLnB1c2goYyk7VChhLFwiVW5jbG9zZWQgcHJlZGljYXRlIGV4cHJlc3Npb24uXCIpOyRiKGEsXCJdXCIpfXJldHVybiBifWZ1bmN0aW9uIFpiKGEpe2lmKFwiLVwiPT15KGEuYSkpcmV0dXJuIHooYS5hKSxuZXcgVGIoWmIoYSkpO3ZhciBiPWNjKGEpO2lmKFwifFwiIT15KGEuYSkpYT1iO2Vsc2V7Zm9yKGI9W2JdO1wifFwiPT16KGEuYSk7KVQoYSxcIk1pc3NpbmcgbmV4dCB1bmlvbiBsb2NhdGlvbiBwYXRoLlwiKSxiLnB1c2goY2MoYSkpO2EuYS5hLS07YT1uZXcgVWIoYil9cmV0dXJuIGF9O2Z1bmN0aW9uIGZjKGEpe3N3aXRjaChhLm5vZGVUeXBlKXtjYXNlIDE6cmV0dXJuIGhhKGdjLGEpO2Nhc2UgOTpyZXR1cm4gZmMoYS5kb2N1bWVudEVsZW1lbnQpO2Nhc2UgMTE6Y2FzZSAxMDpjYXNlIDY6Y2FzZSAxMjpyZXR1cm4gaGM7ZGVmYXVsdDpyZXR1cm4gYS5wYXJlbnROb2RlP2ZjKGEucGFyZW50Tm9kZSk6aGN9fWZ1bmN0aW9uIGhjKCl7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZ2MoYSxiKXtpZihhLnByZWZpeD09YilyZXR1cm4gYS5uYW1lc3BhY2VVUkl8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO3ZhciBjPWEuZ2V0QXR0cmlidXRlTm9kZShcInhtbG5zOlwiK2IpO3JldHVybiBjJiZjLnNwZWNpZmllZD9jLnZhbHVlfHxudWxsOmEucGFyZW50Tm9kZSYmOSE9YS5wYXJlbnROb2RlLm5vZGVUeXBlP2djKGEucGFyZW50Tm9kZSxiKTpudWxsfTtmdW5jdGlvbiBpYyhhLGIpe2lmKCFhLmxlbmd0aCl0aHJvdyBFcnJvcihcIkVtcHR5IFhQYXRoIGV4cHJlc3Npb24uXCIpO2E9UWEoYSk7aWYoVGEoYSkpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFhQYXRoIGV4cHJlc3Npb24uXCIpO2I/XCJmdW5jdGlvblwiPT1jYShiKXx8KGI9ZmEoYi5sb29rdXBOYW1lc3BhY2VVUkksYikpOmI9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07dmFyIGM9WWIobmV3IFZiKGEsYikpO2lmKCFUYShhKSl0aHJvdyBFcnJvcihcIkJhZCB0b2tlbjogXCIreihhKSk7dGhpcy5ldmFsdWF0ZT1mdW5jdGlvbihkLGUpe2Q9Yy5hKG5ldyBpYShkKSk7cmV0dXJuIG5ldyBVKGQsZSl9fVxuZnVuY3Rpb24gVShhLGIpe2lmKDA9PWIpaWYoYSBpbnN0YW5jZW9mIEUpYj00O2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGEpYj0yO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGEpYj0xO2Vsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBhKWI9MztlbHNlIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCBldmFsdWF0aW9uIHJlc3VsdC5cIik7aWYoMiE9YiYmMSE9YiYmMyE9YiYmIShhIGluc3RhbmNlb2YgRSkpdGhyb3cgRXJyb3IoXCJ2YWx1ZSBjb3VsZCBub3QgYmUgY29udmVydGVkIHRvIHRoZSBzcGVjaWZpZWQgdHlwZVwiKTt0aGlzLnJlc3VsdFR5cGU9Yjtzd2l0Y2goYil7Y2FzZSAyOnRoaXMuc3RyaW5nVmFsdWU9YSBpbnN0YW5jZW9mIEU/bmIoYSk6XCJcIithO2JyZWFrO2Nhc2UgMTp0aGlzLm51bWJlclZhbHVlPWEgaW5zdGFuY2VvZiBFPytuYihhKTorYTticmVhaztjYXNlIDM6dGhpcy5ib29sZWFuVmFsdWU9YSBpbnN0YW5jZW9mIEU/MDxhLmw6ISFhO2JyZWFrO2Nhc2UgNDpjYXNlIDU6Y2FzZSA2OmNhc2UgNzp2YXIgYz1cbkgoYSk7dmFyIGQ9W107Zm9yKHZhciBlPUkoYyk7ZTtlPUkoYykpZC5wdXNoKGUgaW5zdGFuY2VvZiBOYT9lLmE6ZSk7dGhpcy5zbmFwc2hvdExlbmd0aD1hLmw7dGhpcy5pbnZhbGlkSXRlcmF0b3JTdGF0ZT0hMTticmVhaztjYXNlIDg6Y2FzZSA5OmE9bWIoYSk7dGhpcy5zaW5nbGVOb2RlVmFsdWU9YSBpbnN0YW5jZW9mIE5hP2EuYTphO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbmtub3duIFhQYXRoUmVzdWx0IHR5cGUuXCIpO312YXIgZj0wO3RoaXMuaXRlcmF0ZU5leHQ9ZnVuY3Rpb24oKXtpZig0IT1iJiY1IT1iKXRocm93IEVycm9yKFwiaXRlcmF0ZU5leHQgY2FsbGVkIHdpdGggd3JvbmcgcmVzdWx0IHR5cGVcIik7cmV0dXJuIGY+PWQubGVuZ3RoP251bGw6ZFtmKytdfTt0aGlzLnNuYXBzaG90SXRlbT1mdW5jdGlvbihnKXtpZig2IT1iJiY3IT1iKXRocm93IEVycm9yKFwic25hcHNob3RJdGVtIGNhbGxlZCB3aXRoIHdyb25nIHJlc3VsdCB0eXBlXCIpO3JldHVybiBnPj1kLmxlbmd0aHx8XG4wPmc/bnVsbDpkW2ddfX1VLkFOWV9UWVBFPTA7VS5OVU1CRVJfVFlQRT0xO1UuU1RSSU5HX1RZUEU9MjtVLkJPT0xFQU5fVFlQRT0zO1UuVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRT00O1UuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEU9NTtVLlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU9NjtVLk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFPTc7VS5BTllfVU5PUkRFUkVEX05PREVfVFlQRT04O1UuRklSU1RfT1JERVJFRF9OT0RFX1RZUEU9OTtmdW5jdGlvbiBqYyhhKXt0aGlzLmxvb2t1cE5hbWVzcGFjZVVSST1mYyhhKX1cbmZ1bmN0aW9uIGtjKGEsYil7YT1hfHxrO3ZhciBjPWEuRG9jdW1lbnQmJmEuRG9jdW1lbnQucHJvdG90eXBlfHxhLmRvY3VtZW50O2lmKCFjLmV2YWx1YXRlfHxiKWEuWFBhdGhSZXN1bHQ9VSxjLmV2YWx1YXRlPWZ1bmN0aW9uKGQsZSxmLGcpe3JldHVybihuZXcgaWMoZCxmKSkuZXZhbHVhdGUoZSxnKX0sYy5jcmVhdGVFeHByZXNzaW9uPWZ1bmN0aW9uKGQsZSl7cmV0dXJuIG5ldyBpYyhkLGUpfSxjLmNyZWF0ZU5TUmVzb2x2ZXI9ZnVuY3Rpb24oZCl7cmV0dXJuIG5ldyBqYyhkKX19YmEoXCJ3Z3hwYXRoLmluc3RhbGxcIixrYyk7YmEoXCJ3Z3hwYXRoLmluc3RhbGxcIixrYyk7dmFyIGxjPXthbGljZWJsdWU6XCIjZjBmOGZmXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLGFxdWE6XCIjMDBmZmZmXCIsYXF1YW1hcmluZTpcIiM3ZmZmZDRcIixhenVyZTpcIiNmMGZmZmZcIixiZWlnZTpcIiNmNWY1ZGNcIixiaXNxdWU6XCIjZmZlNGM0XCIsYmxhY2s6XCIjMDAwMDAwXCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsYmx1ZTpcIiMwMDAwZmZcIixibHVldmlvbGV0OlwiIzhhMmJlMlwiLGJyb3duOlwiI2E1MmEyYVwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixjYWRldGJsdWU6XCIjNWY5ZWEwXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixjaG9jb2xhdGU6XCIjZDI2OTFlXCIsY29yYWw6XCIjZmY3ZjUwXCIsY29ybmZsb3dlcmJsdWU6XCIjNjQ5NWVkXCIsY29ybnNpbGs6XCIjZmZmOGRjXCIsY3JpbXNvbjpcIiNkYzE0M2NcIixjeWFuOlwiIzAwZmZmZlwiLGRhcmtibHVlOlwiIzAwMDA4YlwiLGRhcmtjeWFuOlwiIzAwOGI4YlwiLGRhcmtnb2xkZW5yb2Q6XCIjYjg4NjBiXCIsZGFya2dyYXk6XCIjYTlhOWE5XCIsZGFya2dyZWVuOlwiIzAwNjQwMFwiLFxuZGFya2dyZXk6XCIjYTlhOWE5XCIsZGFya2toYWtpOlwiI2JkYjc2YlwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGRhcmtvcmFuZ2U6XCIjZmY4YzAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrcmVkOlwiIzhiMDAwMFwiLGRhcmtzYWxtb246XCIjZTk5NjdhXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZGFya3NsYXRlZ3JheTpcIiMyZjRmNGZcIixkYXJrc2xhdGVncmV5OlwiIzJmNGY0ZlwiLGRhcmt0dXJxdW9pc2U6XCIjMDBjZWQxXCIsZGFya3Zpb2xldDpcIiM5NDAwZDNcIixkZWVwcGluazpcIiNmZjE0OTNcIixkZWVwc2t5Ymx1ZTpcIiMwMGJmZmZcIixkaW1ncmF5OlwiIzY5Njk2OVwiLGRpbWdyZXk6XCIjNjk2OTY5XCIsZG9kZ2VyYmx1ZTpcIiMxZTkwZmZcIixmaXJlYnJpY2s6XCIjYjIyMjIyXCIsZmxvcmFsd2hpdGU6XCIjZmZmYWYwXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsZnVjaHNpYTpcIiNmZjAwZmZcIixnYWluc2Jvcm86XCIjZGNkY2RjXCIsXG5naG9zdHdoaXRlOlwiI2Y4ZjhmZlwiLGdvbGQ6XCIjZmZkNzAwXCIsZ29sZGVucm9kOlwiI2RhYTUyMFwiLGdyYXk6XCIjODA4MDgwXCIsZ3JlZW46XCIjMDA4MDAwXCIsZ3JlZW55ZWxsb3c6XCIjYWRmZjJmXCIsZ3JleTpcIiM4MDgwODBcIixob25leWRldzpcIiNmMGZmZjBcIixob3RwaW5rOlwiI2ZmNjliNFwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsaXZvcnk6XCIjZmZmZmYwXCIsa2hha2k6XCIjZjBlNjhjXCIsbGF2ZW5kZXI6XCIjZTZlNmZhXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixsYXduZ3JlZW46XCIjN2NmYzAwXCIsbGVtb25jaGlmZm9uOlwiI2ZmZmFjZFwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGxpZ2h0Y3lhbjpcIiNlMGZmZmZcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixsaWdodGdyYXk6XCIjZDNkM2QzXCIsbGlnaHRncmVlbjpcIiM5MGVlOTBcIixsaWdodGdyZXk6XCIjZDNkM2QzXCIsbGlnaHRwaW5rOlwiI2ZmYjZjMVwiLGxpZ2h0c2FsbW9uOlwiI2ZmYTA3YVwiLFxubGlnaHRzZWFncmVlbjpcIiMyMGIyYWFcIixsaWdodHNreWJsdWU6XCIjODdjZWZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbGlnaHR5ZWxsb3c6XCIjZmZmZmUwXCIsbGltZTpcIiMwMGZmMDBcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbGluZW46XCIjZmFmMGU2XCIsbWFnZW50YTpcIiNmZjAwZmZcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixtZWRpdW1ibHVlOlwiIzAwMDBjZFwiLG1lZGl1bW9yY2hpZDpcIiNiYTU1ZDNcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGRiXCIsbWVkaXVtc2VhZ3JlZW46XCIjM2NiMzcxXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLG1lZGl1bXNwcmluZ2dyZWVuOlwiIzAwZmE5YVwiLG1lZGl1bXR1cnF1b2lzZTpcIiM0OGQxY2NcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIsbWlkbmlnaHRibHVlOlwiIzE5MTk3MFwiLG1pbnRjcmVhbTpcIiNmNWZmZmFcIixtaXN0eXJvc2U6XCIjZmZlNGUxXCIsXG5tb2NjYXNpbjpcIiNmZmU0YjVcIixuYXZham93aGl0ZTpcIiNmZmRlYWRcIixuYXZ5OlwiIzAwMDA4MFwiLG9sZGxhY2U6XCIjZmRmNWU2XCIsb2xpdmU6XCIjODA4MDAwXCIsb2xpdmVkcmFiOlwiIzZiOGUyM1wiLG9yYW5nZTpcIiNmZmE1MDBcIixvcmFuZ2VyZWQ6XCIjZmY0NTAwXCIsb3JjaGlkOlwiI2RhNzBkNlwiLHBhbGVnb2xkZW5yb2Q6XCIjZWVlOGFhXCIscGFsZWdyZWVuOlwiIzk4ZmI5OFwiLHBhbGV0dXJxdW9pc2U6XCIjYWZlZWVlXCIscGFsZXZpb2xldHJlZDpcIiNkYjcwOTNcIixwYXBheWF3aGlwOlwiI2ZmZWZkNVwiLHBlYWNocHVmZjpcIiNmZmRhYjlcIixwZXJ1OlwiI2NkODUzZlwiLHBpbms6XCIjZmZjMGNiXCIscGx1bTpcIiNkZGEwZGRcIixwb3dkZXJibHVlOlwiI2IwZTBlNlwiLHB1cnBsZTpcIiM4MDAwODBcIixyZWQ6XCIjZmYwMDAwXCIscm9zeWJyb3duOlwiI2JjOGY4ZlwiLHJveWFsYmx1ZTpcIiM0MTY5ZTFcIixzYWRkbGVicm93bjpcIiM4YjQ1MTNcIixzYWxtb246XCIjZmE4MDcyXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixzZWFncmVlbjpcIiMyZThiNTdcIixcbnNlYXNoZWxsOlwiI2ZmZjVlZVwiLHNpZW5uYTpcIiNhMDUyMmRcIixzaWx2ZXI6XCIjYzBjMGMwXCIsc2t5Ymx1ZTpcIiM4N2NlZWJcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixzbm93OlwiI2ZmZmFmYVwiLHNwcmluZ2dyZWVuOlwiIzAwZmY3ZlwiLHN0ZWVsYmx1ZTpcIiM0NjgyYjRcIix0YW46XCIjZDJiNDhjXCIsdGVhbDpcIiMwMDgwODBcIix0aGlzdGxlOlwiI2Q4YmZkOFwiLHRvbWF0bzpcIiNmZjYzNDdcIix0dXJxdW9pc2U6XCIjNDBlMGQwXCIsdmlvbGV0OlwiI2VlODJlZVwiLHdoZWF0OlwiI2Y1ZGViM1wiLHdoaXRlOlwiI2ZmZmZmZlwiLHdoaXRlc21va2U6XCIjZjVmNWY1XCIseWVsbG93OlwiI2ZmZmYwMFwiLHllbGxvd2dyZWVuOlwiIzlhY2QzMlwifTt2YXIgbWM9XCJiYWNrZ3JvdW5kQ29sb3IgYm9yZGVyVG9wQ29sb3IgYm9yZGVyUmlnaHRDb2xvciBib3JkZXJCb3R0b21Db2xvciBib3JkZXJMZWZ0Q29sb3IgY29sb3Igb3V0bGluZUNvbG9yXCIuc3BsaXQoXCIgXCIpLG5jPS8jKFswLTlhLWZBLUZdKShbMC05YS1mQS1GXSkoWzAtOWEtZkEtRl0pLyxvYz0vXiMoPzpbMC05YS1mXXszfSl7MSwyfSQvaSxwYz0vXig/OnJnYmEpP1xcKChcXGR7MSwzfSksXFxzPyhcXGR7MSwzfSksXFxzPyhcXGR7MSwzfSksXFxzPygwfDF8MFxcLlxcZCopXFwpJC9pLHFjPS9eKD86cmdiKT9cXCgoMHxbMS05XVxcZHswLDJ9KSxcXHM/KDB8WzEtOV1cXGR7MCwyfSksXFxzPygwfFsxLTldXFxkezAsMn0pXFwpJC9pO2Z1bmN0aW9uIHJjKGEsYil7dGhpcy5jb2RlPWE7dGhpcy5hPVZbYV18fHNjO3RoaXMubWVzc2FnZT1ifHxcIlwiO2E9dGhpcy5hLnJlcGxhY2UoLygoPzpefFxccyspW2Etel0pL2csZnVuY3Rpb24oYyl7cmV0dXJuIGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9eW1xcc1xceGEwXSsvZyxcIlwiKX0pO2I9YS5sZW5ndGgtNTtpZigwPmJ8fGEuaW5kZXhPZihcIkVycm9yXCIsYikhPWIpYSs9XCJFcnJvclwiO3RoaXMubmFtZT1hO2E9RXJyb3IodGhpcy5tZXNzYWdlKTthLm5hbWU9dGhpcy5uYW1lO3RoaXMuc3RhY2s9YS5zdGFja3x8XCJcIn1sKHJjLEVycm9yKTt2YXIgc2M9XCJ1bmtub3duIGVycm9yXCIsVj17MTU6XCJlbGVtZW50IG5vdCBzZWxlY3RhYmxlXCIsMTE6XCJlbGVtZW50IG5vdCB2aXNpYmxlXCJ9O1ZbMzFdPXNjO1ZbMzBdPXNjO1ZbMjRdPVwiaW52YWxpZCBjb29raWUgZG9tYWluXCI7VlsyOV09XCJpbnZhbGlkIGVsZW1lbnQgY29vcmRpbmF0ZXNcIjtWWzEyXT1cImludmFsaWQgZWxlbWVudCBzdGF0ZVwiO1xuVlszMl09XCJpbnZhbGlkIHNlbGVjdG9yXCI7Vls1MV09XCJpbnZhbGlkIHNlbGVjdG9yXCI7Vls1Ml09XCJpbnZhbGlkIHNlbGVjdG9yXCI7VlsxN109XCJqYXZhc2NyaXB0IGVycm9yXCI7Vls0MDVdPVwidW5zdXBwb3J0ZWQgb3BlcmF0aW9uXCI7VlszNF09XCJtb3ZlIHRhcmdldCBvdXQgb2YgYm91bmRzXCI7VlsyN109XCJubyBzdWNoIGFsZXJ0XCI7Vls3XT1cIm5vIHN1Y2ggZWxlbWVudFwiO1ZbOF09XCJubyBzdWNoIGZyYW1lXCI7VlsyM109XCJubyBzdWNoIHdpbmRvd1wiO1ZbMjhdPVwic2NyaXB0IHRpbWVvdXRcIjtWWzMzXT1cInNlc3Npb24gbm90IGNyZWF0ZWRcIjtWWzEwXT1cInN0YWxlIGVsZW1lbnQgcmVmZXJlbmNlXCI7VlsyMV09XCJ0aW1lb3V0XCI7VlsyNV09XCJ1bmFibGUgdG8gc2V0IGNvb2tpZVwiO1ZbMjZdPVwidW5leHBlY3RlZCBhbGVydCBvcGVuXCI7VlsxM109c2M7Vls5XT1cInVua25vd24gY29tbWFuZFwiO3ZhciB0Yz12YSgpLHVjPXlhKCl8fHUoXCJpUG9kXCIpLHZjPXUoXCJpUGFkXCIpLHdjPXUoXCJBbmRyb2lkXCIpJiYhKHdhKCl8fHZhKCl8fHUoXCJPcGVyYVwiKXx8dShcIlNpbGtcIikpLHhjPXdhKCkseWM9dShcIlNhZmFyaVwiKSYmISh3YSgpfHx1KFwiQ29hc3RcIil8fHUoXCJPcGVyYVwiKXx8dShcIkVkZ2VcIil8fHUoXCJFZGcvXCIpfHx1KFwiT1BSXCIpfHx2YSgpfHx1KFwiU2lsa1wiKXx8dShcIkFuZHJvaWRcIikpJiYhKHlhKCl8fHUoXCJpUGFkXCIpfHx1KFwiaVBvZFwiKSk7ZnVuY3Rpb24gemMoYSl7cmV0dXJuKGE9YS5leGVjKHQpKT9hWzFdOlwiXCJ9KGZ1bmN0aW9uKCl7aWYodGMpcmV0dXJuIHpjKC9GaXJlZm94XFwvKFswLTkuXSspLyk7aWYodnx8Q2F8fEJhKXJldHVybiBHYTtpZih4YylyZXR1cm4geWEoKXx8dShcImlQYWRcIil8fHUoXCJpUG9kXCIpP3pjKC9DcmlPU1xcLyhbMC05Ll0rKS8pOnpjKC9DaHJvbWVcXC8oWzAtOS5dKykvKTtpZih5YyYmISh5YSgpfHx1KFwiaVBhZFwiKXx8dShcImlQb2RcIikpKXJldHVybiB6YygvVmVyc2lvblxcLyhbMC05Ll0rKS8pO2lmKHVjfHx2Yyl7dmFyIGE9L1ZlcnNpb25cXC8oXFxTKykuKk1vYmlsZVxcLyhcXFMrKS8uZXhlYyh0KTtpZihhKXJldHVybiBhWzFdK1wiLlwiK2FbMl19ZWxzZSBpZih3YylyZXR1cm4oYT16YygvQW5kcm9pZFxccysoWzAtOS5dKykvKSk/YTp6YygvVmVyc2lvblxcLyhbMC05Ll0rKS8pO3JldHVyblwiXCJ9KSgpO3ZhciBBYz12JiYhKDk8PU51bWJlcihMYSkpO2Z1bmN0aW9uIFcoYSxiKXtiJiZcInN0cmluZ1wiIT09dHlwZW9mIGImJihiPWIudG9TdHJpbmcoKSk7cmV0dXJuISFhJiYxPT1hLm5vZGVUeXBlJiYoIWJ8fGEudGFnTmFtZS50b1VwcGVyQ2FzZSgpPT1iKX07dmFyIEJjPWZ1bmN0aW9uKCl7dmFyIGE9e0s6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGFbYl18fG51bGx9fSgpO1xuZnVuY3Rpb24gQ2MoYSxiKXt2YXIgYz1BKGEpO2lmKCFjLmRvY3VtZW50RWxlbWVudClyZXR1cm4gbnVsbDsodnx8d2MpJiZrYyhjP2MucGFyZW50V2luZG93fHxjLmRlZmF1bHRWaWV3OndpbmRvdyk7dHJ5e3ZhciBkPWMuY3JlYXRlTlNSZXNvbHZlcj9jLmNyZWF0ZU5TUmVzb2x2ZXIoYy5kb2N1bWVudEVsZW1lbnQpOkJjO2lmKHYmJiFLYSg3KSlyZXR1cm4gYy5ldmFsdWF0ZS5jYWxsKGMsYixhLGQsOSxudWxsKTtpZighdnx8OTw9TnVtYmVyKExhKSl7Zm9yKHZhciBlPXt9LGY9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIiksZz0wO2c8Zi5sZW5ndGg7KytnKXt2YXIgaD1mW2ddLG09aC5uYW1lc3BhY2VVUkk7aWYobSYmIWVbbV0pe3ZhciB3PWgubG9va3VwUHJlZml4KG0pO2lmKCF3KXt2YXIgcj1tLm1hdGNoKFwiLiovKFxcXFx3KykvPyRcIik7dz1yP3JbMV06XCJ4aHRtbFwifWVbbV09d319dmFyIEQ9e30sTDtmb3IoTCBpbiBlKURbZVtMXV09TDtkPWZ1bmN0aW9uKE0pe3JldHVybiBEW01dfHxcbm51bGx9fXRyeXtyZXR1cm4gYy5ldmFsdWF0ZShiLGEsZCw5LG51bGwpfWNhdGNoKE0pe2lmKFwiVHlwZUVycm9yXCI9PT1NLm5hbWUpcmV0dXJuIGQ9Yy5jcmVhdGVOU1Jlc29sdmVyP2MuY3JlYXRlTlNSZXNvbHZlcihjLmRvY3VtZW50RWxlbWVudCk6QmMsYy5ldmFsdWF0ZShiLGEsZCw5LG51bGwpO3Rocm93IE07fX1jYXRjaChNKXtpZighRGF8fFwiTlNfRVJST1JfSUxMRUdBTF9WQUxVRVwiIT1NLm5hbWUpdGhyb3cgbmV3IHJjKDMyLFwiVW5hYmxlIHRvIGxvY2F0ZSBhbiBlbGVtZW50IHdpdGggdGhlIHhwYXRoIGV4cHJlc3Npb24gXCIrYitcIiBiZWNhdXNlIG9mIHRoZSBmb2xsb3dpbmcgZXJyb3I6XFxuXCIrTSk7fX1cbmZ1bmN0aW9uIERjKGEsYil7dmFyIGM9ZnVuY3Rpb24oKXt2YXIgZD1DYyhiLGEpO3JldHVybiBkP2Quc2luZ2xlTm9kZVZhbHVlfHxudWxsOmIuc2VsZWN0U2luZ2xlTm9kZT8oZD1BKGIpLGQuc2V0UHJvcGVydHkmJmQuc2V0UHJvcGVydHkoXCJTZWxlY3Rpb25MYW5ndWFnZVwiLFwiWFBhdGhcIiksYi5zZWxlY3RTaW5nbGVOb2RlKGEpKTpudWxsfSgpO2lmKG51bGwhPT1jJiYoIWN8fDEhPWMubm9kZVR5cGUpKXRocm93IG5ldyByYygzMiwnVGhlIHJlc3VsdCBvZiB0aGUgeHBhdGggZXhwcmVzc2lvbiBcIicrYSsnXCIgaXM6ICcrYytcIi4gSXQgc2hvdWxkIGJlIGFuIGVsZW1lbnQuXCIpO3JldHVybiBjfTtmdW5jdGlvbiBFYyhhLGIsYyxkKXt0aGlzLmM9YTt0aGlzLmE9Yjt0aGlzLmI9Yzt0aGlzLmY9ZH1FYy5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3RoaXMuYz1NYXRoLmNlaWwodGhpcy5jKTt0aGlzLmE9TWF0aC5jZWlsKHRoaXMuYSk7dGhpcy5iPU1hdGguY2VpbCh0aGlzLmIpO3RoaXMuZj1NYXRoLmNlaWwodGhpcy5mKTtyZXR1cm4gdGhpc307RWMucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7dGhpcy5jPU1hdGguZmxvb3IodGhpcy5jKTt0aGlzLmE9TWF0aC5mbG9vcih0aGlzLmEpO3RoaXMuYj1NYXRoLmZsb29yKHRoaXMuYik7dGhpcy5mPU1hdGguZmxvb3IodGhpcy5mKTtyZXR1cm4gdGhpc307RWMucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKCl7dGhpcy5jPU1hdGgucm91bmQodGhpcy5jKTt0aGlzLmE9TWF0aC5yb3VuZCh0aGlzLmEpO3RoaXMuYj1NYXRoLnJvdW5kKHRoaXMuYik7dGhpcy5mPU1hdGgucm91bmQodGhpcy5mKTtyZXR1cm4gdGhpc307ZnVuY3Rpb24gWChhLGIsYyxkKXt0aGlzLmE9YTt0aGlzLmI9Yjt0aGlzLndpZHRoPWM7dGhpcy5oZWlnaHQ9ZH1YLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKCl7dGhpcy5hPU1hdGguY2VpbCh0aGlzLmEpO3RoaXMuYj1NYXRoLmNlaWwodGhpcy5iKTt0aGlzLndpZHRoPU1hdGguY2VpbCh0aGlzLndpZHRoKTt0aGlzLmhlaWdodD1NYXRoLmNlaWwodGhpcy5oZWlnaHQpO3JldHVybiB0aGlzfTtYLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3RoaXMuYT1NYXRoLmZsb29yKHRoaXMuYSk7dGhpcy5iPU1hdGguZmxvb3IodGhpcy5iKTt0aGlzLndpZHRoPU1hdGguZmxvb3IodGhpcy53aWR0aCk7dGhpcy5oZWlnaHQ9TWF0aC5mbG9vcih0aGlzLmhlaWdodCk7cmV0dXJuIHRoaXN9O1xuWC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXt0aGlzLmE9TWF0aC5yb3VuZCh0aGlzLmEpO3RoaXMuYj1NYXRoLnJvdW5kKHRoaXMuYik7dGhpcy53aWR0aD1NYXRoLnJvdW5kKHRoaXMud2lkdGgpO3RoaXMuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5oZWlnaHQpO3JldHVybiB0aGlzfTt2YXIgRmM9XCJmdW5jdGlvblwiPT09dHlwZW9mIFNoYWRvd1Jvb3Q7ZnVuY3Rpb24gR2MoYSl7Zm9yKGE9YS5wYXJlbnROb2RlO2EmJjEhPWEubm9kZVR5cGUmJjkhPWEubm9kZVR5cGUmJjExIT1hLm5vZGVUeXBlOylhPWEucGFyZW50Tm9kZTtyZXR1cm4gVyhhKT9hOm51bGx9XG5mdW5jdGlvbiBZKGEsYil7Yj14YShiKTtpZihcImZsb2F0XCI9PWJ8fFwiY3NzRmxvYXRcIj09Ynx8XCJzdHlsZUZsb2F0XCI9PWIpYj1BYz9cInN0eWxlRmxvYXRcIjpcImNzc0Zsb2F0XCI7YTp7dmFyIGM9Yjt2YXIgZD1BKGEpO2lmKGQuZGVmYXVsdFZpZXcmJmQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSYmKGQ9ZC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGEsbnVsbCkpKXtjPWRbY118fGQuZ2V0UHJvcGVydHlWYWx1ZShjKXx8XCJcIjticmVhayBhfWM9XCJcIn1hPWN8fEhjKGEsYik7aWYobnVsbD09PWEpYT1udWxsO2Vsc2UgaWYoMDw9amEobWMsYikpe2I6e3ZhciBlPWEubWF0Y2gocGMpO2lmKGUmJihiPU51bWJlcihlWzFdKSxjPU51bWJlcihlWzJdKSxkPU51bWJlcihlWzNdKSxlPU51bWJlcihlWzRdKSwwPD1iJiYyNTU+PWImJjA8PWMmJjI1NT49YyYmMDw9ZCYmMjU1Pj1kJiYwPD1lJiYxPj1lKSl7Yj1bYixjLGQsZV07YnJlYWsgYn1iPW51bGx9aWYoIWIpYjp7aWYoZD1hLm1hdGNoKHFjKSlpZihiPVxuTnVtYmVyKGRbMV0pLGM9TnVtYmVyKGRbMl0pLGQ9TnVtYmVyKGRbM10pLDA8PWImJjI1NT49YiYmMDw9YyYmMjU1Pj1jJiYwPD1kJiYyNTU+PWQpe2I9W2IsYyxkLDFdO2JyZWFrIGJ9Yj1udWxsfWlmKCFiKWI6e2I9YS50b0xvd2VyQ2FzZSgpO2M9bGNbYi50b0xvd2VyQ2FzZSgpXTtpZighYyYmKGM9XCIjXCI9PWIuY2hhckF0KDApP2I6XCIjXCIrYiw0PT1jLmxlbmd0aCYmKGM9Yy5yZXBsYWNlKG5jLFwiIyQxJDEkMiQyJDMkM1wiKSksIW9jLnRlc3QoYykpKXtiPW51bGw7YnJlYWsgYn1iPVtwYXJzZUludChjLnN1YnN0cigxLDIpLDE2KSxwYXJzZUludChjLnN1YnN0cigzLDIpLDE2KSxwYXJzZUludChjLnN1YnN0cig1LDIpLDE2KSwxXX1hPWI/XCJyZ2JhKFwiK2Iuam9pbihcIiwgXCIpK1wiKVwiOmF9cmV0dXJuIGF9XG5mdW5jdGlvbiBIYyhhLGIpe3ZhciBjPWEuY3VycmVudFN0eWxlfHxhLnN0eWxlLGQ9Y1tiXTt2b2lkIDA9PT1kJiZcImZ1bmN0aW9uXCI9PWNhKGMuZ2V0UHJvcGVydHlWYWx1ZSkmJihkPWMuZ2V0UHJvcGVydHlWYWx1ZShiKSk7cmV0dXJuXCJpbmhlcml0XCIhPWQ/dm9pZCAwIT09ZD9kOm51bGw6KGE9R2MoYSkpP0hjKGEsYik6bnVsbH1cbmZ1bmN0aW9uIEljKGEsYixjKXtmdW5jdGlvbiBkKGcpe3ZhciBoPUpjKGcpO3JldHVybiAwPGguaGVpZ2h0JiYwPGgud2lkdGg/ITA6VyhnLFwiUEFUSFwiKSYmKDA8aC5oZWlnaHR8fDA8aC53aWR0aCk/KGc9WShnLFwic3Ryb2tlLXdpZHRoXCIpLCEhZyYmMDxwYXJzZUludChnLDEwKSk6XCJoaWRkZW5cIiE9WShnLFwib3ZlcmZsb3dcIikmJm1hKGcuY2hpbGROb2RlcyxmdW5jdGlvbihtKXtyZXR1cm4gMz09bS5ub2RlVHlwZXx8VyhtKSYmZChtKX0pfWZ1bmN0aW9uIGUoZyl7cmV0dXJuIEtjKGcpPT1aJiZuYShnLmNoaWxkTm9kZXMsZnVuY3Rpb24oaCl7cmV0dXJuIVcoaCl8fGUoaCl8fCFkKGgpfSl9aWYoIVcoYSkpdGhyb3cgRXJyb3IoXCJBcmd1bWVudCB0byBpc1Nob3duIG11c3QgYmUgb2YgdHlwZSBFbGVtZW50XCIpO2lmKFcoYSxcIkJPRFlcIikpcmV0dXJuITA7aWYoVyhhLFwiT1BUSU9OXCIpfHxXKGEsXCJPUFRHUk9VUFwiKSlyZXR1cm4gYT0kYShhLGZ1bmN0aW9uKGcpe3JldHVybiBXKGcsXCJTRUxFQ1RcIil9KSxcbiEhYSYmSWMoYSwhMCxjKTt2YXIgZj1MYyhhKTtpZihmKXJldHVybiEhZi5pbWFnZSYmMDxmLnJlY3Qud2lkdGgmJjA8Zi5yZWN0LmhlaWdodCYmSWMoZi5pbWFnZSxiLGMpO2lmKFcoYSxcIklOUFVUXCIpJiZcImhpZGRlblwiPT1hLnR5cGUudG9Mb3dlckNhc2UoKXx8VyhhLFwiTk9TQ1JJUFRcIikpcmV0dXJuITE7Zj1ZKGEsXCJ2aXNpYmlsaXR5XCIpO3JldHVyblwiY29sbGFwc2VcIiE9ZiYmXCJoaWRkZW5cIiE9ZiYmYyhhKSYmKGJ8fDAhPU1jKGEpKSYmZChhKT8hZShhKTohMX12YXIgWj1cImhpZGRlblwiO1xuZnVuY3Rpb24gS2MoYSl7ZnVuY3Rpb24gYihwKXtmdW5jdGlvbiBxKGZiKXtpZihmYj09ZylyZXR1cm4hMDt2YXIgV2I9WShmYixcImRpc3BsYXlcIik7cmV0dXJuIDA9PVdiLmxhc3RJbmRleE9mKFwiaW5saW5lXCIsMCl8fFwiY29udGVudHNcIj09V2J8fFwiYWJzb2x1dGVcIj09WGImJlwic3RhdGljXCI9PVkoZmIsXCJwb3NpdGlvblwiKT8hMTohMH12YXIgWGI9WShwLFwicG9zaXRpb25cIik7aWYoXCJmaXhlZFwiPT1YYilyZXR1cm4gdz0hMCxwPT1nP251bGw6Zztmb3IocD1HYyhwKTtwJiYhcShwKTspcD1HYyhwKTtyZXR1cm4gcH1mdW5jdGlvbiBjKHApe3ZhciBxPXA7aWYoXCJ2aXNpYmxlXCI9PW0paWYocD09ZyYmaClxPWg7ZWxzZSBpZihwPT1oKXJldHVybnt4OlwidmlzaWJsZVwiLHk6XCJ2aXNpYmxlXCJ9O3E9e3g6WShxLFwib3ZlcmZsb3cteFwiKSx5OlkocSxcIm92ZXJmbG93LXlcIil9O3A9PWcmJihxLng9XCJ2aXNpYmxlXCI9PXEueD9cImF1dG9cIjpxLngscS55PVwidmlzaWJsZVwiPT1xLnk/XCJhdXRvXCI6cS55KTtyZXR1cm4gcX1cbmZ1bmN0aW9uIGQocCl7aWYocD09Zyl7dmFyIHE9KG5ldyBhYihmKSkuYTtwPXEuc2Nyb2xsaW5nRWxlbWVudD9xLnNjcm9sbGluZ0VsZW1lbnQ6RWF8fFwiQ1NTMUNvbXBhdFwiIT1xLmNvbXBhdE1vZGU/cS5ib2R5fHxxLmRvY3VtZW50RWxlbWVudDpxLmRvY3VtZW50RWxlbWVudDtxPXEucGFyZW50V2luZG93fHxxLmRlZmF1bHRWaWV3O3A9diYmS2EoXCIxMFwiKSYmcS5wYWdlWU9mZnNldCE9cC5zY3JvbGxUb3A/bmV3IFVhKHAuc2Nyb2xsTGVmdCxwLnNjcm9sbFRvcCk6bmV3IFVhKHEucGFnZVhPZmZzZXR8fHAuc2Nyb2xsTGVmdCxxLnBhZ2VZT2Zmc2V0fHxwLnNjcm9sbFRvcCl9ZWxzZSBwPW5ldyBVYShwLnNjcm9sbExlZnQscC5zY3JvbGxUb3ApO3JldHVybiBwfXZhciBlPU5jKGEpLGY9QShhKSxnPWYuZG9jdW1lbnRFbGVtZW50LGg9Zi5ib2R5LG09WShnLFwib3ZlcmZsb3dcIiksdztmb3IoYT1iKGEpO2E7YT1iKGEpKXt2YXIgcj1jKGEpO2lmKFwidmlzaWJsZVwiIT1yLnh8fFwidmlzaWJsZVwiIT1cbnIueSl7dmFyIEQ9SmMoYSk7aWYoMD09RC53aWR0aHx8MD09RC5oZWlnaHQpcmV0dXJuIFo7dmFyIEw9ZS5hPEQuYSxNPWUuYjxELmI7aWYoTCYmXCJoaWRkZW5cIj09ci54fHxNJiZcImhpZGRlblwiPT1yLnkpcmV0dXJuIFo7aWYoTCYmXCJ2aXNpYmxlXCIhPXIueHx8TSYmXCJ2aXNpYmxlXCIhPXIueSl7TD1kKGEpO009ZS5iPEQuYi1MLnk7aWYoZS5hPEQuYS1MLngmJlwidmlzaWJsZVwiIT1yLnh8fE0mJlwidmlzaWJsZVwiIT1yLngpcmV0dXJuIFo7ZT1LYyhhKTtyZXR1cm4gZT09Wj9aOlwic2Nyb2xsXCJ9TD1lLmY+PUQuYStELndpZHRoO0Q9ZS5jPj1ELmIrRC5oZWlnaHQ7aWYoTCYmXCJoaWRkZW5cIj09ci54fHxEJiZcImhpZGRlblwiPT1yLnkpcmV0dXJuIFo7aWYoTCYmXCJ2aXNpYmxlXCIhPXIueHx8RCYmXCJ2aXNpYmxlXCIhPXIueSl7aWYodyYmKHI9ZChhKSxlLmY+PWcuc2Nyb2xsV2lkdGgtci54fHxlLmE+PWcuc2Nyb2xsSGVpZ2h0LXIueSkpcmV0dXJuIFo7ZT1LYyhhKTtyZXR1cm4gZT09Wj9aOlwic2Nyb2xsXCJ9fX1yZXR1cm5cIm5vbmVcIn1cbmZ1bmN0aW9uIEpjKGEpe3ZhciBiPUxjKGEpO2lmKGIpcmV0dXJuIGIucmVjdDtpZihXKGEsXCJIVE1MXCIpKXJldHVybiBhPUEoYSksYT0oKGE/YS5wYXJlbnRXaW5kb3d8fGEuZGVmYXVsdFZpZXc6d2luZG93KXx8d2luZG93KS5kb2N1bWVudCxhPVwiQ1NTMUNvbXBhdFwiPT1hLmNvbXBhdE1vZGU/YS5kb2N1bWVudEVsZW1lbnQ6YS5ib2R5LGE9bmV3IFZhKGEuY2xpZW50V2lkdGgsYS5jbGllbnRIZWlnaHQpLG5ldyBYKDAsMCxhLndpZHRoLGEuaGVpZ2h0KTt0cnl7dmFyIGM9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKX1jYXRjaChkKXtyZXR1cm4gbmV3IFgoMCwwLDAsMCl9Yj1uZXcgWChjLmxlZnQsYy50b3AsYy5yaWdodC1jLmxlZnQsYy5ib3R0b20tYy50b3ApO3YmJmEub3duZXJEb2N1bWVudC5ib2R5JiYoYT1BKGEpLGIuYS09YS5kb2N1bWVudEVsZW1lbnQuY2xpZW50TGVmdCthLmJvZHkuY2xpZW50TGVmdCxiLmItPWEuZG9jdW1lbnRFbGVtZW50LmNsaWVudFRvcCthLmJvZHkuY2xpZW50VG9wKTtcbnJldHVybiBifWZ1bmN0aW9uIExjKGEpe3ZhciBiPVcoYSxcIk1BUFwiKTtpZighYiYmIVcoYSxcIkFSRUFcIikpcmV0dXJuIG51bGw7dmFyIGM9Yj9hOlcoYS5wYXJlbnROb2RlLFwiTUFQXCIpP2EucGFyZW50Tm9kZTpudWxsLGQ9bnVsbCxlPW51bGw7YyYmYy5uYW1lJiYoZD1EYygnL2Rlc2NlbmRhbnQ6OipbQHVzZW1hcCA9IFwiIycrYy5uYW1lKydcIl0nLEEoYykpKSYmKGU9SmMoZCksYnx8XCJkZWZhdWx0XCI9PWEuc2hhcGUudG9Mb3dlckNhc2UoKXx8KGE9T2MoYSksYj1NYXRoLm1pbihNYXRoLm1heChhLmEsMCksZS53aWR0aCksYz1NYXRoLm1pbihNYXRoLm1heChhLmIsMCksZS5oZWlnaHQpLGU9bmV3IFgoYitlLmEsYytlLmIsTWF0aC5taW4oYS53aWR0aCxlLndpZHRoLWIpLE1hdGgubWluKGEuaGVpZ2h0LGUuaGVpZ2h0LWMpKSkpO3JldHVybntpbWFnZTpkLHJlY3Q6ZXx8bmV3IFgoMCwwLDAsMCl9fVxuZnVuY3Rpb24gT2MoYSl7dmFyIGI9YS5zaGFwZS50b0xvd2VyQ2FzZSgpO2E9YS5jb29yZHMuc3BsaXQoXCIsXCIpO2lmKFwicmVjdFwiPT1iJiY0PT1hLmxlbmd0aCl7Yj1hWzBdO3ZhciBjPWFbMV07cmV0dXJuIG5ldyBYKGIsYyxhWzJdLWIsYVszXS1jKX1pZihcImNpcmNsZVwiPT1iJiYzPT1hLmxlbmd0aClyZXR1cm4gYj1hWzJdLG5ldyBYKGFbMF0tYixhWzFdLWIsMipiLDIqYik7aWYoXCJwb2x5XCI9PWImJjI8YS5sZW5ndGgpe2I9YVswXTtjPWFbMV07Zm9yKHZhciBkPWIsZT1jLGY9MjtmKzE8YS5sZW5ndGg7Zis9MiliPU1hdGgubWluKGIsYVtmXSksZD1NYXRoLm1heChkLGFbZl0pLGM9TWF0aC5taW4oYyxhW2YrMV0pLGU9TWF0aC5tYXgoZSxhW2YrMV0pO3JldHVybiBuZXcgWChiLGMsZC1iLGUtYyl9cmV0dXJuIG5ldyBYKDAsMCwwLDApfWZ1bmN0aW9uIE5jKGEpe2E9SmMoYSk7cmV0dXJuIG5ldyBFYyhhLmIsYS5hK2Eud2lkdGgsYS5iK2EuaGVpZ2h0LGEuYSl9XG5mdW5jdGlvbiBNYyhhKXtpZihBYyl7aWYoXCJyZWxhdGl2ZVwiPT1ZKGEsXCJwb3NpdGlvblwiKSlyZXR1cm4gMTthPVkoYSxcImZpbHRlclwiKTtyZXR1cm4oYT1hLm1hdGNoKC9eYWxwaGFcXChvcGFjaXR5PShcXGQqKVxcKS8pfHxhLm1hdGNoKC9ecHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhXFwoT3BhY2l0eT0oXFxkKilcXCkvKSk/TnVtYmVyKGFbMV0pLzEwMDoxfXJldHVybiBQYyhhKX1mdW5jdGlvbiBQYyhhKXt2YXIgYj0xLGM9WShhLFwib3BhY2l0eVwiKTtjJiYoYj1OdW1iZXIoYykpOyhhPUdjKGEpKSYmKGIqPVBjKGEpKTtyZXR1cm4gYn07YmEoXCJfXCIsZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGQpe2lmKFcoZCkmJlwibm9uZVwiPT1ZKGQsXCJkaXNwbGF5XCIpKXJldHVybiExO3ZhciBlO2lmKChlPWQucGFyZW50Tm9kZSkmJmUuc2hhZG93Um9vdCYmdm9pZCAwIT09ZC5hc3NpZ25lZFNsb3QpZT1kLmFzc2lnbmVkU2xvdD9kLmFzc2lnbmVkU2xvdC5wYXJlbnROb2RlOm51bGw7ZWxzZSBpZihkLmdldERlc3RpbmF0aW9uSW5zZXJ0aW9uUG9pbnRzKXt2YXIgZj1kLmdldERlc3RpbmF0aW9uSW5zZXJ0aW9uUG9pbnRzKCk7MDxmLmxlbmd0aCYmKGU9ZltmLmxlbmd0aC0xXSl9aWYoRmMmJmUgaW5zdGFuY2VvZiBTaGFkb3dSb290KXtpZihlLmhvc3Quc2hhZG93Um9vdCE9PWUpcmV0dXJuITE7ZT1lLmhvc3R9cmV0dXJuIWV8fDkhPWUubm9kZVR5cGUmJjExIT1lLm5vZGVUeXBlP2UmJlcoZSxcIkRFVEFJTFNcIikmJiFlLm9wZW4mJiFXKGQsXCJTVU1NQVJZXCIpPyExOiEhZSYmYyhlKTohMH1yZXR1cm4gSWMoYSwhIWIsYyl9KTs7IHJldHVybiB0aGlzLl8uYXBwbHkobnVsbCxhcmd1bWVudHMpO30pLmFwcGx5KHtuYXZpZ2F0b3I6dHlwZW9mIHdpbmRvdyE9J3VuZGVmaW5lZCc/d2luZG93Lm5hdmlnYXRvcjpudWxsLGRvY3VtZW50OnR5cGVvZiB3aW5kb3chPSd1bmRlZmluZWQnP3dpbmRvdy5kb2N1bWVudDpudWxsfSwgYXJndW1lbnRzKTt9O1xuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuKGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAobXV0YXRpb24udHlwZSkge1xuICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAvLyBEb24ndCByZXBvcnQgb3VyIG93biBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFwiZGF0YS1fX3dlYmRyaXZlcl9pZFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VyciA9IG11dGF0aW9uLnRhcmdldC5nZXRBdHRyaWJ1dGUobXV0YXRpb24uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgdmFyIGlkID0gbXV0YXRpb24udGFyZ2V0LmRhdGFzZXQuX193ZWJkcml2ZXJfaWRcbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKSArIERhdGUubm93KCkudG9TdHJpbmcoMzYpO1xuICAgICAgICAgICAgbXV0YXRpb24udGFyZ2V0LmRhdGFzZXQuX193ZWJkcml2ZXJfaWQgPSBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICd0YXJnZXQnOiBpZCxcbiAgICAgICAgICAgICduYW1lJzogbXV0YXRpb24uYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgICd2YWx1ZSc6IGN1cnIsXG4gICAgICAgICAgICAnb2xkVmFsdWUnOiBtdXRhdGlvbi5vbGRWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9fd2ViZHJpdmVyX2F0dHJpYnV0ZShqc29uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAnYXR0cmlidXRlcyc6IHRydWUsXG4gICAgJ2F0dHJpYnV0ZU9sZFZhbHVlJzogdHJ1ZSxcbiAgICAnY2hhcmFjdGVyRGF0YSc6IHRydWUsXG4gICAgJ2NoYXJhY3RlckRhdGFPbGRWYWx1ZSc6IHRydWUsXG4gICAgJ2NoaWxkTGlzdCc6IHRydWUsXG4gICAgJ3N1YnRyZWUnOiB0cnVlXG4gIH0pO1xufSkoKTtcbiIsInZhciBtYXAgPSB7XG5cdFwiLi9maW5kLWVsZW1lbnRzXCI6IFwiLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9maW5kLWVsZW1lbnRzLmpzXCIsXG5cdFwiLi9maW5kLWVsZW1lbnRzLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9maW5kLWVsZW1lbnRzLmpzXCIsXG5cdFwiLi9nZXQtYXR0cmlidXRlXCI6IFwiLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9nZXQtYXR0cmlidXRlLmpzXCIsXG5cdFwiLi9nZXQtYXR0cmlidXRlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9nZXQtYXR0cmlidXRlLmpzXCIsXG5cdFwiLi9pcy1kaXNwbGF5ZWRcIjogXCIuL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2F0b21zL2lzLWRpc3BsYXllZC5qc1wiLFxuXHRcIi4vaXMtZGlzcGxheWVkLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9pcy1kaXNwbGF5ZWQuanNcIixcblx0XCIuL211dGF0aW9uLWxpc3RlbmVyXCI6IFwiLi9ub2RlX21vZHVsZXMvc2VsZW5pdW0td2ViZHJpdmVyL2xpYi9hdG9tcy9tdXRhdGlvbi1saXN0ZW5lci5qc1wiLFxuXHRcIi4vbXV0YXRpb24tbGlzdGVuZXIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2F0b21zL211dGF0aW9uLWxpc3RlbmVyLmpzXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvYXRvbXMgc3luYyByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKiRcIjsiLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgbWV0aG9kcyBmb3IgdGhlIHN1cHBvcnRlZCBsb2NhdG9yIHN0cmF0ZWdpZXMuXG4gKi9cblxuLyoqXG4gKiBTaG9ydC1oYW5kIGV4cHJlc3Npb25zIGZvciB0aGUgcHJpbWFyeSBlbGVtZW50IGxvY2F0b3Igc3RyYXRlZ2llcy5cbiAqIEZvciBleGFtcGxlIHRoZSBmb2xsb3dpbmcgdHdvIHN0YXRlbWVudHMgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAgIHZhciBlMSA9IGRyaXZlci5maW5kRWxlbWVudChCeS5pZCgnZm9vJykpO1xuICogICAgIHZhciBlMiA9IGRyaXZlci5maW5kRWxlbWVudCh7aWQ6ICdmb28nfSk7XG4gKlxuICogQ2FyZSBzaG91bGQgYmUgdGFrZW4gd2hlbiB1c2luZyBKYXZhU2NyaXB0IG1pbmlmaWVycyAoc3VjaCBhcyB0aGVcbiAqIENsb3N1cmUgY29tcGlsZXIpLCBhcyBsb2NhdG9yIGhhc2hlcyB3aWxsIGFsd2F5cyBiZSBwYXJzZWQgdXNpbmdcbiAqIHRoZSB1bi1vYmZ1c2NhdGVkIHByb3BlcnRpZXMgbGlzdGVkLlxuICpcbiAqIEB0eXBlZGVmIHsoXG4gKiAgICAge2NsYXNzTmFtZTogc3RyaW5nfXxcbiAqICAgICB7Y3NzOiBzdHJpbmd9fFxuICogICAgIHtpZDogc3RyaW5nfXxcbiAqICAgICB7anM6IHN0cmluZ318XG4gKiAgICAge2xpbmtUZXh0OiBzdHJpbmd9fFxuICogICAgIHtuYW1lOiBzdHJpbmd9fFxuICogICAgIHtwYXJ0aWFsTGlua1RleHQ6IHN0cmluZ318XG4gKiAgICAge3RhZ05hbWU6IHN0cmluZ318XG4gKiAgICAge3hwYXRoOiBzdHJpbmd9KX0gQnlIYXNoXG4gKi9cblxuLyoqXG4gKiBFcnJvciB0aHJvd24gaWYgYW4gaW52YWxpZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgd2hpbGUgZXNjYXBpbmcgYSBDU1NcbiAqIGlkZW50aWZpZXIuXG4gKiBAc2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jc2VyaWFsaXplLWFuLWlkZW50aWZpZXJcbiAqL1xuY2xhc3MgSW52YWxpZENoYXJhY3RlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGVzIGEgQ1NTIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgdGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgdGhlIGlucHV0IHZhbHVlIGlzIG5vdCBhIHN0cmluZy5cbiAqIEB0aHJvd3Mge0ludmFsaWRDaGFyYWN0ZXJFcnJvcn0gaWYgdGhlIHN0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3Rlci5cbiAqIEBzZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNzZXJpYWxpemUtYW4taWRlbnRpZmllclxuICovXG5mdW5jdGlvbiBlc2NhcGVDc3MoY3NzKSB7XG4gIGlmICh0eXBlb2YgY3NzICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG4gIGxldCByZXQgPSAnJ1xuICBjb25zdCBuID0gY3NzLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGNvbnN0IGMgPSBjc3MuY2hhckNvZGVBdChpKVxuICAgIGlmIChjID09IDB4MCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgKGMgPj0gMHgwMDAxICYmIGMgPD0gMHgwMDFmKSB8fFxuICAgICAgYyA9PSAweDAwN2YgfHxcbiAgICAgIChpID09IDAgJiYgYyA+PSAweDAwMzAgJiYgYyA8PSAweDAwMzkpIHx8XG4gICAgICAoaSA9PSAxICYmIGMgPj0gMHgwMDMwICYmIGMgPD0gMHgwMDM5ICYmIGNzcy5jaGFyQ29kZUF0KDApID09IDB4MDAyZClcbiAgICApIHtcbiAgICAgIHJldCArPSAnXFxcXCcgKyBjLnRvU3RyaW5nKDE2KSArICcgJ1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoaSA9PSAwICYmIGMgPT0gMHgwMDJkICYmIG4gPT0gMSkge1xuICAgICAgcmV0ICs9ICdcXFxcJyArIGNzcy5jaGFyQXQoaSlcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgYyA+PSAweDAwODAgfHxcbiAgICAgIGMgPT0gMHgwMDJkIHx8IC8vIC1cbiAgICAgIGMgPT0gMHgwMDVmIHx8IC8vIF9cbiAgICAgIChjID49IDB4MDAzMCAmJiBjIDw9IDB4MDAzOSkgfHwgLy8gWzAtOV1cbiAgICAgIChjID49IDB4MDA0MSAmJiBjIDw9IDB4MDA1YSkgfHwgLy8gW0EtWl1cbiAgICAgIChjID49IDB4MDA2MSAmJiBjIDw9IDB4MDA3YSlcbiAgICApIHtcbiAgICAgIC8vIFthLXpdXG4gICAgICByZXQgKz0gY3NzLmNoYXJBdChpKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICByZXQgKz0gJ1xcXFwnICsgY3NzLmNoYXJBdChpKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSBtZWNoYW5pc20gZm9yIGxvY2F0aW5nIGFuIGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgQnkge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzaW5nIHRoZSBuYW1lIG9mIHRoZSBsb2NhdGlvbiBzdHJhdGVneSB0byB1c2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHVzaW5nLCB2YWx1ZSkge1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMudXNpbmcgPSB1c2luZ1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogTG9jYXRlcyBlbGVtZW50cyB0aGF0IGhhdmUgYSBzcGVjaWZpYyBjbGFzcyBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgY2xhc3MgbmFtZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIHshQnl9IFRoZSBuZXcgbG9jYXRvci5cbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L2VsZW1lbnRzLmh0bWwjY2xhc3Nlc1xuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc2VsZWN0b3IuaHRtbCNjbGFzcy1odG1sXG4gICAqL1xuICBzdGF0aWMgY2xhc3NOYW1lKG5hbWUpIHtcbiAgICBsZXQgbmFtZXMgPSBuYW1lXG4gICAgICAuc3BsaXQoL1xccysvZylcbiAgICAgIC5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMClcbiAgICAgIC5tYXAoKHMpID0+IGVzY2FwZUNzcyhzKSlcbiAgICByZXR1cm4gQnkuY3NzKCcuJyArIG5hbWVzLmpvaW4oJy4nKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGVsZW1lbnRzIHVzaW5nIGEgQ1NTIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIENTUyBzZWxlY3RvciB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCeX0gVGhlIG5ldyBsb2NhdG9yLlxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc2VsZWN0b3IuaHRtbFxuICAgKi9cbiAgc3RhdGljIGNzcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgQnkoJ2NzcyBzZWxlY3RvcicsIHNlbGVjdG9yKVxuICB9XG5cbiAgLyoqXG4gICAqIExvY2F0ZXMgZWxlbWVudHMgYnkgdGhlIElEIGF0dHJpYnV0ZS4gVGhpcyBsb2NhdG9yIHVzZXMgdGhlIENTUyBzZWxlY3RvclxuICAgKiBgKltpZD1cIiRJRFwiXWAsIF9ub3RfIGBkb2N1bWVudC5nZXRFbGVtZW50QnlJZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybiB7IUJ5fSBUaGUgbmV3IGxvY2F0b3IuXG4gICAqL1xuICBzdGF0aWMgaWQoaWQpIHtcbiAgICByZXR1cm4gQnkuY3NzKCcqW2lkPVwiJyArIGVzY2FwZUNzcyhpZCkgKyAnXCJdJylcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGxpbmsgZWxlbWVudHMgd2hvc2VcbiAgICoge0BsaW5rcGxhaW4gd2ViZHJpdmVyLldlYkVsZW1lbnQjZ2V0VGV4dCB2aXNpYmxlIHRleHR9IG1hdGNoZXMgdGhlIGdpdmVuXG4gICAqIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGxpbmsgdGV4dCB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIHshQnl9IFRoZSBuZXcgbG9jYXRvci5cbiAgICovXG4gIHN0YXRpYyBsaW5rVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBCeSgnbGluayB0ZXh0JywgdGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGVsZW1lbnRzIGJ5IGV2YWx1YXRpbmcgYSBgc2NyaXB0YCB0aGF0IGRlZmluZXMgdGhlIGJvZHkgb2ZcbiAgICogYSB7QGxpbmtwbGFpbiB3ZWJkcml2ZXIuV2ViRHJpdmVyI2V4ZWN1dGVTY3JpcHQgSmF2YVNjcmlwdCBmdW5jdGlvbn0uXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGFuIGVsZW1lbnQgb3IgYW4gYXJyYXktbGlrZVxuICAgKiBsaXN0IG9mIGVsZW1lbnRzLiBXaGVuIHRoaXMgbG9jYXRvciByZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50cywgYnV0IG9ubHlcbiAgICogb25lIGlzIGV4cGVjdGVkLCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGlzIGxpc3Qgd2lsbCBiZSB1c2VkIGFzIHRoZVxuICAgKiBzaW5nbGUgZWxlbWVudCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHshKHN0cmluZ3xGdW5jdGlvbil9IHNjcmlwdCBUaGUgc2NyaXB0IHRvIGV4ZWN1dGUuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBzY3JpcHQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKCEuL3dlYmRyaXZlci5XZWJEcml2ZXIpOiAhUHJvbWlzZX1cbiAgICogICAgIEEgbmV3IEphdmFTY3JpcHQtYmFzZWQgbG9jYXRvciBmdW5jdGlvbi5cbiAgICovXG4gIHN0YXRpYyBqcyhzY3JpcHQsIC4uLnZhcl9hcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkcml2ZXIpIHtcbiAgICAgIHJldHVybiBkcml2ZXIuZXhlY3V0ZVNjcmlwdC5jYWxsKGRyaXZlciwgc2NyaXB0LCAuLi52YXJfYXJncylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9jYXRlcyBlbGVtZW50cyB3aG9zZSBgbmFtZWAgYXR0cmlidXRlIGhhcyB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIGF0dHJpYnV0ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIHshQnl9IFRoZSBuZXcgbG9jYXRvci5cbiAgICovXG4gIHN0YXRpYyBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gQnkuY3NzKCcqW25hbWU9XCInICsgZXNjYXBlQ3NzKG5hbWUpICsgJ1wiXScpXG4gIH1cblxuICAvKipcbiAgICogTG9jYXRlcyBsaW5rIGVsZW1lbnRzIHdob3NlXG4gICAqIHtAbGlua3BsYWluIHdlYmRyaXZlci5XZWJFbGVtZW50I2dldFRleHQgdmlzaWJsZSB0ZXh0fSBjb250YWlucyB0aGUgZ2l2ZW5cbiAgICogc3Vic3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgc3Vic3RyaW5nIHRvIGNoZWNrIGZvciBpbiBhIGxpbmsncyB2aXNpYmxlIHRleHQuXG4gICAqIEByZXR1cm4geyFCeX0gVGhlIG5ldyBsb2NhdG9yLlxuICAgKi9cbiAgc3RhdGljIHBhcnRpYWxMaW5rVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBCeSgncGFydGlhbCBsaW5rIHRleHQnLCB0ZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIExvY2F0ZXMgZWxlbWVudHMgd2l0aCBhIGdpdmVuIHRhZyBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgdGFnIG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybiB7IUJ5fSBUaGUgbmV3IGxvY2F0b3IuXG4gICAqL1xuICBzdGF0aWMgdGFnTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBCeSgndGFnIG5hbWUnLCBuYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIExvY2F0ZXMgZWxlbWVudHMgbWF0Y2hpbmcgYSBYUGF0aCBzZWxlY3Rvci4gQ2FyZSBzaG91bGQgYmUgdGFrZW4gd2hlblxuICAgKiB1c2luZyBhbiBYUGF0aCBzZWxlY3RvciB3aXRoIGEge0BsaW5rIHdlYmRyaXZlci5XZWJFbGVtZW50fSBhcyBXZWJEcml2ZXJcbiAgICogd2lsbCByZXNwZWN0IHRoZSBjb250ZXh0IGluIHRoZSBzcGVjaWZpZWQgaW4gdGhlIHNlbGVjdG9yLiBGb3IgZXhhbXBsZSxcbiAgICogZ2l2ZW4gdGhlIHNlbGVjdG9yIGAvL2RpdmAsIFdlYkRyaXZlciB3aWxsIHNlYXJjaCBmcm9tIHRoZSBkb2N1bWVudCByb290XG4gICAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgbG9jYXRvciB3YXMgdXNlZCB3aXRoIGEgV2ViRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHhwYXRoIFRoZSBYUGF0aCBzZWxlY3RvciB0byB1c2UuXG4gICAqIEByZXR1cm4geyFCeX0gVGhlIG5ldyBsb2NhdG9yLlxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3hwYXRoL1xuICAgKi9cbiAgc3RhdGljIHhwYXRoKHhwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBCeSgneHBhdGgnLCB4cGF0aClcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgLy8gVGhlIHN0YXRpYyBCeS5uYW1lKCkgb3ZlcnJpZGVzIHRoaXMuY29uc3RydWN0b3IubmFtZS4gIFNoYW1lLi4uXG4gICAgcmV0dXJuIGBCeSgke3RoaXMudXNpbmd9LCAke3RoaXMudmFsdWV9KWBcbiAgfVxuXG4gIHRvT2JqZWN0KCkge1xuICAgIGNvbnN0IHRtcCA9IHt9XG4gICAgdG1wW3RoaXMudXNpbmddID0gdGhpcy52YWx1ZVxuICAgIHJldHVybiB0bXBcbiAgfVxufVxuXG4vKipcbiAqIFN0YXJ0IFNlYXJjaGluZyBmb3IgcmVsYXRpdmUgb2JqZWN0cyB1c2luZyB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbVxuICogYEJ5LnRhZ05hbWUoKWAuXG4gKlxuICogTm90ZTogdGhpcyBtZXRob2Qgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlIHBsZWFzZSB1c2VcbiAqIGBsb2NhdGVXaXRoYC5cbiAqIEBwYXJhbSB7Qnl9IFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIGNhbGxpbmcgQnkudGFnTmFtZSgpXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB3aXRoVGFnTmFtZSh0YWdOYW1lKSB7XG4gIHJldHVybiBuZXcgUmVsYXRpdmVCeSh7ICdjc3Mgc2VsZWN0b3InOiB0YWdOYW1lIH0pXG59XG5cbi8qKlxuICogU3RhcnQgc2VhcmNoaW5nIGZvciByZWxhdGl2ZSBvYmplY3RzIHVzaW5nIHNlYXJjaCBjcml0ZXJpYSB3aXRoIEJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IEEgQnkgbWFwIHRoYXQgc2hvd3MgaG93IHRvIGZpbmQgdGhlIGluaXRpYWwgZWxlbWVudFxuICogQHJldHVybnMge1JlbGF0aXZlQnl9XG4gKi9cbmZ1bmN0aW9uIGxvY2F0ZVdpdGgoYnkpIHtcbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZUJ5KGdldExvY2F0b3IoYnkpKVxufVxuXG5mdW5jdGlvbiBnZXRMb2NhdG9yKGxvY2F0b3JPckVsZW1lbnQpIHtcbiAgbGV0IHRvRmluZFxuICBpZiAobG9jYXRvck9yRWxlbWVudCBpbnN0YW5jZW9mIEJ5KSB7XG4gICAgdG9GaW5kID0gbG9jYXRvck9yRWxlbWVudC50b09iamVjdCgpXG4gIH0gZWxzZSB7XG4gICAgdG9GaW5kID0gbG9jYXRvck9yRWxlbWVudFxuICB9XG4gIHJldHVybiB0b0ZpbmRcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSBtZWNoYW5pc20gZm9yIGxvY2F0aW5nIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gb3RoZXJzXG4gKiBvbiB0aGUgcGFnZS5cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBSZWxhdGl2ZUJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Qnl9IGZpbmREZXRhaWxzXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmlsdGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoZmluZERldGFpbHMsIGZpbHRlcnMgPSBudWxsKSB7XG4gICAgdGhpcy5yb290ID0gZmluZERldGFpbHNcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzIHx8IFtdXG4gIH1cblxuICAvKipcbiAgICogTG9vayBmb3IgZWxlbWVudHMgYWJvdmUgdGhlIHJvb3QgZWxlbWVudCBwYXNzZWQgaW5cbiAgICogQHBhcmFtIHtzdHJpbmd8V2ViRWxlbWVudH0gbG9jYXRvck9yRWxlbWVudFxuICAgKiBAcmV0dXJuIHshUmVsYXRpdmVCeX0gUmV0dXJuIHRoaXMgb2JqZWN0XG4gICAqL1xuICBhYm92ZShsb2NhdG9yT3JFbGVtZW50KSB7XG4gICAgdGhpcy5maWx0ZXJzLnB1c2goe1xuICAgICAga2luZDogJ2Fib3ZlJyxcbiAgICAgIGFyZ3M6IFtnZXRMb2NhdG9yKGxvY2F0b3JPckVsZW1lbnQpXSxcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTG9vayBmb3IgZWxlbWVudHMgYmVsb3cgdGhlIHJvb3QgZWxlbWVudCBwYXNzZWQgaW5cbiAgICogQHBhcmFtIHtzdHJpbmd8V2ViRWxlbWVudH0gbG9jYXRvck9yRWxlbWVudFxuICAgKiBAcmV0dXJuIHshUmVsYXRpdmVCeX0gUmV0dXJuIHRoaXMgb2JqZWN0XG4gICAqL1xuICBiZWxvdyhsb2NhdG9yT3JFbGVtZW50KSB7XG4gICAgdGhpcy5maWx0ZXJzLnB1c2goe1xuICAgICAga2luZDogJ2JlbG93JyxcbiAgICAgIGFyZ3M6IFtnZXRMb2NhdG9yKGxvY2F0b3JPckVsZW1lbnQpXSxcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTG9vayBmb3IgZWxlbWVudHMgbGVmdCB0aGUgcm9vdCBlbGVtZW50IHBhc3NlZCBpblxuICAgKiBAcGFyYW0ge3N0cmluZ3xXZWJFbGVtZW50fSBsb2NhdG9yT3JFbGVtZW50XG4gICAqIEByZXR1cm4geyFSZWxhdGl2ZUJ5fSBSZXR1cm4gdGhpcyBvYmplY3RcbiAgICovXG4gIHRvTGVmdE9mKGxvY2F0b3JPckVsZW1lbnQpIHtcbiAgICB0aGlzLmZpbHRlcnMucHVzaCh7XG4gICAgICBraW5kOiAnbGVmdCcsXG4gICAgICBhcmdzOiBbZ2V0TG9jYXRvcihsb2NhdG9yT3JFbGVtZW50KV0sXG4gICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgZm9yIGVsZW1lbnRzIHJpZ2h0IHRoZSByb290IGVsZW1lbnQgcGFzc2VkIGluXG4gICAqIEBwYXJhbSB7c3RyaW5nfFdlYkVsZW1lbnR9IGxvY2F0b3JPckVsZW1lbnRcbiAgICogQHJldHVybiB7IVJlbGF0aXZlQnl9IFJldHVybiB0aGlzIG9iamVjdFxuICAgKi9cbiAgdG9SaWdodE9mKGxvY2F0b3JPckVsZW1lbnQpIHtcbiAgICB0aGlzLmZpbHRlcnMucHVzaCh7XG4gICAgICBraW5kOiAncmlnaHQnLFxuICAgICAgYXJnczogW2dldExvY2F0b3IobG9jYXRvck9yRWxlbWVudCldLFxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIGZvciBlbGVtZW50cyBuZWFyIHRoZSByb290IGVsZW1lbnQgcGFzc2VkIGluXG4gICAqIEBwYXJhbSB7c3RyaW5nfFdlYkVsZW1lbnR9IGxvY2F0b3JPckVsZW1lbnRcbiAgICogQHJldHVybiB7IVJlbGF0aXZlQnl9IFJldHVybiB0aGlzIG9iamVjdFxuICAgKi9cbiAgbmVhcihsb2NhdG9yT3JFbGVtZW50KSB7XG4gICAgdGhpcy5maWx0ZXJzLnB1c2goe1xuICAgICAga2luZDogJ25lYXInLFxuICAgICAgYXJnczogW2dldExvY2F0b3IobG9jYXRvck9yRWxlbWVudCldLFxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWFyc2hhbGxlZCB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgUmVsYXRpdmVCeX1cbiAgICogQHJldHVybiB7IU9iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEge0BsaW5rIFdlYkVsZW1lbnR9XG4gICAqICAgICB0aGF0IHdpbGwgYmUgdXNlZCBpbiB7QGxpbmsgI2ZpbmRFbGVtZW50c30uXG4gICAqL1xuICBtYXJzaGFsbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVsYXRpdmU6IHtcbiAgICAgICAgcm9vdDogdGhpcy5yb290LFxuICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgLy8gVGhlIHN0YXRpYyBCeS5uYW1lKCkgb3ZlcnJpZGVzIHRoaXMuY29uc3RydWN0b3IubmFtZS4gIFNoYW1lLi4uXG4gICAgcmV0dXJuIGBSZWxhdGl2ZUJ5KCR7SlNPTi5zdHJpbmdpZnkodGhpcy5tYXJzaGFsbCgpKX0pYFxuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBsb2NhdG9yLlxuICogQHBhcmFtIHshKEJ5fEZ1bmN0aW9ufEJ5SGFzaCl9IGxvY2F0b3IgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7IShCeXxGdW5jdGlvbil9IFRoZSB2YWxpZCBsb2NhdG9yLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgZ2l2ZW4gdmFsdWUgZG9lcyBub3QgZGVmaW5lIGEgdmFsaWQgbG9jYXRvclxuICogICAgIHN0cmF0ZWd5LlxuICovXG5mdW5jdGlvbiBjaGVjayhsb2NhdG9yKSB7XG4gIGlmIChsb2NhdG9yIGluc3RhbmNlb2YgQnkgfHwgdHlwZW9mIGxvY2F0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbG9jYXRvclxuICB9XG5cbiAgaWYgKFxuICAgIGxvY2F0b3IgJiZcbiAgICB0eXBlb2YgbG9jYXRvciA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgbG9jYXRvci51c2luZyA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgbG9jYXRvci52YWx1ZSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBCeShsb2NhdG9yLnVzaW5nLCBsb2NhdG9yLnZhbHVlKVxuICB9XG5cbiAgZm9yIChsZXQga2V5IGluIGxvY2F0b3IpIHtcbiAgICBpZiAoXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYXRvciwga2V5KSAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEJ5LCBrZXkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gQnlba2V5XShsb2NhdG9yW2tleV0pXG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbG9jYXRvcicpXG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJ5LFxuICBSZWxhdGl2ZUJ5LFxuICB3aXRoVGFnTmFtZSxcbiAgbG9jYXRlV2l0aCxcbiAgZXNjYXBlQ3NzLFxuICBjaGVja2VkTG9jYXRvcjogY2hlY2ssXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmluZXMgdHlwZXMgcmVsYXRlZCB0byBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgb2YgYVxuICogV2ViRHJpdmVyIHNlc3Npb24uXG4gKi9cblxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5cbi8qKlxuICogUmVjb2duaXplZCBicm93c2VyIG5hbWVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgQnJvd3NlciA9IHtcbiAgQ0hST01FOiAnY2hyb21lJyxcbiAgRURHRTogJ01pY3Jvc29mdEVkZ2UnLFxuICBGSVJFRk9YOiAnZmlyZWZveCcsXG4gIElOVEVSTkVUX0VYUExPUkVSOiAnaW50ZXJuZXQgZXhwbG9yZXInLFxuICBTQUZBUkk6ICdzYWZhcmknLFxufVxuXG4vKipcbiAqIFN0cmF0ZWdpZXMgZm9yIHdhaXRpbmcgZm9yIFtkb2N1bWVudCByZWFkaW5lc3NdIGFmdGVyIGEgbmF2aWdhdGlvblxuICogZXZlbnQuXG4gKlxuICogW2RvY3VtZW50IHJlYWRpbmVzc106IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2N1cnJlbnQtZG9jdW1lbnQtcmVhZGluZXNzXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgUGFnZUxvYWRTdHJhdGVneSA9IHtcbiAgLyoqXG4gICAqIEluZGljYXRlcyBXZWJEcml2ZXIgc2hvdWxkIG5vdCB3YWl0IG9uIHRoZSBkb2N1bWVudCByZWFkaW5lc3Mgc3RhdGUgYWZ0ZXIgYVxuICAgKiBuYXZpZ2F0aW9uIGV2ZW50LlxuICAgKi9cbiAgTk9ORTogJ25vbmUnLFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgV2ViRHJpdmVyIHNob3VsZCB3YWl0IGZvciB0aGUgZG9jdW1lbnQgcmVhZGluZXNzIHN0YXRlIHRvXG4gICAqIGJlY29tZSBcImludGVyYWN0aXZlXCIgYWZ0ZXIgbmF2aWdhdGlvbi5cbiAgICovXG4gIEVBR0VSOiAnZWFnZXInLFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgV2ViRHJpdmVyIHNob3VsZCB3YWl0IGZvciB0aGUgZG9jdW1lbnQgcmVhZGluZXNzIHN0YXRlIHRvXG4gICAqIGJlIFwiY29tcGxldGVcIiBhZnRlciBuYXZpZ2F0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IHBhZ2UgbG9hZGluZyBzdHJhdGVneS5cbiAgICovXG4gIE5PUk1BTDogJ25vcm1hbCcsXG59XG5cbi8qKlxuICogQ29tbW9uIHBsYXRmb3JtIG5hbWVzLiBUaGVzZSBwbGF0Zm9ybXMgYXJlIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgYnkgdGhlXG4gKiBXZWJEcml2ZXIgc3BlYywgaG93ZXZlciwgdGhlaXIgdXNlIGlzIGVuY291cmFnZWQgZm9yIGludGVyb3BlcmFiaWxpdHkuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBzZWUgPGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvd2ViZHJpdmVyLXNwZWMuaHRtbD5cbiAqL1xuY29uc3QgUGxhdGZvcm0gPSB7XG4gIExJTlVYOiAnbGludXgnLFxuICBNQUM6ICdtYWMnLFxuICBXSU5ET1dTOiAnd2luZG93cycsXG59XG5cbi8qKlxuICogUmVjb3JkIG9iamVjdCBkZWZpbmluZyB0aGUgdGltZW91dHMgdGhhdCBhcHBseSB0byBjZXJ0YWluIFdlYkRyaXZlciBhY3Rpb25zLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuZnVuY3Rpb24gVGltZW91dHMoKSB7fVxuXG4vKipcbiAqIERlZmluZXMgd2hlbiwgaW4gbWlsbGlzZWNvbmRzLCB0byBpbnRlcnJ1cHQgYSBzY3JpcHQgdGhhdCBpcyBiZWluZ1xuICoge0BsaW5rcGxhaW4gLi93ZWJkcml2ZXIuSVdlYkRyaXZlciNleGVjdXRlU2NyaXB0IGV2YWx1YXRlZH0uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5UaW1lb3V0cy5wcm90b3R5cGUuc2NyaXB0XG5cbi8qKlxuICogVGhlIHRpbWVvdXQsIGluIG1pbGxpc2Vjb25kcywgdG8gYXBwbHkgdG8gbmF2aWdhdGlvbiBldmVudHMgYWxvbmcgd2l0aCB0aGVcbiAqIHtAbGluayBQYWdlTG9hZFN0cmF0ZWd5fS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cblRpbWVvdXRzLnByb3RvdHlwZS5wYWdlTG9hZFxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRvIHNwZW5kIGF0dGVtcHRpbmcgdG9cbiAqIHtAbGlua3BsYWluIC4vd2ViZHJpdmVyLklXZWJEcml2ZXIjZmluZEVsZW1lbnQgbG9jYXRlfSBhbiBlbGVtZW50IG9uIHRoZVxuICogY3VycmVudCBwYWdlLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuVGltZW91dHMucHJvdG90eXBlLmltcGxpY2l0XG5cbi8qKlxuICogVGhlIHBvc3NpYmxlIGRlZmF1bHQgYWN0aW9ucyBhIFdlYkRyaXZlciBzZXNzaW9uIGNhbiB0YWtlIHRvIHJlc3BvbmQgdG9cbiAqIHVuaGFuZGxlZCB1c2VyIHByb21wdHMgKGB3aW5kb3cuYWxlcnQoKWAsIGB3aW5kb3cuY29uZmlybSgpYCwgYW5kXG4gKiBgd2luZG93LnByb21wdCgpYCkuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVXNlclByb21wdEhhbmRsZXIgPSB7XG4gIC8qKiBBbGwgcHJvbXB0cyBzaG91bGQgYmUgc2lsZW50bHkgYWNjZXB0ZWQuICovXG4gIEFDQ0VQVDogJ2FjY2VwdCcsXG4gIC8qKiBBbGwgcHJvbXB0cyBzaG91bGQgYmUgc2lsZW50bHkgZGlzbWlzc2VkLiAqL1xuICBESVNNSVNTOiAnZGlzbWlzcycsXG4gIC8qKlxuICAgKiBBbGwgcHJvbXB0cyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBhY2NlcHRlZCwgYnV0IGFuIGVycm9yIHNob3VsZCBiZVxuICAgKiByZXR1cm5lZCB0byB0aGUgbmV4dCAob3IgY3VycmVudGx5IGV4ZWN1dGluZykgV2ViRHJpdmVyIGNvbW1hbmQuXG4gICAqL1xuICBBQ0NFUFRfQU5EX05PVElGWTogJ2FjY2VwdCBhbmQgbm90aWZ5JyxcbiAgLyoqXG4gICAqIEFsbCBwcm9tcHRzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGRpc21pc3NlZCwgYnV0IGFuIGVycm9yIHNob3VsZCBiZVxuICAgKiByZXR1cm5lZCB0byB0aGUgbmV4dCAob3IgY3VycmVudGx5IGV4ZWN1dGluZykgV2ViRHJpdmVyIGNvbW1hbmQuXG4gICAqL1xuICBESVNNSVNTX0FORF9OT1RJRlk6ICdkaXNtaXNzIGFuZCBub3RpZnknLFxuICAvKiogQWxsIHByb21wdHMgc2hvdWxkIGJlIGxlZnQgdW5oYW5kbGVkLiAqL1xuICBJR05PUkU6ICdpZ25vcmUnLFxufVxuXG4vKipcbiAqIFRoZSBzdGFuZGFyZCBXZWJEcml2ZXIgY2FwYWJpbGl0eSBrZXlzLlxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAc2VlIDxodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyL3dlYmRyaXZlci1zcGVjLmh0bWwjY2FwYWJpbGl0aWVzPlxuICovXG5jb25zdCBDYXBhYmlsaXR5ID0ge1xuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgYSBXZWJEcml2ZXIgc2Vzc2lvbiBpbXBsaWNpdGx5IHRydXN0cyBvdGhlcndpc2UgdW50cnVzdGVkXG4gICAqIGFuZCBzZWxmLXNpZ25lZCBUTFMgY2VydGlmaWNhdGVzIGR1cmluZyBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgQUNDRVBUX0lOU0VDVVJFX1RMU19DRVJUUzogJ2FjY2VwdEluc2VjdXJlQ2VydHMnLFxuXG4gIC8qKlxuICAgKiBUaGUgYnJvd3NlciBuYW1lLiBDb21tb24gYnJvd3NlciBuYW1lcyBhcmUgZGVmaW5lZCBpbiB0aGVcbiAgICoge0BsaW5rIC4vY2FwYWJpbGl0aWVzLkJyb3dzZXIgQnJvd3Nlcn0gZW51bS5cbiAgICovXG4gIEJST1dTRVJfTkFNRTogJ2Jyb3dzZXJOYW1lJyxcblxuICAvKiogSWRlbnRpZmllcyB0aGUgYnJvd3NlciB2ZXJzaW9uLiAqL1xuICBCUk9XU0VSX1ZFUlNJT046ICdicm93c2VyVmVyc2lvbicsXG5cbiAgLyoqXG4gICAqIEtleSBmb3IgdGhlIGxvZ2dpbmcgZHJpdmVyIGxvZ2dpbmcgcHJlZmVyZW5jZXMuXG4gICAqIFRoZSBicm93c2VyIG5hbWUuIENvbW1vbiBicm93c2VyIG5hbWVzIGFyZSBkZWZpbmVkIGluIHRoZVxuICAgKiB7QGxpbmsgLi9jYXBhYmlsaXRpZXMuQnJvd3NlciBCcm93c2VyfSBlbnVtLlxuICAgKi9cbiAgTE9HR0lOR19QUkVGUzogJ2dvb2c6bG9nZ2luZ1ByZWZzJyxcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgc2Vzc2lvbidzXG4gICAqIHtAbGlua3BsYWluIC4vY2FwYWJpbGl0aWVzLlBhZ2VMb2FkU3RyYXRlZ3kgcGFnZSBsb2FkaW5nIHN0cmF0ZWd5fS5cbiAgICovXG4gIFBBR0VfTE9BRF9TVFJBVEVHWTogJ3BhZ2VMb2FkU3RyYXRlZ3knLFxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVzIHRoZSBvcGVyYXRpbmcgc3lzdGVtIG9mIHRoZSBlbmRwb2ludCBub2RlLiBDb21tb24gdmFsdWVzXG4gICAqIHJlY29nbml6ZWQgYnkgdGhlIG1vc3QgV2ViRHJpdmVyIHNlcnZlciBpbXBsZW1lbnRhdGlvbnMgYXJlIHByZWRlZmluZWQgaW5cbiAgICogdGhlIHtAbGluayAuL2NhcGFiaWxpdGllcy5QbGF0Zm9ybSBQbGF0Zm9ybX0gZW51bS5cbiAgICovXG4gIFBMQVRGT1JNX05BTUU6ICdwbGF0Zm9ybU5hbWUnLFxuXG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHByb3h5IGNvbmZpZ3VyYXRpb24gdG8gdXNlIGZvciBhIG5ldyBXZWJEcml2ZXIgc2Vzc2lvbi5cbiAgICovXG4gIFBST1hZOiAncHJveHknLFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVtb3RlIGVuZCBzdXBwb3J0cyBhbGwgb2YgdGhlIHdpbmRvdyByZXNpemluZyBhbmRcbiAgICogcG9zaXRpb25pbmcgY29tbWFuZHM6XG4gICAqXG4gICAqIC0gIHtAbGlua3BsYWluIC4vd2ViZHJpdmVyLldpbmRvdyNnZXRSZWN0IFdpbmRvdy5nZXRSZWN0KCl9XG4gICAqIC0gIHtAbGlua3BsYWluIC4vd2ViZHJpdmVyLldpbmRvdyNzZXRSZWN0IFdpbmRvdy5zZXRSZWN0KCl9XG4gICAqIC0gIHtAbGlua3BsYWluIC4vd2ViZHJpdmVyLldpbmRvdyNtYXhpbWl6ZSBXaW5kb3cubWF4aW1pemUoKX1cbiAgICogLSAge0BsaW5rcGxhaW4gLi93ZWJkcml2ZXIuV2luZG93I21pbmltaXplIFdpbmRvdy5taW5pbWl6ZSgpfVxuICAgKiAtICB7QGxpbmtwbGFpbiAuL3dlYmRyaXZlci5XaW5kb3cjZnVsbHNjcmVlbiBXaW5kb3cuZnVsbHNjcmVlbigpfVxuICAgKi9cbiAgU0VUX1dJTkRPV19SRUNUOiAnc2V0V2luZG93UmVjdCcsXG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUge0BsaW5rcGxhaW4gLi9jYXBhYmlsaXRpZXMuVGltZW91dHMgdGltZW91dHN9IGltcG9zZWQgb25cbiAgICogY2VydGFpbiBzZXNzaW9uIG9wZXJhdGlvbnMuXG4gICAqL1xuICBUSU1FT1VUUzogJ3RpbWVvdXRzJyxcblxuICAvKipcbiAgICogRGVmaW5lcyBob3cgYSBXZWJEcml2ZXIgc2Vzc2lvbiBzaG91bGRcbiAgICoge0BsaW5rcGxhaW4gLi9jYXBhYmlsaXRpZXMuVXNlclByb21wdEhhbmRsZXIgcmVzcG9uZH0gdG8gdW5oYW5kbGVkIHVzZXJcbiAgICogcHJvbXB0cy5cbiAgICovXG4gIFVOSEFORExFRF9QUk9NUFRfQkVIQVZJT1I6ICd1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcicsXG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIGN1cnJlbnQgc2Vzc2lvbuKAmXMgc3RyaWN0IGZpbGUgaW50ZXJhY3RhYmlsaXR5LlxuICAgKiBVc2VkIHRvIHVwbG9hZCBhIGZpbGUgd2hlbiBzdHJpY3QgZmlsZSBpbnRlcmFjdGFiaWxpdHkgaXMgb25cbiAgICovXG4gIFNUUklDVF9GSUxFX0lOVEVSQUNUQUJJTElUWTogJ3N0cmljdEZpbGVJbnRlcmFjdGFiaWxpdHknLFxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgZ2VuZXJpYyBoYXNoIG9iamVjdCB0byBhIG1hcC5cbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsID8+fSBoYXNoIFRoZSBoYXNoIG9iamVjdC5cbiAqIEByZXR1cm4geyFNYXA8c3RyaW5nLCA/Pn0gVGhlIGNvbnZlcnRlZCBtYXAuXG4gKi9cbmZ1bmN0aW9uIHRvTWFwKGhhc2gpIHtcbiAgbGV0IG0gPSBuZXcgTWFwKClcbiAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhc2gsIGtleSkpIHtcbiAgICAgIG0uc2V0KGtleSwgaGFzaFtrZXldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbVxufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIHNldCBvZiBjYXBhYmlsaXRpZXMgZm9yIGEgV2ViRHJpdmVyIHNlc3Npb24uXG4gKi9cbmNsYXNzIENhcGFiaWxpdGllcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyhDYXBhYmlsaXRpZXN8TWFwPHN0cmluZywgPz58T2JqZWN0KT19IG90aGVyIEFub3RoZXIgc2V0IG9mXG4gICAqICAgICBjYXBhYmlsaXRpZXMgdG8gaW5pdGlhbGl6ZSB0aGlzIGluc3RhbmNlIGZyb20uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvdGhlciA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENhcGFiaWxpdGllcykge1xuICAgICAgb3RoZXIgPSBvdGhlci5tYXBfXG4gICAgfSBlbHNlIGlmIChvdGhlciAmJiAhKG90aGVyIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgb3RoZXIgPSB0b01hcChvdGhlcilcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IU1hcDxzdHJpbmcsID8+fSAqL1xuICAgIHRoaXMubWFwXyA9IG5ldyBNYXAob3RoZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUNhcGFiaWxpdGllc30gQSBiYXNpYyBzZXQgb2YgY2FwYWJpbGl0aWVzIGZvciBDaHJvbWUuXG4gICAqL1xuICBzdGF0aWMgY2hyb21lKCkge1xuICAgIHJldHVybiBuZXcgQ2FwYWJpbGl0aWVzKCkuc2V0QnJvd3Nlck5hbWUoQnJvd3Nlci5DSFJPTUUpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUNhcGFiaWxpdGllc30gQSBiYXNpYyBzZXQgb2YgY2FwYWJpbGl0aWVzIGZvciBNaWNyb3NvZnQgRWRnZS5cbiAgICovXG4gIHN0YXRpYyBlZGdlKCkge1xuICAgIHJldHVybiBuZXcgQ2FwYWJpbGl0aWVzKCkuc2V0QnJvd3Nlck5hbWUoQnJvd3Nlci5FREdFKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFDYXBhYmlsaXRpZXN9IEEgYmFzaWMgc2V0IG9mIGNhcGFiaWxpdGllcyBmb3IgRmlyZWZveC5cbiAgICovXG4gIHN0YXRpYyBmaXJlZm94KCkge1xuICAgIHJldHVybiBuZXcgQ2FwYWJpbGl0aWVzKClcbiAgICAgIC5zZXRCcm93c2VyTmFtZShCcm93c2VyLkZJUkVGT1gpXG4gICAgICAuc2V0KCdtb3o6ZGVidWdnZXJBZGRyZXNzJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBBIGJhc2ljIHNldCBvZiBjYXBhYmlsaXRpZXMgZm9yIEludGVybmV0IEV4cGxvcmVyLlxuICAgKi9cbiAgc3RhdGljIGllKCkge1xuICAgIHJldHVybiBuZXcgQ2FwYWJpbGl0aWVzKCkuc2V0QnJvd3Nlck5hbWUoQnJvd3Nlci5JTlRFUk5FVF9FWFBMT1JFUilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBBIGJhc2ljIHNldCBvZiBjYXBhYmlsaXRpZXMgZm9yIFNhZmFyaS5cbiAgICovXG4gIHN0YXRpYyBzYWZhcmkoKSB7XG4gICAgcmV0dXJuIG5ldyBDYXBhYmlsaXRpZXMoKS5zZXRCcm93c2VyTmFtZShCcm93c2VyLlNBRkFSSSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgPz59IFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgaW5zdGFuY2UuXG4gICAqICAgICBOb3RlLCB0aGUgcmV0dXJuZWQgb2JqZWN0IG1heSBjb250YWluIG5lc3RlZCBwcm9taXNlZCB2YWx1ZXMuXG4gICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gU3VwcHJlc3MgW10gYWNjZXNzIG9uIGEgc3RydWN0IChzdGF0ZSBpbmhlcml0ZWQgZnJvbVxuICAgKiAgICAgTWFwKS5cbiAgICovXG4gIFtTeW1ib2xzLnNlcmlhbGl6ZV0oKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIHBhcmFtZXRlciBrZXkgdG8gZ2V0LlxuICAgKiBAcmV0dXJuIHtUfSB0aGUgc3RvcmVkIHBhcmFtZXRlciB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfLmdldChrZXkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUga2V5IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhpcyBjYXBhYmlsaXR5IHNldCBoYXMgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXy5oYXMoa2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcjxzdHJpbmc+fSBhbiBpdGVyYXRvciBvZiB0aGUga2V5cyBzZXQuXG4gICAqL1xuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF8ua2V5cygpXG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNhcGFiaWxpdGllcyBzZXQuICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF8uc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBhbm90aGVyIHNldCBvZiBjYXBhYmlsaXRpZXMgaW50byB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0geyEoQ2FwYWJpbGl0aWVzfE1hcDxTdHJpbmcsID8+fE9iamVjdDxzdHJpbmcsID8+KX0gb3RoZXIgVGhlIG90aGVyXG4gICAqICAgICBzZXQgb2YgY2FwYWJpbGl0aWVzIHRvIG1lcmdlLlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgbWVyZ2Uob3RoZXIpIHtcbiAgICBpZiAob3RoZXIpIHtcbiAgICAgIGxldCBvdGhlck1hcFxuICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgIG90aGVyTWFwID0gb3RoZXIubWFwX1xuICAgICAgfSBlbHNlIGlmIChvdGhlciBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvdGhlck1hcCA9IG90aGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdGhlck1hcCA9IHRvTWFwKG90aGVyKVxuICAgICAgfVxuICAgICAgb3RoZXJNYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGNhcGFiaWxpdGllcyBwcm92aWRlZCBmb3IgbWVyZ2UnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGVudHJ5IGZyb20gdGhpcyBzZXQgb2YgY2FwYWJpbGl0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBjYXBhYmlsaXR5IGtleSB0byBkZWxldGUuXG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5tYXBfLmRlbGV0ZShrZXkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgY2FwYWJpbGl0eSBrZXkuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGNhcGFiaWxpdHkgdmFsdWUuXG4gICAqIEByZXR1cm4geyFDYXBhYmlsaXRpZXN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGBrZXlgIGlzIG5vdCBhIHN0cmluZy5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYXBhYmlsaXR5IGtleXMgbXVzdCBiZSBzdHJpbmdzOiAnICsgdHlwZW9mIGtleSlcbiAgICB9XG4gICAgdGhpcy5tYXBfLnNldChrZXksIHZhbHVlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIGEgV2ViRHJpdmVyIHNlc3Npb24gc2hvdWxkIGltcGxpY2l0bHkgYWNjZXB0IHNlbGYtc2lnbmVkLCBvclxuICAgKiBvdGhlciB1bnRydXN0ZWQgVExTIGNlcnRpZmljYXRlcyBvbiBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjY2VwdCB3aGV0aGVyIHRvIGFjY2VwdCBpbnNlY3VyZSBjZXJ0cy5cbiAgICogQHJldHVybiB7IUNhcGFiaWxpdGllc30gYSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNldEFjY2VwdEluc2VjdXJlQ2VydHMoYWNjZXB0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KENhcGFiaWxpdHkuQUNDRVBUX0lOU0VDVVJFX1RMU19DRVJUUywgYWNjZXB0KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHNlc3Npb24gaXMgY29uZmlndXJlZCB0byBhY2NlcHQgaW5zZWN1cmVcbiAgICogICAgIFRMUyBjZXJ0aWZpY2F0ZXMuXG4gICAqL1xuICBnZXRBY2NlcHRJbnNlY3VyZUNlcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldChDYXBhYmlsaXR5LkFDQ0VQVF9JTlNFQ1VSRV9UTFNfQ0VSVFMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgdGFyZ2V0IGJyb3dzZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJyb3dzZXJ8c3RyaW5nKX0gbmFtZSB0aGUgYnJvd3NlciBuYW1lLlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0QnJvd3Nlck5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNldChDYXBhYmlsaXR5LkJST1dTRVJfTkFNRSwgbmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHsoc3RyaW5nfHVuZGVmaW5lZCl9IHRoZSBjb25maWd1cmVkIGJyb3dzZXIgbmFtZSwgb3IgdW5kZWZpbmVkIGlmXG4gICAqICAgICBub3Qgc2V0LlxuICAgKi9cbiAgZ2V0QnJvd3Nlck5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KENhcGFiaWxpdHkuQlJPV1NFUl9OQU1FKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlc2lyZWQgdmVyc2lvbiBvZiB0aGUgdGFyZ2V0IGJyb3dzZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIHRoZSBkZXNpcmVkIHZlcnNpb24uXG4gICAqIEByZXR1cm4geyFDYXBhYmlsaXRpZXN9IGEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRCcm93c2VyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KENhcGFiaWxpdHkuQlJPV1NFUl9WRVJTSU9OLCB2ZXJzaW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyhzdHJpbmd8dW5kZWZpbmVkKX0gdGhlIGNvbmZpZ3VyZWQgYnJvd3NlciB2ZXJzaW9uLCBvciB1bmRlZmluZWRcbiAgICogICAgIGlmIG5vdCBzZXQuXG4gICAqL1xuICBnZXRCcm93c2VyVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoQ2FwYWJpbGl0eS5CUk9XU0VSX1ZFUlNJT04pXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGVzaXJlZCBwYWdlIGxvYWRpbmcgc3RyYXRlZ3kgZm9yIGEgbmV3IFdlYkRyaXZlciBzZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhZ2VMb2FkU3RyYXRlZ3l9IHN0cmF0ZWd5IHRoZSBkZXNpcmVkIHN0cmF0ZWd5LlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0UGFnZUxvYWRTdHJhdGVneShzdHJhdGVneSkge1xuICAgIHJldHVybiB0aGlzLnNldChDYXBhYmlsaXR5LlBBR0VfTE9BRF9TVFJBVEVHWSwgc3RyYXRlZ3kpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29uZmlndXJlZCBwYWdlIGxvYWQgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEByZXR1cm4geyhzdHJpbmd8dW5kZWZpbmVkKX0gdGhlIHBhZ2UgbG9hZCBzdHJhdGVneS5cbiAgICovXG4gIGdldFBhZ2VMb2FkU3RyYXRlZ3koKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KENhcGFiaWxpdHkuUEFHRV9MT0FEX1NUUkFURUdZKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRhcmdldCBwbGF0Zm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHsoUGxhdGZvcm18c3RyaW5nKX0gcGxhdGZvcm0gdGhlIHRhcmdldCBwbGF0Zm9ybS5cbiAgICogQHJldHVybiB7IUNhcGFiaWxpdGllc30gYSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNldFBsYXRmb3JtKHBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KENhcGFiaWxpdHkuUExBVEZPUk1fTkFNRSwgcGxhdGZvcm0pXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7KHN0cmluZ3x1bmRlZmluZWQpfSB0aGUgY29uZmlndXJlZCBwbGF0Zm9ybSBvciB1bmRlZmluZWQgaWYgbm90XG4gICAqICAgICBzZXQuXG4gICAqL1xuICBnZXRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoQ2FwYWJpbGl0eS5QTEFURk9STV9OQU1FKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxvZ2dpbmcgcHJlZmVyZW5jZXMuIFByZWZlcmVuY2VzIG1heSBiZSBzcGVjaWZpZWQgYXMgYVxuICAgKiB7QGxpbmsgLi9sb2dnaW5nLlByZWZlcmVuY2VzfSBpbnN0YW5jZSwgb3IgYXMgYSBtYXAgb2YgbG9nLXR5cGUgdG9cbiAgICogbG9nLWxldmVsLlxuICAgKiBAcGFyYW0geyEoLi9sb2dnaW5nLlByZWZlcmVuY2VzfE9iamVjdDxzdHJpbmc+KX0gcHJlZnMgVGhlIGxvZ2dpbmdcbiAgICogICAgIHByZWZlcmVuY2VzLlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0TG9nZ2luZ1ByZWZzKHByZWZzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KENhcGFiaWxpdHkuTE9HR0lOR19QUkVGUywgcHJlZnMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJveHkgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtwcm94eS5Db25maWd9IHByb3h5IFRoZSBkZXNpcmVkIHByb3h5IGNvbmZpZ3VyYXRpb24uXG4gICAqIEByZXR1cm4geyFDYXBhYmlsaXRpZXN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRQcm94eShwcm94eSkge1xuICAgIHJldHVybiB0aGlzLnNldChDYXBhYmlsaXR5LlBST1hZLCBwcm94eSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHsocHJveHkuQ29uZmlnfHVuZGVmaW5lZCl9IHRoZSBjb25maWd1cmVkIHByb3h5IHNldHRpbmdzLCBvclxuICAgKiAgICAgdW5kZWZpbmVkIGlmIG5vdCBzZXQuXG4gICAqL1xuICBnZXRQcm94eSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoQ2FwYWJpbGl0eS5QUk9YWSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IGFjdGlvbiB0byB0YWtlIHdpdGggYW4gdW5leHBlY3RlZCBhbGVydCBiZWZvcmUgcmV0dXJuaW5nXG4gICAqIGFuIGVycm9yLiBJZiB1bnNwZWNpZmllZCwgV2ViRHJpdmVyIHdpbGwgZGVmYXVsdCB0b1xuICAgKiB7QGxpbmsgVXNlclByb21wdEhhbmRsZXIuRElTTUlTU19BTkRfTk9USUZZfS5cbiAgICpcbiAgICogQHBhcmFtIHs/VXNlclByb21wdEhhbmRsZXJ9IGJlaGF2aW9yIFRoZSB3YXkgV2ViRHJpdmVyIHNob3VsZCByZXNwb25kIHRvXG4gICAqICAgICB1bmhhbmRsZWQgdXNlciBwcm9tcHRzLlxuICAgKiBAcmV0dXJuIHshQ2FwYWJpbGl0aWVzfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0QWxlcnRCZWhhdmlvcihiZWhhdmlvcikge1xuICAgIHJldHVybiB0aGlzLnNldChDYXBhYmlsaXR5LlVOSEFORExFRF9QUk9NUFRfQkVIQVZJT1IsIGJlaGF2aW9yKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyhVc2VyUHJvbXB0SGFuZGxlcnx1bmRlZmluZWQpfSB0aGUgYmVoYXZpb3IgcGF0dGVybiBmb3IgcmVzcG9uZGluZ1xuICAgKiAgICAgdG8gdW5oYW5kbGVkIHVzZXIgcHJvbXB0cywgb3IgdW5kZWZpbmVkIGlmIG5vdCBzZXQuXG4gICAqL1xuICBnZXRBbGVydEJlaGF2aW9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChDYXBhYmlsaXR5LlVOSEFORExFRF9QUk9NUFRfQkVIQVZJT1IpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYm9vbGVhbiBmbGFnIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBzZXRTdHJpY3RGaWxlSW50ZXJhY3RhYmlsaXR5KHN0cmljdEZpbGVJbnRlcmFjdGFiaWxpdHkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICBDYXBhYmlsaXR5LlNUUklDVF9GSUxFX0lOVEVSQUNUQUJJTElUWSxcbiAgICAgIHN0cmljdEZpbGVJbnRlcmFjdGFiaWxpdHlcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgY2FwYWJpbGl0aWVzIG9iamVjdC4gVGhpcyBpcyBkZWZpbmVkIGFzIGEgc3RhbmRhbG9uZSBmdW5jdGlvblxuICogc28gaXQgbWF5IGJlIHR5cGUgY2hlY2tlZCAod2hlcmUgQ2FwYWJpbGl0aWVzW1N5bWJvbHMuc2VyaWFsaXplXSBoYXMgdHlwZVxuICogY2hlY2tpbmcgZGlzYWJsZWQgc2luY2UgaXQgaXMgZGVmaW5lZCB3aXRoIFtdIGFjY2VzcyBvbiBhIHN0cnVjdCkuXG4gKlxuICogQHBhcmFtIHshQ2FwYWJpbGl0aWVzfSBjYXBzIFRoZSBjYXBhYmlsaXRpZXMgdG8gc2VyaWFsaXplLlxuICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsID8+fSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxuICogICAgIE5vdGUsIHRoZSByZXR1cm5lZCBvYmplY3QgbWF5IGNvbnRhaW4gbmVzdGVkIHByb21pc2VkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplKGNhcHMpIHtcbiAgbGV0IHJldCA9IHt9XG4gIGZvciAobGV0IGtleSBvZiBjYXBzLmtleXMoKSkge1xuICAgIGxldCBjYXAgPSBjYXBzLmdldChrZXkpXG4gICAgaWYgKGNhcCAhPT0gdW5kZWZpbmVkICYmIGNhcCAhPT0gbnVsbCkge1xuICAgICAgcmV0W2tleV0gPSBjYXBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCcm93c2VyLFxuICBDYXBhYmlsaXRpZXMsXG4gIENhcGFiaWxpdHksXG4gIFBhZ2VMb2FkU3RyYXRlZ3ksXG4gIFBsYXRmb3JtLFxuICBUaW1lb3V0cyxcbiAgVXNlclByb21wdEhhbmRsZXIsXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29udGFpbnMgc2V2ZXJhbCBjbGFzc2VzIGZvciBoYW5kbGluZyBjb21tYW5kcy5cbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBEZXNjcmliZXMgYSBjb21tYW5kIHRvIGV4ZWN1dGUuXG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgQ29tbWFuZCB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGlzIGNvbW1hbmQuICovXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLm5hbWVfID0gbmFtZVxuXG4gICAgLyoqIEBwcml2YXRlIHshT2JqZWN0PCo+fSAqL1xuICAgIHRoaXMucGFyYW1ldGVyc18gPSB7fVxuICB9XG5cbiAgLyoqIEByZXR1cm4ge3N0cmluZ30gVGhpcyBjb21tYW5kJ3MgbmFtZS4gKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lX1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBwYXJhbWV0ZXIgdG8gc2VuZCB3aXRoIHRoaXMgY29tbWFuZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gICAqIEByZXR1cm4geyFDb21tYW5kfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0UGFyYW1ldGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5wYXJhbWV0ZXJzX1tuYW1lXSA9IHZhbHVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIGNvbW1hbmQuXG4gICAqIEBwYXJhbSB7IU9iamVjdDwqPn0gcGFyYW1ldGVycyBUaGUgY29tbWFuZCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHshQ29tbWFuZH0gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNldFBhcmFtZXRlcnMocGFyYW1ldGVycykge1xuICAgIHRoaXMucGFyYW1ldGVyc18gPSBwYXJhbWV0ZXJzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmFtZWQgY29tbWFuZCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciBrZXkgdG8gbG9vayB1cC5cbiAgICogQHJldHVybiB7Kn0gVGhlIHBhcmFtZXRlciB2YWx1ZSwgb3IgdW5kZWZpbmVkIGlmIGl0IGhhcyBub3QgYmVlbiBzZXQuXG4gICAqL1xuICBnZXRQYXJhbWV0ZXIoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyc19ba2V5XVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFPYmplY3Q8Kj59IFRoZSBwYXJhbWV0ZXJzIHRvIHNlbmQgd2l0aCB0aGlzIGNvbW1hbmQuXG4gICAqL1xuICBnZXRQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnNfXG4gIH1cbn1cblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBwcmVkZWZpbmVkIG5hbWVzIGNvbW1hbmQgbmFtZXMgdGhhdCBhbGwgY29tbWFuZCBwcm9jZXNzb3JzXG4gKiB3aWxsIHN1cHBvcnQuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBOYW1lID0ge1xuICBHRVRfU0VSVkVSX1NUQVRVUzogJ2dldFN0YXR1cycsXG5cbiAgTkVXX1NFU1NJT046ICduZXdTZXNzaW9uJyxcbiAgR0VUX1NFU1NJT05TOiAnZ2V0U2Vzc2lvbnMnLFxuXG4gIENMT1NFOiAnY2xvc2UnLFxuICBRVUlUOiAncXVpdCcsXG5cbiAgR0VUX0NVUlJFTlRfVVJMOiAnZ2V0Q3VycmVudFVybCcsXG4gIEdFVDogJ2dldCcsXG4gIEdPX0JBQ0s6ICdnb0JhY2snLFxuICBHT19GT1JXQVJEOiAnZ29Gb3J3YXJkJyxcbiAgUkVGUkVTSDogJ3JlZnJlc2gnLFxuXG4gIEFERF9DT09LSUU6ICdhZGRDb29raWUnLFxuICBHRVRfQ09PS0lFOiAnZ2V0Q29va2llJyxcbiAgR0VUX0FMTF9DT09LSUVTOiAnZ2V0Q29va2llcycsXG4gIERFTEVURV9DT09LSUU6ICdkZWxldGVDb29raWUnLFxuICBERUxFVEVfQUxMX0NPT0tJRVM6ICdkZWxldGVBbGxDb29raWVzJyxcblxuICBHRVRfQUNUSVZFX0VMRU1FTlQ6ICdnZXRBY3RpdmVFbGVtZW50JyxcbiAgRklORF9FTEVNRU5UOiAnZmluZEVsZW1lbnQnLFxuICBGSU5EX0VMRU1FTlRTOiAnZmluZEVsZW1lbnRzJyxcbiAgRklORF9FTEVNRU5UU19SRUxBVElWRTogJ2ZpbmRFbGVtZW50c1JlbGF0aXZlJyxcbiAgRklORF9DSElMRF9FTEVNRU5UOiAnZmluZENoaWxkRWxlbWVudCcsXG4gIEZJTkRfQ0hJTERfRUxFTUVOVFM6ICdmaW5kQ2hpbGRFbGVtZW50cycsXG5cbiAgQ0xFQVJfRUxFTUVOVDogJ2NsZWFyRWxlbWVudCcsXG4gIENMSUNLX0VMRU1FTlQ6ICdjbGlja0VsZW1lbnQnLFxuICBTRU5EX0tFWVNfVE9fRUxFTUVOVDogJ3NlbmRLZXlzVG9FbGVtZW50JyxcblxuICBHRVRfQ1VSUkVOVF9XSU5ET1dfSEFORExFOiAnZ2V0Q3VycmVudFdpbmRvd0hhbmRsZScsXG4gIEdFVF9XSU5ET1dfSEFORExFUzogJ2dldFdpbmRvd0hhbmRsZXMnLFxuICBHRVRfV0lORE9XX1JFQ1Q6ICdnZXRXaW5kb3dSZWN0JyxcbiAgU0VUX1dJTkRPV19SRUNUOiAnc2V0V2luZG93UmVjdCcsXG4gIE1BWElNSVpFX1dJTkRPVzogJ21heGltaXplV2luZG93JyxcbiAgTUlOSU1JWkVfV0lORE9XOiAnbWluaW1pemVXaW5kb3cnLFxuICBGVUxMU0NSRUVOX1dJTkRPVzogJ2Z1bGxzY3JlZW5XaW5kb3cnLFxuXG4gIFNXSVRDSF9UT19XSU5ET1c6ICdzd2l0Y2hUb1dpbmRvdycsXG4gIFNXSVRDSF9UT19ORVdfV0lORE9XOiAnbmV3V2luZG93JyxcbiAgU1dJVENIX1RPX0ZSQU1FOiAnc3dpdGNoVG9GcmFtZScsXG4gIFNXSVRDSF9UT19GUkFNRV9QQVJFTlQ6ICdzd2l0Y2hUb0ZyYW1lUGFyZW50JyxcbiAgR0VUX1BBR0VfU09VUkNFOiAnZ2V0UGFnZVNvdXJjZScsXG4gIEdFVF9USVRMRTogJ2dldFRpdGxlJyxcblxuICBFWEVDVVRFX1NDUklQVDogJ2V4ZWN1dGVTY3JpcHQnLFxuICBFWEVDVVRFX0FTWU5DX1NDUklQVDogJ2V4ZWN1dGVBc3luY1NjcmlwdCcsXG5cbiAgR0VUX0VMRU1FTlRfVEVYVDogJ2dldEVsZW1lbnRUZXh0JyxcbiAgR0VUX0NPTVBVVEVEX1JPTEU6ICdnZXRBcmlhUm9sZScsXG4gIEdFVF9DT01QVVRFRF9MQUJFTDogJ2dldEFjY2Vzc2libGVOYW1lJyxcbiAgR0VUX0VMRU1FTlRfVEFHX05BTUU6ICdnZXRFbGVtZW50VGFnTmFtZScsXG4gIElTX0VMRU1FTlRfU0VMRUNURUQ6ICdpc0VsZW1lbnRTZWxlY3RlZCcsXG4gIElTX0VMRU1FTlRfRU5BQkxFRDogJ2lzRWxlbWVudEVuYWJsZWQnLFxuICBJU19FTEVNRU5UX0RJU1BMQVlFRDogJ2lzRWxlbWVudERpc3BsYXllZCcsXG4gIEdFVF9FTEVNRU5UX1JFQ1Q6ICdnZXRFbGVtZW50UmVjdCcsXG4gIEdFVF9FTEVNRU5UX0FUVFJJQlVURTogJ2dldEVsZW1lbnRBdHRyaWJ1dGUnLFxuICBHRVRfRE9NX0FUVFJJQlVURTogJ2dldERvbUF0dHJpYnV0ZScsXG4gIEdFVF9FTEVNRU5UX1ZBTFVFX09GX0NTU19QUk9QRVJUWTogJ2dldEVsZW1lbnRWYWx1ZU9mQ3NzUHJvcGVydHknLFxuICBHRVRfRUxFTUVOVF9QUk9QRVJUWTogJ2dldEVsZW1lbnRQcm9wZXJ0eScsXG5cbiAgU0NSRUVOU0hPVDogJ3NjcmVlbnNob3QnLFxuICBUQUtFX0VMRU1FTlRfU0NSRUVOU0hPVDogJ3Rha2VFbGVtZW50U2NyZWVuc2hvdCcsXG5cbiAgUFJJTlRfUEFHRTogJ3ByaW50UGFnZScsXG5cbiAgR0VUX1RJTUVPVVQ6ICdnZXRUaW1lb3V0JyxcbiAgU0VUX1RJTUVPVVQ6ICdzZXRUaW1lb3V0JyxcblxuICBBQ0NFUFRfQUxFUlQ6ICdhY2NlcHRBbGVydCcsXG4gIERJU01JU1NfQUxFUlQ6ICdkaXNtaXNzQWxlcnQnLFxuICBHRVRfQUxFUlRfVEVYVDogJ2dldEFsZXJ0VGV4dCcsXG4gIFNFVF9BTEVSVF9URVhUOiAnc2V0QWxlcnRWYWx1ZScsXG5cbiAgLy8gU2hhZG93IERPTSBDb21tYW5kc1xuICBHRVRfU0hBRE9XX1JPT1Q6ICdnZXRTaGFkb3dSb290JyxcbiAgRklORF9FTEVNRU5UX0ZST01fU0hBRE9XUk9PVDogJ2ZpbmRFbGVtZW50RnJvbVNoYWRvd1Jvb3QnLFxuICBGSU5EX0VMRU1FTlRTX0ZST01fU0hBRE9XUk9PVDogJ2ZpbmRFbGVtZW50c0Zyb21TaGFkb3dSb290JyxcblxuICAvLyBWaXJ0dWFsIEF1dGhlbnRpY2F0b3IgQ29tbWFuZHNcbiAgQUREX1ZJUlRVQUxfQVVUSEVOVElDQVRPUjogJ2FkZFZpcnR1YWxBdXRoZW50aWNhdG9yJyxcbiAgUkVNT1ZFX1ZJUlRVQUxfQVVUSEVOVElDQVRPUjogJ3JlbW92ZVZpcnR1YWxBdXRoZW50aWNhdG9yJyxcbiAgQUREX0NSRURFTlRJQUw6ICdhZGRDcmVkZW50aWFsJyxcbiAgR0VUX0NSRURFTlRJQUxTOiAnZ2V0Q3JlZGVudGlhbHMnLFxuICBSRU1PVkVfQ1JFREVOVElBTDogJ3JlbW92ZUNyZWRlbnRpYWwnLFxuICBSRU1PVkVfQUxMX0NSRURFTlRJQUxTOiAncmVtb3ZlQWxsQ3JlZGVudGlhbHMnLFxuICBTRVRfVVNFUl9WRVJJRklFRDogJ3NldFVzZXJWZXJpZmllZCcsXG5cbiAgR0VUX0FWQUlMQUJMRV9MT0dfVFlQRVM6ICdnZXRBdmFpbGFibGVMb2dUeXBlcycsXG4gIEdFVF9MT0c6ICdnZXRMb2cnLFxuXG4gIC8vIE5vbi1zdGFuZGFyZCBjb21tYW5kcyB1c2VkIGJ5IHRoZSBzdGFuZGFsb25lIFNlbGVuaXVtIHNlcnZlci5cbiAgVVBMT0FEX0ZJTEU6ICd1cGxvYWRGaWxlJyxcblxuICBBQ1RJT05TOiAnYWN0aW9ucycsXG4gIENMRUFSX0FDVElPTlM6ICdjbGVhckFjdGlvbnMnLFxufVxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGV4ZWN1dGlvbiBvZiBXZWJEcml2ZXIge0BsaW5rIENvbW1hbmQgY29tbWFuZHN9LlxuICogQHJlY29yZFxuICovXG5jbGFzcyBFeGVjdXRvciB7XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZ2l2ZW4ge0Bjb2RlIGNvbW1hbmR9LiBJZiB0aGVyZSBpcyBhbiBlcnJvciBleGVjdXRpbmcgdGhlXG4gICAqIGNvbW1hbmQsIHRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgb2ZmZW5kaW5nIGVycm9yLlxuICAgKiBPdGhlcndpc2UsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2l0aCBhIG51bGwgRXJyb3IgYW5kIG5vbi1udWxsXG4gICAqIHJlc3BvbnNlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHshQ29tbWFuZH0gY29tbWFuZCBUaGUgY29tbWFuZCB0byBleGVjdXRlLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTw/Pn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgY29tbWFuZFxuICAgKiAgICAgcmVzdWx0LlxuICAgKi9cbiAgZXhlY3V0ZShjb21tYW5kKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbW1hbmQsXG4gIE5hbWUsXG4gIEV4ZWN1dG9yLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNPYmplY3QgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKlxuICogVGhlIGJhc2UgV2ViRHJpdmVyIGVycm9yIHR5cGUuIFRoaXMgZXJyb3IgdHlwZSBpcyBvbmx5IHVzZWQgZGlyZWN0bHkgd2hlbiBhXG4gKiBtb3JlIGFwcHJvcHJpYXRlIGNhdGVnb3J5IGlzIG5vdCBkZWZpbmVkIGZvciB0aGUgb2ZmZW5kaW5nIGVycm9yLlxuICovXG5jbGFzcyBXZWJEcml2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcblxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWVcblxuICAgIC8qKlxuICAgICAqIEEgc3RhY2t0cmFjZSByZXBvcnRlZCBieSB0aGUgcmVtb3RlIHdlYmRyaXZlciBlbmRwb2ludCB0aGF0IGluaXRpYWxseVxuICAgICAqIHJlcG9ydGVkIHRoaXMgZXJyb3IuIFRoaXMgcHJvcGVydHkgd2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIHJlbW90ZVxuICAgICAqIGVuZCBkaWQgbm90IHByb3ZpZGUgYSBzdGFja3RyYWNlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZW1vdGVTdGFja3RyYWNlID0gJydcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGUgc2hhZG93IHJvb3QgaXMgbm8gbG9uZ2VyIGF0dGFjaGVkIHRvIHRoZSBET01cbiAqL1xuY2xhc3MgRGV0YWNoZWRTaGFkb3dSb290RXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgYSB7QGxpbmtwbGFpbiAuL3dlYmRyaXZlci5XZWJFbGVtZW50I2NsaWNrIGNsaWNrIGNvbW1hbmR9IGNvdWxkIG5vdFxuICogY29tcGxldGVkIGJlY2F1c2UgdGhlIGNsaWNrIHRhcmdldCBpcyBvYnNjdXJlZCBieSBvdGhlciBlbGVtZW50cyBvbiB0aGVcbiAqIHBhZ2UuXG4gKi9cbmNsYXNzIEVsZW1lbnRDbGlja0ludGVyY2VwdGVkRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIHNlbGVjdCBhbiBlbGVtZW50IHRoYXQgY2Fubm90IGJlIHNlbGVjdGVkLlxuICovXG5jbGFzcyBFbGVtZW50Tm90U2VsZWN0YWJsZUVycm9yIGV4dGVuZHMgV2ViRHJpdmVyRXJyb3Ige1xuICAvKiogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZXJyb3IgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGFueS4gKi9cbiAgY29uc3RydWN0b3Iob3B0X2Vycm9yKSB7XG4gICAgc3VwZXIob3B0X2Vycm9yKVxuICB9XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIGEgY29tbWFuZCBjb3VsZCBub3QgYmUgY29tcGxldGVkIGJlY2F1c2UgdGhlIHRhcmdldCBlbGVtZW50IGlzXG4gKiBub3QgcG9pbnRlciBvciBrZXlib2FyZCBpbnRlcmFjdGFibGUuIFRoaXMgd2lsbCBvZnRlbiBvY2N1ciBpZiBhbiBlbGVtZW50XG4gKiBpcyBwcmVzZW50IGluIHRoZSBET00sIGJ1dCBub3QgcmVuZGVyZWQgKGkuZS4gaXRzIENTUyBzdHlsZSBoYXNcbiAqIFwiZGlzcGxheTogbm9uZVwiKS5cbiAqL1xuY2xhc3MgRWxlbWVudE5vdEludGVyYWN0YWJsZUVycm9yIGV4dGVuZHMgV2ViRHJpdmVyRXJyb3Ige1xuICAvKiogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZXJyb3IgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGFueS4gKi9cbiAgY29uc3RydWN0b3Iob3B0X2Vycm9yKSB7XG4gICAgc3VwZXIob3B0X2Vycm9yKVxuICB9XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIGEgbmF2aWdhdGlvbiBldmVudCBjYXVzZWQgdGhlIGJyb3dzZXIgdG8gZ2VuZXJhdGUgYSBjZXJ0aWZpY2F0ZVxuICogd2FybmluZy4gVGhpcyBpcyB1c3VhbGx5IGNhdXNlZCBieSBhbiBleHBpcmVkIG9yIGludmFsaWQgVExTIGNlcnRpZmljYXRlLlxuICovXG5jbGFzcyBJbnNlY3VyZUNlcnRpZmljYXRlRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byBhIGNvbW1hbmQgYXJlIGVpdGhlciBpbnZhbGlkIG9yIG1hbGZvcm1lZC5cbiAqL1xuY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbGxlZ2FsIGF0dGVtcHQgd2FzIG1hZGUgdG8gc2V0IGEgY29va2llIHVuZGVyIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuXG4gKiB0aGUgY3VycmVudCBwYWdlLlxuICovXG5jbGFzcyBJbnZhbGlkQ29va2llRG9tYWluRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY29vcmRpbmF0ZXMgcHJvdmlkZWQgdG8gYW4gaW50ZXJhY3Rpb25zIG9wZXJhdGlvbiBhcmUgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZENvb3JkaW5hdGVzRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbGVtZW50IGNvbW1hbmQgY291bGQgbm90IGJlIGNvbXBsZXRlZCBiZWNhdXNlIHRoZSBlbGVtZW50IGlzIGluIGFuXG4gKiBpbnZhbGlkIHN0YXRlLCBlLmcuIGF0dGVtcHRpbmcgdG8gY2xpY2sgYW4gZWxlbWVudCB0aGF0IGlzIG5vIGxvbmdlciBhdHRhY2hlZFxuICogdG8gdGhlIGRvY3VtZW50LlxuICovXG5jbGFzcyBJbnZhbGlkRWxlbWVudFN0YXRlRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudCB3YXMgYW4gaW52YWxpZCBzZWxlY3Rvci5cbiAqL1xuY2xhc3MgSW52YWxpZFNlbGVjdG9yRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBPY2N1cnMgd2hlbiBhIGNvbW1hbmQgaXMgZGlyZWN0ZWQgdG8gYSBzZXNzaW9uIHRoYXQgZG9lcyBub3QgZXhpc3QuXG4gKi9cbmNsYXNzIE5vU3VjaFNlc3Npb25FcnJvciBleHRlbmRzIFdlYkRyaXZlckVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGV4ZWN1dGluZyBKYXZhU2NyaXB0IHN1cHBsaWVkIGJ5IHRoZSB1c2VyLlxuICovXG5jbGFzcyBKYXZhc2NyaXB0RXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgdGFyZ2V0IGZvciBtb3VzZSBpbnRlcmFjdGlvbiBpcyBub3QgaW4gdGhlIGJyb3dzZXLigJlzIHZpZXdwb3J0IGFuZCBjYW5ub3RcbiAqIGJlIGJyb3VnaHQgaW50byB0aGF0IHZpZXdwb3J0LlxuICovXG5jbGFzcyBNb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIFdlYkRyaXZlckVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gb3BlcmF0ZSBvbiBhIG1vZGFsIGRpYWxvZyB3aGVuIG9uZSB3YXMgbm90IG9wZW4uXG4gKi9cbmNsYXNzIE5vU3VjaEFsZXJ0RXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgYSBuYW1lZCBjb29raWUgY291bGQgbm90IGJlIGZvdW5kIGluIHRoZSBjb29raWUgamFyIGZvciB0aGVcbiAqIGN1cnJlbnRseSBzZWxlY3RlZCBkb2N1bWVudC5cbiAqL1xuY2xhc3MgTm9TdWNoQ29va2llRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbGVtZW50IGNvdWxkIG5vdCBiZSBsb2NhdGVkIG9uIHRoZSBwYWdlIHVzaW5nIHRoZSBnaXZlbiBzZWFyY2hcbiAqIHBhcmFtZXRlcnMuXG4gKi9cbmNsYXNzIE5vU3VjaEVsZW1lbnRFcnJvciBleHRlbmRzIFdlYkRyaXZlckVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEEgU2hhZG93Um9vdCBjb3VsZCBub3QgYmUgbG9jYXRlZCBvbiB0aGUgZWxlbWVudFxuICovXG5jbGFzcyBOb1N1Y2hTaGFkb3dSb290RXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBIHJlcXVlc3QgdG8gc3dpdGNoIHRvIGEgZnJhbWUgY291bGQgbm90IGJlIHNhdGlzZmllZCBiZWNhdXNlIHRoZSBmcmFtZVxuICogY291bGQgbm90IGJlIGZvdW5kLlxuICovXG5jbGFzcyBOb1N1Y2hGcmFtZUVycm9yIGV4dGVuZHMgV2ViRHJpdmVyRXJyb3Ige1xuICAvKiogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZXJyb3IgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGFueS4gKi9cbiAgY29uc3RydWN0b3Iob3B0X2Vycm9yKSB7XG4gICAgc3VwZXIob3B0X2Vycm9yKVxuICB9XG59XG5cbi8qKlxuICogQSByZXF1ZXN0IHRvIHN3aXRjaCB0byBhIHdpbmRvdyBjb3VsZCBub3QgYmUgc2F0aXNmaWVkIGJlY2F1c2UgdGhlIHdpbmRvd1xuICogY291bGQgbm90IGJlIGZvdW5kLlxuICovXG5jbGFzcyBOb1N1Y2hXaW5kb3dFcnJvciBleHRlbmRzIFdlYkRyaXZlckVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEEgc2NyaXB0IGRpZCBub3QgY29tcGxldGUgYmVmb3JlIGl0cyB0aW1lb3V0IGV4cGlyZWQuXG4gKi9cbmNsYXNzIFNjcmlwdFRpbWVvdXRFcnJvciBleHRlbmRzIFdlYkRyaXZlckVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEEgbmV3IHNlc3Npb24gY291bGQgbm90IGJlIGNyZWF0ZWQuXG4gKi9cbmNsYXNzIFNlc3Npb25Ob3RDcmVhdGVkRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbGVtZW50IGNvbW1hbmQgZmFpbGVkIGJlY2F1c2UgdGhlIHJlZmVyZW5jZWQgZWxlbWVudCBpcyBubyBsb25nZXJcbiAqIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gKi9cbmNsYXNzIFN0YWxlRWxlbWVudFJlZmVyZW5jZUVycm9yIGV4dGVuZHMgV2ViRHJpdmVyRXJyb3Ige1xuICAvKiogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZXJyb3IgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGFueS4gKi9cbiAgY29uc3RydWN0b3Iob3B0X2Vycm9yKSB7XG4gICAgc3VwZXIob3B0X2Vycm9yKVxuICB9XG59XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIGRpZCBub3QgY29tcGxldGUgYmVmb3JlIGl0cyB0aW1lb3V0IGV4cGlyZWQuXG4gKi9cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIFdlYkRyaXZlckVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEEgcmVxdWVzdCB0byBzZXQgYSBjb29raWXigJlzIHZhbHVlIGNvdWxkIG5vdCBiZSBzYXRpc2ZpZWQuXG4gKi9cbmNsYXNzIFVuYWJsZVRvU2V0Q29va2llRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBBIHNjcmVlbiBjYXB0dXJlIG9wZXJhdGlvbiB3YXMgbm90IHBvc3NpYmxlLlxuICovXG5jbGFzcyBVbmFibGVUb0NhcHR1cmVTY3JlZW5FcnJvciBleHRlbmRzIFdlYkRyaXZlckVycm9yIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2Vycm9yIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBhbnkuICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvcikge1xuICAgIHN1cGVyKG9wdF9lcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEEgbW9kYWwgZGlhbG9nIHdhcyBvcGVuLCBibG9ja2luZyB0aGlzIG9wZXJhdGlvbi5cbiAqL1xuY2xhc3MgVW5leHBlY3RlZEFsZXJ0T3BlbkVycm9yIGV4dGVuZHMgV2ViRHJpdmVyRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZXJyb3IgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGFueS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdGV4dCB0aGUgdGV4dCBvZiB0aGUgb3BlbiBkaWFsb2csIGlmIGF2YWlsYWJsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9lcnJvciwgb3B0X3RleHQpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG5cbiAgICAvKiogQHByaXZhdGUgeyhzdHJpbmd8dW5kZWZpbmVkKX0gKi9cbiAgICB0aGlzLnRleHRfID0gb3B0X3RleHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHsoc3RyaW5nfHVuZGVmaW5lZCl9IFRoZSB0ZXh0IGRpc3BsYXllZCB3aXRoIHRoZSB1bmhhbmRsZWQgYWxlcnQsXG4gICAqICAgICBpZiBhdmFpbGFibGUuXG4gICAqL1xuICBnZXRBbGVydFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dF9cbiAgfVxufVxuXG4vKipcbiAqIEEgY29tbWFuZCBjb3VsZCBub3QgYmUgZXhlY3V0ZWQgYmVjYXVzZSB0aGUgcmVtb3RlIGVuZCBpcyBub3QgYXdhcmUgb2YgaXQuXG4gKi9cbmNsYXNzIFVua25vd25Db21tYW5kRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgcmVxdWVzdGVkIGNvbW1hbmQgbWF0Y2hlZCBhIGtub3duIFVSTCBidXQgZGlkIG5vdCBtYXRjaCBhbiBtZXRob2QgZm9yXG4gKiB0aGF0IFVSTC5cbiAqL1xuY2xhc3MgVW5rbm93bk1ldGhvZEVycm9yIGV4dGVuZHMgV2ViRHJpdmVyRXJyb3Ige1xuICAvKiogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZXJyb3IgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGFueS4gKi9cbiAgY29uc3RydWN0b3Iob3B0X2Vycm9yKSB7XG4gICAgc3VwZXIob3B0X2Vycm9yKVxuICB9XG59XG5cbi8qKlxuICogUmVwb3J0cyBhbiB1bnN1cHBvcnRlZCBvcGVyYXRpb24uXG4gKi9cbmNsYXNzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IgZXh0ZW5kcyBXZWJEcml2ZXJFcnJvciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lcnJvciB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgYW55LiAqL1xuICBjb25zdHJ1Y3RvcihvcHRfZXJyb3IpIHtcbiAgICBzdXBlcihvcHRfZXJyb3IpXG4gIH1cbn1cblxuLy8gVE9ETyhqbGV5YmEpOiBEZWZpbmUgVW5rbm93bkVycm9yIGFzIGFuIGFsaWFzIG9mIFdlYkRyaXZlckVycm9yP1xuXG4vKipcbiAqIEVudW0gb2YgbGVnYWN5IGVycm9yIGNvZGVzLlxuICogVE9ETzogcmVtb3ZlIHRoaXMgd2hlbiBhbGwgY29kZSBwYXRocyBoYXZlIGJlZW4gc3dpdGNoZWQgdG8gdGhlIG5ldyBlcnJvclxuICogdHlwZXMuXG4gKiBAZGVwcmVjYXRlZFxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgRXJyb3JDb2RlID0ge1xuICBTVUNDRVNTOiAwLFxuICBOT19TVUNIX1NFU1NJT046IDYsXG4gIE5PX1NVQ0hfRUxFTUVOVDogNyxcbiAgTk9fU1VDSF9GUkFNRTogOCxcbiAgVU5LTk9XTl9DT01NQU5EOiA5LFxuICBVTlNVUFBPUlRFRF9PUEVSQVRJT046IDksXG4gIFNUQUxFX0VMRU1FTlRfUkVGRVJFTkNFOiAxMCxcbiAgRUxFTUVOVF9OT1RfVklTSUJMRTogMTEsXG4gIElOVkFMSURfRUxFTUVOVF9TVEFURTogMTIsXG4gIFVOS05PV05fRVJST1I6IDEzLFxuICBFTEVNRU5UX05PVF9TRUxFQ1RBQkxFOiAxNSxcbiAgSkFWQVNDUklQVF9FUlJPUjogMTcsXG4gIFhQQVRIX0xPT0tVUF9FUlJPUjogMTksXG4gIFRJTUVPVVQ6IDIxLFxuICBOT19TVUNIX1dJTkRPVzogMjMsXG4gIElOVkFMSURfQ09PS0lFX0RPTUFJTjogMjQsXG4gIFVOQUJMRV9UT19TRVRfQ09PS0lFOiAyNSxcbiAgVU5FWFBFQ1RFRF9BTEVSVF9PUEVOOiAyNixcbiAgTk9fU1VDSF9BTEVSVDogMjcsXG4gIFNDUklQVF9USU1FT1VUOiAyOCxcbiAgSU5WQUxJRF9FTEVNRU5UX0NPT1JESU5BVEVTOiAyOSxcbiAgSU1FX05PVF9BVkFJTEFCTEU6IDMwLFxuICBJTUVfRU5HSU5FX0FDVElWQVRJT05fRkFJTEVEOiAzMSxcbiAgSU5WQUxJRF9TRUxFQ1RPUl9FUlJPUjogMzIsXG4gIFNFU1NJT05fTk9UX0NSRUFURUQ6IDMzLFxuICBNT1ZFX1RBUkdFVF9PVVRfT0ZfQk9VTkRTOiAzNCxcbiAgU1FMX0RBVEFCQVNFX0VSUk9SOiAzNSxcbiAgSU5WQUxJRF9YUEFUSF9TRUxFQ1RPUjogNTEsXG4gIElOVkFMSURfWFBBVEhfU0VMRUNUT1JfUkVUVVJOX1RZUEU6IDUyLFxuICBFTEVNRU5UX05PVF9JTlRFUkFDVEFCTEU6IDYwLFxuICBJTlZBTElEX0FSR1VNRU5UOiA2MSxcbiAgTk9fU1VDSF9DT09LSUU6IDYyLFxuICBVTkFCTEVfVE9fQ0FQVFVSRV9TQ1JFRU46IDYzLFxuICBFTEVNRU5UX0NMSUNLX0lOVEVSQ0VQVEVEOiA2NCxcbiAgTUVUSE9EX05PVF9BTExPV0VEOiA0MDUsXG59XG5cbmNvbnN0IExFR0FDWV9FUlJPUl9DT0RFX1RPX1RZUEUgPSBuZXcgTWFwKFtcbiAgW0Vycm9yQ29kZS5OT19TVUNIX1NFU1NJT04sIE5vU3VjaFNlc3Npb25FcnJvcl0sXG4gIFtFcnJvckNvZGUuTk9fU1VDSF9FTEVNRU5ULCBOb1N1Y2hFbGVtZW50RXJyb3JdLFxuICBbRXJyb3JDb2RlLk5PX1NVQ0hfRlJBTUUsIE5vU3VjaEZyYW1lRXJyb3JdLFxuICBbRXJyb3JDb2RlLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcl0sXG4gIFtFcnJvckNvZGUuU1RBTEVfRUxFTUVOVF9SRUZFUkVOQ0UsIFN0YWxlRWxlbWVudFJlZmVyZW5jZUVycm9yXSxcbiAgW0Vycm9yQ29kZS5JTlZBTElEX0VMRU1FTlRfU1RBVEUsIEludmFsaWRFbGVtZW50U3RhdGVFcnJvcl0sXG4gIFtFcnJvckNvZGUuVU5LTk9XTl9FUlJPUiwgV2ViRHJpdmVyRXJyb3JdLFxuICBbRXJyb3JDb2RlLkVMRU1FTlRfTk9UX1NFTEVDVEFCTEUsIEVsZW1lbnROb3RTZWxlY3RhYmxlRXJyb3JdLFxuICBbRXJyb3JDb2RlLkpBVkFTQ1JJUFRfRVJST1IsIEphdmFzY3JpcHRFcnJvcl0sXG4gIFtFcnJvckNvZGUuWFBBVEhfTE9PS1VQX0VSUk9SLCBJbnZhbGlkU2VsZWN0b3JFcnJvcl0sXG4gIFtFcnJvckNvZGUuVElNRU9VVCwgVGltZW91dEVycm9yXSxcbiAgW0Vycm9yQ29kZS5OT19TVUNIX1dJTkRPVywgTm9TdWNoV2luZG93RXJyb3JdLFxuICBbRXJyb3JDb2RlLklOVkFMSURfQ09PS0lFX0RPTUFJTiwgSW52YWxpZENvb2tpZURvbWFpbkVycm9yXSxcbiAgW0Vycm9yQ29kZS5VTkFCTEVfVE9fU0VUX0NPT0tJRSwgVW5hYmxlVG9TZXRDb29raWVFcnJvcl0sXG4gIFtFcnJvckNvZGUuVU5FWFBFQ1RFRF9BTEVSVF9PUEVOLCBVbmV4cGVjdGVkQWxlcnRPcGVuRXJyb3JdLFxuICBbRXJyb3JDb2RlLk5PX1NVQ0hfQUxFUlQsIE5vU3VjaEFsZXJ0RXJyb3JdLFxuICBbRXJyb3JDb2RlLlNDUklQVF9USU1FT1VULCBTY3JpcHRUaW1lb3V0RXJyb3JdLFxuICBbRXJyb3JDb2RlLklOVkFMSURfRUxFTUVOVF9DT09SRElOQVRFUywgSW52YWxpZENvb3JkaW5hdGVzRXJyb3JdLFxuICBbRXJyb3JDb2RlLklOVkFMSURfU0VMRUNUT1JfRVJST1IsIEludmFsaWRTZWxlY3RvckVycm9yXSxcbiAgW0Vycm9yQ29kZS5TRVNTSU9OX05PVF9DUkVBVEVELCBTZXNzaW9uTm90Q3JlYXRlZEVycm9yXSxcbiAgW0Vycm9yQ29kZS5NT1ZFX1RBUkdFVF9PVVRfT0ZfQk9VTkRTLCBNb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFcnJvcl0sXG4gIFtFcnJvckNvZGUuSU5WQUxJRF9YUEFUSF9TRUxFQ1RPUiwgSW52YWxpZFNlbGVjdG9yRXJyb3JdLFxuICBbRXJyb3JDb2RlLklOVkFMSURfWFBBVEhfU0VMRUNUT1JfUkVUVVJOX1RZUEUsIEludmFsaWRTZWxlY3RvckVycm9yXSxcbiAgW0Vycm9yQ29kZS5FTEVNRU5UX05PVF9JTlRFUkFDVEFCTEUsIEVsZW1lbnROb3RJbnRlcmFjdGFibGVFcnJvcl0sXG4gIFtFcnJvckNvZGUuSU5WQUxJRF9BUkdVTUVOVCwgSW52YWxpZEFyZ3VtZW50RXJyb3JdLFxuICBbRXJyb3JDb2RlLk5PX1NVQ0hfQ09PS0lFLCBOb1N1Y2hDb29raWVFcnJvcl0sXG4gIFtFcnJvckNvZGUuVU5BQkxFX1RPX0NBUFRVUkVfU0NSRUVOLCBVbmFibGVUb0NhcHR1cmVTY3JlZW5FcnJvcl0sXG4gIFtFcnJvckNvZGUuRUxFTUVOVF9DTElDS19JTlRFUkNFUFRFRCwgRWxlbWVudENsaWNrSW50ZXJjZXB0ZWRFcnJvcl0sXG4gIFtFcnJvckNvZGUuTUVUSE9EX05PVF9BTExPV0VELCBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yXSxcbl0pXG5cbmNvbnN0IEVSUk9SX0NPREVfVE9fVFlQRSA9IG5ldyBNYXAoW1xuICBbJ3Vua25vd24gZXJyb3InLCBXZWJEcml2ZXJFcnJvcl0sXG4gIFsnZGV0YWNoZWQgc2hhZG93IHJvb3QnLCBEZXRhY2hlZFNoYWRvd1Jvb3RFcnJvcl0sXG4gIFsnZWxlbWVudCBjbGljayBpbnRlcmNlcHRlZCcsIEVsZW1lbnRDbGlja0ludGVyY2VwdGVkRXJyb3JdLFxuICBbJ2VsZW1lbnQgbm90IGludGVyYWN0YWJsZScsIEVsZW1lbnROb3RJbnRlcmFjdGFibGVFcnJvcl0sXG4gIFsnZWxlbWVudCBub3Qgc2VsZWN0YWJsZScsIEVsZW1lbnROb3RTZWxlY3RhYmxlRXJyb3JdLFxuICBbJ2luc2VjdXJlIGNlcnRpZmljYXRlJywgSW5zZWN1cmVDZXJ0aWZpY2F0ZUVycm9yXSxcbiAgWydpbnZhbGlkIGFyZ3VtZW50JywgSW52YWxpZEFyZ3VtZW50RXJyb3JdLFxuICBbJ2ludmFsaWQgY29va2llIGRvbWFpbicsIEludmFsaWRDb29raWVEb21haW5FcnJvcl0sXG4gIFsnaW52YWxpZCBjb29yZGluYXRlcycsIEludmFsaWRDb29yZGluYXRlc0Vycm9yXSxcbiAgWydpbnZhbGlkIGVsZW1lbnQgc3RhdGUnLCBJbnZhbGlkRWxlbWVudFN0YXRlRXJyb3JdLFxuICBbJ2ludmFsaWQgc2VsZWN0b3InLCBJbnZhbGlkU2VsZWN0b3JFcnJvcl0sXG4gIFsnaW52YWxpZCBzZXNzaW9uIGlkJywgTm9TdWNoU2Vzc2lvbkVycm9yXSxcbiAgWydqYXZhc2NyaXB0IGVycm9yJywgSmF2YXNjcmlwdEVycm9yXSxcbiAgWydtb3ZlIHRhcmdldCBvdXQgb2YgYm91bmRzJywgTW92ZVRhcmdldE91dE9mQm91bmRzRXJyb3JdLFxuICBbJ25vIHN1Y2ggYWxlcnQnLCBOb1N1Y2hBbGVydEVycm9yXSxcbiAgWydubyBzdWNoIGNvb2tpZScsIE5vU3VjaENvb2tpZUVycm9yXSxcbiAgWydubyBzdWNoIGVsZW1lbnQnLCBOb1N1Y2hFbGVtZW50RXJyb3JdLFxuICBbJ25vIHN1Y2ggZnJhbWUnLCBOb1N1Y2hGcmFtZUVycm9yXSxcbiAgWydubyBzdWNoIHNoYWRvdyByb290JywgTm9TdWNoU2hhZG93Um9vdEVycm9yXSxcbiAgWydubyBzdWNoIHdpbmRvdycsIE5vU3VjaFdpbmRvd0Vycm9yXSxcbiAgWydzY3JpcHQgdGltZW91dCcsIFNjcmlwdFRpbWVvdXRFcnJvcl0sXG4gIFsnc2Vzc2lvbiBub3QgY3JlYXRlZCcsIFNlc3Npb25Ob3RDcmVhdGVkRXJyb3JdLFxuICBbJ3N0YWxlIGVsZW1lbnQgcmVmZXJlbmNlJywgU3RhbGVFbGVtZW50UmVmZXJlbmNlRXJyb3JdLFxuICBbJ3RpbWVvdXQnLCBUaW1lb3V0RXJyb3JdLFxuICBbJ3VuYWJsZSB0byBzZXQgY29va2llJywgVW5hYmxlVG9TZXRDb29raWVFcnJvcl0sXG4gIFsndW5hYmxlIHRvIGNhcHR1cmUgc2NyZWVuJywgVW5hYmxlVG9DYXB0dXJlU2NyZWVuRXJyb3JdLFxuICBbJ3VuZXhwZWN0ZWQgYWxlcnQgb3BlbicsIFVuZXhwZWN0ZWRBbGVydE9wZW5FcnJvcl0sXG4gIFsndW5rbm93biBjb21tYW5kJywgVW5rbm93bkNvbW1hbmRFcnJvcl0sXG4gIFsndW5rbm93biBtZXRob2QnLCBVbmtub3duTWV0aG9kRXJyb3JdLFxuICBbJ3Vuc3VwcG9ydGVkIG9wZXJhdGlvbicsIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3JdLFxuXSlcblxuY29uc3QgVFlQRV9UT19FUlJPUl9DT0RFID0gbmV3IE1hcCgpXG5FUlJPUl9DT0RFX1RPX1RZUEUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICBUWVBFX1RPX0VSUk9SX0NPREUuc2V0KHZhbHVlLCBrZXkpXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gZXJyIFRoZSBlcnJvciB0byBlbmNvZGUuXG4gKiBAcmV0dXJuIHt7ZXJyb3I6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nfX0gdGhlIGVuY29kZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUVycm9yKGVycikge1xuICBsZXQgdHlwZSA9IFdlYkRyaXZlckVycm9yXG4gIGlmIChcbiAgICBlcnIgaW5zdGFuY2VvZiBXZWJEcml2ZXJFcnJvciAmJlxuICAgIFRZUEVfVE9fRVJST1JfQ09ERS5oYXMoZXJyLmNvbnN0cnVjdG9yKVxuICApIHtcbiAgICB0eXBlID0gZXJyLmNvbnN0cnVjdG9yXG4gIH1cblxuICBsZXQgbWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnIgKyAnJ1xuXG4gIGxldCBjb2RlID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChUWVBFX1RPX0VSUk9SX0NPREUuZ2V0KHR5cGUpKVxuICByZXR1cm4geyBlcnJvcjogY29kZSwgbWVzc2FnZTogbWVzc2FnZSB9XG59XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgZXJyb3IgcmVzcG9uc2Ugb2JqZWN0IGFjY29yZGluZyB0byB0aGVcbiAqIFczQyBXZWJEcml2ZXIgc3BlYy5cbiAqXG4gKiBAcGFyYW0gez99IGRhdGEgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBkYXRhIG9iamVjdCBpcyBhIHZhbGlkIGVycm9yXG4gKiAgICAgcmVzcG9uc2UuXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvd2ViZHJpdmVyLXNwZWMuaHRtbCNwcm90b2NvbFxuICovXG5mdW5jdGlvbiBpc0Vycm9yUmVzcG9uc2UoZGF0YSkge1xuICByZXR1cm4gaXNPYmplY3QoZGF0YSkgJiYgdHlwZW9mIGRhdGEuZXJyb3IgPT09ICdzdHJpbmcnXG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGNvZGVkIGZyb20gdGhlIFczQyBwcm90b2NvbC4gQSBnZW5lcmljIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiBpZiB0aGUgcHJvdmlkZWQgYGRhdGFgIGlzIG5vdCBhIHZhbGlkIGVuY29kZWQgZXJyb3IuXG4gKlxuICogQHBhcmFtIHt7ZXJyb3I6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nfX0gZGF0YSBUaGUgZXJyb3IgZGF0YSB0byBkZWNvZGUuXG4gKiBAdGhyb3dzIHtXZWJEcml2ZXJFcnJvcn0gdGhlIGRlY29kZWQgZXJyb3IuXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvd2ViZHJpdmVyLXNwZWMuaHRtbCNwcm90b2NvbFxuICovXG5mdW5jdGlvbiB0aHJvd0RlY29kZWRFcnJvcihkYXRhKSB7XG4gIGlmIChpc0Vycm9yUmVzcG9uc2UoZGF0YSkpIHtcbiAgICBsZXQgY3RvciA9IEVSUk9SX0NPREVfVE9fVFlQRS5nZXQoZGF0YS5lcnJvcikgfHwgV2ViRHJpdmVyRXJyb3JcbiAgICBsZXQgZXJyID0gbmV3IGN0b3IoZGF0YS5tZXNzYWdlKVxuICAgIC8vIFRPRE8oamxleWJhKTogcmVtb3ZlIHdoaWNoZXZlciBjYXNlIGlzIGV4Y2x1ZGVkIGZyb20gdGhlIGZpbmFsIFczQyBzcGVjLlxuICAgIGlmICh0eXBlb2YgZGF0YS5zdGFja3RyYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyLnJlbW90ZVN0YWNrdHJhY2UgPSBkYXRhLnN0YWNrdHJhY2VcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLnN0YWNrVHJhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnIucmVtb3RlU3RhY2t0cmFjZSA9IGRhdGEuc3RhY2tUcmFjZVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfVxuICB0aHJvdyBuZXcgV2ViRHJpdmVyRXJyb3IoJ1Vua25vd24gZXJyb3I6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhKSlcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBsZWdhY3kgcmVzcG9uc2UgZnJvbSB0aGUgU2VsZW5pdW0gMi4wIHdpcmUgcHJvdG9jb2wgZm9yIGFuIGVycm9yLlxuICogQHBhcmFtIHsqfSByZXNwb25zZU9iaiB0aGUgcmVzcG9uc2Ugb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Kn0gcmVzcG9uc2VPYmogdGhlIG9yaWdpbmFsIHJlc3BvbnNlIGlmIGl0IGRvZXMgbm90IGRlZmluZSBhbiBlcnJvci5cbiAqIEB0aHJvd3Mge1dlYkRyaXZlckVycm9yfSBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGRlZmluZXMgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTGVnYWN5UmVzcG9uc2UocmVzcG9uc2VPYmopIHtcbiAgLy8gSGFuZGxlIHRoZSBsZWdhY3kgU2VsZW5pdW0gZXJyb3IgcmVzcG9uc2UgZm9ybWF0LlxuICBpZiAoXG4gICAgaXNPYmplY3QocmVzcG9uc2VPYmopICYmXG4gICAgdHlwZW9mIHJlc3BvbnNlT2JqLnN0YXR1cyA9PT0gJ251bWJlcicgJiZcbiAgICByZXNwb25zZU9iai5zdGF0dXMgIT09IDBcbiAgKSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIHZhbHVlIH0gPSByZXNwb25zZU9ialxuXG4gICAgbGV0IGN0b3IgPSBMRUdBQ1lfRVJST1JfQ09ERV9UT19UWVBFLmdldChzdGF0dXMpIHx8IFdlYkRyaXZlckVycm9yXG5cbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBjdG9yKHZhbHVlICsgJycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXNzYWdlID0gdmFsdWVbJ21lc3NhZ2UnXSArICcnXG4gICAgICBpZiAoY3RvciAhPT0gVW5leHBlY3RlZEFsZXJ0T3BlbkVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBjdG9yKG1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0ID0gJydcbiAgICAgIGlmICh2YWx1ZVsnYWxlcnQnXSAmJiB0eXBlb2YgdmFsdWVbJ2FsZXJ0J11bJ3RleHQnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGV4dCA9IHZhbHVlWydhbGVydCddWyd0ZXh0J11cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWxlcnRPcGVuRXJyb3IobWVzc2FnZSwgdGV4dClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlT2JqXG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVycm9yQ29kZSxcblxuICBXZWJEcml2ZXJFcnJvcixcbiAgRGV0YWNoZWRTaGFkb3dSb290RXJyb3IsXG4gIEVsZW1lbnRDbGlja0ludGVyY2VwdGVkRXJyb3IsXG4gIEVsZW1lbnROb3RJbnRlcmFjdGFibGVFcnJvcixcbiAgRWxlbWVudE5vdFNlbGVjdGFibGVFcnJvcixcbiAgSW5zZWN1cmVDZXJ0aWZpY2F0ZUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZENvb2tpZURvbWFpbkVycm9yLFxuICBJbnZhbGlkQ29vcmRpbmF0ZXNFcnJvcixcbiAgSW52YWxpZEVsZW1lbnRTdGF0ZUVycm9yLFxuICBJbnZhbGlkU2VsZWN0b3JFcnJvcixcbiAgSmF2YXNjcmlwdEVycm9yLFxuICBNb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFcnJvcixcbiAgTm9TdWNoQWxlcnRFcnJvcixcbiAgTm9TdWNoQ29va2llRXJyb3IsXG4gIE5vU3VjaEVsZW1lbnRFcnJvcixcbiAgTm9TdWNoRnJhbWVFcnJvcixcbiAgTm9TdWNoU2hhZG93Um9vdEVycm9yLFxuICBOb1N1Y2hTZXNzaW9uRXJyb3IsXG4gIE5vU3VjaFdpbmRvd0Vycm9yLFxuICBTY3JpcHRUaW1lb3V0RXJyb3IsXG4gIFNlc3Npb25Ob3RDcmVhdGVkRXJyb3IsXG4gIFN0YWxlRWxlbWVudFJlZmVyZW5jZUVycm9yLFxuICBUaW1lb3V0RXJyb3IsXG4gIFVuYWJsZVRvU2V0Q29va2llRXJyb3IsXG4gIFVuYWJsZVRvQ2FwdHVyZVNjcmVlbkVycm9yLFxuICBVbmV4cGVjdGVkQWxlcnRPcGVuRXJyb3IsXG4gIFVua25vd25Db21tYW5kRXJyb3IsXG4gIFVua25vd25NZXRob2RFcnJvcixcbiAgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcixcbiAgY2hlY2tMZWdhY3lSZXNwb25zZSxcbiAgZW5jb2RlRXJyb3IsXG4gIGlzRXJyb3JSZXNwb25zZSxcbiAgdGhyb3dEZWNvZGVkRXJyb3IsXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBhbiBlbnZpcm9ubWVudCBhZ25vc3RpYyB7QGxpbmtwbGFpbiBjbWQuRXhlY3V0b3JcbiAqIGNvbW1hbmQgZXhlY3V0b3J9IHRoYXQgY29tbXVuaWNhdGVzIHdpdGggYSByZW1vdGUgZW5kIHVzaW5nIEpTT04gb3ZlciBIVFRQLlxuICpcbiAqIENsaWVudHMgc2hvdWxkIGltcGxlbWVudCB0aGUge0BsaW5rIENsaWVudH0gaW50ZXJmYWNlLCB3aGljaCBpcyB1c2VkIGJ5XG4gKiB0aGUge0BsaW5rIEV4ZWN1dG9yfSB0byBzZW5kIGNvbW1hbmRzIHRvIHRoZSByZW1vdGUgZW5kLlxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjbWQgPSByZXF1aXJlKCcuL2NvbW1hbmQnKVxuY29uc3QgZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJylcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKCcuL2xvZ2dpbmcnKVxuY29uc3QgcHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpXG5jb25zdCB7IFNlc3Npb24gfSA9IHJlcXVpcmUoJy4vc2Vzc2lvbicpXG5jb25zdCB3ZWJFbGVtZW50ID0gcmVxdWlyZSgnLi93ZWJlbGVtZW50JylcbmNvbnN0IHsgaXNPYmplY3QgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IGdldEF0dHJpYnV0ZSA9IHJlcXVpcmVBdG9tKFxuICAnZ2V0LWF0dHJpYnV0ZS5qcycsXG4gICcvL2phdmFzY3JpcHQvbm9kZS9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2F0b21zOmdldC1hdHRyaWJ1dGUuanMnXG4pXG5jb25zdCBpc0Rpc3BsYXllZCA9IHJlcXVpcmVBdG9tKFxuICAnaXMtZGlzcGxheWVkLmpzJyxcbiAgJy8vamF2YXNjcmlwdC9ub2RlL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvYXRvbXM6aXMtZGlzcGxheWVkLmpzJ1xuKVxuY29uc3QgZmluZEVsZW1lbnRzID0gcmVxdWlyZUF0b20oXG4gICdmaW5kLWVsZW1lbnRzLmpzJyxcbiAgJy8vamF2YXNjcmlwdC9ub2RlL3NlbGVuaXVtLXdlYmRyaXZlci9saWIvYXRvbXM6ZmluZC1lbGVtZW50cy5qcydcbilcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gYmF6ZWxUYXJnZXRcbiAqIEByZXR1cm4geyFGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUF0b20obW9kdWxlLCBiYXplbFRhcmdldCkge1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCcuL2F0b21zLycgKyBtb2R1bGUpXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGUgPSBiYXplbFRhcmdldC5zbGljZSgyKS5yZXBsYWNlKCc6JywgJy8nKVxuICAgICAgY29uc29sZS5sb2coYC4uLy4uLy4uL2JhemVsLWJpbi8ke2ZpbGV9YClcbiAgICAgIHJldHVybiByZXF1aXJlKHBhdGgucmVzb2x2ZShgLi4vLi4vLi4vYmF6ZWwtYmluLyR7ZmlsZX1gKSlcbiAgICB9IGNhdGNoIChleDIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGV4MilcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGltcG9ydCBhdG9tcyBtb2R1bGUgJHttb2R1bGV9LiBJZiBydW5uaW5nIGluIGRldiBtb2RlLCB5b3VgICtcbiAgICAgICAgICBgIG5lZWQgdG8gcnVuIFxcYGJhemVsIGJ1aWxkICR7YmF6ZWxUYXJnZXR9XFxgIGZyb20gdGhlIHByb2plY3RgICtcbiAgICAgICAgICBgcm9vdDogJHtleH1gXG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZWFkZXJzIG1hcCB0byBhIEhUVFAgaGVhZGVyIGJsb2NrIHN0cmluZy5cbiAqIEBwYXJhbSB7IU1hcDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnMgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGVhZGVycyBhcyBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaGVhZGVyc1RvU3RyaW5nKGhlYWRlcnMpIHtcbiAgY29uc3QgcmV0ID0gW11cbiAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIHJldC5wdXNoKGAke25hbWUudG9Mb3dlckNhc2UoKX06ICR7dmFsdWV9YClcbiAgfSlcbiAgcmV0dXJuIHJldC5qb2luKCdcXG4nKVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBIVFRQIHJlcXVlc3QgbWVzc2FnZS4gVGhpcyBjbGFzcyBpcyBhIFwicGFydGlhbFwiIHJlcXVlc3QgYW5kIG9ubHlcbiAqIGRlZmluZXMgdGhlIHBhdGggb24gdGhlIHNlcnZlciB0byBzZW5kIGEgcmVxdWVzdCB0by4gSXQgaXMgZWFjaCBjbGllbnQnc1xuICogcmVzcG9uc2liaWxpdHkgdG8gYnVpbGQgdGhlIGZ1bGwgVVJMIGZvciB0aGUgZmluYWwgcmVxdWVzdC5cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBSZXF1ZXN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9uIHRoZSBzZXJ2ZXIgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZGF0YSBUaGlzIHJlcXVlc3QncyBub24tc2VyaWFsaXplZCBKU09OIHBheWxvYWQgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1ldGhvZCwgcGF0aCwgb3B0X2RhdGEpIHtcbiAgICB0aGlzLm1ldGhvZCA9IC8qKiBzdHJpbmcgKi8gbWV0aG9kXG4gICAgdGhpcy5wYXRoID0gLyoqIHN0cmluZyAqLyBwYXRoXG4gICAgdGhpcy5kYXRhID0gLyoqIE9iamVjdCAqLyBvcHRfZGF0YVxuICAgIHRoaXMuaGVhZGVycyA9IC8qKiAhTWFwPHN0cmluZywgc3RyaW5nPiAqLyBuZXcgTWFwKFtcbiAgICAgIFsnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXSxcbiAgICBdKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmV0ID0gYCR7dGhpcy5tZXRob2R9ICR7dGhpcy5wYXRofSBIVFRQLzEuMVxcbmBcbiAgICByZXQgKz0gaGVhZGVyc1RvU3RyaW5nKHRoaXMuaGVhZGVycykgKyAnXFxuXFxuJ1xuICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgIHJldCArPSBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBIVFRQIHJlc3BvbnNlIG1lc3NhZ2UuXG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgUmVzcG9uc2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBUaGUgcmVzcG9uc2UgY29kZS5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZz59IGhlYWRlcnMgVGhlIHJlc3BvbnNlIGhlYWRlcnMuIEFsbCBoZWFkZXIgbmFtZXNcbiAgICogICAgIHdpbGwgYmUgY29udmVydGVkIHRvIGxvd2VyY2FzZSBzdHJpbmdzIGZvciBjb25zaXN0ZW50IGxvb2t1cHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5IFRoZSByZXNwb25zZSBib2R5LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgdGhpcy5zdGF0dXMgPSAvKiogbnVtYmVyICovIHN0YXR1c1xuICAgIHRoaXMuYm9keSA9IC8qKiBzdHJpbmcgKi8gYm9keVxuICAgIHRoaXMuaGVhZGVycyA9IC8qKiAhTWFwPHN0cmluZywgc3RyaW5nPiovIG5ldyBNYXAoKVxuICAgIGZvciAobGV0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuc2V0KGhlYWRlci50b0xvd2VyQ2FzZSgpLCBoZWFkZXJzW2hlYWRlcl0pXG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmV0ID0gYEhUVFAvMS4xICR7dGhpcy5zdGF0dXN9XFxuJHtoZWFkZXJzVG9TdHJpbmcodGhpcy5oZWFkZXJzKX1cXG5cXG5gXG4gICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgcmV0ICs9IHRoaXMuYm9keVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuLyoqIEBlbnVtIHshRnVuY3Rpb259ICovXG5jb25zdCBBdG9tID0ge1xuICBHRVRfQVRUUklCVVRFOiBnZXRBdHRyaWJ1dGUsXG4gIElTX0RJU1BMQVlFRDogaXNEaXNwbGF5ZWQsXG4gIEZJTkRfRUxFTUVOVFM6IGZpbmRFbGVtZW50cyxcbn1cblxuY29uc3QgTE9HID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3dlYmRyaXZlci5odHRwJylcblxuZnVuY3Rpb24gcG9zdChwYXRoKSB7XG4gIHJldHVybiByZXNvdXJjZSgnUE9TVCcsIHBhdGgpXG59XG5mdW5jdGlvbiBkZWwocGF0aCkge1xuICByZXR1cm4gcmVzb3VyY2UoJ0RFTEVURScsIHBhdGgpXG59XG5mdW5jdGlvbiBnZXQocGF0aCkge1xuICByZXR1cm4gcmVzb3VyY2UoJ0dFVCcsIHBhdGgpXG59XG5mdW5jdGlvbiByZXNvdXJjZShtZXRob2QsIHBhdGgpIHtcbiAgcmV0dXJuIHsgbWV0aG9kOiBtZXRob2QsIHBhdGg6IHBhdGggfVxufVxuXG4vKiogQHR5cGVkZWYge3ttZXRob2Q6IHN0cmluZywgcGF0aDogc3RyaW5nfX0gKi9cbnZhciBDb21tYW5kU3BlYyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb24oIWNtZC5Db21tYW5kKTogIWNtZC5Db21tYW5kfSAqL1xudmFyIENvbW1hbmRUcmFuc2Zvcm1lciAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmNsYXNzIEludGVybmFsVHlwZUVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHt9XG5cbi8qKlxuICogQHBhcmFtIHshY21kLkNvbW1hbmR9IGNvbW1hbmQgVGhlIGluaXRpYWwgY29tbWFuZC5cbiAqIEBwYXJhbSB7QXRvbX0gYXRvbSBUaGUgbmFtZSBvZiB0aGUgYXRvbSB0byBleGVjdXRlLlxuICogQHBhcmFtIHBhcmFtc1xuICogQHJldHVybiB7IUNvbW1hbmR9IFRoZSB0cmFuc2Zvcm1lZCBjb21tYW5kIHRvIGV4ZWN1dGUuXG4gKi9cbmZ1bmN0aW9uIHRvRXhlY3V0ZUF0b21Db21tYW5kKGNvbW1hbmQsIGF0b20sIG5hbWUsIC4uLnBhcmFtcykge1xuICBpZiAodHlwZW9mIGF0b20gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgSW50ZXJuYWxUeXBlRXJyb3IoJ2F0b20gaXMgbm90IGEgZnVuY3Rpb246ICcgKyB0eXBlb2YgYXRvbSlcbiAgfVxuXG4gIHJldHVybiBuZXcgY21kLkNvbW1hbmQoY21kLk5hbWUuRVhFQ1VURV9TQ1JJUFQpXG4gICAgLnNldFBhcmFtZXRlcignc2Vzc2lvbklkJywgY29tbWFuZC5nZXRQYXJhbWV0ZXIoJ3Nlc3Npb25JZCcpKVxuICAgIC5zZXRQYXJhbWV0ZXIoXG4gICAgICAnc2NyaXB0JyxcbiAgICAgIGAvKiAke25hbWV9ICovcmV0dXJuICgke2F0b219KS5hcHBseShudWxsLCBhcmd1bWVudHMpYFxuICAgIClcbiAgICAuc2V0UGFyYW1ldGVyKFxuICAgICAgJ2FyZ3MnLFxuICAgICAgcGFyYW1zLm1hcCgocGFyYW0pID0+IGNvbW1hbmQuZ2V0UGFyYW1ldGVyKHBhcmFtKSlcbiAgICApXG59XG5cbi8qKiBAY29uc3QgeyFNYXA8c3RyaW5nLCAoQ29tbWFuZFNwZWN8Q29tbWFuZFRyYW5zZm9ybWVyKT59ICovXG5jb25zdCBXM0NfQ09NTUFORF9NQVAgPSBuZXcgTWFwKFtcbiAgLy8gU2Vzc2lvbiBtYW5hZ2VtZW50LlxuICBbY21kLk5hbWUuTkVXX1NFU1NJT04sIHBvc3QoJy9zZXNzaW9uJyldLFxuICBbY21kLk5hbWUuUVVJVCwgZGVsKCcvc2Vzc2lvbi86c2Vzc2lvbklkJyldLFxuXG4gIC8vIFNlcnZlciBzdGF0dXMuXG4gIFtjbWQuTmFtZS5HRVRfU0VSVkVSX1NUQVRVUywgZ2V0KCcvc3RhdHVzJyldLFxuXG4gIC8vIHRpbWVvdXRzXG4gIFtjbWQuTmFtZS5HRVRfVElNRU9VVCwgZ2V0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3RpbWVvdXRzJyldLFxuICBbY21kLk5hbWUuU0VUX1RJTUVPVVQsIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvdGltZW91dHMnKV0sXG5cbiAgLy8gTmF2aWdhdGlvbi5cbiAgW2NtZC5OYW1lLkdFVF9DVVJSRU5UX1VSTCwgZ2V0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3VybCcpXSxcbiAgW2NtZC5OYW1lLkdFVCwgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC91cmwnKV0sXG4gIFtjbWQuTmFtZS5HT19CQUNLLCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2JhY2snKV0sXG4gIFtjbWQuTmFtZS5HT19GT1JXQVJELCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2ZvcndhcmQnKV0sXG4gIFtjbWQuTmFtZS5SRUZSRVNILCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3JlZnJlc2gnKV0sXG5cbiAgLy8gUGFnZSBpbnNwZWN0aW9uLlxuICBbY21kLk5hbWUuR0VUX1BBR0VfU09VUkNFLCBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvc291cmNlJyldLFxuICBbY21kLk5hbWUuR0VUX1RJVExFLCBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvdGl0bGUnKV0sXG5cbiAgLy8gU2NyaXB0IGV4ZWN1dGlvbi5cbiAgW2NtZC5OYW1lLkVYRUNVVEVfU0NSSVBULCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2V4ZWN1dGUvc3luYycpXSxcbiAgW2NtZC5OYW1lLkVYRUNVVEVfQVNZTkNfU0NSSVBULCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2V4ZWN1dGUvYXN5bmMnKV0sXG5cbiAgLy8gRnJhbWUgc2VsZWN0aW9uLlxuICBbY21kLk5hbWUuU1dJVENIX1RPX0ZSQU1FLCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2ZyYW1lJyldLFxuICBbY21kLk5hbWUuU1dJVENIX1RPX0ZSQU1FX1BBUkVOVCwgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC9mcmFtZS9wYXJlbnQnKV0sXG5cbiAgLy8gV2luZG93IG1hbmFnZW1lbnQuXG4gIFtjbWQuTmFtZS5HRVRfQ1VSUkVOVF9XSU5ET1dfSEFORExFLCBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvd2luZG93JyldLFxuICBbY21kLk5hbWUuQ0xPU0UsIGRlbCgnL3Nlc3Npb24vOnNlc3Npb25JZC93aW5kb3cnKV0sXG4gIFtjbWQuTmFtZS5TV0lUQ0hfVE9fV0lORE9XLCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3dpbmRvdycpXSxcbiAgW2NtZC5OYW1lLlNXSVRDSF9UT19ORVdfV0lORE9XLCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3dpbmRvdy9uZXcnKV0sXG4gIFtjbWQuTmFtZS5HRVRfV0lORE9XX0hBTkRMRVMsIGdldCgnL3Nlc3Npb24vOnNlc3Npb25JZC93aW5kb3cvaGFuZGxlcycpXSxcbiAgW2NtZC5OYW1lLkdFVF9XSU5ET1dfUkVDVCwgZ2V0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3dpbmRvdy9yZWN0JyldLFxuICBbY21kLk5hbWUuU0VUX1dJTkRPV19SRUNULCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3dpbmRvdy9yZWN0JyldLFxuICBbY21kLk5hbWUuTUFYSU1JWkVfV0lORE9XLCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3dpbmRvdy9tYXhpbWl6ZScpXSxcbiAgW2NtZC5OYW1lLk1JTklNSVpFX1dJTkRPVywgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC93aW5kb3cvbWluaW1pemUnKV0sXG4gIFtjbWQuTmFtZS5GVUxMU0NSRUVOX1dJTkRPVywgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC93aW5kb3cvZnVsbHNjcmVlbicpXSxcblxuICAvLyBBY3Rpb25zLlxuICBbY21kLk5hbWUuQUNUSU9OUywgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC9hY3Rpb25zJyldLFxuICBbY21kLk5hbWUuQ0xFQVJfQUNUSU9OUywgZGVsKCcvc2Vzc2lvbi86c2Vzc2lvbklkL2FjdGlvbnMnKV0sXG4gIFtjbWQuTmFtZS5QUklOVF9QQUdFLCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3ByaW50JyldLFxuXG4gIC8vIExvY2F0aW5nIGVsZW1lbnRzLlxuICBbY21kLk5hbWUuR0VUX0FDVElWRV9FTEVNRU5ULCBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC9hY3RpdmUnKV0sXG4gIFtjbWQuTmFtZS5GSU5EX0VMRU1FTlQsIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudCcpXSxcbiAgW2NtZC5OYW1lLkZJTkRfRUxFTUVOVFMsIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudHMnKV0sXG4gIFtcbiAgICBjbWQuTmFtZS5GSU5EX0VMRU1FTlRTX1JFTEFUSVZFLFxuICAgIChjbWQpID0+IHtcbiAgICAgIHJldHVybiB0b0V4ZWN1dGVBdG9tQ29tbWFuZChcbiAgICAgICAgY21kLFxuICAgICAgICBBdG9tLkZJTkRfRUxFTUVOVFMsXG4gICAgICAgICdmaW5kRWxlbWVudHMnLFxuICAgICAgICAnYXJncydcbiAgICAgIClcbiAgICB9LFxuICBdLFxuICBbXG4gICAgY21kLk5hbWUuRklORF9DSElMRF9FTEVNRU5ULFxuICAgIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvZWxlbWVudCcpLFxuICBdLFxuICBbXG4gICAgY21kLk5hbWUuRklORF9DSElMRF9FTEVNRU5UUyxcbiAgICBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2VsZW1lbnQvOmlkL2VsZW1lbnRzJyksXG4gIF0sXG4gIC8vIEVsZW1lbnQgaW50ZXJhY3Rpb24uXG4gIFtjbWQuTmFtZS5HRVRfRUxFTUVOVF9UQUdfTkFNRSwgZ2V0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2VsZW1lbnQvOmlkL25hbWUnKV0sXG4gIFtcbiAgICBjbWQuTmFtZS5HRVRfRE9NX0FUVFJJQlVURSxcbiAgICBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvYXR0cmlidXRlLzpuYW1lJyksXG4gIF0sXG4gIFtcbiAgICBjbWQuTmFtZS5HRVRfRUxFTUVOVF9BVFRSSUJVVEUsXG4gICAgKGNtZCkgPT4ge1xuICAgICAgcmV0dXJuIHRvRXhlY3V0ZUF0b21Db21tYW5kKFxuICAgICAgICBjbWQsXG4gICAgICAgIEF0b20uR0VUX0FUVFJJQlVURSxcbiAgICAgICAgJ2dldEF0dHJpYnV0ZScsXG4gICAgICAgICdpZCcsXG4gICAgICAgICduYW1lJ1xuICAgICAgKVxuICAgIH0sXG4gIF0sXG4gIFtcbiAgICBjbWQuTmFtZS5HRVRfRUxFTUVOVF9QUk9QRVJUWSxcbiAgICBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvcHJvcGVydHkvOm5hbWUnKSxcbiAgXSxcbiAgW1xuICAgIGNtZC5OYW1lLkdFVF9FTEVNRU5UX1ZBTFVFX09GX0NTU19QUk9QRVJUWSxcbiAgICBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvY3NzLzpwcm9wZXJ0eU5hbWUnKSxcbiAgXSxcbiAgW2NtZC5OYW1lLkdFVF9FTEVNRU5UX1JFQ1QsIGdldCgnL3Nlc3Npb24vOnNlc3Npb25JZC9lbGVtZW50LzppZC9yZWN0JyldLFxuICBbY21kLk5hbWUuQ0xFQVJfRUxFTUVOVCwgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC9lbGVtZW50LzppZC9jbGVhcicpXSxcbiAgW2NtZC5OYW1lLkNMSUNLX0VMRU1FTlQsIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvY2xpY2snKV0sXG4gIFtcbiAgICBjbWQuTmFtZS5TRU5EX0tFWVNfVE9fRUxFTUVOVCxcbiAgICBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2VsZW1lbnQvOmlkL3ZhbHVlJyksXG4gIF0sXG4gIFtjbWQuTmFtZS5HRVRfRUxFTUVOVF9URVhULCBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvdGV4dCcpXSxcbiAgW1xuICAgIGNtZC5OYW1lLkdFVF9DT01QVVRFRF9ST0xFLFxuICAgIGdldCgnL3Nlc3Npb24vOnNlc3Npb25JZC9lbGVtZW50LzppZC9jb21wdXRlZHJvbGUnKSxcbiAgXSxcbiAgW1xuICAgIGNtZC5OYW1lLkdFVF9DT01QVVRFRF9MQUJFTCxcbiAgICBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvY29tcHV0ZWRsYWJlbCcpLFxuICBdLFxuICBbY21kLk5hbWUuSVNfRUxFTUVOVF9FTkFCTEVELCBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvZW5hYmxlZCcpXSxcbiAgW1xuICAgIGNtZC5OYW1lLklTX0VMRU1FTlRfU0VMRUNURUQsXG4gICAgZ2V0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2VsZW1lbnQvOmlkL3NlbGVjdGVkJyksXG4gIF0sXG5cbiAgW1xuICAgIGNtZC5OYW1lLklTX0VMRU1FTlRfRElTUExBWUVELFxuICAgIChjbWQpID0+IHtcbiAgICAgIHJldHVybiB0b0V4ZWN1dGVBdG9tQ29tbWFuZChjbWQsIEF0b20uSVNfRElTUExBWUVELCAnaXNEaXNwbGF5ZWQnLCAnaWQnKVxuICAgIH0sXG4gIF0sXG5cbiAgLy8gQ29va2llIG1hbmFnZW1lbnQuXG4gIFtjbWQuTmFtZS5HRVRfQUxMX0NPT0tJRVMsIGdldCgnL3Nlc3Npb24vOnNlc3Npb25JZC9jb29raWUnKV0sXG4gIFtjbWQuTmFtZS5BRERfQ09PS0lFLCBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2Nvb2tpZScpXSxcbiAgW2NtZC5OYW1lLkRFTEVURV9BTExfQ09PS0lFUywgZGVsKCcvc2Vzc2lvbi86c2Vzc2lvbklkL2Nvb2tpZScpXSxcbiAgW2NtZC5OYW1lLkdFVF9DT09LSUUsIGdldCgnL3Nlc3Npb24vOnNlc3Npb25JZC9jb29raWUvOm5hbWUnKV0sXG4gIFtjbWQuTmFtZS5ERUxFVEVfQ09PS0lFLCBkZWwoJy9zZXNzaW9uLzpzZXNzaW9uSWQvY29va2llLzpuYW1lJyldLFxuXG4gIC8vIEFsZXJ0IG1hbmFnZW1lbnQuXG4gIFtjbWQuTmFtZS5BQ0NFUFRfQUxFUlQsIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvYWxlcnQvYWNjZXB0JyldLFxuICBbY21kLk5hbWUuRElTTUlTU19BTEVSVCwgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC9hbGVydC9kaXNtaXNzJyldLFxuICBbY21kLk5hbWUuR0VUX0FMRVJUX1RFWFQsIGdldCgnL3Nlc3Npb24vOnNlc3Npb25JZC9hbGVydC90ZXh0JyldLFxuICBbY21kLk5hbWUuU0VUX0FMRVJUX1RFWFQsIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvYWxlcnQvdGV4dCcpXSxcblxuICAvLyBTY3JlZW5zaG90cy5cbiAgW2NtZC5OYW1lLlNDUkVFTlNIT1QsIGdldCgnL3Nlc3Npb24vOnNlc3Npb25JZC9zY3JlZW5zaG90JyldLFxuICBbXG4gICAgY21kLk5hbWUuVEFLRV9FTEVNRU5UX1NDUkVFTlNIT1QsXG4gICAgZ2V0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL2VsZW1lbnQvOmlkL3NjcmVlbnNob3QnKSxcbiAgXSxcblxuICAvLyBTaGFkb3cgUm9vdFxuICBbY21kLk5hbWUuR0VUX1NIQURPV19ST09ULCBnZXQoJy9zZXNzaW9uLzpzZXNzaW9uSWQvZWxlbWVudC86aWQvc2hhZG93JyldLFxuICBbXG4gICAgY21kLk5hbWUuRklORF9FTEVNRU5UX0ZST01fU0hBRE9XUk9PVCxcbiAgICBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3NoYWRvdy86aWQvZWxlbWVudCcpLFxuICBdLFxuICBbXG4gICAgY21kLk5hbWUuRklORF9FTEVNRU5UU19GUk9NX1NIQURPV1JPT1QsXG4gICAgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC9zaGFkb3cvOmlkL2VsZW1lbnRzJyksXG4gIF0sXG4gIC8vIExvZyBleHRlbnNpb25zLlxuICBbY21kLk5hbWUuR0VUX0xPRywgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC9zZS9sb2cnKV0sXG4gIFtjbWQuTmFtZS5HRVRfQVZBSUxBQkxFX0xPR19UWVBFUywgZ2V0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3NlL2xvZy90eXBlcycpXSxcblxuICAvLyBTZXJ2ZXIgRXh0ZW5zaW9uc1xuICBbY21kLk5hbWUuVVBMT0FEX0ZJTEUsIHBvc3QoJy9zZXNzaW9uLzpzZXNzaW9uSWQvc2UvZmlsZScpXSxcblxuICAvLyBWaXJ0dWFsIEF1dGhlbnRpY2F0b3JcbiAgW1xuICAgIGNtZC5OYW1lLkFERF9WSVJUVUFMX0FVVEhFTlRJQ0FUT1IsXG4gICAgcG9zdCgnL3Nlc3Npb24vOnNlc3Npb25JZC93ZWJhdXRobi9hdXRoZW50aWNhdG9yJyksXG4gIF0sXG4gIFtcbiAgICBjbWQuTmFtZS5SRU1PVkVfVklSVFVBTF9BVVRIRU5USUNBVE9SLFxuICAgIGRlbCgnL3Nlc3Npb24vOnNlc3Npb25JZC93ZWJhdXRobi9hdXRoZW50aWNhdG9yLzphdXRoZW50aWNhdG9ySWQnKSxcbiAgXSxcbiAgW1xuICAgIGNtZC5OYW1lLkFERF9DUkVERU5USUFMLFxuICAgIHBvc3QoXG4gICAgICAnL3Nlc3Npb24vOnNlc3Npb25JZC93ZWJhdXRobi9hdXRoZW50aWNhdG9yLzphdXRoZW50aWNhdG9ySWQvY3JlZGVudGlhbCdcbiAgICApLFxuICBdLFxuICBbXG4gICAgY21kLk5hbWUuR0VUX0NSRURFTlRJQUxTLFxuICAgIGdldChcbiAgICAgICcvc2Vzc2lvbi86c2Vzc2lvbklkL3dlYmF1dGhuL2F1dGhlbnRpY2F0b3IvOmF1dGhlbnRpY2F0b3JJZC9jcmVkZW50aWFscydcbiAgICApLFxuICBdLFxuICBbXG4gICAgY21kLk5hbWUuUkVNT1ZFX0NSRURFTlRJQUwsXG4gICAgZGVsKFxuICAgICAgJy9zZXNzaW9uLzpzZXNzaW9uSWQvd2ViYXV0aG4vYXV0aGVudGljYXRvci86YXV0aGVudGljYXRvcklkL2NyZWRlbnRpYWxzLzpjcmVkZW50aWFsSWQnXG4gICAgKSxcbiAgXSxcbiAgW1xuICAgIGNtZC5OYW1lLlJFTU9WRV9BTExfQ1JFREVOVElBTFMsXG4gICAgZGVsKFxuICAgICAgJy9zZXNzaW9uLzpzZXNzaW9uSWQvd2ViYXV0aG4vYXV0aGVudGljYXRvci86YXV0aGVudGljYXRvcklkL2NyZWRlbnRpYWxzJ1xuICAgICksXG4gIF0sXG4gIFtcbiAgICBjbWQuTmFtZS5TRVRfVVNFUl9WRVJJRklFRCxcbiAgICBwb3N0KCcvc2Vzc2lvbi86c2Vzc2lvbklkL3dlYmF1dGhuL2F1dGhlbnRpY2F0b3IvOmF1dGhlbnRpY2F0b3JJZC91dicpLFxuICBdLFxuXSlcblxuLyoqXG4gKiBIYW5kbGVzIHNlbmRpbmcgSFRUUCBtZXNzYWdlcyB0byBhIHJlbW90ZSBlbmQuXG4gKlxuICogQGludGVyZmFjZVxuICovXG5jbGFzcyBDbGllbnQge1xuICAvKipcbiAgICogU2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuIFRoZSBjbGllbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGZvbGxvdyBhbnlcbiAgICogcmVkaXJlY3RzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIsIGZ1bGZpbGxpbmcgdGhlIHJldHVybmVkIHByb21pc2Ugd2l0aCB0aGVcbiAgICogZmluYWwgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7IVJlcXVlc3R9IGh0dHBSZXF1ZXN0IFRoZSByZXF1ZXN0IHRvIHNlbmQuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGVcbiAgICogICAgIHNlcnZlcidzIHJlc3BvbnNlLlxuICAgKi9cbiAgc2VuZChodHRwUmVxdWVzdCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgQ29tbWFuZFNwZWM+fSBjdXN0b21Db21tYW5kc1xuICogICAgIEEgbWFwIG9mIGN1c3RvbSBjb21tYW5kIGRlZmluaXRpb25zLlxuICogQHBhcmFtIHshY21kLkNvbW1hbmR9IGNvbW1hbmQgVGhlIGNvbW1hbmQgdG8gcmVzb2x2ZS5cbiAqIEByZXR1cm4geyFSZXF1ZXN0fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGVcbiAqICAgICBjb21tYW5kIHRvIGV4ZWN1dGUuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChjdXN0b21Db21tYW5kcywgY29tbWFuZCkge1xuICBMT0cuZmluZXN0KCgpID0+IGBUcmFuc2xhdGluZyBjb21tYW5kOiAke2NvbW1hbmQuZ2V0TmFtZSgpfWApXG4gIGxldCBzcGVjID0gY3VzdG9tQ29tbWFuZHMgJiYgY3VzdG9tQ29tbWFuZHMuZ2V0KGNvbW1hbmQuZ2V0TmFtZSgpKVxuICBpZiAoc3BlYykge1xuICAgIHJldHVybiB0b0h0dHBSZXF1ZXN0KHNwZWMpXG4gIH1cblxuICBzcGVjID0gVzNDX0NPTU1BTkRfTUFQLmdldChjb21tYW5kLmdldE5hbWUoKSlcbiAgaWYgKHR5cGVvZiBzcGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgTE9HLmZpbmVzdCgoKSA9PiBgVHJhbnNmb3JtaW5nIGNvbW1hbmQgZm9yIFczQzogJHtjb21tYW5kLmdldE5hbWUoKX1gKVxuICAgIGxldCBuZXdDb21tYW5kID0gc3BlYyhjb21tYW5kKVxuICAgIHJldHVybiBidWlsZFJlcXVlc3QoY3VzdG9tQ29tbWFuZHMsIG5ld0NvbW1hbmQpXG4gIH0gZWxzZSBpZiAoc3BlYykge1xuICAgIHJldHVybiB0b0h0dHBSZXF1ZXN0KHNwZWMpXG4gIH1cbiAgdGhyb3cgbmV3IGVycm9yLlVua25vd25Db21tYW5kRXJyb3IoXG4gICAgJ1VucmVjb2duaXplZCBjb21tYW5kOiAnICsgY29tbWFuZC5nZXROYW1lKClcbiAgKVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbW1hbmRTcGVjfSByZXNvdXJjZVxuICAgKiBAcmV0dXJuIHshUmVxdWVzdH1cbiAgICovXG4gIGZ1bmN0aW9uIHRvSHR0cFJlcXVlc3QocmVzb3VyY2UpIHtcbiAgICBMT0cuZmluZXN0KCgpID0+IGBCdWlsZGluZyBIVFRQIHJlcXVlc3Q6ICR7SlNPTi5zdHJpbmdpZnkocmVzb3VyY2UpfWApXG4gICAgbGV0IHBhcmFtZXRlcnMgPSBjb21tYW5kLmdldFBhcmFtZXRlcnMoKVxuICAgIGxldCBwYXRoID0gYnVpbGRQYXRoKHJlc291cmNlLnBhdGgsIHBhcmFtZXRlcnMpXG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHJlc291cmNlLm1ldGhvZCwgcGF0aCwgcGFyYW1ldGVycylcbiAgfVxufVxuXG5jb25zdCBDTElFTlRTID1cbiAgLyoqICFXZWFrTWFwPCFFeGVjdXRvciwgIShDbGllbnR8SVRoZW5hYmxlPCFDbGllbnQ+KT4gKi8gbmV3IFdlYWtNYXAoKVxuXG4vKipcbiAqIEEgY29tbWFuZCBleGVjdXRvciB0aGF0IGNvbW11bmljYXRlcyB3aXRoIHRoZSBzZXJ2ZXIgdXNpbmcgSlNPTiBvdmVyIEhUVFAuXG4gKlxuICogQnkgZGVmYXVsdCwgZWFjaCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIHdpbGwgdXNlIHRoZSBsZWdhY3kgd2lyZSBwcm90b2NvbFxuICogZnJvbSBbU2VsZW5pdW0gcHJvamVjdF1banNvbl0uIFRoZSBleGVjdXRvciB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHRvIHRoZVxuICogW1czQyB3aXJlIHByb3RvY29sXVt3M2NdIGlmIHRoZSByZW1vdGUgZW5kIHJldHVybnMgYSBjb21wbGlhbnQgcmVzcG9uc2UgdG9cbiAqIGEgbmV3IHNlc3Npb24gY29tbWFuZC5cbiAqXG4gKiBbanNvbl06IGh0dHBzOi8vZ2l0aHViLmNvbS9TZWxlbml1bUhRL3NlbGVuaXVtL3dpa2kvSnNvbldpcmVQcm90b2NvbFxuICogW3czY106IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvd2ViZHJpdmVyLXNwZWMuaHRtbFxuICpcbiAqIEBpbXBsZW1lbnRzIHtjbWQuRXhlY3V0b3J9XG4gKi9cbmNsYXNzIEV4ZWN1dG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IShDbGllbnR8SVRoZW5hYmxlPCFDbGllbnQ+KX0gY2xpZW50IFRoZSBjbGllbnQgdG8gdXNlIGZvciBzZW5kaW5nXG4gICAqICAgICByZXF1ZXN0cyB0byB0aGUgc2VydmVyLCBvciBhIHByb21pc2UtbGlrZSBvYmplY3QgdGhhdCB3aWxsIHJlc29sdmVcbiAgICogICAgIHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICBDTElFTlRTLnNldCh0aGlzLCBjbGllbnQpXG5cbiAgICAvKiogQHByaXZhdGUge01hcDxzdHJpbmcsIENvbW1hbmRTcGVjPn0gKi9cbiAgICB0aGlzLmN1c3RvbUNvbW1hbmRzXyA9IG51bGxcblxuICAgIC8qKiBAcHJpdmF0ZSB7IWxvZ2dpbmcuTG9nZ2VyfSAqL1xuICAgIHRoaXMubG9nXyA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKCd3ZWJkcml2ZXIuaHR0cC5FeGVjdXRvcicpXG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIG5ldyBjb21tYW5kIGZvciB1c2Ugd2l0aCB0aGlzIGV4ZWN1dG9yLiBXaGVuIGEgY29tbWFuZCBpcyBzZW50LFxuICAgKiB0aGUge0Bjb2RlIHBhdGh9IHdpbGwgYmUgcHJlcHJvY2Vzc2VkIHVzaW5nIHRoZSBjb21tYW5kJ3MgcGFyYW1ldGVyczsgYW55XG4gICAqIHBhdGggc2VnbWVudHMgcHJlZml4ZWQgd2l0aCBcIjpcIiB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBwYXJhbWV0ZXIgb2YgdGhlXG4gICAqIHNhbWUgbmFtZS4gRm9yIGV4YW1wbGUsIGdpdmVuIFwiL3BlcnNvbi86bmFtZVwiIGFuZCB0aGUgcGFyYW1ldGVyc1xuICAgKiBcIntuYW1lOiAnQm9iJ31cIiwgdGhlIGZpbmFsIGNvbW1hbmQgcGF0aCB3aWxsIGJlIFwiL3BlcnNvbi9Cb2JcIi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGNvbW1hbmQgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gc2VuZGluZyB0aGlzIGNvbW1hbmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHNlbmQgdGhlIGNvbW1hbmQgdG8sIHJlbGF0aXZlIHRvXG4gICAqICAgICB0aGUgV2ViRHJpdmVyIHNlcnZlcidzIGNvbW1hbmQgcm9vdCBhbmQgb2YgdGhlIGZvcm1cbiAgICogICAgIFwiL3BhdGgvOnZhcmlhYmxlL3NlZ21lbnRcIi5cbiAgICovXG4gIGRlZmluZUNvbW1hbmQobmFtZSwgbWV0aG9kLCBwYXRoKSB7XG4gICAgaWYgKCF0aGlzLmN1c3RvbUNvbW1hbmRzXykge1xuICAgICAgdGhpcy5jdXN0b21Db21tYW5kc18gPSBuZXcgTWFwKClcbiAgICB9XG4gICAgdGhpcy5jdXN0b21Db21tYW5kc18uc2V0KG5hbWUsIHsgbWV0aG9kLCBwYXRoIH0pXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGFzeW5jIGV4ZWN1dGUoY29tbWFuZCkge1xuICAgIGxldCByZXF1ZXN0ID0gYnVpbGRSZXF1ZXN0KHRoaXMuY3VzdG9tQ29tbWFuZHNfLCBjb21tYW5kKVxuICAgIHRoaXMubG9nXy5maW5lcigoKSA9PiBgPj4+ICR7cmVxdWVzdC5tZXRob2R9ICR7cmVxdWVzdC5wYXRofWApXG5cbiAgICBsZXQgY2xpZW50ID0gQ0xJRU5UUy5nZXQodGhpcylcbiAgICBpZiAocHJvbWlzZS5pc1Byb21pc2UoY2xpZW50KSkge1xuICAgICAgY2xpZW50ID0gYXdhaXQgY2xpZW50XG4gICAgICBDTElFTlRTLnNldCh0aGlzLCBjbGllbnQpXG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnNlbmQocmVxdWVzdClcbiAgICB0aGlzLmxvZ18uZmluZXIoKCkgPT4gYD4+PlxcbiR7cmVxdWVzdH1cXG48PDxcXG4ke3Jlc3BvbnNlfWApXG5cbiAgICBsZXQgaHR0cFJlc3BvbnNlID0gLyoqIEB0eXBlIHshUmVzcG9uc2V9ICovIChyZXNwb25zZSlcblxuICAgIGxldCB7IGlzVzNDLCB2YWx1ZSB9ID0gcGFyc2VIdHRwUmVzcG9uc2UoY29tbWFuZCwgaHR0cFJlc3BvbnNlKVxuXG4gICAgaWYgKGNvbW1hbmQuZ2V0TmFtZSgpID09PSBjbWQuTmFtZS5ORVdfU0VTU0lPTikge1xuICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuc2Vzc2lvbklkKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvci5XZWJEcml2ZXJFcnJvcihcbiAgICAgICAgICBgVW5hYmxlIHRvIHBhcnNlIG5ldyBzZXNzaW9uIHJlc3BvbnNlOiAke3Jlc3BvbnNlLmJvZHl9YFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZW1vdGUgZW5kIGlzIGEgVzNDIGNvbXBsaWFudCBzZXJ2ZXIgaWYgdGhlcmUgaXMgbm8gYHN0YXR1c2BcbiAgICAgIC8vIGZpZWxkIGluIHRoZSByZXNwb25zZS5cbiAgICAgIGlmIChjb21tYW5kLmdldE5hbWUoKSA9PT0gY21kLk5hbWUuTkVXX1NFU1NJT04pIHtcbiAgICAgICAgdGhpcy53M2MgPSB0aGlzLnczYyB8fCBpc1czQ1xuICAgICAgfVxuXG4gICAgICAvLyBObyBpbXBsZW1lbnRhdGlvbnMgdXNlIHRoZSBgY2FwYWJpbGl0aWVzYCBrZXkgeWV0Li4uXG4gICAgICBsZXQgY2FwYWJpbGl0aWVzID0gdmFsdWUuY2FwYWJpbGl0aWVzIHx8IHZhbHVlLnZhbHVlXG4gICAgICByZXR1cm4gbmV3IFNlc3Npb24oXG4gICAgICAgIC8qKiBAdHlwZSB7e3Nlc3Npb25JZDogc3RyaW5nfX0gKi8gKHZhbHVlKS5zZXNzaW9uSWQsXG4gICAgICAgIGNhcGFiaWxpdGllc1xuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHZhbHVlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC5cbiAqIEByZXR1cm4gez99IC5cbiAqL1xuZnVuY3Rpb24gdHJ5UGFyc2Uoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKVxuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIHVzZWQgdG8gcGFyc2Uge0BsaW5rIFJlc3BvbnNlfSBvYmplY3RzIGZyb20gYVxuICoge0BsaW5rIEh0dHBDbGllbnR9LlxuICpcbiAqIEBwYXJhbSB7IWNtZC5Db21tYW5kfSBjb21tYW5kIFRoZSBjb21tYW5kIHRoZSByZXNwb25zZSBpcyBmb3IuXG4gKiBAcGFyYW0geyFSZXNwb25zZX0gaHR0cFJlc3BvbnNlIFRoZSBIVFRQIHJlc3BvbnNlIHRvIHBhcnNlLlxuICogQHJldHVybiB7e2lzVzNDOiBib29sZWFuLCB2YWx1ZTogP319IEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBwYXJzZWRcbiAqICAgICByZXNwb25zZS4gVGhpcyBvYmplY3Qgd2lsbCBoYXZlIHR3byBmaWVsZHM6IGBpc1czQ2AgaW5kaWNhdGVzIHdoZXRoZXJcbiAqICAgICB0aGUgcmVzcG9uc2UgbG9va3MgbGlrZSBpdCBjYW1lIGZyb20gYSByZW1vdGUgZW5kIHRoYXQgY29uZm9ybXMgd2l0aCB0aGVcbiAqICAgICBXM0MgV2ViRHJpdmVyIHNwZWMsIGFuZCBgdmFsdWVgLCB0aGUgYWN0dWFsIHJlc3BvbnNlIHZhbHVlLlxuICogQHRocm93cyB7V2ViRHJpdmVyRXJyb3J9IElmIHRoZSBIVFRQIHJlc3BvbnNlIGlzIGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBwYXJzZUh0dHBSZXNwb25zZShjb21tYW5kLCBodHRwUmVzcG9uc2UpIHtcbiAgaWYgKGh0dHBSZXNwb25zZS5zdGF0dXMgPCAyMDApIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCB0aHJvdyB0aGUgcmF3IHJlc3BvbnNlIHNvIHVzZXJzIHJlcG9ydCBpdC5cbiAgICB0aHJvdyBuZXcgZXJyb3IuV2ViRHJpdmVyRXJyb3IoYFVuZXhwZWN0ZWQgSFRUUCByZXNwb25zZTpcXG4ke2h0dHBSZXNwb25zZX1gKVxuICB9XG5cbiAgbGV0IHBhcnNlZCA9IHRyeVBhcnNlKGh0dHBSZXNwb25zZS5ib2R5KVxuXG4gIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gJ29iamVjdCcpIHtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWQudmFsdWVcbiAgICBsZXQgaXNXM0MgPSBpc09iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHBhcnNlZC5zdGF0dXMgPT09ICd1bmRlZmluZWQnXG5cbiAgICBpZiAoIWlzVzNDKSB7XG4gICAgICBlcnJvci5jaGVja0xlZ2FjeVJlc3BvbnNlKHBhcnNlZClcblxuICAgICAgLy8gQWRqdXN0IGxlZ2FjeSBuZXcgc2Vzc2lvbiByZXNwb25zZXMgdG8gbG9vayBsaWtlIFczQyB0byBzaW1wbGlmeVxuICAgICAgLy8gbGF0ZXIgcHJvY2Vzc2luZy5cbiAgICAgIGlmIChjb21tYW5kLmdldE5hbWUoKSA9PT0gY21kLk5hbWUuTkVXX1NFU1NJT04pIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZWRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGh0dHBSZXNwb25zZS5zdGF0dXMgPiAzOTkpIHtcbiAgICAgIGVycm9yLnRocm93RGVjb2RlZEVycm9yKHZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiB7IGlzVzNDLCB2YWx1ZSB9XG4gIH1cblxuICBpZiAocGFyc2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geyBpc1czQzogZmFsc2UsIHZhbHVlOiBwYXJzZWQgfVxuICB9XG5cbiAgbGV0IHZhbHVlID0gaHR0cFJlc3BvbnNlLmJvZHkucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKVxuXG4gIC8vIDQwNCByZXByZXNlbnRzIGFuIHVua25vd24gY29tbWFuZDsgYW55dGhpbmcgZWxzZSA+IDM5OSBpcyBhIGdlbmVyaWMgdW5rbm93blxuICAvLyBlcnJvci5cbiAgaWYgKGh0dHBSZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgIHRocm93IG5ldyBlcnJvci5VbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKGNvbW1hbmQuZ2V0TmFtZSgpICsgJzogJyArIHZhbHVlKVxuICB9IGVsc2UgaWYgKGh0dHBSZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9yLldlYkRyaXZlckVycm9yKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHsgaXNXM0M6IGZhbHNlLCB2YWx1ZTogdmFsdWUgfHwgbnVsbCB9XG59XG5cbi8qKlxuICogQnVpbGRzIGEgZnVsbHkgcXVhbGlmaWVkIHBhdGggdXNpbmcgdGhlIGdpdmVuIHNldCBvZiBjb21tYW5kIHBhcmFtZXRlcnMuIEVhY2hcbiAqIHBhdGggc2VnbWVudCBwcmVmaXhlZCB3aXRoICc6JyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSB2YWx1ZSBvZiB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyLiBBbGwgcGFyYW1ldGVycyBzcGxpY2VkIGludG8gdGhlIHBhdGggd2lsbCBiZVxuICogcmVtb3ZlZCBmcm9tIHRoZSBwYXJhbWV0ZXIgbWFwLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIG9yaWdpbmFsIHJlc291cmNlIHBhdGguXG4gKiBAcGFyYW0geyFPYmplY3Q8Kj59IHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgb2JqZWN0IHRvIHNwbGljZSBpbnRvIHRoZSBwYXRoLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbW9kaWZpZWQgcGF0aC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHBhcmFtZXRlcnMpIHtcbiAgbGV0IHBhdGhQYXJhbWV0ZXJzID0gcGF0aC5tYXRjaCgvXFwvOihcXHcrKVxcYi9nKVxuICBpZiAocGF0aFBhcmFtZXRlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhQYXJhbWV0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQga2V5ID0gcGF0aFBhcmFtZXRlcnNbaV0uc3Vic3RyaW5nKDIpIC8vIFRyaW0gdGhlIC86XG4gICAgICBpZiAoa2V5IGluIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1ldGVyc1trZXldXG4gICAgICAgIGlmICh3ZWJFbGVtZW50LmlzSWQodmFsdWUpKSB7XG4gICAgICAgICAgLy8gV2hlbiBpbnNlcnRpbmcgYSBXZWJFbGVtZW50IGludG8gdGhlIFVSTCwgb25seSB1c2UgaXRzIElEIHZhbHVlLFxuICAgICAgICAgIC8vIG5vdCB0aGUgZnVsbCBKU09OLlxuICAgICAgICAgIHZhbHVlID0gd2ViRWxlbWVudC5leHRyYWN0SWQodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShwYXRoUGFyYW1ldGVyc1tpXSwgJy8nICsgdmFsdWUpXG4gICAgICAgIGRlbGV0ZSBwYXJhbWV0ZXJzW2tleV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvci5JbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgICAnTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6ICcgKyBrZXlcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFeGVjdXRvcixcbiAgQ2xpZW50LFxuICBSZXF1ZXN0LFxuICBSZXNwb25zZSxcbiAgLy8gRXhwb3J0ZWQgZm9yIHRlc3RpbmcuXG4gIGJ1aWxkUGF0aCxcbn1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyB0eXBlcyByZWxhdGVkIHRvIHVzZXIgaW5wdXQgd2l0aCB0aGUgV2ViRHJpdmVyIEFQSS5cbiAqL1xuY29uc3QgeyBDb21tYW5kLCBOYW1lIH0gPSByZXF1aXJlKCcuL2NvbW1hbmQnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcicpXG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgdGhlIGJ1dHRvbnMgdXNlZCBpbiB0aGUgYWR2YW5jZWQgaW50ZXJhY3Rpb25zIEFQSS5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IEJ1dHRvbiA9IHtcbiAgTEVGVDogMCxcbiAgTUlERExFOiAxLFxuICBSSUdIVDogMixcbiAgQkFDSzogMyxcbiAgRk9SV0FSRDogNCxcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbnMgb2YgcHJlc3NhYmxlIGtleXMgdGhhdCBhcmVuJ3QgdGV4dC4gIFRoZXNlIGFyZSBzdG9yZWQgaW5cbiAqIHRoZSBVbmljb2RlIFBVQSAoUHJpdmF0ZSBVc2UgQXJlYSkgY29kZSBwb2ludHMsIDB4RTAwMC0weEY4RkYuICBSZWZlciB0b1xuICogaHR0cDovL3d3dy5nb29nbGUuY29tLmF1L3NlYXJjaD8mcT11bmljb2RlK3B1YSZidG5LPVNlYXJjaFxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAc2VlIDxodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNrZXlib2FyZC1hY3Rpb25zPlxuICovXG5jb25zdCBLZXkgPSB7XG4gIE5VTEw6ICdcXHVFMDAwJyxcbiAgQ0FOQ0VMOiAnXFx1RTAwMScsIC8vIF5icmVha1xuICBIRUxQOiAnXFx1RTAwMicsXG4gIEJBQ0tfU1BBQ0U6ICdcXHVFMDAzJyxcbiAgVEFCOiAnXFx1RTAwNCcsXG4gIENMRUFSOiAnXFx1RTAwNScsXG4gIFJFVFVSTjogJ1xcdUUwMDYnLFxuICBFTlRFUjogJ1xcdUUwMDcnLFxuICBTSElGVDogJ1xcdUUwMDgnLFxuICBDT05UUk9MOiAnXFx1RTAwOScsXG4gIEFMVDogJ1xcdUUwMEEnLFxuICBQQVVTRTogJ1xcdUUwMEInLFxuICBFU0NBUEU6ICdcXHVFMDBDJyxcbiAgU1BBQ0U6ICdcXHVFMDBEJyxcbiAgUEFHRV9VUDogJ1xcdUUwMEUnLFxuICBQQUdFX0RPV046ICdcXHVFMDBGJyxcbiAgRU5EOiAnXFx1RTAxMCcsXG4gIEhPTUU6ICdcXHVFMDExJyxcbiAgQVJST1dfTEVGVDogJ1xcdUUwMTInLFxuICBMRUZUOiAnXFx1RTAxMicsXG4gIEFSUk9XX1VQOiAnXFx1RTAxMycsXG4gIFVQOiAnXFx1RTAxMycsXG4gIEFSUk9XX1JJR0hUOiAnXFx1RTAxNCcsXG4gIFJJR0hUOiAnXFx1RTAxNCcsXG4gIEFSUk9XX0RPV046ICdcXHVFMDE1JyxcbiAgRE9XTjogJ1xcdUUwMTUnLFxuICBJTlNFUlQ6ICdcXHVFMDE2JyxcbiAgREVMRVRFOiAnXFx1RTAxNycsXG4gIFNFTUlDT0xPTjogJ1xcdUUwMTgnLFxuICBFUVVBTFM6ICdcXHVFMDE5JyxcblxuICBOVU1QQUQwOiAnXFx1RTAxQScsIC8vIG51bWJlciBwYWQga2V5c1xuICBOVU1QQUQxOiAnXFx1RTAxQicsXG4gIE5VTVBBRDI6ICdcXHVFMDFDJyxcbiAgTlVNUEFEMzogJ1xcdUUwMUQnLFxuICBOVU1QQUQ0OiAnXFx1RTAxRScsXG4gIE5VTVBBRDU6ICdcXHVFMDFGJyxcbiAgTlVNUEFENjogJ1xcdUUwMjAnLFxuICBOVU1QQUQ3OiAnXFx1RTAyMScsXG4gIE5VTVBBRDg6ICdcXHVFMDIyJyxcbiAgTlVNUEFEOTogJ1xcdUUwMjMnLFxuICBNVUxUSVBMWTogJ1xcdUUwMjQnLFxuICBBREQ6ICdcXHVFMDI1JyxcbiAgU0VQQVJBVE9SOiAnXFx1RTAyNicsXG4gIFNVQlRSQUNUOiAnXFx1RTAyNycsXG4gIERFQ0lNQUw6ICdcXHVFMDI4JyxcbiAgRElWSURFOiAnXFx1RTAyOScsXG5cbiAgRjE6ICdcXHVFMDMxJywgLy8gZnVuY3Rpb24ga2V5c1xuICBGMjogJ1xcdUUwMzInLFxuICBGMzogJ1xcdUUwMzMnLFxuICBGNDogJ1xcdUUwMzQnLFxuICBGNTogJ1xcdUUwMzUnLFxuICBGNjogJ1xcdUUwMzYnLFxuICBGNzogJ1xcdUUwMzcnLFxuICBGODogJ1xcdUUwMzgnLFxuICBGOTogJ1xcdUUwMzknLFxuICBGMTA6ICdcXHVFMDNBJyxcbiAgRjExOiAnXFx1RTAzQicsXG4gIEYxMjogJ1xcdUUwM0MnLFxuXG4gIENPTU1BTkQ6ICdcXHVFMDNEJywgLy8gQXBwbGUgY29tbWFuZCBrZXlcbiAgTUVUQTogJ1xcdUUwM0QnLCAvLyBhbGlhcyBmb3IgV2luZG93cyBrZXlcblxuICAvKipcbiAgICogSmFwYW5lc2UgbW9kaWZpZXIga2V5IGZvciBzd2l0Y2hpbmcgYmV0d2VlbiBmdWxsLSBhbmQgaGFsZi13aWR0aFxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKiBAc2VlIDxodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYW5ndWFnZV9pbnB1dF9rZXlzPlxuICAgKi9cbiAgWkVOS0FLVV9IQU5LQUtVOiAnXFx1RTA0MCcsXG59XG5cbi8qKlxuICogU2ltdWxhdGUgcHJlc3NpbmcgbWFueSBrZXlzIGF0IG9uY2UgaW4gYSBcImNob3JkXCIuIFRha2VzIGEgc2VxdWVuY2Ugb2ZcbiAqIHtAbGlua3BsYWluIEtleSBrZXlzfSBvciBzdHJpbmdzLCBhcHBlbmRzIGVhY2ggb2YgdGhlIHZhbHVlcyB0byBhIHN0cmluZyxcbiAqIGFkZHMgdGhlIGNob3JkIHRlcm1pbmF0aW9uIGtleSAoe0BsaW5rIEtleS5OVUxMfSkgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZ1xuICogc3RyaW5nLlxuICpcbiAqIE5vdGU6IHdoZW4gdGhlIGxvdy1sZXZlbCB3ZWJkcml2ZXIga2V5IGhhbmRsZXJzIHNlZSBLZXlzLk5VTEwsIGFjdGl2ZVxuICogbW9kaWZpZXIga2V5cyAoQ1RSTC9BTFQvU0hJRlQvZXRjKSByZWxlYXNlIHZpYSBhIGtleXVwIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXkgc2VxdWVuY2UgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBudWxsLXRlcm1pbmF0ZWQga2V5IHNlcXVlbmNlLlxuICovXG5LZXkuY2hvcmQgPSBmdW5jdGlvbiAoLi4ua2V5cykge1xuICByZXR1cm4ga2V5cy5qb2luKCcnKSArIEtleS5OVUxMXG59XG5cbi8qKlxuICogVXNlZCB3aXRoIHtAbGluayAuL3dlYmVsZW1lbnQuV2ViRWxlbWVudCNzZW5kS2V5cyBXZWJFbGVtZW50I3NlbmRLZXlzfSBvblxuICogZmlsZSBpbnB1dCBlbGVtZW50cyAoYDxpbnB1dCB0eXBlPVwiZmlsZVwiPmApIHRvIGRldGVjdCB3aGVuIHRoZSBlbnRlcmVkIGtleVxuICogc2VxdWVuY2UgZGVmaW5lcyB0aGUgcGF0aCB0byBhIGZpbGUuXG4gKlxuICogQnkgZGVmYXVsdCwge0BsaW5rcGxhaW4gLi93ZWJlbGVtZW50LldlYkVsZW1lbnQgV2ViRWxlbWVudCdzfSB3aWxsIGVudGVyIGFsbFxuICoga2V5IHNlcXVlbmNlcyBleGFjdGx5IGFzIGVudGVyZWQuIFlvdSBtYXkgc2V0IGFcbiAqIHtAbGlua3BsYWluIC4vd2ViZHJpdmVyLldlYkRyaXZlciNzZXRGaWxlRGV0ZWN0b3IgZmlsZSBkZXRlY3Rvcn0gb24gdGhlXG4gKiBwYXJlbnQgV2ViRHJpdmVyIGluc3RhbmNlIHRvIGRlZmluZSBjdXN0b20gYmVoYXZpb3IgZm9yIGhhbmRsaW5nIGZpbGVcbiAqIGVsZW1lbnRzLiBPZiBwYXJ0aWN1bGFyIG5vdGUgaXMgdGhlXG4gKiB7QGxpbmsgc2VsZW5pdW0td2ViZHJpdmVyL3JlbW90ZS5GaWxlRGV0ZWN0b3J9LCB3aGljaCBzaG91bGQgYmUgdXNlZCB3aGVuXG4gKiBydW5uaW5nIGFnYWluc3QgYSByZW1vdGVcbiAqIFtTZWxlbml1bSBTZXJ2ZXJdKGh0dHBzOi8vc2VsZW5pdW0uZGV2L2Rvd25sb2Fkcy8pLlxuICovXG5jbGFzcyBGaWxlRGV0ZWN0b3Ige1xuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHBhdGgsIHByZXBhcmluZyBpdCBmb3IgdXNlIHdpdGhcbiAgICogdGhlIGN1cnJlbnQgYnJvd3Nlci4gSWYgdGhlIHBhdGggZG9lcyBub3QgcmVmZXIgdG8gYSB2YWxpZCBmaWxlLCBpdCB3aWxsXG4gICAqIGJlIHJldHVybmVkIHVuY2hhbmdlZCwgb3RoZXJ3aXNlIGEgcGF0aCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggdGhlIGN1cnJlbnRcbiAgICogYnJvd3NlciB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgYSBuby1vcC4gU3VidHlwZXMgbWF5IG92ZXJyaWRlIHRoaXMgZnVuY3Rpb25cbiAgICogZm9yIGN1c3RvbSB0YWlsb3JlZCBmaWxlIGhhbmRsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyEuL3dlYmRyaXZlci5XZWJEcml2ZXJ9IGRyaXZlciBUaGUgZHJpdmVyIGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgZm9yIHRoZSBwcm9jZXNzZWQgZmlsZSBwYXRoLlxuICAgKiBAcGFja2FnZVxuICAgKi9cbiAgaGFuZGxlRmlsZShfZHJpdmVyLCBwYXRoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGF0aClcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyaWMgZGVzY3JpcHRpb24gb2YgYSBzaW5nbGUgYWN0aW9uIHRvIHNlbmQgdG8gdGhlIHJlbW90ZSBlbmQuXG4gKlxuICogQHJlY29yZFxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQWN0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshQWN0aW9uLlR5cGV9ICovXG4gICAgdGhpcy50eXBlXG4gICAgLyoqIEB0eXBlIHsobnVtYmVyfHVuZGVmaW5lZCl9ICovXG4gICAgdGhpcy5kdXJhdGlvblxuICAgIC8qKiBAdHlwZSB7KHN0cmluZ3x1bmRlZmluZWQpfSAqL1xuICAgIHRoaXMudmFsdWVcbiAgICAvKiogQHR5cGUgeyhCdXR0b258dW5kZWZpbmVkKX0gKi9cbiAgICB0aGlzLmJ1dHRvblxuICAgIC8qKiBAdHlwZSB7KG51bWJlcnx1bmRlZmluZWQpfSAqL1xuICAgIHRoaXMueFxuICAgIC8qKiBAdHlwZSB7KG51bWJlcnx1bmRlZmluZWQpfSAqL1xuICAgIHRoaXMueVxuICB9XG59XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwYWNrYWdlXG4gKiBAc2VlIDxodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyL3dlYmRyaXZlci1zcGVjLmh0bWwjdGVybWlub2xvZ3ktMD5cbiAqL1xuQWN0aW9uLlR5cGUgPSB7XG4gIEtFWV9ET1dOOiAna2V5RG93bicsXG4gIEtFWV9VUDogJ2tleVVwJyxcbiAgUEFVU0U6ICdwYXVzZScsXG4gIFBPSU5URVJfRE9XTjogJ3BvaW50ZXJEb3duJyxcbiAgUE9JTlRFUl9VUDogJ3BvaW50ZXJVcCcsXG4gIFBPSU5URVJfTU9WRTogJ3BvaW50ZXJNb3ZlJyxcbiAgUE9JTlRFUl9DQU5DRUw6ICdwb2ludGVyQ2FuY2VsJyxcbiAgU0NST0xMOiAnc2Nyb2xsJyxcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdXNlciBpbnB1dCBkZXZpY2UuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIERldmljZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RldmljZS5UeXBlfSB0eXBlIHRoZSBpbnB1dCB0eXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgYSB1bmlxdWUgSUQgZm9yIHRoaXMgZGV2aWNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgaWQpIHtcbiAgICAvKiogQHByaXZhdGUgQGNvbnN0ICovIHRoaXMudHlwZV8gPSB0eXBlXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCAqLyB0aGlzLmlkXyA9IGlkXG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gdGhlIEpTT04gZW5jb2RpbmcgZm9yIHRoaXMgZGV2aWNlLiAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdGhpcy50eXBlXywgaWQ6IHRoaXMuaWRfIH1cbiAgfVxufVxuXG4vKipcbiAqIERldmljZSB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhlIFdlYkRyaXZlciBwcm90b2NvbC5cbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHNlZSA8aHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci93ZWJkcml2ZXItc3BlYy5odG1sI2lucHV0LXNvdXJjZS1zdGF0ZT5cbiAqL1xuRGV2aWNlLlR5cGUgPSB7XG4gIEtFWTogJ2tleScsXG4gIE5PTkU6ICdub25lJyxcbiAgUE9JTlRFUjogJ3BvaW50ZXInLFxuICBXSEVFTDogJ3doZWVsJyxcbn1cblxuLyoqXG4gKiBAcGFyYW0geyhzdHJpbmd8S2V5fG51bWJlcil9IGtleVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHRocm93cyB7IShJbnZhbGlkQXJndW1lbnRFcnJvcnxSYW5nZUVycm9yKX1cbiAqL1xuZnVuY3Rpb24gY2hlY2tDb2RlUG9pbnQoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChrZXkpXG4gIH1cblxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGtleSBpcyBub3QgYSBzdHJpbmc6ICR7a2V5fWApXG4gIH1cblxuICBrZXkgPSBrZXkubm9ybWFsaXplKClcbiAgaWYgKEFycmF5LmZyb20oa2V5KS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICBga2V5IGlucHV0IGlzIG5vdCBhIHNpbmdsZSBjb2RlIHBvaW50OiAke2tleX1gXG4gICAgKVxuICB9XG4gIHJldHVybiBrZXlcbn1cblxuLyoqXG4gKiBLZXlib2FyZCBpbnB1dCBkZXZpY2UuXG4gKlxuICogQGZpbmFsXG4gKiBAc2VlIDxodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNkZm4ta2V5LWlucHV0LXNvdXJjZT5cbiAqL1xuY2xhc3MgS2V5Ym9hcmQgZXh0ZW5kcyBEZXZpY2Uge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBkZXZpY2UgSUQuICovXG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgc3VwZXIoRGV2aWNlLlR5cGUuS0VZLCBpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBrZXkgZG93biBhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7KEtleXxzdHJpbmd8bnVtYmVyKX0ga2V5IHRoZSBrZXkgdG8gcHJlc3MuIFRoaXMga2V5IG1heSBiZVxuICAgKiAgICAgc3BlY2lmaWVkIGFzIGEge0BsaW5rIEtleX0gdmFsdWUsIGEgc3BlY2lmaWMgdW5pY29kZSBjb2RlIHBvaW50LFxuICAgKiAgICAgb3IgYSBzdHJpbmcgY29udGFpbmluZyBhIHNpbmdsZSB1bmljb2RlIGNvZGUgcG9pbnQuXG4gICAqIEByZXR1cm4geyFBY3Rpb259IGEgbmV3IGtleSBkb3duIGFjdGlvbi5cbiAgICogQHBhY2thZ2VcbiAgICovXG4gIGtleURvd24oa2V5KSB7XG4gICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uLlR5cGUuS0VZX0RPV04sIHZhbHVlOiBjaGVja0NvZGVQb2ludChrZXkpIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBrZXkgdXAgYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyhLZXl8c3RyaW5nfG51bWJlcil9IGtleSB0aGUga2V5IHRvIHByZXNzLiBUaGlzIGtleSBtYXkgYmVcbiAgICogICAgIHNwZWNpZmllZCBhcyBhIHtAbGluayBLZXl9IHZhbHVlLCBhIHNwZWNpZmljIHVuaWNvZGUgY29kZSBwb2ludCxcbiAgICogICAgIG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBzaW5nbGUgdW5pY29kZSBjb2RlIHBvaW50LlxuICAgKiBAcmV0dXJuIHshQWN0aW9ufSBhIG5ldyBrZXkgdXAgYWN0aW9uLlxuICAgKiBAcGFja2FnZVxuICAgKi9cbiAga2V5VXAoa2V5KSB7XG4gICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uLlR5cGUuS0VZX1VQLCB2YWx1ZTogY2hlY2tDb2RlUG9pbnQoa2V5KSB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmVzIHRoZSByZWZlcmVuY2UgcG9pbnQgZnJvbSB3aGljaCB0byBjb21wdXRlIG9mZnNldHMgZm9yXG4gKiB7QGxpbmtwbGFpbiAuL2lucHV0LlBvaW50ZXIjbW92ZSBwb2ludGVyIG1vdmV9IGFjdGlvbnMuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgT3JpZ2luID0ge1xuICAvKiogQ29tcHV0ZSBvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBwb2ludGVyJ3MgY3VycmVudCBwb3NpdGlvbi4gKi9cbiAgUE9JTlRFUjogJ3BvaW50ZXInLFxuICAvKiogQ29tcHV0ZSBvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC4gKi9cbiAgVklFV1BPUlQ6ICd2aWV3cG9ydCcsXG59XG5cbi8qKlxuICogUG9pbnRlciBpbnB1dCBkZXZpY2UuXG4gKlxuICogQGZpbmFsXG4gKiBAc2VlIDxodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNkZm4tcG9pbnRlci1pbnB1dC1zb3VyY2U+XG4gKi9cbmNsYXNzIFBvaW50ZXIgZXh0ZW5kcyBEZXZpY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBkZXZpY2UgSUQuXG4gICAqIEBwYXJhbSB7UG9pbnRlci5UeXBlfSB0eXBlIHRoZSBwb2ludGVyIHR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpZCwgdHlwZSkge1xuICAgIHN1cGVyKERldmljZS5UeXBlLlBPSU5URVIsIGlkKVxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgKi8gdGhpcy5wb2ludGVyVHlwZV8gPSB0eXBlXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHsgcGFyYW1ldGVyczogeyBwb2ludGVyVHlwZTogdGhpcy5wb2ludGVyVHlwZV8gfSB9LFxuICAgICAgc3VwZXIudG9KU09OKClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUFjdGlvbn0gQW4gYWN0aW9uIHRoYXQgY2FuY2VscyB0aGlzIHBvaW50ZXIncyBjdXJyZW50IGlucHV0LlxuICAgKiBAcGFja2FnZVxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHJldHVybiB7IHR5cGU6IEFjdGlvbi5UeXBlLlBPSU5URVJfQ0FOQ0VMIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFCdXR0b249fSBidXR0b24gVGhlIGJ1dHRvbiB0byBwcmVzcy5cbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHRcbiAgICogQHBhcmFtIHByZXNzdXJlXG4gICAqIEBwYXJhbSB0YW5nZW50aWFsUHJlc3N1cmVcbiAgICogQHBhcmFtIHRpbHRYXG4gICAqIEBwYXJhbSB0aWx0WVxuICAgKiBAcGFyYW0gdHdpc3RcbiAgICogQHBhcmFtIGFsdGl0dWRlQW5nbGVcbiAgICogQHBhcmFtIGF6aW11dGhBbmdsZVxuICAgKiBAcmV0dXJuIHshQWN0aW9ufSBBbiBhY3Rpb24gdG8gcHJlc3MgdGhlIHNwZWNpZmllZCBidXR0b24gd2l0aCB0aGlzIGRldmljZS5cbiAgICogQHBhY2thZ2VcbiAgICovXG4gIHByZXNzKFxuICAgIGJ1dHRvbiA9IEJ1dHRvbi5MRUZULFxuICAgIHdpZHRoID0gMCxcbiAgICBoZWlnaHQgPSAwLFxuICAgIHByZXNzdXJlID0gMCxcbiAgICB0YW5nZW50aWFsUHJlc3N1cmUgPSAwLFxuICAgIHRpbHRYID0gMCxcbiAgICB0aWx0WSA9IDAsXG4gICAgdHdpc3QgPSAwLFxuICAgIGFsdGl0dWRlQW5nbGUgPSAwLFxuICAgIGF6aW11dGhBbmdsZSA9IDBcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IEFjdGlvbi5UeXBlLlBPSU5URVJfRE9XTixcbiAgICAgIGJ1dHRvbixcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcHJlc3N1cmUsXG4gICAgICB0YW5nZW50aWFsUHJlc3N1cmUsXG4gICAgICB0aWx0WCxcbiAgICAgIHRpbHRZLFxuICAgICAgdHdpc3QsXG4gICAgICBhbHRpdHVkZUFuZ2xlLFxuICAgICAgYXppbXV0aEFuZ2xlLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFCdXR0b249fSBidXR0b24gVGhlIGJ1dHRvbiB0byByZWxlYXNlLlxuICAgKiBAcmV0dXJuIHshQWN0aW9ufSBBbiBhY3Rpb24gdG8gcmVsZWFzZSB0aGUgc3BlY2lmaWVkIGJ1dHRvbiB3aXRoIHRoaXNcbiAgICogICAgIGRldmljZS5cbiAgICogQHBhY2thZ2VcbiAgICovXG4gIHJlbGVhc2UoYnV0dG9uID0gQnV0dG9uLkxFRlQpIHtcbiAgICByZXR1cm4geyB0eXBlOiBBY3Rpb24uVHlwZS5QT0lOVEVSX1VQLCBidXR0b24gfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYWN0aW9uIGZvciBtb3ZpbmcgdGhlIHBvaW50ZXIgYHhgIGFuZCBgeWAgcGl4ZWxzIGZyb20gdGhlXG4gICAqIHNwZWNpZmllZCBgb3JpZ2luYC4gVGhlIGBvcmlnaW5gIG1heSBiZSBkZWZpbmVkIGFzIHRoZSBwb2ludGVyJ3NcbiAgICoge0BsaW5rcGxhaW4gT3JpZ2luLlBPSU5URVIgY3VycmVudCBwb3NpdGlvbn0sIHRoZVxuICAgKiB7QGxpbmtwbGFpbiBPcmlnaW4uVklFV1BPUlQgdmlld3BvcnR9LCBvciB0aGUgY2VudGVyIG9mIGEgc3BlY2lmaWNcbiAgICoge0BsaW5rcGxhaW4gLi93ZWJkcml2ZXIuV2ViRWxlbWVudCBXZWJFbGVtZW50fS5cbiAgICpcbiAgICogQHBhcmFtIHt7XG4gICAqICAgeDogKG51bWJlcnx1bmRlZmluZWQpLFxuICAgKiAgIHk6IChudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICBkdXJhdGlvbjogKG51bWJlcnx1bmRlZmluZWQpLFxuICAgKiAgIG9yaWdpbjogKCFPcmlnaW58IS4vd2ViZHJpdmVyLldlYkVsZW1lbnR8dW5kZWZpbmVkKSxcbiAgICogfT19IG9wdGlvbnMgdGhlIG1vdmUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7IUFjdGlvbn0gVGhlIG5ldyBhY3Rpb24uXG4gICAqIEBwYWNrYWdlXG4gICAqL1xuICBtb3ZlKHtcbiAgICB4ID0gMCxcbiAgICB5ID0gMCxcbiAgICBkdXJhdGlvbiA9IDEwMCxcbiAgICBvcmlnaW4gPSBPcmlnaW4uVklFV1BPUlQsXG4gICAgd2lkdGggPSAwLFxuICAgIGhlaWdodCA9IDAsXG4gICAgcHJlc3N1cmUgPSAwLFxuICAgIHRhbmdlbnRpYWxQcmVzc3VyZSA9IDAsXG4gICAgdGlsdFggPSAwLFxuICAgIHRpbHRZID0gMCxcbiAgICB0d2lzdCA9IDAsXG4gICAgYWx0aXR1ZGVBbmdsZSA9IDAsXG4gICAgYXppbXV0aEFuZ2xlID0gMCxcbiAgfSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBBY3Rpb24uVHlwZS5QT0lOVEVSX01PVkUsXG4gICAgICBvcmlnaW4sXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwcmVzc3VyZSxcbiAgICAgIHRhbmdlbnRpYWxQcmVzc3VyZSxcbiAgICAgIHRpbHRYLFxuICAgICAgdGlsdFksXG4gICAgICB0d2lzdCxcbiAgICAgIGFsdGl0dWRlQW5nbGUsXG4gICAgICBhemltdXRoQW5nbGUsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhlIHN1cHBvcnRlZCB0eXBlcyBvZiBwb2ludGVycy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cblBvaW50ZXIuVHlwZSA9IHtcbiAgTU9VU0U6ICdtb3VzZScsXG4gIFBFTjogJ3BlbicsXG4gIFRPVUNIOiAndG91Y2gnLFxufVxuXG5jbGFzcyBXaGVlbCBleHRlbmRzIERldmljZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGRldmljZSBJRC4uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHN1cGVyKERldmljZS5UeXBlLldIRUVMLCBpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIGEgcGFnZSB2aWEgdGhlIGNvb3JkaW5hdGVzIGdpdmVuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHN0YXJ0aW5nIHggY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geSBzdGFydGluZyB5IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYIHRvIHNjcm9sbCB0byB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZIHRvIHNjcm9sbCB0byB0YXJnZXRcbiAgICogQHBhcmFtIHtXZWJFbGVtZW50fSBvcmlnaW4gZWxlbWVudCBvcmlnaW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIGR1cmF0aW9uIHJhdGlvIGJlIHRoZSByYXRpbyBvZiB0aW1lIGRlbHRhIGFuZCBkdXJhdGlvblxuICAgKiBAcmV0dXJucyB7IUFjdGlvbn0gQW4gYWN0aW9uIHRvIHNjcm9sbCB3aXRoIHRoaXMgZGV2aWNlLlxuICAgKi9cbiAgc2Nyb2xsKHgsIHksIGRlbHRhWCwgZGVsdGFZLCBvcmlnaW4sIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IEFjdGlvbi5UeXBlLlNDUk9MTCxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICBkZWx0YVk6IGRlbHRhWSxcbiAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVzZXIgZmFjaW5nIEFQSSBmb3IgZ2VuZXJhdGluZyBjb21wbGV4IHVzZXIgZ2VzdHVyZXMuIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdFxuICogYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2VycyBzaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZXMgYnlcbiAqIGNhbGxpbmcge0BsaW5rIC4vd2ViZHJpdmVyLldlYkRyaXZlciNhY3Rpb25zIFdlYkRyaXZlci5hY3Rpb25zKCl9LlxuICpcbiAqICMjIyBBY3Rpb24gVGlja3NcbiAqXG4gKiBBY3Rpb24gc2VxdWVuY2VzIGFyZSBkaXZpZGVkIGludG8gYSBzZXJpZXMgb2YgXCJ0aWNrc1wiLiBBdCBlYWNoIHRpY2ssIHRoZVxuICogV2ViRHJpdmVyIHJlbW90ZSBlbmQgd2lsbCBwZXJmb3JtIGEgc2luZ2xlIGFjdGlvbiBmb3IgZWFjaCBkZXZpY2UgaW5jbHVkZWRcbiAqIGluIHRoZSBhY3Rpb24gc2VxdWVuY2UuIEF0IHRpY2sgMCwgdGhlIGRyaXZlciB3aWxsIHBlcmZvcm0gdGhlIGZpcnN0IGFjdGlvblxuICogZGVmaW5lZCBmb3IgZWFjaCBkZXZpY2UsIGF0IHRpY2sgMSB0aGUgc2Vjb25kIGFjdGlvbiBmb3IgZWFjaCBkZXZpY2UsIGFuZFxuICogc28gb24gdW50aWwgYWxsIGFjdGlvbnMgaGF2ZSBiZWVuIGV4ZWN1dGVkLiBJZiBhbiBpbmRpdmlkdWFsIGRldmljZSBkb2VzXG4gKiBub3QgaGF2ZSBhbiBhY3Rpb24gZGVmaW5lZCBhdCBhIHBhcnRpY3VsYXIgdGljaywgaXQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gKiBwYXVzZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBhY3Rpb24gc2VxdWVuY2VzIHdpbGwgYmUgc3luY2hyb25pemVkIHNvIG9ubHkgb25lIGRldmljZSBoYXMgYVxuICogZGVmaW5lIGFjdGlvbiBpbiBlYWNoIHRpY2suIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgY29kZSBzYW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFjdGlvbnMgPSBkcml2ZXIuYWN0aW9ucygpO1xuICpcbiAqICAgICBhd2FpdCBhY3Rpb25zXG4gKiAgICAgICAgIC5rZXlEb3duKFNISUZUKVxuICogICAgICAgICAubW92ZSh7b3JpZ2luOiBlbH0pXG4gKiAgICAgICAgIC5wcmVzcygpXG4gKiAgICAgICAgIC5yZWxlYXNlKClcbiAqICAgICAgICAgLmtleVVwKFNISUZUKVxuICogICAgICAgICAucGVyZm9ybSgpO1xuICpcbiAqIFRoaXMgc2FtcGxlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2Ugb2YgdGlja3M6XG4gKlxuICogfCBEZXZpY2UgICB8IFRpY2sgMSAgICAgICAgIHwgVGljayAyICAgICAgICAgICAgIHwgVGljayAzICB8IFRpY2sgNCAgICB8IFRpY2sgNSAgICAgICB8XG4gKiB8IC0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tIHxcbiAqIHwgS2V5Ym9hcmQgfCBrZXlEb3duKFNISUZUKSB8IHBhdXNlKCkgICAgICAgICAgICB8IHBhdXNlKCkgfCBwYXVzZSgpICAgfCBrZXlVcChTSElGVCkgfFxuICogfCBNb3VzZSAgICB8IHBhdXNlKCkgICAgICAgIHwgbW92ZSh7b3JpZ2luOiBlbH0pIHwgcHJlc3MoKSB8IHJlbGVhc2UoKSB8IHBhdXNlKCkgICAgICB8XG4gKlxuICogSWYgeW91J2QgbGlrZSB0aGUgcmVtb3RlIGVuZCB0byBleGVjdXRlIGFjdGlvbnMgd2l0aCBtdWx0aXBsZSBkZXZpY2VzXG4gKiBzaW11bHRhbmVvdXNseSwgeW91IG1heSBwYXNzIGB7YXN5bmM6IHRydWV9YCB3aGVuIGNyZWF0aW5nIHRoZSBhY3Rpb25zXG4gKiBidWlsZGVyLiBXaXRoIHN5bmNocm9uaXphdGlvbiBkaXNhYmxlZCAoYHthc3luYzogdHJ1ZX1gKSwgdGhlIHRpY2tzIGZyb20gb3VyXG4gKiBwcmV2aW91cyBleGFtcGxlIGJlY29tZTpcbiAqXG4gKiB8IERldmljZSAgIHwgVGljayAxICAgICAgICAgICAgIHwgVGljayAyICAgICAgIHwgVGljayAzICAgIHxcbiAqIHwgLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0gfFxuICogfCBLZXlib2FyZCB8IGtleURvd24oU0hJRlQpICAgICB8IGtleVVwKFNISUZUKSB8ICAgICAgICAgICB8XG4gKiB8IE1vdXNlICAgIHwgbW92ZSh7b3JpZ2luOiBlbH0pIHwgcHJlc3MoKSAgICAgIHwgcmVsZWFzZSgpIHxcbiAqXG4gKiBXaGVuIHN5bmNocm9uaXphdGlvbiBpcyBkaXNhYmxlZCwgaXQgaXMgeW91ciByZXNwb25zaWJpbGl0eSB0byBpbnNlcnRcbiAqIHtAbGlua3BsYWluICNwYXVzZSgpIHBhdXNlc30gZm9yIGVhY2ggZGV2aWNlLCBhcyBuZWVkZWQ6XG4gKlxuICogICAgIGNvbnN0IGFjdGlvbnMgPSBkcml2ZXIuYWN0aW9ucyh7YXN5bmM6IHRydWV9KTtcbiAqICAgICBjb25zdCBrYiA9IGFjdGlvbnMua2V5Ym9hcmQoKTtcbiAqICAgICBjb25zdCBtb3VzZSA9IGFjdGlvbnMubW91c2UoKTtcbiAqXG4gKiAgICAgYWN0aW9ucy5rZXlEb3duKFNISUZUKS5wYXVzZShrYikucGF1c2Uoa2IpLmtleShTSElGVCk7XG4gKiAgICAgYWN0aW9ucy5wYXVzZShtb3VzZSkubW92ZSh7b3JpZ2luOiBlbH0pLnByZXNzKCkucmVsZWFzZSgpO1xuICogICAgIGFjdGlvbnMucGVyZm9ybSgpO1xuICpcbiAqIFdpdGggcGF1c2VzIGluc2VydCBmb3IgaW5kaXZpZHVhbCBkZXZpY2VzLCB3ZSdyZSBiYWNrIHRvOlxuICpcbiAqIHwgRGV2aWNlICAgfCBUaWNrIDEgICAgICAgICB8IFRpY2sgMiAgICAgICAgICAgICB8IFRpY2sgMyAgfCBUaWNrIDQgICAgICAgfFxuICogfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0tLS0tLSB8XG4gKiB8IEtleWJvYXJkIHwga2V5RG93bihTSElGVCkgfCBwYXVzZSgpICAgICAgICAgICAgfCBwYXVzZSgpIHwga2V5VXAoU0hJRlQpIHxcbiAqIHwgTW91c2UgICAgfCBwYXVzZSgpICAgICAgICB8IG1vdmUoe29yaWdpbjogZWx9KSB8IHByZXNzKCkgfCByZWxlYXNlKCkgICAgfFxuICpcbiAqICMjIyMgVGljayBEdXJhdGlvbnNcbiAqXG4gKiBUaGUgbGVuZ3RoIG9mIGVhY2ggYWN0aW9uIHRpY2sgaXMgaG93ZXZlciBsb25nIGl0IHRha2VzIHRoZSByZW1vdGUgZW5kIHRvXG4gKiBleGVjdXRlIHRoZSBhY3Rpb25zIGZvciBldmVyeSBkZXZpY2UgaW4gdGhhdCB0aWNrLiBNb3N0IGFjdGlvbnMgYXJlXG4gKiBcImluc3RhbnRhbmVvdXNcIiwgaG93ZXZlciwge0BsaW5rcGxhaW4gI3BhdXNlIHBhdXNlfSBhbmRcbiAqIHtAbGlua3BsYWluICNtb3ZlIHBvaW50ZXIgbW92ZX0gYWN0aW9ucyBhbGxvdyB5b3UgdG8gc3BlY2lmeSBhIGR1cmF0aW9uIGZvclxuICogaG93IGxvbmcgdGhhdCBhY3Rpb24gc2hvdWxkIHRha2UuIFRoZSByZW1vdGUgZW5kIHdpbGwgYWx3YXlzIHdhaXQgZm9yIGFsbFxuICogYWN0aW9ucyB3aXRoaW4gYSB0aWNrIHRvIGZpbmlzaCBiZWZvcmUgc3RhcnRpbmcgdGhlIG5leHQgdGljaywgc28gYSBkZXZpY2VcbiAqIG1heSBpbXBsaWNpdGx5IHBhdXNlIHdoaWxlIHdhaXRpbmcgZm9yIG90aGVyIGRldmljZXMgdG8gZmluaXNoLlxuICpcbiAqIHwgRGV2aWNlICAgIHwgVGljayAxICAgICAgICAgICAgICAgIHwgVGljayAyICB8XG4gKiB8IC0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0gfFxuICogfCBQb2ludGVyIDEgfCBtb3ZlKHtkdXJhdGlvbjogMjAwfSkgfCBwcmVzcygpIHxcbiAqIHwgUG9pbnRlciAyIHwgbW92ZSh7ZHVyYXRpb246IDMwMH0pIHwgcHJlc3MoKSB8XG4gKlxuICogSW4gdGFibGUgYWJvdmUsIHRoZSBtb3ZlIGZvciBQb2ludGVyIDEgc2hvdWxkIG9ubHkgdGFrZSAyMDAgbXMsIGJ1dCB0aGVcbiAqIHJlbW90ZSBlbmQgd2lsbCB3YWl0IGZvciB0aGUgbW92ZSBmb3IgUG9pbnRlciAyIHRvIGZpbmlzaFxuICogKGFuIGFkZGl0aW9uYWwgMTAwIG1zKSBiZWZvcmUgcHJvY2VlZGluZyB0byBUaWNrIDIuXG4gKlxuICogVGhpcyBpbXBsaWNpdCB3YWl0aW5nIGFsc28gYXBwbGllcyB0byBwYXVzZXMuIEluIHRoZSB0YWJsZSBiZWxvdywgZXZlbiB0aG91Z2hcbiAqIHRoZSBrZXlib2FyZCBvbmx5IGRlZmluZXMgYSBwYXVzZSBvZiAxMDAgbXMsIHRoZSByZW1vdGUgZW5kIHdpbGwgd2FpdCBhblxuICogYWRkaXRpb25hbCAyMDAgbXMgZm9yIHRoZSBtb3VzZSBtb3ZlIHRvIGZpbmlzaCBiZWZvcmUgbW92aW5nIHRvIFRpY2sgMi5cbiAqXG4gKiB8IERldmljZSAgIHwgVGljayAxICAgICAgICAgICAgICAgIHwgVGljayAyICAgICAgICAgfFxuICogfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgS2V5Ym9hcmQgfCBwYXVzZSgxMDApICAgICAgICAgICAgfCBrZXlEb3duKFNISUZUKSB8XG4gKiB8IE1vdXNlICAgIHwgbW92ZSh7ZHVyYXRpb246IDMwMH0pIHwgICAgICAgICAgICAgICAgfFxuICpcbiAqIFtjbGllbnQgcmVjdF06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldENsaWVudFJlY3RzXG4gKiBbYm91bmRpbmcgY2xpZW50IHJlY3RdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqXG4gKiBAZmluYWxcbiAqIEBzZWUgPGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJkcml2ZXIvI2FjdGlvbnM+XG4gKi9cbmNsYXNzIEFjdGlvbnMge1xuICAvKipcbiAgICogQHBhcmFtIHshRXhlY3V0b3J9IGV4ZWN1dG9yIFRoZSBvYmplY3QgdG8gZXhlY3V0ZSB0aGUgY29uZmlndXJlZFxuICAgKiAgICAgYWN0aW9ucyB3aXRoLlxuICAgKiBAcGFyYW0ge3thc3luYzogKGJvb2xlYW58dW5kZWZpbmVkKX19IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhpcyBhY3Rpb25cbiAgICogICAgIHNlcXVlbmNlIChzZWUgY2xhc3MgZGVzY3JpcHRpb24gZm9yIGRldGFpbHMpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZXhlY3V0b3IsIHsgYXN5bmMgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAvKiogQHByaXZhdGUgQGNvbnN0ICovXG4gICAgdGhpcy5leGVjdXRvcl8gPSBleGVjdXRvclxuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCAqL1xuICAgIHRoaXMuc3luY18gPSAhYXN5bmNcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgKi9cbiAgICB0aGlzLmtleWJvYXJkXyA9IG5ldyBLZXlib2FyZCgnZGVmYXVsdCBrZXlib2FyZCcpXG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0ICovXG4gICAgdGhpcy5tb3VzZV8gPSBuZXcgUG9pbnRlcignZGVmYXVsdCBtb3VzZScsIFBvaW50ZXIuVHlwZS5NT1VTRSlcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgKi9cbiAgICB0aGlzLndoZWVsXyA9IG5ldyBXaGVlbCgnZGVmYXVsdCB3aGVlbCcpXG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshTWFwPCFEZXZpY2UsICFBcnJheTwhQWN0aW9uPj59ICovXG4gICAgdGhpcy5zZXF1ZW5jZXNfID0gbmV3IE1hcChbXG4gICAgICBbdGhpcy5rZXlib2FyZF8sIFtdXSxcbiAgICAgIFt0aGlzLm1vdXNlXywgW11dLFxuICAgICAgW3RoaXMud2hlZWxfLCBbXV0sXG4gICAgXSlcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshS2V5Ym9hcmR9IHRoZSBrZXlib2FyZCBkZXZpY2UgaGFuZGxlLiAqL1xuICBrZXlib2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlib2FyZF9cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshUG9pbnRlcn0gdGhlIG1vdXNlIHBvaW50ZXIgZGV2aWNlIGhhbmRsZS4gKi9cbiAgbW91c2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VfXG4gIH1cblxuICAvKiogQHJldHVybiB7IVdoZWVsfSB0aGUgd2hlZWwgZGV2aWNlIGhhbmRsZS4gKi9cbiAgd2hlZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMud2hlZWxfXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRGV2aWNlfSBkZXZpY2VcbiAgICogQHJldHVybiB7IUFycmF5PCFBY3Rpb24+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VxdWVuY2VfKGRldmljZSkge1xuICAgIGxldCBzZXF1ZW5jZSA9IHRoaXMuc2VxdWVuY2VzXy5nZXQoZGV2aWNlKVxuICAgIGlmICghc2VxdWVuY2UpIHtcbiAgICAgIHNlcXVlbmNlID0gW11cbiAgICAgIHRoaXMuc2VxdWVuY2VzXy5zZXQoZGV2aWNlLCBzZXF1ZW5jZSlcbiAgICB9XG4gICAgcmV0dXJuIHNlcXVlbmNlXG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBgYWN0aW9uc2AgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzZXF1ZW5jZSBmb3IgdGhlIGdpdmVuXG4gICAqIGBkZXZpY2VgLiBJZiBkZXZpY2Ugc3luY2hyb25pemF0aW9uIGlzIGVuYWJsZWQsIGFmdGVyIGluc2VydGluZyB0aGVcbiAgICogYWN0aW9ucywgcGF1c2VzIHdpbGwgYmUgaW5zZXJ0ZWQgZm9yIGFsbCBvdGhlciBkZXZpY2VzIHRvIGVuc3VyZSBhbGwgYWN0aW9uXG4gICAqIHNlcXVlbmNlcyBhcmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgKlxuICAgKiBAcGFyYW0geyFEZXZpY2V9IGRldmljZSB0aGUgZGV2aWNlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHsuLi4hQWN0aW9ufSBhY3Rpb25zIHRoZSBhY3Rpb25zIHRvIGluc2VydC5cbiAgICogQHJldHVybiB7IUFjdGlvbnN9IGEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBpbnNlcnQoZGV2aWNlLCAuLi5hY3Rpb25zKSB7XG4gICAgdGhpcy5zZXF1ZW5jZV8oZGV2aWNlKS5wdXNoKC4uLmFjdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMuc3luY18gPyB0aGlzLnN5bmNocm9uaXplKCkgOiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGUgYWN0aW9uIHNlcXVlbmNlIGZvciBldmVyeSBkZXZpY2UgcmVmZXJlbmNlZCBpbiB0aGlzIGFjdGlvblxuICAgKiBzZXF1ZW5jZSBpcyB0aGUgc2FtZSBsZW5ndGguIEZvciBkZXZpY2VzIHdob3NlIHNlcXVlbmNlIGlzIHRvbyBzaG9ydCxcbiAgICogdGhpcyB3aWxsIGluc2VydCB7QGxpbmtwbGFpbiAjcGF1c2UgcGF1c2VzfSBzbyB0aGF0IGV2ZXJ5IGRldmljZSBoYXMgYW5cbiAgICogZXhwbGljaXQgYWN0aW9uIGRlZmluZWQgYXQgZWFjaCB0aWNrLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLiFEZXZpY2V9IGRldmljZXMgVGhlIHNwZWNpZmljIGRldmljZXMgdG8gc3luY2hyb25pemUuXG4gICAqICAgICBJZiB1bnNwZWNpZmllZCwgdGhlIGFjdGlvbiBzZXF1ZW5jZXMgZm9yIGV2ZXJ5IGRldmljZSB3aWxsIGJlXG4gICAqICAgICBzeW5jaHJvbml6ZWQuXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc3luY2hyb25pemUoLi4uZGV2aWNlcykge1xuICAgIGxldCBzZXF1ZW5jZXNcbiAgICBsZXQgbWF4ID0gMFxuICAgIGlmIChkZXZpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuc2VxdWVuY2VzXy52YWx1ZXMoKSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHMubGVuZ3RoKVxuICAgICAgfVxuICAgICAgc2VxdWVuY2VzID0gdGhpcy5zZXF1ZW5jZXNfLnZhbHVlcygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcXVlbmNlcyA9IFtdXG4gICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICAgIGNvbnN0IHNlcSA9IHRoaXMuc2VxdWVuY2VfKGRldmljZSlcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBzZXEubGVuZ3RoKVxuICAgICAgICBzZXF1ZW5jZXMucHVzaChzZXEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGF1c2UgPSB7IHR5cGU6IEFjdGlvbi5UeXBlLlBBVVNFLCBkdXJhdGlvbjogMCB9XG4gICAgZm9yIChjb25zdCBzZXEgb2Ygc2VxdWVuY2VzKSB7XG4gICAgICB3aGlsZSAoc2VxLmxlbmd0aCA8IG1heCkge1xuICAgICAgICBzZXEucHVzaChwYXVzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBwYXVzZSBhY3Rpb24gZm9yIHRoZSBzcGVjaWZpZWQgZGV2aWNlcywgZW5zdXJpbmcgZWFjaCBkZXZpY2UgaXNcbiAgICogaWRsZSBmb3IgYSB0aWNrLiBUaGUgbGVuZ3RoIG9mIHRoZSBwYXVzZSAoaW4gbWlsbGlzZWNvbmRzKSBtYXkgYmUgc3BlY2lmaWVkXG4gICAqIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gdGhpcyBtZXRob2QgKGRlZmF1bHRzIHRvIDApLiBPdGhlcndpc2UsIHlvdSBtYXlcbiAgICoganVzdCBzcGVjaWZ5IHRoZSBpbmRpdmlkdWFsIGRldmljZXMgdGhhdCBzaG91bGQgcGF1c2UuXG4gICAqXG4gICAqIElmIG5vIGRldmljZXMgYXJlIHNwZWNpZmllZCwgYSBwYXVzZSBhY3Rpb24gd2lsbCBiZSBjcmVhdGVkICh1c2luZyB0aGUgc2FtZVxuICAgKiBkdXJhdGlvbikgZm9yIGV2ZXJ5IGRldmljZS5cbiAgICpcbiAgICogV2hlbiBkZXZpY2Ugc3luY2hyb25pemF0aW9uIGlzIGVuYWJsZWQgKHRoZSBkZWZhdWx0IGZvciBuZXcge0BsaW5rIEFjdGlvbnN9XG4gICAqIG9iamVjdHMpLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNwZWNpZnkgZGV2aWNlcyBhcyBwYXVzaW5nIG9uZSBhdXRvbWF0aWNhbGx5XG4gICAqIHBhdXNlcyB0aGUgb3RoZXJzIGZvciB0aGUgc2FtZSBkdXJhdGlvbi4gSW4gb3RoZXIgd29yZHMsIHRoZSBmb2xsb3dpbmcgYXJlXG4gICAqIGFsbCBlcXVpdmFsZW50OlxuICAgKlxuICAgKiAgICAgbGV0IGExID0gZHJpdmVyLmFjdGlvbnMoKTtcbiAgICogICAgIGExLnBhdXNlKDEwMCkucGVyZm9ybSgpO1xuICAgKlxuICAgKiAgICAgbGV0IGEyID0gZHJpdmVyLmFjdGlvbnMoKTtcbiAgICogICAgIGEyLnBhdXNlKDEwMCwgYTIua2V5Ym9hcmQoKSkucGVyZm9ybSgpO1xuICAgKiAgICAgLy8gU3luY2hyb25pemF0aW9uIGVuc3VyZXMgYTIubW91c2UoKSBpcyBhdXRvbWF0aWNhbGx5IHBhdXNlZCB0b28uXG4gICAqXG4gICAqICAgICBsZXQgYTMgPSBkcml2ZXIuYWN0aW9ucygpO1xuICAgKiAgICAgYTMucGF1c2UoMTAwLCBhMy5rZXlib2FyZCgpLCBhMy5tb3VzZSgpKS5wZXJmb3JtKCk7XG4gICAqXG4gICAqIFdoZW4gZGV2aWNlIHN5bmNocm9uaXphdGlvbiBpcyBfZGlzYWJsZWRfLCB5b3UgY2FuIGNhdXNlIGluZGl2aWR1YWwgZGV2aWNlc1xuICAgKiB0byBwYXVzZSBkdXJpbmcgYSB0aWNrLiBGb3IgZXhhbXBsZSwgdG8gaG9sZCB0aGUgU0hJRlQga2V5IGRvd24gd2hpbGVcbiAgICogbW92aW5nIHRoZSBtb3VzZTpcbiAgICpcbiAgICogICAgIGxldCBhY3Rpb25zID0gZHJpdmVyLmFjdGlvbnMoe2FzeW5jOiB0cnVlfSk7XG4gICAqXG4gICAqICAgICBhY3Rpb25zLmtleURvd24oS2V5LlNISUZUKTtcbiAgICogICAgIGFjdGlvbnMucGF1c2UoYWN0aW9ucy5tb3VzZSgpKSAgLy8gUGF1c2UgZm9yIHNoaWZ0IGRvd25cbiAgICogICAgICAgICAucHJlc3MoQnV0dG9uLkxFRlQpXG4gICAqICAgICAgICAgLm1vdmUoe3g6IDEwLCB5OiAxMH0pXG4gICAqICAgICAgICAgLnJlbGVhc2UoQnV0dG9uLkxFRlQpO1xuICAgKiAgICAgYWN0aW9uc1xuICAgKiAgICAgICAgIC5wYXVzZShcbiAgICogICAgICAgICAgICAgYWN0aW9ucy5rZXlib2FyZCgpLCAgLy8gUGF1c2UgZm9yIHByZXNzIGxlZnRcbiAgICogICAgICAgICAgICAgYWN0aW9ucy5rZXlib2FyZCgpLCAgLy8gUGF1c2UgZm9yIG1vdmVcbiAgICogICAgICAgICAgICAgYWN0aW9ucy5rZXlib2FyZCgpKSAgLy8gUGF1c2UgZm9yIHJlbGVhc2UgbGVmdFxuICAgKiAgICAgICAgLmtleVVwKEtleS5TSElGVCk7XG4gICAqICAgICBhd2FpdCBhY3Rpb25zLnBlcmZvcm0oKTtcbiAgICpcbiAgICogQHBhcmFtIHsobnVtYmVyfCFEZXZpY2UpPX0gZHVyYXRpb24gVGhlIGxlbmd0aCBvZiB0aGUgcGF1c2UgdG8gaW5zZXJ0LCBpblxuICAgKiAgICAgbWlsbGlzZWNvbmRzLiBBbHRlcm5hdGl2ZWx5LCB0aGUgZHVyYXRpb24gbWF5IGJlIG9taXR0ZWQgKHlpZWxkaW5nIGFcbiAgICogICAgIGRlZmF1bHQgMCBtcyBwYXVzZSksIGFuZCB0aGUgZmlyc3QgZGV2aWNlIHRvIHBhdXNlIG1heSBiZSBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7Li4uIURldmljZX0gZGV2aWNlcyBUaGUgZGV2aWNlcyB0byBpbnNlcnQgdGhlIHBhdXNlIGZvci4gSWYgbm9cbiAgICogICAgIGRldmljZXMgYXJlIHNwZWNpZmllZCwgdGhlIHBhdXNlIHdpbGwgYmUgaW5zZXJ0ZWQgZm9yIF9hbGxfIGRldmljZXMuXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgcGF1c2UoZHVyYXRpb24sIC4uLmRldmljZXMpIHtcbiAgICBpZiAoZHVyYXRpb24gaW5zdGFuY2VvZiBEZXZpY2UpIHtcbiAgICAgIGRldmljZXMucHVzaChkdXJhdGlvbilcbiAgICAgIGR1cmF0aW9uID0gMFxuICAgIH0gZWxzZSBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiA9IDBcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb24gPSB7IHR5cGU6IEFjdGlvbi5UeXBlLlBBVVNFLCBkdXJhdGlvbiB9XG5cbiAgICAvLyBOQjogbmVlZCBhIHByb3Blcmx5IHR5cGVkIHZhcmlhYmxlIGZvciB0eXBlIGNoZWNraW5nLlxuICAgIC8qKiBAdHlwZSB7IUl0ZXJhYmxlPCFEZXZpY2U+fSAqL1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gZGV2aWNlcy5sZW5ndGggPT09IDAgPyB0aGlzLnNlcXVlbmNlc18ua2V5cygpIDogZGV2aWNlc1xuICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICB0aGlzLnNlcXVlbmNlXyhkZXZpY2UpLnB1c2goYWN0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zeW5jXyA/IHRoaXMuc3luY2hyb25pemUoKSA6IHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIGFjdGlvbiB0byBwcmVzcyBhIHNpbmdsZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7KEtleXxzdHJpbmd8bnVtYmVyKX0ga2V5IHRoZSBrZXkgdG8gcHJlc3MuIFRoaXMga2V5IG1heSBiZVxuICAgKiAgICAgc3BlY2lmaWVkIGFzIGEge0BsaW5rIEtleX0gdmFsdWUsIGEgc3BlY2lmaWMgdW5pY29kZSBjb2RlIHBvaW50LFxuICAgKiAgICAgb3IgYSBzdHJpbmcgY29udGFpbmluZyBhIHNpbmdsZSB1bmljb2RlIGNvZGUgcG9pbnQuXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAga2V5RG93bihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQodGhpcy5rZXlib2FyZF8sIHRoaXMua2V5Ym9hcmRfLmtleURvd24oa2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIGFjdGlvbiB0byByZWxlYXNlIGEgc2luZ2xlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHsoS2V5fHN0cmluZ3xudW1iZXIpfSBrZXkgdGhlIGtleSB0byByZWxlYXNlLiBUaGlzIGtleSBtYXkgYmVcbiAgICogICAgIHNwZWNpZmllZCBhcyBhIHtAbGluayBLZXl9IHZhbHVlLCBhIHNwZWNpZmljIHVuaWNvZGUgY29kZSBwb2ludCxcbiAgICogICAgIG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBzaW5nbGUgdW5pY29kZSBjb2RlIHBvaW50LlxuICAgKiBAcmV0dXJuIHshQWN0aW9uc30gYSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGtleVVwKGtleSkge1xuICAgIHJldHVybiB0aGlzLmluc2VydCh0aGlzLmtleWJvYXJkXywgdGhpcy5rZXlib2FyZF8ua2V5VXAoa2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyB0byB0eXBlIHRoZSBwcm92aWRlZCBrZXkgc2VxdWVuY2UuXG4gICAqIEZvciBlYWNoIGtleSwgdGhpcyB3aWxsIHJlY29yZCBhIHBhaXIgb2Yge0BsaW5rcGxhaW4gI2tleURvd24ga2V5RG93bn1cbiAgICogYW5kIHtAbGlua3BsYWluICNrZXlVcCBrZXlVcH0gYWN0aW9ucy4gQW4gaW1wbGljYXRpb24gb2YgdGhpcyBwYWlyaW5nXG4gICAqIGlzIHRoYXQgbW9kaWZpZXIga2V5cyAoZS5nLiB7QGxpbmsgLi9pbnB1dC5LZXkuU0hJRlQgS2V5LlNISUZUfSkgd2lsbFxuICAgKiBhbHdheXMgYmUgaW1tZWRpYXRlbHkgcmVsZWFzZWQuIEluIG90aGVyIHdvcmRzLCBgc2VuZEtleXMoS2V5LlNISUZULCAnYScpYFxuICAgKiBpcyB0aGUgc2FtZSBhcyB0eXBpbmcgYHNlbmRLZXlzKCdhJylgLCBfbm90XyBgc2VuZEtleXMoJ0EnKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKEtleXxzdHJpbmd8bnVtYmVyKX0ga2V5cyB0aGUga2V5cyB0byB0eXBlLlxuICAgKiBAcmV0dXJuIHshQWN0aW9uc30gYSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNlbmRLZXlzKC4uLmtleXMpIHtcbiAgICBjb25zdCB7IFdlYkVsZW1lbnQgfSA9IHJlcXVpcmUoJy4vd2ViZHJpdmVyJylcblxuICAgIGNvbnN0IGFjdGlvbnMgPSBbXVxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDEgJiYga2V5c1swXSBpbnN0YW5jZW9mIFdlYkVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY2xpY2soa2V5c1swXSlcbiAgICAgIGtleXMuc2hpZnQoKVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yIChjb25zdCBzeW1ib2wgb2Yga2V5KSB7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5rZXlib2FyZF8ua2V5RG93bihzeW1ib2wpLFxuICAgICAgICAgICAgdGhpcy5rZXlib2FyZF8ua2V5VXAoc3ltYm9sKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9ucy5wdXNoKHRoaXMua2V5Ym9hcmRfLmtleURvd24oa2V5KSwgdGhpcy5rZXlib2FyZF8ua2V5VXAoa2V5KSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHRoaXMua2V5Ym9hcmRfLCAuLi5hY3Rpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gYWN0aW9uIHRvIHByZXNzIGEgbW91c2UgYnV0dG9uIGF0IHRoZSBtb3VzZSdzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7IUJ1dHRvbj19IGJ1dHRvbiBUaGUgYnV0dG9uIHRvIHByZXNzOyBkZWZhdWx0cyB0byBgTEVGVGAuXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgcHJlc3MoYnV0dG9uID0gQnV0dG9uLkxFRlQpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQodGhpcy5tb3VzZV8sIHRoaXMubW91c2VfLnByZXNzKGJ1dHRvbikpXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBhY3Rpb24gdG8gcmVsZWFzZSBhIG1vdXNlIGJ1dHRvbiBhdCB0aGUgbW91c2UncyBjdXJyZW50XG4gICAqIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyFCdXR0b249fSBidXR0b24gVGhlIGJ1dHRvbiB0byByZWxlYXNlOyBkZWZhdWx0cyB0byBgTEVGVGAuXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgcmVsZWFzZShidXR0b24gPSBCdXR0b24uTEVGVCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydCh0aGlzLm1vdXNlXywgdGhpcy5tb3VzZV8ucmVsZWFzZShidXR0b24pKVxuICB9XG5cbiAgLyoqXG4gICAqIHNjcm9sbHMgYSBwYWdlIHZpYSB0aGUgY29vcmRpbmF0ZXMgZ2l2ZW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggc3RhcnRpbmcgeCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHN0YXJ0aW5nIHkgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGF4IGRlbHRhIHggdG8gc2Nyb2xsIHRvIHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGF5IGRlbHRhIHkgdG8gc2Nyb2xsIHRvIHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gZHVyYXRpb24gcmF0aW8gYmUgdGhlIHJhdGlvIG9mIHRpbWUgZGVsdGEgYW5kIGR1cmF0aW9uXG4gICAqIEByZXR1cm5zIHshQWN0aW9uc30gQW4gYWN0aW9uIHRvIHNjcm9sbCB3aXRoIHRoaXMgZGV2aWNlLlxuICAgKi9cbiAgc2Nyb2xsKHgsIHksIHRhcmdldERlbHRhWCwgdGFyZ2V0RGVsdGFZLCBvcmlnaW4sIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KFxuICAgICAgdGhpcy53aGVlbF8sXG4gICAgICB0aGlzLndoZWVsXy5zY3JvbGwoeCwgeSwgdGFyZ2V0RGVsdGFYLCB0YXJnZXREZWx0YVksIG9yaWdpbiwgZHVyYXRpb24pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gYWN0aW9uIGZvciBtb3ZpbmcgdGhlIG1vdXNlIGB4YCBhbmQgYHlgIHBpeGVscyByZWxhdGl2ZSB0byB0aGVcbiAgICogc3BlY2lmaWVkIGBvcmlnaW5gLiBUaGUgYG9yaWdpbmAgbWF5IGJlIGRlZmluZWQgYXMgdGhlIG1vdXNlJ3NcbiAgICoge0BsaW5rcGxhaW4gLi9pbnB1dC5PcmlnaW4uUE9JTlRFUiBjdXJyZW50IHBvc2l0aW9ufSwgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGVcbiAgICoge0BsaW5rcGxhaW4gLi9pbnB1dC5PcmlnaW4uVklFV1BPUlQgdmlld3BvcnR9LCBvciB0aGUgY2VudGVyIG9mIGEgc3BlY2lmaWNcbiAgICoge0BsaW5rcGxhaW4gLi93ZWJkcml2ZXIuV2ViRWxlbWVudCBXZWJFbGVtZW50fS4gRGVmYXVsdCBpcyB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHZpZXctcG9ydCBpZiBvcmlnaW4gaXMgbm90IHNwZWNpZmllZFxuICAgKlxuICAgKiBZb3UgbWF5IGFkanVzdCBob3cgbG9uZyB0aGUgcmVtb3RlIGVuZCBzaG91bGQgdGFrZSwgaW4gbWlsbGlzZWNvbmRzLCB0b1xuICAgKiBwZXJmb3JtIHRoZSBtb3ZlIHVzaW5nIHRoZSBgZHVyYXRpb25gIHBhcmFtZXRlciAoZGVmYXVsdHMgdG8gMTAwIG1zKS5cbiAgICogVGhlIG51bWJlciBvZiBpbmNyZW1lbnRhbCBtb3ZlIGV2ZW50cyBnZW5lcmF0ZWQgb3ZlciB0aGlzIGR1cmF0aW9uIGlzIGFuXG4gICAqIGltcGxlbWVudGF0aW9uIGRldGFpbCBmb3IgdGhlIHJlbW90ZSBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7e1xuICAgKiAgIHg6IChudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICB5OiAobnVtYmVyfHVuZGVmaW5lZCksXG4gICAqICAgZHVyYXRpb246IChudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICBvcmlnaW46ICghT3JpZ2lufCEuL3dlYmRyaXZlci5XZWJFbGVtZW50fHVuZGVmaW5lZCksXG4gICAqIH09fSBvcHRpb25zIFRoZSBtb3ZlIG9wdGlvbnMuIERlZmF1bHRzIHRvIG1vdmluZyB0aGUgbW91c2UgdG8gdGhlIHRvcC1sZWZ0XG4gICAqICAgICBjb3JuZXIgb2YgdGhlIHZpZXdwb3J0IG92ZXIgMTAwbXMuXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgbW92ZSh7IHggPSAwLCB5ID0gMCwgZHVyYXRpb24gPSAxMDAsIG9yaWdpbiA9IE9yaWdpbi5WSUVXUE9SVCB9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoXG4gICAgICB0aGlzLm1vdXNlXyxcbiAgICAgIHRoaXMubW91c2VfLm1vdmUoeyB4LCB5LCBkdXJhdGlvbiwgb3JpZ2luIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0LWhhbmQgZm9yIHBlcmZvcm1pbmcgYSBzaW1wbGUgbGVmdC1jbGljayAoZG93bi91cCkgd2l0aCB0aGUgbW91c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Li93ZWJkcml2ZXIuV2ViRWxlbWVudD19IGVsZW1lbnQgSWYgc3BlY2lmaWVkLCB0aGUgbW91c2Ugd2lsbFxuICAgKiAgICAgZmlyc3QgYmUgbW92ZWQgdG8gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudCBiZWZvcmUgcGVyZm9ybWluZyB0aGVcbiAgICogICAgIGNsaWNrLlxuICAgKiBAcmV0dXJuIHshQWN0aW9uc30gYSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGNsaWNrKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5tb3ZlKHsgb3JpZ2luOiBlbGVtZW50IH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXNzKCkucmVsZWFzZSgpXG4gIH1cblxuICAvKipcbiAgICogU2hvcnQtaGFuZCBmb3IgcGVyZm9ybWluZyBhIHNpbXBsZSByaWdodC1jbGljayAoZG93bi91cCkgd2l0aCB0aGUgbW91c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Li93ZWJkcml2ZXIuV2ViRWxlbWVudD19IGVsZW1lbnQgSWYgc3BlY2lmaWVkLCB0aGUgbW91c2Ugd2lsbFxuICAgKiAgICAgZmlyc3QgYmUgbW92ZWQgdG8gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudCBiZWZvcmUgcGVyZm9ybWluZyB0aGVcbiAgICogICAgIGNsaWNrLlxuICAgKiBAcmV0dXJuIHshQWN0aW9uc30gYSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIGNvbnRleHRDbGljayhlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMubW92ZSh7IG9yaWdpbjogZWxlbWVudCB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmVzcyhCdXR0b24uUklHSFQpLnJlbGVhc2UoQnV0dG9uLlJJR0hUKVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0LWhhbmQgZm9yIHBlcmZvcm1pbmcgYSBkb3VibGUgbGVmdC1jbGljayB3aXRoIHRoZSBtb3VzZS5cbiAgICpcbiAgICogQHBhcmFtIHsuL3dlYmRyaXZlci5XZWJFbGVtZW50PX0gZWxlbWVudCBJZiBzcGVjaWZpZWQsIHRoZSBtb3VzZSB3aWxsXG4gICAqICAgICBmaXJzdCBiZSBtb3ZlZCB0byB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50IGJlZm9yZSBwZXJmb3JtaW5nIHRoZVxuICAgKiAgICAgY2xpY2suXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgZG91YmxlQ2xpY2soZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmNsaWNrKGVsZW1lbnQpLnByZXNzKCkucmVsZWFzZSgpXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhIGRyYWctYW5kLWRyb3AgYWN0aW9uIGNvbnNpc3Rpbmcgb2YgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICpcbiAgICogMS4gIE1vdmUgdG8gdGhlIGNlbnRlciBvZiB0aGUgYGZyb21gIGVsZW1lbnQgKGVsZW1lbnQgdG8gYmUgZHJhZ2dlZCkuXG4gICAqIDIuICBQcmVzcyB0aGUgbGVmdCBtb3VzZSBidXR0b24uXG4gICAqIDMuICBJZiB0aGUgYHRvYCB0YXJnZXQgaXMgYSB7QGxpbmtwbGFpbiAuL3dlYmRyaXZlci5XZWJFbGVtZW50IFdlYkVsZW1lbnR9LFxuICAgKiAgICAgbW92ZSB0aGUgbW91c2UgdG8gaXRzIGNlbnRlci4gT3RoZXJ3aXNlLCBtb3ZlIHRoZSBtb3VzZSBieSB0aGVcbiAgICogICAgIHNwZWNpZmllZCBvZmZzZXQuXG4gICAqIDQuICBSZWxlYXNlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtIHshLi93ZWJkcml2ZXIuV2ViRWxlbWVudH0gZnJvbSBUaGUgZWxlbWVudCB0byBwcmVzcyB0aGUgbGVmdCBtb3VzZVxuICAgKiAgICAgYnV0dG9uIG9uIHRvIHN0YXJ0IHRoZSBkcmFnLlxuICAgKiBAcGFyYW0geyghLi93ZWJkcml2ZXIuV2ViRWxlbWVudHx7eDogbnVtYmVyLCB5OiBudW1iZXJ9KX0gdG8gRWl0aGVyIGFub3RoZXJcbiAgICogICAgIGVsZW1lbnQgdG8gZHJhZyB0byAod2lsbCBkcmFnIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQpLCBvciBhblxuICAgKiAgICAgb2JqZWN0IHNwZWNpZnlpbmcgdGhlIG9mZnNldCB0byBkcmFnIGJ5LCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm4geyFBY3Rpb25zfSBhIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgZHJhZ0FuZERyb3AoZnJvbSwgdG8pIHtcbiAgICAvLyBEbyBub3QgcmVxdWlyZSB1cCB0b3AgdG8gYXZvaWQgYSBjeWNsZSB0aGF0IGJyZWFrcyBzdGF0aWMgYW5hbHlzaXMuXG4gICAgY29uc3QgeyBXZWJFbGVtZW50IH0gPSByZXF1aXJlKCcuL3dlYmRyaXZlcicpXG4gICAgaWYgKFxuICAgICAgISh0byBpbnN0YW5jZW9mIFdlYkVsZW1lbnQpICYmXG4gICAgICAoIXRvIHx8IHR5cGVvZiB0by54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdG8ueSAhPT0gJ251bWJlcicpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgICdJbnZhbGlkIGRyYWcgdGFyZ2V0OyBtdXN0IHNwZWNpZnkgYSBXZWJFbGVtZW50IG9yIHt4LCB5fSBvZmZzZXQnXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlKHsgb3JpZ2luOiBmcm9tIH0pLnByZXNzKClcbiAgICBpZiAodG8gaW5zdGFuY2VvZiBXZWJFbGVtZW50KSB7XG4gICAgICB0aGlzLm1vdmUoeyBvcmlnaW46IHRvIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW92ZSh7IHg6IHRvLngsIHk6IHRvLnksIG9yaWdpbjogT3JpZ2luLlBPSU5URVIgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVsZWFzZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIGtleXMsIHBvaW50ZXJzLCBhbmQgY2xlYXJzIGludGVybmFsIHN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gZmluaXNoZWRcbiAgICogICAgIGNsZWFyaW5nIGFsbCBhY3Rpb24gc3RhdGUuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5zZXF1ZW5jZXNfLnZhbHVlcygpKSB7XG4gICAgICBzLmxlbmd0aCA9IDBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0b3JfLmV4ZWN1dGUobmV3IENvbW1hbmQoTmFtZS5DTEVBUl9BQ1RJT05TKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyB0aGUgY29uZmlndXJlZCBhY3Rpb24gc2VxdWVuY2UuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiBhbGwgYWN0aW9ucyBoYXZlXG4gICAqICAgICBiZWVuIGNvbXBsZXRlZC5cbiAgICovXG4gIGFzeW5jIHBlcmZvcm0oKSB7XG4gICAgY29uc3QgX2FjdGlvbnMgPSBbXVxuICAgIHRoaXMuc2VxdWVuY2VzXy5mb3JFYWNoKChhY3Rpb25zLCBkZXZpY2UpID0+IHtcbiAgICAgIGlmICghaXNJZGxlKGFjdGlvbnMpKSB7XG4gICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdCgpIC8vIERlZmVuc2l2ZSBjb3B5LlxuICAgICAgICBfYWN0aW9ucy5wdXNoKE9iamVjdC5hc3NpZ24oeyBhY3Rpb25zIH0sIGRldmljZS50b0pTT04oKSkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmIChfYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuZXhlY3V0b3JfLmV4ZWN1dGUoXG4gICAgICBuZXcgQ29tbWFuZChOYW1lLkFDVElPTlMpLnNldFBhcmFtZXRlcignYWN0aW9ucycsIF9hY3Rpb25zKVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5PCFBY3Rpb24+fSBhY3Rpb25zXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0lkbGUoYWN0aW9ucykge1xuICByZXR1cm4gKFxuICAgIGFjdGlvbnMubGVuZ3RoID09PSAwIHx8XG4gICAgYWN0aW9ucy5ldmVyeSgoYSkgPT4gYS50eXBlID09PSBBY3Rpb24uVHlwZS5QQVVTRSAmJiAhYS5kdXJhdGlvbilcbiAgKVxufVxuXG4vKipcbiAqIFNjcmlwdCB1c2VkIHRvIGNvbXB1dGUgdGhlIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgb2YgYSBET00gZWxlbWVudCdzIGZpcnN0XG4gKiBjbGllbnQgcmVjdCBmcm9tIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnQncyBib3VuZGluZyBjbGllbnQgcmVjdC5cbiAqIFRoZSBlbGVtZW50J3MgY2VudGVyIHBvaW50IGlzIGNvbXB1dGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBoZXJlOlxuICogPGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvd2ViZHJpdmVyLXNwZWMuaHRtbCNkZm4tY2VudGVyLXBvaW50Pi5cbiAqXG4gKiBfX1RoaXMgaXMgb25seSBleHBvcnRlZCBmb3IgdXNlIGluIGludGVybmFsIHVuaXQgdGVzdHMuIERPIE5PVCBVU0UuX19cbiAqXG4gKiBAcGFja2FnZVxuICovXG5jb25zdCBJTlRFUk5BTF9DT01QVVRFX09GRlNFVF9TQ1JJUFQgPSBgXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0KGVsKSB7XG4gIHZhciByZWN0ID0gZWwuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgdmFyIGxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0LngsIHJlY3QueCArIHJlY3Qud2lkdGgpKTtcbiAgdmFyIHJpZ2h0ID1cbiAgICAgIE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCBNYXRoLm1heChyZWN0LngsIHJlY3QueCArIHJlY3Qud2lkdGgpKTtcbiAgdmFyIHRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3QueSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpKTtcbiAgdmFyIGJvdCA9XG4gICAgICBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIE1hdGgubWF4KHJlY3QueSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpKTtcbiAgdmFyIHggPSBNYXRoLmZsb29yKDAuNSAqIChsZWZ0ICsgcmlnaHQpKTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKDAuNSAqICh0b3AgKyBib3QpKTtcblxuICB2YXIgYmJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gW3ggLSBiYm94LmxlZnQsIHkgLSBiYm94LnRvcF07XG59XG5yZXR1cm4gY29tcHV0ZU9mZnNldChhcmd1bWVudHNbMF0pO2BcblxuLy8gUFVCTElDIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWN0aW9uLCAvLyBGb3IgZG9jdW1lbnRhdGlvbiBvbmx5LlxuICBBY3Rpb25zLFxuICBCdXR0b24sXG4gIERldmljZSxcbiAgS2V5LFxuICBLZXlib2FyZCxcbiAgRmlsZURldGVjdG9yLFxuICBPcmlnaW4sXG4gIFBvaW50ZXIsXG4gIElOVEVSTkFMX0NPTVBVVEVfT0ZGU0VUX1NDUklQVCxcbn1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBXZWJEcml2ZXIncyBsb2dnaW5nIHN5c3RlbS4gVGhlIGxvZ2dpbmcgc3lzdGVtIGlzXG4gKiBicm9rZW4gaW50byBtYWpvciBjb21wb25lbnRzOiBsb2NhbCBhbmQgcmVtb3RlIGxvZ2dpbmcuXG4gKlxuICogVGhlIGxvY2FsIGxvZ2dpbmcgQVBJLCB3aGljaCBpcyBhbmNob3JlZCBieSB0aGUge0BsaW5rcGxhaW4gTG9nZ2VyfSBjbGFzcyBpc1xuICogc2ltaWxhciB0byBKYXZhJ3MgbG9nZ2luZyBBUEkuIExvZ2dlcnMsIHJldHJpZXZlZCBieVxuICoge0BsaW5rcGxhaW4gI2dldExvZ2dlciBnZXRMb2dnZXIobmFtZSl9LCB1c2UgaGllcmFyY2hpY2FsLCBkb3QtZGVsaW1pdGVkXG4gKiBuYW1lc3BhY2VzIChlLmcuIFwiXCIgPiBcIndlYmRyaXZlclwiID4gXCJ3ZWJkcml2ZXIubG9nZ2luZ1wiKS4gUmVjb3JkZWQgbG9nXG4gKiBtZXNzYWdlcyBhcmUgcmVwcmVzZW50ZWQgYnkgdGhlIHtAbGlua3BsYWluIEVudHJ5fSBjbGFzcy4gWW91IGNhbiBjYXB0dXJlIGxvZ1xuICogcmVjb3JkcyBieSB7QGxpbmtwbGFpbiBMb2dnZXIjYWRkSGFuZGxlciBhdHRhY2hpbmd9IGEgaGFuZGxlciBmdW5jdGlvbiB0byB0aGVcbiAqIGRlc2lyZWQgbG9nZ2VyLiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gcXVpY2tseSBlbmFibGUgbG9nZ2luZyB0byB0aGVcbiAqIGNvbnNvbGUgYnkgc2ltcGx5IGNhbGxpbmcge0BsaW5rcGxhaW4gI2luc3RhbGxDb25zb2xlSGFuZGxlclxuICogaW5zdGFsbENvbnNvbGVIYW5kbGVyfS5cbiAqXG4gKiBUaGUgW3JlbW90ZSBsb2dnaW5nIEFQSV0oaHR0cHM6Ly9naXRodWIuY29tL1NlbGVuaXVtSFEvc2VsZW5pdW0vd2lraS9Mb2dnaW5nKVxuICogYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBsb2dzIGZyb20gYSByZW1vdGUgV2ViRHJpdmVyIHNlcnZlci4gVGhpcyBBUEkgdXNlcyB0aGVcbiAqIHtAbGluayBQcmVmZXJlbmNlc30gY2xhc3MgdG8gZGVmaW5lIGRlc2lyZWQgbG9nIGxldmVscyBwcmlvciB0byBjcmVhdGluZ1xuICogYSBXZWJEcml2ZXIgc2Vzc2lvbjpcbiAqXG4gKiAgICAgdmFyIHByZWZzID0gbmV3IGxvZ2dpbmcuUHJlZmVyZW5jZXMoKTtcbiAqICAgICBwcmVmcy5zZXRMZXZlbChsb2dnaW5nLlR5cGUuQlJPV1NFUiwgbG9nZ2luZy5MZXZlbC5ERUJVRyk7XG4gKlxuICogICAgIHZhciBjYXBzID0gQ2FwYWJpbGl0aWVzLmNocm9tZSgpO1xuICogICAgIGNhcHMuc2V0TG9nZ2luZ1ByZWZzKHByZWZzKTtcbiAqICAgICAvLyAuLi5cbiAqXG4gKiBSZW1vdGUgbG9nIGVudHJpZXMsIGFsc28gcmVwcmVzZW50ZWQgYnkgdGhlIHtAbGluayBFbnRyeX0gY2xhc3MsIG1heSBiZVxuICogcmV0cmlldmVkIHZpYSB7QGxpbmsgd2ViZHJpdmVyLldlYkRyaXZlci5Mb2dzfTpcbiAqXG4gKiAgICAgZHJpdmVyLm1hbmFnZSgpLmxvZ3MoKS5nZXQobG9nZ2luZy5UeXBlLkJST1dTRVIpXG4gKiAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAqICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1slc10gJXMnLCBlbnRyeS5sZXZlbC5uYW1lLCBlbnRyeS5tZXNzYWdlKTtcbiAqICAgICAgICAgICAgfSk7XG4gKiAgICAgICAgIH0pO1xuICpcbiAqICoqTk9URToqKiBPbmx5IGEgZmV3IGJyb3dzZXJzIHN1cHBvcnQgdGhlIHJlbW90ZSBsb2dnaW5nIEFQSSAobm90YWJseVxuICogRmlyZWZveCBhbmQgQ2hyb21lKS4gRmlyZWZveCBzdXBwb3J0cyBiYXNpYyBsb2dnaW5nIGZ1bmN0aW9uYWxpdHksIHdoaWxlXG4gKiBDaHJvbWUgZXhwb3NlcyByb2J1c3RcbiAqIFtwZXJmb3JtYW5jZSBsb2dnaW5nXShodHRwczovL2Nocm9tZWRyaXZlci5jaHJvbWl1bS5vcmcvbG9nZ2luZylcbiAqIG9wdGlvbnMuIFJlbW90ZSBsb2dnaW5nIGlzIHN0aWxsIGNvbnNpZGVyZWQgYSBub24tc3RhbmRhcmQgZmVhdHVyZSwgYW5kIHRoZVxuICogQVBJcyBleHBvc2VkIGJ5IHRoaXMgbW9kdWxlIGZvciBpdCBhcmUgbm9uLWZyb3plbi4gVGhpcyBtb2R1bGUgd2lsbCBiZVxuICogdXBkYXRlZCwgcG9zc2libHkgYnJlYWtpbmcgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIG9uY2UgbG9nZ2luZyBpc1xuICogb2ZmaWNpYWxseSBkZWZpbmVkIGJ5IHRoZVxuICogW1czQyBXZWJEcml2ZXIgc3BlY10oaHR0cDovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLykuXG4gKi9cblxuLyoqXG4gKiBEZWZpbmVzIGEgbWVzc2FnZSBsZXZlbCB0aGF0IG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgbG9nZ2luZyBvdXRwdXQuXG4gKlxuICogQGZpbmFsXG4gKi9cbmNsYXNzIExldmVsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBsZXZlbCdzIG5hbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCB0aGUgbGV2ZWwncyBudW1lcmljIHZhbHVlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgbGV2ZWwpIHtcbiAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMZXZlbCBtdXN0IGJlID49IDAnKVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLnZhbHVlXyA9IGxldmVsXG4gIH1cblxuICAvKiogVGhpcyBsb2dnZXIncyBuYW1lLiAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lX1xuICB9XG5cbiAgLyoqIFRoZSBudW1lcmljIGxvZyBsZXZlbC4gKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlX1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXG4gIH1cbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgbm8gbG9nIG1lc3NhZ2VzIHNob3VsZCBiZSByZWNvcmRlZC5cbiAqIEBjb25zdFxuICovXG5MZXZlbC5PRkYgPSBuZXcgTGV2ZWwoJ09GRicsIEluZmluaXR5KVxuXG4vKipcbiAqIExvZyBtZXNzYWdlcyB3aXRoIGEgbGV2ZWwgb2YgYDEwMDBgIG9yIGhpZ2hlci5cbiAqIEBjb25zdFxuICovXG5MZXZlbC5TRVZFUkUgPSBuZXcgTGV2ZWwoJ1NFVkVSRScsIDEwMDApXG5cbi8qKlxuICogTG9nIG1lc3NhZ2VzIHdpdGggYSBsZXZlbCBvZiBgOTAwYCBvciBoaWdoZXIuXG4gKiBAY29uc3RcbiAqL1xuTGV2ZWwuV0FSTklORyA9IG5ldyBMZXZlbCgnV0FSTklORycsIDkwMClcblxuLyoqXG4gKiBMb2cgbWVzc2FnZXMgd2l0aCBhIGxldmVsIG9mIGA4MDBgIG9yIGhpZ2hlci5cbiAqIEBjb25zdFxuICovXG5MZXZlbC5JTkZPID0gbmV3IExldmVsKCdJTkZPJywgODAwKVxuXG4vKipcbiAqIExvZyBtZXNzYWdlcyB3aXRoIGEgbGV2ZWwgb2YgYDcwMGAgb3IgaGlnaGVyLlxuICogQGNvbnN0XG4gKi9cbkxldmVsLkRFQlVHID0gbmV3IExldmVsKCdERUJVRycsIDcwMClcblxuLyoqXG4gKiBMb2cgbWVzc2FnZXMgd2l0aCBhIGxldmVsIG9mIGA1MDBgIG9yIGhpZ2hlci5cbiAqIEBjb25zdFxuICovXG5MZXZlbC5GSU5FID0gbmV3IExldmVsKCdGSU5FJywgNTAwKVxuXG4vKipcbiAqIExvZyBtZXNzYWdlcyB3aXRoIGEgbGV2ZWwgb2YgYDQwMGAgb3IgaGlnaGVyLlxuICogQGNvbnN0XG4gKi9cbkxldmVsLkZJTkVSID0gbmV3IExldmVsKCdGSU5FUicsIDQwMClcblxuLyoqXG4gKiBMb2cgbWVzc2FnZXMgd2l0aCBhIGxldmVsIG9mIGAzMDBgIG9yIGhpZ2hlci5cbiAqIEBjb25zdFxuICovXG5MZXZlbC5GSU5FU1QgPSBuZXcgTGV2ZWwoJ0ZJTkVTVCcsIDMwMClcblxuLyoqXG4gKiBJbmRpY2F0ZXMgYWxsIGxvZyBtZXNzYWdlcyBzaG91bGQgYmUgcmVjb3JkZWQuXG4gKiBAY29uc3RcbiAqL1xuTGV2ZWwuQUxMID0gbmV3IExldmVsKCdBTEwnLCAwKVxuXG5jb25zdCBBTExfTEVWRUxTID0gLyoqICFTZXQ8TGV2ZWw+ICovIG5ldyBTZXQoW1xuICBMZXZlbC5PRkYsXG4gIExldmVsLlNFVkVSRSxcbiAgTGV2ZWwuV0FSTklORyxcbiAgTGV2ZWwuSU5GTyxcbiAgTGV2ZWwuREVCVUcsXG4gIExldmVsLkZJTkUsXG4gIExldmVsLkZJTkVSLFxuICBMZXZlbC5GSU5FU1QsXG4gIExldmVsLkFMTCxcbl0pXG5cbmNvbnN0IExFVkVMU19CWV9OQU1FID0gLyoqICFNYXA8c3RyaW5nLCAhTGV2ZWw+ICovIG5ldyBNYXAoW1xuICBbTGV2ZWwuT0ZGLm5hbWUsIExldmVsLk9GRl0sXG4gIFtMZXZlbC5TRVZFUkUubmFtZSwgTGV2ZWwuU0VWRVJFXSxcbiAgW0xldmVsLldBUk5JTkcubmFtZSwgTGV2ZWwuV0FSTklOR10sXG4gIFtMZXZlbC5JTkZPLm5hbWUsIExldmVsLklORk9dLFxuICBbTGV2ZWwuREVCVUcubmFtZSwgTGV2ZWwuREVCVUddLFxuICBbTGV2ZWwuRklORS5uYW1lLCBMZXZlbC5GSU5FXSxcbiAgW0xldmVsLkZJTkVSLm5hbWUsIExldmVsLkZJTkVSXSxcbiAgW0xldmVsLkZJTkVTVC5uYW1lLCBMZXZlbC5GSU5FU1RdLFxuICBbTGV2ZWwuQUxMLm5hbWUsIExldmVsLkFMTF0sXG5dKVxuXG4vKipcbiAqIENvbnZlcnRzIGEgbGV2ZWwgbmFtZSBvciB2YWx1ZSB0byBhIHtAbGluayBMZXZlbH0gdmFsdWUuIElmIHRoZSBuYW1lL3ZhbHVlXG4gKiBpcyBub3QgcmVjb2duaXplZCwge0BsaW5rIExldmVsLkFMTH0gd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gbmFtZU9yVmFsdWUgVGhlIGxvZyBsZXZlbCBuYW1lLCBvciB2YWx1ZSwgdG9cbiAqICAgICBjb252ZXJ0LlxuICogQHJldHVybiB7IUxldmVsfSBUaGUgY29udmVydGVkIGxldmVsLlxuICovXG5mdW5jdGlvbiBnZXRMZXZlbChuYW1lT3JWYWx1ZSkge1xuICBpZiAodHlwZW9mIG5hbWVPclZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBMRVZFTFNfQllfTkFNRS5nZXQobmFtZU9yVmFsdWUpIHx8IExldmVsLkFMTFxuICB9XG4gIGlmICh0eXBlb2YgbmFtZU9yVmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgc3RyaW5nIG9yIG51bWJlcicpXG4gIH1cbiAgZm9yIChsZXQgbGV2ZWwgb2YgQUxMX0xFVkVMUykge1xuICAgIGlmIChuYW1lT3JWYWx1ZSA+PSBsZXZlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuIGxldmVsXG4gICAgfVxuICB9XG4gIHJldHVybiBMZXZlbC5BTExcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgbG9nIGVudHJ5LlxuICpcbiAqIEBmaW5hbFxuICovXG5jbGFzcyBFbnRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyghTGV2ZWx8c3RyaW5nfG51bWJlcil9IGxldmVsIFRoZSBlbnRyeSBsZXZlbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGxvZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF90aW1lc3RhbXAgVGhlIHRpbWUgdGhpcyBlbnRyeSB3YXMgZ2VuZXJhdGVkLCBpblxuICAgKiAgICAgbWlsbGlzZWNvbmRzIHNpbmNlIDA6MDA6MDAsIEphbnVhcnkgMSwgMTk3MCBVVEMuIElmIG9taXR0ZWQsIHRoZVxuICAgKiAgICAgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdHlwZSBUaGUgbG9nIHR5cGUsIGlmIGtub3duLlxuICAgKi9cbiAgY29uc3RydWN0b3IobGV2ZWwsIG1lc3NhZ2UsIG9wdF90aW1lc3RhbXAsIG9wdF90eXBlKSB7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsIGluc3RhbmNlb2YgTGV2ZWwgPyBsZXZlbCA6IGdldExldmVsKGxldmVsKVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB0aGlzLnRpbWVzdGFtcCA9XG4gICAgICB0eXBlb2Ygb3B0X3RpbWVzdGFtcCA9PT0gJ251bWJlcicgPyBvcHRfdGltZXN0YW1wIDogRGF0ZS5ub3coKVxuICAgIHRoaXMudHlwZSA9IG9wdF90eXBlIHx8ICcnXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7e2xldmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgdGltZXN0YW1wOiBudW1iZXIsXG4gICAqICAgICAgICAgICB0eXBlOiBzdHJpbmd9fSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGVudHJ5LlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogdGhpcy5sZXZlbC5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBvYmplY3QgdXNlZCB0byBsb2cgZGVidWdnaW5nIG1lc3NhZ2VzLiBMb2dnZXJzIHVzZSBhIGhpZXJhcmNoaWNhbCxcbiAqIGRvdC1zZXBhcmF0ZWQgbmFtaW5nIHNjaGVtZS4gRm9yIGluc3RhbmNlLCBcImZvb1wiIGlzIGNvbnNpZGVyZWQgdGhlIHBhcmVudCBvZlxuICogdGhlIFwiZm9vLmJhclwiIGFuZCBhbiBhbmNlc3RvciBvZiBcImZvby5iYXIuYmF6XCIuXG4gKlxuICogRWFjaCBsb2dnZXIgbWF5IGJlIGFzc2lnbmVkIGEge0BsaW5rcGxhaW4gI3NldExldmVsIGxvZyBsZXZlbH0sIHdoaWNoXG4gKiBjb250cm9scyB3aGljaCBsZXZlbCBvZiBtZXNzYWdlcyB3aWxsIGJlIHJlcG9ydGVkIHRvIHRoZVxuICoge0BsaW5rcGxhaW4gI2FkZEhhbmRsZXIgaGFuZGxlcnN9IGF0dGFjaGVkIHRvIHRoaXMgaW5zdGFuY2UuIElmIGEgbG9nIGxldmVsXG4gKiBpcyBub3QgZXhwbGljaXRseSBzZXQgb24gYSBsb2dnZXIsIGl0IHdpbGwgaW5oZXJpdCBpdHMgcGFyZW50LlxuICpcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGRpcmVjdGx5IGluc3RhbnRpYXRlZC4gSW5zdGVhZCwgdXNlcnMgc2hvdWxkXG4gKiBvYnRhaW4gbG9nZ2VyIHJlZmVyZW5jZXMgdXNpbmcgdGhlIHtAbGlua3BsYWluIC4vbG9nZ2luZy5nZXRMb2dnZXIoKVxuICogZ2V0TG9nZ2VyKCl9IGZ1bmN0aW9uLlxuICpcbiAqIEBmaW5hbFxuICovXG5jbGFzcyBMb2dnZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhpcyBsb2dnZXIuXG4gICAqIEBwYXJhbSB7TGV2ZWw9fSBvcHRfbGV2ZWwgdGhlIGluaXRpYWwgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgb3B0X2xldmVsKSB7XG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5uYW1lXyA9IG5hbWVcblxuICAgIC8qKiBAcHJpdmF0ZSB7TGV2ZWx9ICovXG4gICAgdGhpcy5sZXZlbF8gPSBvcHRfbGV2ZWwgfHwgbnVsbFxuXG4gICAgLyoqIEBwcml2YXRlIHtMb2dnZXJ9ICovXG4gICAgdGhpcy5wYXJlbnRfID0gbnVsbFxuXG4gICAgLyoqIEBwcml2YXRlIHtTZXQ8ZnVuY3Rpb24oIUVudHJ5KT59ICovXG4gICAgdGhpcy5oYW5kbGVyc18gPSBudWxsXG4gIH1cblxuICAvKiogQHJldHVybiB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGlzIGxvZ2dlci4gKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lX1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TGV2ZWx9IGxldmVsIHRoZSBuZXcgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLCBvciBgbnVsbGAgaWYgdGhlIGxvZ2dlclxuICAgKiAgICAgc2hvdWxkIGluaGVyaXQgaXRzIGxldmVsIGZyb20gaXRzIHBhcmVudCBsb2dnZXIuXG4gICAqL1xuICBzZXRMZXZlbChsZXZlbCkge1xuICAgIHRoaXMubGV2ZWxfID0gbGV2ZWxcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtMZXZlbH0gdGhlIGxvZyBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuICovXG4gIGdldExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsX1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFMZXZlbH0gdGhlIGVmZmVjdGl2ZSBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuXG4gICAqL1xuICBnZXRFZmZlY3RpdmVMZXZlbCgpIHtcbiAgICBsZXQgbG9nZ2VyID0gdGhpc1xuICAgIGxldCBsZXZlbFxuICAgIGRvIHtcbiAgICAgIGxldmVsID0gbG9nZ2VyLmxldmVsX1xuICAgICAgbG9nZ2VyID0gbG9nZ2VyLnBhcmVudF9cbiAgICB9IHdoaWxlIChsb2dnZXIgJiYgIWxldmVsKVxuICAgIHJldHVybiBsZXZlbCB8fCBMZXZlbC5PRkZcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFMZXZlbH0gbGV2ZWwgdGhlIGxldmVsIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIG1lc3NhZ2VzIHJlY29yZGVkIGF0IHRoZSBnaXZlbiBsZXZlbCBhcmUgbG9nZ2FibGVcbiAgICogICAgIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBpc0xvZ2dhYmxlKGxldmVsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxldmVsLnZhbHVlICE9PSBMZXZlbC5PRkYudmFsdWUgJiZcbiAgICAgIGxldmVsLnZhbHVlID49IHRoaXMuZ2V0RWZmZWN0aXZlTGV2ZWwoKS52YWx1ZVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgaGFuZGxlciB0byB0aGlzIGxvZ2dlci4gVGhlIGhhbmRsZXIgd2lsbCBiZSBpbnZva2VkIGZvciBlYWNoIG1lc3NhZ2VcbiAgICogbG9nZ2VkIHdpdGggdGhpcyBpbnN0YW5jZSwgb3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRW50cnkpfSBoYW5kbGVyIHRoZSBoYW5kbGVyIHRvIGFkZC5cbiAgICovXG4gIGFkZEhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5oYW5kbGVyc18pIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNfID0gbmV3IFNldCgpXG4gICAgfVxuICAgIHRoaXMuaGFuZGxlcnNfLmFkZChoYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBoYW5kbGVyIGZyb20gdGhpcyBsb2dnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUVudHJ5KX0gaGFuZGxlciB0aGUgaGFuZGxlciB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgYSBoYW5kbGVyIHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5oYW5kbGVyc18pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyc18uZGVsZXRlKGhhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhIG1lc3NhZ2UgYXQgdGhlIGdpdmVuIGxldmVsLiBUaGUgbWVzc2FnZSBtYXkgYmUgZGVmaW5lZCBhcyBhIHN0cmluZ1xuICAgKiBvciBhcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIG1lc3NhZ2UuIElmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsXG4gICAqIGl0IHdpbGwgb25seSBiZSBpbnZva2VkIGlmIHRoaXMgbG9nZ2VyJ3NcbiAgICoge0BsaW5rcGxhaW4gI2dldEVmZmVjdGl2ZUxldmVsKCkgZWZmZWN0aXZlIGxvZyBsZXZlbH0gaW5jbHVkZXMgdGhlIGdpdmVuXG4gICAqIGBsZXZlbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7IUxldmVsfSBsZXZlbCB0aGUgbGV2ZWwgYXQgd2hpY2ggdG8gbG9nIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8ZnVuY3Rpb24oKTogc3RyaW5nKX0gbG9nZ2FibGUgdGhlIG1lc3NhZ2UgdG8gbG9nLCBvciBhXG4gICAqICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgbG9nKGxldmVsLCBsb2dnYWJsZSkge1xuICAgIGlmICghdGhpcy5pc0xvZ2dhYmxlKGxldmVsKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxldCBtZXNzYWdlID1cbiAgICAgICdbJyArXG4gICAgICB0aGlzLm5hbWVfICtcbiAgICAgICddICcgK1xuICAgICAgKHR5cGVvZiBsb2dnYWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IGxvZ2dhYmxlKCkgOiBsb2dnYWJsZSlcbiAgICBsZXQgZW50cnkgPSBuZXcgRW50cnkobGV2ZWwsIG1lc3NhZ2UsIERhdGUubm93KCkpXG4gICAgZm9yIChsZXQgbG9nZ2VyID0gdGhpczsgbG9nZ2VyOyBsb2dnZXIgPSBsb2dnZXIucGFyZW50Xykge1xuICAgICAgaWYgKGxvZ2dlci5oYW5kbGVyc18pIHtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBsb2dnZXIuaGFuZGxlcnNfKSB7XG4gICAgICAgICAgaGFuZGxlcihlbnRyeSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUge0BsaW5rIExldmVsLlNFVkVSRX0gbG9nIGxldmVsLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8ZnVuY3Rpb24oKTogc3RyaW5nKX0gbG9nZ2FibGUgdGhlIG1lc3NhZ2UgdG8gbG9nLCBvciBhXG4gICAqICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc2V2ZXJlKGxvZ2dhYmxlKSB7XG4gICAgdGhpcy5sb2coTGV2ZWwuU0VWRVJFLCBsb2dnYWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUge0BsaW5rIExldmVsLldBUk5JTkd9IGxvZyBsZXZlbC5cbiAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKCk6IHN0cmluZyl9IGxvZ2dhYmxlIHRoZSBtZXNzYWdlIHRvIGxvZywgb3IgYVxuICAgKiAgICAgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHdhcm5pbmcobG9nZ2FibGUpIHtcbiAgICB0aGlzLmxvZyhMZXZlbC5XQVJOSU5HLCBsb2dnYWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUge0BsaW5rIExldmVsLklORk99IGxvZyBsZXZlbC5cbiAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKCk6IHN0cmluZyl9IGxvZ2dhYmxlIHRoZSBtZXNzYWdlIHRvIGxvZywgb3IgYVxuICAgKiAgICAgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGluZm8obG9nZ2FibGUpIHtcbiAgICB0aGlzLmxvZyhMZXZlbC5JTkZPLCBsb2dnYWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUge0BsaW5rIExldmVsLkRFQlVHfSBsb2cgbGV2ZWwuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xmdW5jdGlvbigpOiBzdHJpbmcpfSBsb2dnYWJsZSB0aGUgbWVzc2FnZSB0byBsb2csIG9yIGFcbiAgICogICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBkZWJ1Zyhsb2dnYWJsZSkge1xuICAgIHRoaXMubG9nKExldmVsLkRFQlVHLCBsb2dnYWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUge0BsaW5rIExldmVsLkZJTkV9IGxvZyBsZXZlbC5cbiAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKCk6IHN0cmluZyl9IGxvZ2dhYmxlIHRoZSBtZXNzYWdlIHRvIGxvZywgb3IgYVxuICAgKiAgICAgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGZpbmUobG9nZ2FibGUpIHtcbiAgICB0aGlzLmxvZyhMZXZlbC5GSU5FLCBsb2dnYWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUge0BsaW5rIExldmVsLkZJTkVSfSBsb2cgbGV2ZWwuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xmdW5jdGlvbigpOiBzdHJpbmcpfSBsb2dnYWJsZSB0aGUgbWVzc2FnZSB0byBsb2csIG9yIGFcbiAgICogICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBmaW5lcihsb2dnYWJsZSkge1xuICAgIHRoaXMubG9nKExldmVsLkZJTkVSLCBsb2dnYWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUge0BsaW5rIExldmVsLkZJTkVTVH0gbG9nIGxldmVsLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8ZnVuY3Rpb24oKTogc3RyaW5nKX0gbG9nZ2FibGUgdGhlIG1lc3NhZ2UgdG8gbG9nLCBvciBhXG4gICAqICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgZmluZXN0KGxvZ2dhYmxlKSB7XG4gICAgdGhpcy5sb2coTGV2ZWwuRklORVNULCBsb2dnYWJsZSlcbiAgfVxufVxuXG4vKipcbiAqIE1haW50YWlucyBhIGNvbGxlY3Rpb24gb2YgbG9nZ2Vycy5cbiAqXG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTG9nTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAcHJpdmF0ZSB7IU1hcDxzdHJpbmcsICFMb2dnZXI+fSAqL1xuICAgIHRoaXMubG9nZ2Vyc18gPSBuZXcgTWFwKClcbiAgICB0aGlzLnJvb3RfID0gbmV3IExvZ2dlcignJywgTGV2ZWwuT0ZGKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIG5hbWVkIGxvZ2dlciwgY3JlYXRpbmcgaXQgaW4gdGhlIHByb2Nlc3MuIFRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiBpbXBsaWNpdGx5IGNyZWF0ZSB0aGUgcmVxdWVzdGVkIGxvZ2dlciwgYW5kIGFueSBvZiBpdHMgcGFyZW50cywgaWYgdGhleVxuICAgKiBkbyBub3QgeWV0IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbG9nZ2VyJ3MgbmFtZS5cbiAgICogQHJldHVybiB7IUxvZ2dlcn0gdGhlIHJlcXVlc3RlZCBsb2dnZXIuXG4gICAqL1xuICBnZXRMb2dnZXIobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdF9cbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHRoaXMucm9vdF9cbiAgICBmb3IgKGxldCBpID0gbmFtZS5pbmRleE9mKCcuJyk7IGkgIT0gLTE7IGkgPSBuYW1lLmluZGV4T2YoJy4nLCBpICsgMSkpIHtcbiAgICAgIGxldCBwYXJlbnROYW1lID0gbmFtZS5zdWJzdHIoMCwgaSlcbiAgICAgIHBhcmVudCA9IHRoaXMuY3JlYXRlTG9nZ2VyXyhwYXJlbnROYW1lLCBwYXJlbnQpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUxvZ2dlcl8obmFtZSwgcGFyZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbG9nZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbG9nZ2VyJ3MgbmFtZS5cbiAgICogQHBhcmFtIHshTG9nZ2VyfSBwYXJlbnQgdGhlIGxvZ2dlcidzIHBhcmVudC5cbiAgICogQHJldHVybiB7IUxvZ2dlcn0gdGhlIG5ldyBsb2dnZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVMb2dnZXJfKG5hbWUsIHBhcmVudCkge1xuICAgIGlmICh0aGlzLmxvZ2dlcnNfLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IUxvZ2dlcn0gKi8gKHRoaXMubG9nZ2Vyc18uZ2V0KG5hbWUpKVxuICAgIH1cbiAgICBsZXQgbG9nZ2VyID0gbmV3IExvZ2dlcihuYW1lLCBudWxsKVxuICAgIGxvZ2dlci5wYXJlbnRfID0gcGFyZW50XG4gICAgdGhpcy5sb2dnZXJzXy5zZXQobmFtZSwgbG9nZ2VyKVxuICAgIHJldHVybiBsb2dnZXJcbiAgfVxufVxuXG5jb25zdCBsb2dNYW5hZ2VyID0gbmV3IExvZ01hbmFnZXIoKVxuXG4vKipcbiAqIFJldHJpZXZlcyBhIG5hbWVkIGxvZ2dlciwgY3JlYXRpbmcgaXQgaW4gdGhlIHByb2Nlc3MuIFRoaXMgZnVuY3Rpb24gd2lsbFxuICogaW1wbGljaXRseSBjcmVhdGUgdGhlIHJlcXVlc3RlZCBsb2dnZXIsIGFuZCBhbnkgb2YgaXRzIHBhcmVudHMsIGlmIHRoZXlcbiAqIGRvIG5vdCB5ZXQgZXhpc3QuXG4gKlxuICogVGhlIGxvZyBsZXZlbCB3aWxsIGJlIHVuc3BlY2lmaWVkIGZvciBuZXdseSBjcmVhdGVkIGxvZ2dlcnMuIFVzZVxuICoge0BsaW5rIExvZ2dlciNzZXRMZXZlbChsZXZlbCl9IHRvIGV4cGxpY2l0bHkgc2V0IGEgbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGxvZ2dlcidzIG5hbWUuXG4gKiBAcmV0dXJuIHshTG9nZ2VyfSB0aGUgcmVxdWVzdGVkIGxvZ2dlci5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgcmV0dXJuIGxvZ01hbmFnZXIuZ2V0TG9nZ2VyKG5hbWUpXG59XG5cbi8qKlxuICogUGFkcyBhIG51bWJlciB0byBlbnN1cmUgaXQgaGFzIGEgbWluaW11bSBvZiB0d28gZGlnaXRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIHRoZSBudW1iZXIgdG8gYmUgcGFkZGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFkZGVkIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gcGFkKG4pIHtcbiAgaWYgKG4gPj0gMTApIHtcbiAgICByZXR1cm4gJycgKyBuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcwJyArIG5cbiAgfVxufVxuXG4vKipcbiAqIExvZ3MgYWxsIG1lc3NhZ2VzIHRvIHRoZSBDb25zb2xlIEFQSS5cbiAqIEBwYXJhbSB7IUVudHJ5fSBlbnRyeSB0aGUgZW50cnkgdG8gbG9nLlxuICovXG5mdW5jdGlvbiBjb25zb2xlSGFuZGxlcihlbnRyeSkge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnIHx8ICFjb25zb2xlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgdGltZXN0YW1wID0gbmV3IERhdGUoZW50cnkudGltZXN0YW1wKVxuICB2YXIgbXNnID1cbiAgICAnWycgK1xuICAgIHRpbWVzdGFtcC5nZXRVVENGdWxsWWVhcigpICtcbiAgICAnLScgK1xuICAgIHBhZCh0aW1lc3RhbXAuZ2V0VVRDTW9udGgoKSArIDEpICtcbiAgICAnLScgK1xuICAgIHBhZCh0aW1lc3RhbXAuZ2V0VVRDRGF0ZSgpKSArXG4gICAgJ1QnICtcbiAgICBwYWQodGltZXN0YW1wLmdldFVUQ0hvdXJzKCkpICtcbiAgICAnOicgK1xuICAgIHBhZCh0aW1lc3RhbXAuZ2V0VVRDTWludXRlcygpKSArXG4gICAgJzonICtcbiAgICBwYWQodGltZXN0YW1wLmdldFVUQ1NlY29uZHMoKSkgK1xuICAgICdaXSAnICtcbiAgICAnWycgK1xuICAgIGVudHJ5LmxldmVsLm5hbWUgK1xuICAgICddICcgK1xuICAgIGVudHJ5Lm1lc3NhZ2VcblxuICB2YXIgbGV2ZWwgPSBlbnRyeS5sZXZlbC52YWx1ZVxuICBpZiAobGV2ZWwgPj0gTGV2ZWwuU0VWRVJFLnZhbHVlKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpXG4gIH0gZWxzZSBpZiAobGV2ZWwgPj0gTGV2ZWwuV0FSTklORy52YWx1ZSkge1xuICAgIGNvbnNvbGUud2Fybihtc2cpXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2cobXNnKVxuICB9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgY29uc29sZSBoYW5kbGVyIHRvIHRoZSBnaXZlbiBsb2dnZXIuIFRoZSBjb25zb2xlIGhhbmRsZXIgd2lsbCBsb2dcbiAqIGFsbCBtZXNzYWdlcyB1c2luZyB0aGUgSmF2YVNjcmlwdCBDb25zb2xlIEFQSS5cbiAqXG4gKiBAcGFyYW0ge0xvZ2dlcj19IG9wdF9sb2dnZXIgVGhlIGxvZ2dlciB0byBhZGQgdGhlIGhhbmRsZXIgdG87IGRlZmF1bHRzXG4gKiAgICAgdG8gdGhlIHJvb3QgbG9nZ2VyLlxuICovXG5mdW5jdGlvbiBhZGRDb25zb2xlSGFuZGxlcihvcHRfbG9nZ2VyKSB7XG4gIGxldCBsb2dnZXIgPSBvcHRfbG9nZ2VyIHx8IGxvZ01hbmFnZXIucm9vdF9cbiAgbG9nZ2VyLmFkZEhhbmRsZXIoY29uc29sZUhhbmRsZXIpXG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgY29uc29sZSBsb2cgaGFuZGxlciBmcm9tIHRoZSBnaXZlbiBsb2dnZXIuXG4gKlxuICogQHBhcmFtIHtMb2dnZXI9fSBvcHRfbG9nZ2VyIFRoZSBsb2dnZXIgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyIGZyb207IGRlZmF1bHRzXG4gKiAgICAgdG8gdGhlIHJvb3QgbG9nZ2VyLlxuICogQHNlZSBleHBvcnRzLmFkZENvbnNvbGVIYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNvbnNvbGVIYW5kbGVyKG9wdF9sb2dnZXIpIHtcbiAgbGV0IGxvZ2dlciA9IG9wdF9sb2dnZXIgfHwgbG9nTWFuYWdlci5yb290X1xuICBsb2dnZXIucmVtb3ZlSGFuZGxlcihjb25zb2xlSGFuZGxlcilcbn1cblxuLyoqXG4gKiBJbnN0YWxscyB0aGUgY29uc29sZSBsb2cgaGFuZGxlciBvbiB0aGUgcm9vdCBsb2dnZXIuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbGxDb25zb2xlSGFuZGxlcigpIHtcbiAgYWRkQ29uc29sZUhhbmRsZXIobG9nTWFuYWdlci5yb290Xylcbn1cblxuLyoqXG4gKiBDb21tb24gbG9nIHR5cGVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVHlwZSA9IHtcbiAgLyoqIExvZ3Mgb3JpZ2luYXRpbmcgZnJvbSB0aGUgYnJvd3Nlci4gKi9cbiAgQlJPV1NFUjogJ2Jyb3dzZXInLFxuICAvKiogTG9ncyBmcm9tIGEgV2ViRHJpdmVyIGNsaWVudC4gKi9cbiAgQ0xJRU5UOiAnY2xpZW50JyxcbiAgLyoqIExvZ3MgZnJvbSBhIFdlYkRyaXZlciBpbXBsZW1lbnRhdGlvbi4gKi9cbiAgRFJJVkVSOiAnZHJpdmVyJyxcbiAgLyoqIExvZ3MgcmVsYXRlZCB0byBwZXJmb3JtYW5jZS4gKi9cbiAgUEVSRk9STUFOQ0U6ICdwZXJmb3JtYW5jZScsXG4gIC8qKiBMb2dzIGZyb20gdGhlIHJlbW90ZSBzZXJ2ZXIuICovXG4gIFNFUlZFUjogJ3NlcnZlcicsXG59XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBsb2cgcHJlZmVyZW5jZXMgZm9yIGEgV2ViRHJpdmVyIHNlc3Npb24uXG4gKlxuICogQGZpbmFsXG4gKi9cbmNsYXNzIFByZWZlcmVuY2VzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEBwcml2YXRlIHshTWFwPHN0cmluZywgIUxldmVsPn0gKi9cbiAgICB0aGlzLnByZWZzXyA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlc2lyZWQgbG9nZ2luZyBsZXZlbCBmb3IgYSBwYXJ0aWN1bGFyIGxvZyB0eXBlLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8VHlwZSl9IHR5cGUgVGhlIGxvZyB0eXBlLlxuICAgKiBAcGFyYW0geyghTGV2ZWx8c3RyaW5nfG51bWJlcil9IGxldmVsIFRoZSBkZXNpcmVkIGxvZyBsZXZlbC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBgdHlwZWAgaXMgbm90IGEgYHN0cmluZ2AuXG4gICAqL1xuICBzZXRMZXZlbCh0eXBlLCBsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignc3BlY2lmaWVkIGxvZyB0eXBlIGlzIG5vdCBhIHN0cmluZzogJyArIHR5cGVvZiB0eXBlKVxuICAgIH1cbiAgICB0aGlzLnByZWZzXy5zZXQodHlwZSwgbGV2ZWwgaW5zdGFuY2VvZiBMZXZlbCA/IGxldmVsIDogZ2V0TGV2ZWwobGV2ZWwpKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgaW5zdGFuY2UgdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCBvZlxuICAgKiAgICAgcHJlZmVyZW5jZXMuXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgbGV0IGpzb24gPSB7fVxuICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnByZWZzXy5rZXlzKCkpIHtcbiAgICAgIGpzb25ba2V5XSA9IHRoaXMucHJlZnNfLmdldChrZXkpLm5hbWVcbiAgICB9XG4gICAgcmV0dXJuIGpzb25cbiAgfVxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFbnRyeTogRW50cnksXG4gIExldmVsOiBMZXZlbCxcbiAgTG9nTWFuYWdlcjogTG9nTWFuYWdlcixcbiAgTG9nZ2VyOiBMb2dnZXIsXG4gIFByZWZlcmVuY2VzOiBQcmVmZXJlbmNlcyxcbiAgVHlwZTogVHlwZSxcbiAgYWRkQ29uc29sZUhhbmRsZXI6IGFkZENvbnNvbGVIYW5kbGVyLFxuICBnZXRMZXZlbDogZ2V0TGV2ZWwsXG4gIGdldExvZ2dlcjogZ2V0TG9nZ2VyLFxuICBpbnN0YWxsQ29uc29sZUhhbmRsZXI6IGluc3RhbGxDb25zb2xlSGFuZGxlcixcbiAgcmVtb3ZlQ29uc29sZUhhbmRsZXI6IHJlbW92ZUNvbnNvbGVIYW5kbGVyLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcblxuY2xhc3MgUGlubmVkU2NyaXB0IHtcbiAgY29uc3RydWN0b3Ioc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHRTb3VyY2VfID0gc2NyaXB0XG4gICAgdGhpcy5zY3JpcHRIYW5kbGVfID0gY3J5cHRvLnJhbmRvbVVVSUQoKS5yZXBsYWNlKC8tL2dpLCAnJylcbiAgfVxuXG4gIGdldCBoYW5kbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyaXB0SGFuZGxlX1xuICB9XG5cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JpcHRTb3VyY2VfXG4gIH1cblxuICBnZXQgc2NyaXB0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyaXB0SWRfXG4gIH1cblxuICBzZXQgc2NyaXB0SWQoaWQpIHtcbiAgICB0aGlzLnNjcmlwdElkXyA9IGlkXG4gIH1cblxuICBjcmVhdGlvblNjcmlwdCgpIHtcbiAgICByZXR1cm4gYGZ1bmN0aW9uIF9fd2ViZHJpdmVyXyR7dGhpcy5zY3JpcHRIYW5kbGVffShhcmd1bWVudHMpIHsgJHt0aGlzLnNjcmlwdFNvdXJjZV99IH1gXG4gIH1cblxuICBleGVjdXRpb25TY3JpcHQoKSB7XG4gICAgcmV0dXJuIGByZXR1cm4gX193ZWJkcml2ZXJfJHt0aGlzLnNjcmlwdEhhbmRsZV99KGFyZ3VtZW50cylgXG4gIH1cblxuICByZW1vdmFsU2NyaXB0KCkge1xuICAgIHJldHVybiBgX193ZWJkcml2ZXJfJHt0aGlzLnNjcmlwdEhhbmRsZV99ID0gdW5kZWZpbmVkYFxuICB9XG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBpbm5lZFNjcmlwdCxcbn1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEZWZpbmVzIGEgaGFuZGZ1bCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0byBzaW1wbGlmeSB3b3JraW5nXG4gKiB3aXRoIHByb21pc2VzLlxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzT2JqZWN0LCBpc1Byb21pc2UgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIGF0IGEgc2V0IHRpbWUgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtcyBUaGUgYW1vdW50IG9mIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgdG8gd2FpdCBiZWZvcmVcbiAqICAgICByZXNvbHZpbmcgdGhlIHByb21pc2UuXG4gKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gVGhlIHByb21pc2UuXG4gKi9cbmZ1bmN0aW9uIGRlbGF5ZWQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSlcbn1cblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgaXRzIGZpbmFsXG4gKiBhcmd1bWVudC4gVGhpcyBjYWxsYmFjayBleHBlY3RzIHR3byBhcmd1bWVudHM6IGFuIGVycm9yIHZhbHVlICh3aGljaCB3aWxsIGJlXG4gKiBudWxsIGlmIHRoZSBjYWxsIHN1Y2NlZWRlZCksIGFuZCB0aGUgc3VjY2VzcyB2YWx1ZSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogVGhlIGNhbGxiYWNrIHdpbGwgdGhlIHJlc29sdmUgb3IgcmVqZWN0IHRoZSByZXR1cm5lZCBwcm9taXNlLCBiYXNlZCBvbiBpdHNcbiAqIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7Li4uP30gYXJncyBUaGUgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbiwgZXhjbHVkaW5nIHRoZVxuICogICAgIGZpbmFsIGNhbGxiYWNrLlxuICogQHJldHVybiB7IVRoZW5hYmxlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlXG4gKiAgICAgcmVzdWx0IG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbidzIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBjaGVja2VkTm9kZUNhbGwoZm4sIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICB0cnkge1xuICAgICAgZm4oLi4uYXJncywgZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgICBlcnJvciA/IHJlamVjdChlcnJvcikgOiBmdWxmaWxsKHZhbHVlKVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmVqZWN0KGV4KVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0byBpbnZva2Ugd2hlbiBhIHByb21pc2UgaXMgcmVzb2x2ZWQsIHJlZ2FyZGxlc3NcbiAqIG9mIHdoZXRoZXIgdGhlIHByb21pc2UncyB2YWx1ZSB3YXMgc3VjY2Vzc2Z1bGx5IGNvbXB1dGVkLiBUaGlzIGZ1bmN0aW9uXG4gKiBpcyBzeW5vbnltb3VzIHdpdGggdGhlIHtAY29kZSBmaW5hbGx5fSBjbGF1c2UgaW4gYSBzeW5jaHJvbm91cyBBUEk6XG4gKlxuICogICAgIC8vIFN5bmNocm9ub3VzIEFQSTpcbiAqICAgICB0cnkge1xuICogICAgICAgZG9TeW5jaHJvbm91c1dvcmsoKTtcbiAqICAgICB9IGZpbmFsbHkge1xuICogICAgICAgY2xlYW5VcCgpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQXN5bmNocm9ub3VzIHByb21pc2UgQVBJOlxuICogICAgIGRvQXN5bmNocm9ub3VzV29yaygpLmZpbmFsbHkoY2xlYW5VcCk7XG4gKlxuICogX19Ob3RlOl9fIHNpbWlsYXIgdG8gdGhlIHtAY29kZSBmaW5hbGx5fSBjbGF1c2UsIGlmIHRoZSByZWdpc3RlcmVkXG4gKiBjYWxsYmFjayByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZSBvciB0aHJvd3MgYW4gZXJyb3IsIGl0IHdpbGwgc2lsZW50bHlcbiAqIHJlcGxhY2UgdGhlIHJlamVjdGlvbiBlcnJvciAoaWYgYW55KSBmcm9tIHRoaXMgcHJvbWlzZTpcbiAqXG4gKiAgICAgdHJ5IHtcbiAqICAgICAgIHRocm93IEVycm9yKCdvbmUnKTtcbiAqICAgICB9IGZpbmFsbHkge1xuICogICAgICAgdGhyb3cgRXJyb3IoJ3R3bycpOyAgLy8gSGlkZXMgRXJyb3I6IG9uZVxuICogICAgIH1cbiAqXG4gKiAgICAgbGV0IHAgPSBQcm9taXNlLnJlamVjdChFcnJvcignb25lJykpO1xuICogICAgIHByb21pc2UuZmluYWxseShwLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRocm93IEVycm9yKCd0d28nKTsgIC8vIEhpZGVzIEVycm9yOiBvbmVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0geyFJVGhlbmFibGU8Pz59IHByb21pc2UgVGhlIHByb21pc2UgdG8gYWRkIHRoZSBsaXN0ZW5lciB0by5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogKFJ8SVRoZW5hYmxlPFI+KX0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlblxuICogICAgIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLlxuICogQHJldHVybiB7IVByb21pc2U8Uj59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgY2FsbGJhY2tcbiAqICAgICByZXN1bHQuXG4gKiBAdGVtcGxhdGUgUlxuICovXG5hc3luYyBmdW5jdGlvbiB0aGVuRmluYWxseShwcm9taXNlLCBjYWxsYmFjaykge1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZShwcm9taXNlKVxuICAgIHJldHVybiBjYWxsYmFjaygpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhd2FpdCBjYWxsYmFjaygpXG4gICAgdGhyb3cgZVxuICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIGFuIGFycmF5IGFuZCBpbnNlcnRzIHRoZSByZXN1bHQgaW50byBhXG4gKiBuZXcgYXJyYXksIHdoaWNoIGlzIHVzZWQgYXMgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIG9mIHRoZSBwcm9taXNlIHJldHVybmVkXG4gKiBieSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIElmIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1hcHBpbmcgZnVuY3Rpb24gaXMgYSBwcm9taXNlLCB0aGlzIGZ1bmN0aW9uXG4gKiB3aWxsIHdhaXQgZm9yIGl0IHRvIGJlIGZ1bGZpbGxlZCBiZWZvcmUgaW5zZXJ0aW5nIGl0IGludG8gdGhlIG5ldyBhcnJheS5cbiAqXG4gKiBJZiB0aGUgbWFwcGluZyBmdW5jdGlvbiB0aHJvd3Mgb3IgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UsIHRoZVxuICogcHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZSByZWFzb24uXG4gKiBPbmx5IHRoZSBmaXJzdCBmYWlsdXJlIHdpbGwgYmUgcmVwb3J0ZWQ7IGFsbCBzdWJzZXF1ZW50IGVycm9ycyB3aWxsIGJlXG4gKiBzaWxlbnRseSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7IShBcnJheTxUWVBFPnxJVGhlbmFibGU8IUFycmF5PFRZUEU+Pil9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlXG4gKiAgICAgb3Zlciwgb3IgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIHNhaWQgYXJyYXkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFNFTEYsIFRZUEUsIG51bWJlciwgIUFycmF5PFRZUEU+KTogP30gZm4gVGhlXG4gKiAgICAgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS4gVGhpcyBmdW5jdGlvbiBzaG91bGRcbiAqICAgICBleHBlY3QgdGhyZWUgYXJndW1lbnRzICh0aGUgZWxlbWVudCwgdGhlIGluZGV4LCBhbmQgdGhlIGFycmF5IGl0c2VsZi5cbiAqIEBwYXJhbSB7U0VMRj19IHNlbGYgVGhlIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSB2YWx1ZSBvZiAndGhpcycgd2l0aGluIGBmbmAuXG4gKiBAdGVtcGxhdGUgVFlQRSwgU0VMRlxuICovXG5hc3luYyBmdW5jdGlvbiBtYXAoYXJyYXksIGZuLCBzZWxmID0gdW5kZWZpbmVkKSB7XG4gIGNvbnN0IHYgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoYXJyYXkpXG4gIGlmICghQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHRocm93IFR5cGVFcnJvcignbm90IGFuIGFycmF5JylcbiAgfVxuXG4gIGNvbnN0IGFyciA9IC8qKiBAdHlwZSB7IUFycmF5fSAqLyAodilcbiAgY29uc3QgdmFsdWVzID0gW11cblxuICBmb3IgKGNvbnN0IFtpbmRleCwgaXRlbV0gb2YgYXJyLmVudHJpZXMoKSkge1xuICAgIHZhbHVlcy5wdXNoKGF3YWl0IFByb21pc2UucmVzb2x2ZShmbi5jYWxsKHNlbGYsIGl0ZW0sIGluZGV4LCBhcnIpKSlcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gYW4gYXJyYXksIGFuZCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogdHJ1ZSBhZGRzIHRoZSBlbGVtZW50IHRvIGEgbmV3IGFycmF5LlxuICpcbiAqIElmIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpbHRlciBmdW5jdGlvbiBpcyBhIHByb21pc2UsIHRoaXMgZnVuY3Rpb25cbiAqIHdpbGwgd2FpdCBmb3IgaXQgdG8gYmUgZnVsZmlsbGVkIGJlZm9yZSBkZXRlcm1pbmluZyB3aGV0aGVyIHRvIGluc2VydCB0aGVcbiAqIGVsZW1lbnQgaW50byB0aGUgbmV3IGFycmF5LlxuICpcbiAqIElmIHRoZSBmaWx0ZXIgZnVuY3Rpb24gdGhyb3dzIG9yIHJldHVybnMgYSByZWplY3RlZCBwcm9taXNlLCB0aGUgcHJvbWlzZVxuICogcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWUgcmVhc29uLiBPbmx5IHRoZVxuICogZmlyc3QgZmFpbHVyZSB3aWxsIGJlIHJlcG9ydGVkOyBhbGwgc3Vic2VxdWVudCBlcnJvcnMgd2lsbCBiZSBzaWxlbnRseVxuICogaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0geyEoQXJyYXk8VFlQRT58SVRoZW5hYmxlPCFBcnJheTxUWVBFPj4pfSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZVxuICogICAgIG92ZXIsIG9yIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byBzYWlkIGFycmF5LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTRUxGLCBUWVBFLCBudW1iZXIsICFBcnJheTxUWVBFPik6IChcbiAqICAgICAgICAgICAgIGJvb2xlYW58SVRoZW5hYmxlPGJvb2xlYW4+KX0gZm4gVGhlIGZ1bmN0aW9uXG4gKiAgICAgdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7U0VMRj19IHNlbGYgVGhlIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSB2YWx1ZSBvZiAndGhpcycgd2l0aGluIGBmbmAuXG4gKiBAdGVtcGxhdGUgVFlQRSwgU0VMRlxuICovXG5hc3luYyBmdW5jdGlvbiBmaWx0ZXIoYXJyYXksIGZuLCBzZWxmID0gdW5kZWZpbmVkKSB7XG4gIGNvbnN0IHYgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoYXJyYXkpXG4gIGlmICghQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHRocm93IFR5cGVFcnJvcignbm90IGFuIGFycmF5JylcbiAgfVxuXG4gIGNvbnN0IGFyciA9IC8qKiBAdHlwZSB7IUFycmF5fSAqLyAodilcbiAgY29uc3QgdmFsdWVzID0gW11cblxuICBmb3IgKGNvbnN0IFtpbmRleCwgaXRlbV0gb2YgYXJyLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGlzQ29uZGl0aW9uVHJ1ZSA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShcbiAgICAgIGZuLmNhbGwoc2VsZiwgaXRlbSwgaW5kZXgsIGFycilcbiAgICApXG4gICAgaWYgKGlzQ29uZGl0aW9uVHJ1ZSkge1xuICAgICAgdmFsdWVzLnB1c2goaXRlbSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGlucHV0IHZhbHVlIGluIGFcbiAqIGZ1bGx5LXJlc29sdmVkIHN0YXRlLiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIGVhY2ggZWxlbWVudCB3aWxsIGJlIGZ1bGx5XG4gKiByZXNvbHZlZC4gTGlrZXdpc2UsIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGFsbCBrZXlzIHdpbGwgYmUgZnVsbHlcbiAqIHJlc29sdmVkLiBJbiBib3RoIGNhc2VzLCBhbGwgbmVzdGVkIGFycmF5cyBhbmQgb2JqZWN0cyB3aWxsIGFsc28gYmVcbiAqIGZ1bGx5IHJlc29sdmVkLiAgQWxsIGZpZWxkcyBhcmUgcmVzb2x2ZWQgaW4gcGxhY2U7IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGxcbiAqIHJlc29sdmUgb24ge0Bjb2RlIHZhbHVlfSBhbmQgbm90IGEgY29weS5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIG1ha2VzIG5vIGNoZWNrcyBhZ2FpbnN0IG9iamVjdHMgdGhhdCBjb250YWluXG4gKiBjeWNsaWNhbCByZWZlcmVuY2VzOlxuICpcbiAqICAgICB2YXIgdmFsdWUgPSB7fTtcbiAqICAgICB2YWx1ZVsnc2VsZiddID0gdmFsdWU7XG4gKiAgICAgcHJvbWlzZS5mdWxseVJlc29sdmVkKHZhbHVlKTsgIC8vIFN0YWNrIG92ZXJmbG93LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZ1bGx5IHJlc29sdmUuXG4gKiBAcmV0dXJuIHshVGhlbmFibGV9IEEgcHJvbWlzZSBmb3IgYSBmdWxseSByZXNvbHZlZCB2ZXJzaW9uXG4gKiAgICAgb2YgdGhlIGlucHV0IHZhbHVlLlxuICovXG5hc3luYyBmdW5jdGlvbiBmdWxseVJlc29sdmVkKHZhbHVlKSB7XG4gIHZhbHVlID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnVsbHlSZXNvbHZlS2V5cygvKiogQHR5cGUgeyFBcnJheX0gKi8gKHZhbHVlKSlcbiAgfVxuXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnVsbHlSZXNvbHZlS2V5cygvKiogQHR5cGUgeyFPYmplY3R9ICovICh2YWx1ZSkpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bGx5UmVzb2x2ZUtleXMoLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAodmFsdWUpKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogQHBhcmFtIHshKEFycmF5fE9iamVjdCl9IG9iaiB0aGUgb2JqZWN0IHRvIHJlc29sdmUuXG4gKiBAcmV0dXJuIHshVGhlbmFibGV9IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAqICAgICBpbnB1dCBvYmplY3Qgb25jZSBhbGwgb2YgaXRzIHZhbHVlcyBoYXZlIGJlZW4gZnVsbHkgcmVzb2x2ZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZ1bGx5UmVzb2x2ZUtleXMob2JqKSB7XG4gIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG9iailcbiAgY29uc3QgbnVtS2V5cyA9IGlzQXJyYXkgPyBvYmoubGVuZ3RoIDogT2JqZWN0LmtleXMob2JqKS5sZW5ndGhcblxuICBpZiAoIW51bUtleXMpIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBmb3JFYWNoUHJvcGVydHkob2JqLCBmbikge1xuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGF3YWl0IGZuKG9ialtrZXldLCBrZXkpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZm9yRWFjaEVsZW1lbnQoYXJyLCBmbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhd2FpdCBmbihhcnJbaV0sIGkpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZm9yRWFjaEtleSA9IGlzQXJyYXkgPyBmb3JFYWNoRWxlbWVudCA6IGZvckVhY2hQcm9wZXJ0eVxuICBhd2FpdCBmb3JFYWNoS2V5KG9iaiwgYXN5bmMgZnVuY3Rpb24gKHBhcnRpYWxWYWx1ZSwga2V5KSB7XG4gICAgaWYgKFxuICAgICAgIUFycmF5LmlzQXJyYXkocGFydGlhbFZhbHVlKSAmJlxuICAgICAgKCFwYXJ0aWFsVmFsdWUgfHwgdHlwZW9mIHBhcnRpYWxWYWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgb2JqW2tleV0gPSBhd2FpdCBmdWxseVJlc29sdmVkKHBhcnRpYWxWYWx1ZSlcbiAgfSlcbiAgcmV0dXJuIG9ialxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja2VkTm9kZUNhbGwsXG4gIGRlbGF5ZWQsXG4gIGZpbHRlcixcbiAgZmluYWxseTogdGhlbkZpbmFsbHksXG4gIGZ1bGx5UmVzb2x2ZWQsXG4gIGlzUHJvbWlzZSxcbiAgbWFwLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnksIGVzY2FwZUNzcyB9ID0gcmVxdWlyZSgnLi9ieScpXG5jb25zdCBlcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKVxuXG4vKipcbiAqIElTZWxlY3QgaW50ZXJmYWNlIG1ha2VzIGEgcHJvdG9jb2wgZm9yIGFsbCBraW5kIG9mIHNlbGVjdCBlbGVtZW50cyAoc3RhbmRhcmQgaHRtbCBhbmQgY3VzdG9tXG4gKiBtb2RlbClcbiAqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuY2xhc3MgSVNlbGVjdCB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxib29sZWFuPn0gV2hldGhlciB0aGlzIHNlbGVjdCBlbGVtZW50IHN1cHBvcnRzIHNlbGVjdGluZyBtdWx0aXBsZSBvcHRpb25zIGF0IHRoZSBzYW1lIHRpbWU/IFRoaXNcbiAgICogaXMgZG9uZSBieSBjaGVja2luZyB0aGUgdmFsdWUgb2YgdGhlIFwibXVsdGlwbGVcIiBhdHRyaWJ1dGUuXG4gICAqL1xuICBpc011bHRpcGxlKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTwhQXJyYXk8IVdlYkVsZW1lbnQ+Pn0gQWxsIG9wdGlvbnMgYmVsb25naW5nIHRvIHRoaXMgc2VsZWN0IHRhZ1xuICAgKi9cbiAgZ2V0T3B0aW9ucygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQHJldHVybiB7IVByb21pc2U8IUFycmF5PCFXZWJFbGVtZW50Pj59IEFsbCBzZWxlY3RlZCBvcHRpb25zIGJlbG9uZ2luZyB0byB0aGlzIHNlbGVjdCB0YWdcbiAgICovXG4gIGdldEFsbFNlbGVjdGVkT3B0aW9ucygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQHJldHVybiB7IVByb21pc2U8IVdlYkVsZW1lbnQ+fSBUaGUgZmlyc3Qgc2VsZWN0ZWQgb3B0aW9uIGluIHRoaXMgc2VsZWN0IHRhZyAob3IgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24gaW4gYVxuICAgKiBub3JtYWwgc2VsZWN0KVxuICAgKi9cbiAgZ2V0Rmlyc3RTZWxlY3RlZE9wdGlvbigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogU2VsZWN0IGFsbCBvcHRpb25zIHRoYXQgZGlzcGxheSB0ZXh0IG1hdGNoaW5nIHRoZSBhcmd1bWVudC4gVGhhdCBpcywgd2hlbiBnaXZlbiBcIkJhclwiIHRoaXNcbiAgICogd291bGQgc2VsZWN0IGFuIG9wdGlvbiBsaWtlOlxuICAgKlxuICAgKiAmbHQ7b3B0aW9uIHZhbHVlPVwiZm9vXCImZ3Q7QmFyJmx0Oy9vcHRpb24mZ3Q7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB2aXNpYmxlIHRleHQgdG8gbWF0Y2ggYWdhaW5zdFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgc2VsZWN0QnlWaXNpYmxlVGV4dCh0ZXh0KSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhbGwgb3B0aW9ucyB0aGF0IGhhdmUgYSB2YWx1ZSBtYXRjaGluZyB0aGUgYXJndW1lbnQuIFRoYXQgaXMsIHdoZW4gZ2l2ZW4gXCJmb29cIiB0aGlzXG4gICAqIHdvdWxkIHNlbGVjdCBhbiBvcHRpb24gbGlrZTpcbiAgICpcbiAgICogJmx0O29wdGlvbiB2YWx1ZT1cImZvb1wiJmd0O0JhciZsdDsvb3B0aW9uJmd0O1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoIGFnYWluc3RcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIHNlbGVjdEJ5VmFsdWUodmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBvcHRpb24gYXQgdGhlIGdpdmVuIGluZGV4LiBUaGlzIGlzIGRvbmUgYnkgZXhhbWluaW5nIHRoZSBcImluZGV4XCIgYXR0cmlidXRlIG9mIGFuXG4gICAqIGVsZW1lbnQsIGFuZCBub3QgbWVyZWx5IGJ5IGNvdW50aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIG9wdGlvbiBhdCB0aGlzIGluZGV4IHdpbGwgYmUgc2VsZWN0ZWRcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIHNlbGVjdEJ5SW5kZXgoaW5kZXgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIHNlbGVjdGVkIGVudHJpZXMuIFRoaXMgaXMgb25seSB2YWxpZCB3aGVuIHRoZSBTRUxFQ1Qgc3VwcG9ydHMgbXVsdGlwbGUgc2VsZWN0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGRlc2VsZWN0QWxsKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhbGwgb3B0aW9ucyB0aGF0IGRpc3BsYXkgdGV4dCBtYXRjaGluZyB0aGUgYXJndW1lbnQuIFRoYXQgaXMsIHdoZW4gZ2l2ZW4gXCJCYXJcIiB0aGlzXG4gICAqIHdvdWxkIGRlc2VsZWN0IGFuIG9wdGlvbiBsaWtlOlxuICAgKlxuICAgKiAmbHQ7b3B0aW9uIHZhbHVlPVwiZm9vXCImZ3Q7QmFyJmx0Oy9vcHRpb24mZ3Q7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB2aXNpYmxlIHRleHQgdG8gbWF0Y2ggYWdhaW5zdFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgZGVzZWxlY3RCeVZpc2libGVUZXh0KHRleHQpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogRGVzZWxlY3QgYWxsIG9wdGlvbnMgdGhhdCBoYXZlIGEgdmFsdWUgbWF0Y2hpbmcgdGhlIGFyZ3VtZW50LiBUaGF0IGlzLCB3aGVuIGdpdmVuIFwiZm9vXCIgdGhpc1xuICAgKiB3b3VsZCBkZXNlbGVjdCBhbiBvcHRpb24gbGlrZTpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBkZXNlbGVjdEJ5VmFsdWUodmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogRGVzZWxlY3QgdGhlIG9wdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXguIFRoaXMgaXMgZG9uZSBieSBleGFtaW5pbmcgdGhlIFwiaW5kZXhcIiBhdHRyaWJ1dGUgb2YgYW5cbiAgICogZWxlbWVudCwgYW5kIG5vdCBtZXJlbHkgYnkgY291bnRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgb3B0aW9uIGF0IHRoaXMgaW5kZXggd2lsbCBiZSBkZXNlbGVjdGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBkZXNlbGVjdEJ5SW5kZXgoaW5kZXgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn1cblxuLyoqXG4gKiBAaW1wbGVtZW50cyBJU2VsZWN0XG4gKi9cbmNsYXNzIFNlbGVjdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gU2VsZWN0IEVsZW1lbnRcbiAgICogQHBhcmFtIHtXZWJFbGVtZW50fSBlbGVtZW50IFNlbGVjdCBXZWJFbGVtZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcblxuICAgIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhZ05hbWUnKS50aGVuKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICBpZiAodGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc2VsZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlbGVjdCBvbmx5IHdvcmtzIG9uIDxzZWxlY3Q+IGVsZW1lbnRzYClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFNlbGVjdCBvcHRpb24gd2l0aCBzcGVjaWZpZWQgaW5kZXguXG4gICAqXG4gICAqIDxleGFtcGxlPlxuICAgPHNlbGVjdCBpZD1cInNlbGVjdGJveFwiPlxuICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+T3B0aW9uIDE8L29wdGlvbj5cbiAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPk9wdGlvbiAyPC9vcHRpb24+XG4gICAgPG9wdGlvbiB2YWx1ZT1cIjNcIj5PcHRpb24gMzwvb3B0aW9uPlxuICAgPC9zZWxlY3Q+XG4gICBjb25zdCBzZWxlY3RCb3ggPSBhd2FpdCBkcml2ZXIuZmluZEVsZW1lbnQoQnkuaWQoXCJzZWxlY3Rib3hcIikpO1xuICAgYXdhaXQgc2VsZWN0T2JqZWN0LnNlbGVjdEJ5SW5kZXgoMSk7XG4gICAqIDwvZXhhbXBsZT5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4XG4gICAqL1xuICBhc3luYyBzZWxlY3RCeUluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBuZWVkcyB0byBiZSAwIG9yIGFueSBvdGhlciBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGxldCBvcHRpb25zID0gYXdhaXQgdGhpcy5lbGVtZW50LmZpbmRFbGVtZW50cyhCeS50YWdOYW1lKCdvcHRpb24nKSlcblxuICAgIGlmIChvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0IGVsZW1lbnQgZG9lc24ndCBjb250YWluIGFueSBvcHRpb24gZWxlbWVudFwiKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxlbmd0aCAtIDEgPCBpbmRleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgT3B0aW9uIHdpdGggaW5kZXggXCIke2luZGV4fVwiIG5vdCBmb3VuZC4gU2VsZWN0IGVsZW1lbnQgb25seSBjb250YWlucyAke1xuICAgICAgICAgIG9wdGlvbnMubGVuZ3RoIC0gMVxuICAgICAgICB9IG9wdGlvbiBlbGVtZW50c2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBmb3IgKGxldCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgaWYgKChhd2FpdCBvcHRpb24uZ2V0QXR0cmlidXRlKCdpbmRleCcpKSA9PT0gaW5kZXgudG9TdHJpbmcoKSkge1xuICAgICAgICBhd2FpdCB0aGlzLnNldFNlbGVjdGVkKG9wdGlvbilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogU2VsZWN0IG9wdGlvbiBieSBzcGVjaWZpYyB2YWx1ZS5cbiAgICpcbiAgICogPGV4YW1wbGU+XG4gICA8c2VsZWN0IGlkPVwic2VsZWN0Ym94XCI+XG4gICA8b3B0aW9uIHZhbHVlPVwiMVwiPk9wdGlvbiAxPC9vcHRpb24+XG4gICA8b3B0aW9uIHZhbHVlPVwiMlwiPk9wdGlvbiAyPC9vcHRpb24+XG4gICA8b3B0aW9uIHZhbHVlPVwiM1wiPk9wdGlvbiAzPC9vcHRpb24+XG4gICA8L3NlbGVjdD5cbiAgIGNvbnN0IHNlbGVjdEJveCA9IGF3YWl0IGRyaXZlci5maW5kRWxlbWVudChCeS5pZChcInNlbGVjdGJveFwiKSk7XG4gICBhd2FpdCBzZWxlY3RPYmplY3Quc2VsZWN0QnlWaXNpYmxlVGV4dChcIk9wdGlvbiAyXCIpO1xuICAgKiA8L2V4YW1wbGU+XG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZSBvZiBvcHRpb24gZWxlbWVudCB0byBiZSBzZWxlY3RlZFxuICAgKi9cbiAgYXN5bmMgc2VsZWN0QnlWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBtYXRjaGVkID0gZmFsc2VcbiAgICBsZXQgaXNNdWx0aSA9IGF3YWl0IHRoaXMuaXNNdWx0aXBsZSgpXG5cbiAgICBsZXQgb3B0aW9ucyA9IGF3YWl0IHRoaXMuZWxlbWVudC5maW5kRWxlbWVudHMoe1xuICAgICAgY3NzOiAnb3B0aW9uW3ZhbHVlID0nICsgZXNjYXBlQ3NzKHZhbHVlKSArICddJyxcbiAgICB9KVxuXG4gICAgZm9yIChsZXQgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2V0U2VsZWN0ZWQob3B0aW9uKVxuXG4gICAgICBpZiAoIWlzTXVsdGkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBtYXRjaGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbG9jYXRlIG9wdGlvbiB3aXRoIHZhbHVlOiAke3ZhbHVlfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFNlbGVjdCBvcHRpb24gd2l0aCBkaXNwbGF5ZWQgdGV4dCBtYXRjaGluZyB0aGUgYXJndW1lbnQuXG4gICAqXG4gICAqIDxleGFtcGxlPlxuICAgPHNlbGVjdCBpZD1cInNlbGVjdGJveFwiPlxuICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj5PcHRpb24gMTwvb3B0aW9uPlxuICAgPG9wdGlvbiB2YWx1ZT1cIjJcIj5PcHRpb24gMjwvb3B0aW9uPlxuICAgPG9wdGlvbiB2YWx1ZT1cIjNcIj5PcHRpb24gMzwvb3B0aW9uPlxuICAgPC9zZWxlY3Q+XG4gICBjb25zdCBzZWxlY3RCb3ggPSBhd2FpdCBkcml2ZXIuZmluZEVsZW1lbnQoQnkuaWQoXCJzZWxlY3Rib3hcIikpO1xuICAgYXdhaXQgc2VsZWN0T2JqZWN0LnNlbGVjdEJ5VmlzaWJsZVRleHQoXCJPcHRpb24gMlwiKTtcbiAgICogPC9leGFtcGxlPlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHRleHQgICAgICAgdGV4dCBvZiBvcHRpb24gZWxlbWVudCB0byBnZXQgc2VsZWN0ZWRcbiAgICpcbiAgICovXG4gIGFzeW5jIHNlbGVjdEJ5VmlzaWJsZVRleHQodGV4dCkge1xuICAgIHRleHQgPSB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicgPyB0ZXh0LnRvU3RyaW5nKCkgOiB0ZXh0XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gdGV4dFxuICAgICAgLnRyaW0oKSAvLyBzdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZS1zcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAucmVwbGFjZSgvXFxzKy8sICcgJykgLy8gcmVwbGFjZSBzZXF1ZW5jZXMgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGJ5IGEgc2luZ2xlIHNwYWNlXG5cbiAgICAvKipcbiAgICAgKiBmaW5kIG9wdGlvbiBlbGVtZW50IHVzaW5nIHhwYXRoXG4gICAgICovXG4gICAgY29uc3QgZm9ybWF0dGVkID0gL1wiLy50ZXN0KG5vcm1hbGl6ZWQpXG4gICAgICA/ICdjb25jYXQoXCInICsgbm9ybWFsaXplZC5zcGxpdCgnXCInKS5qb2luKCdcIiwgXFwnXCJcXCcsIFwiJykgKyAnXCIpJ1xuICAgICAgOiBgXCIke25vcm1hbGl6ZWR9XCJgXG4gICAgY29uc3QgZG90Rm9ybWF0ID0gYFsuID0gJHtmb3JtYXR0ZWR9XWBcbiAgICBjb25zdCBzcGFjZUZvcm1hdCA9IGBbbm9ybWFsaXplLXNwYWNlKHRleHQoKSkgPSAke2Zvcm1hdHRlZH1dYFxuXG4gICAgY29uc3Qgc2VsZWN0aW9ucyA9IFtcbiAgICAgIGAuL29wdGlvbiR7ZG90Rm9ybWF0fWAsXG4gICAgICBgLi9vcHRpb24ke3NwYWNlRm9ybWF0fWAsXG4gICAgICBgLi9vcHRncm91cC9vcHRpb24ke2RvdEZvcm1hdH1gLFxuICAgICAgYC4vb3B0Z3JvdXAvb3B0aW9uJHtzcGFjZUZvcm1hdH1gLFxuICAgIF1cblxuICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBhd2FpdCB0aGlzLmVsZW1lbnQuZmluZEVsZW1lbnQoe1xuICAgICAgeHBhdGg6IHNlbGVjdGlvbnMuam9pbignfCcpLFxuICAgIH0pXG4gICAgYXdhaXQgdGhpcy5zZXRTZWxlY3RlZChvcHRpb25FbGVtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBvcHRpb25zIGJlbG9uZ2luZyB0byB0aGlzIHNlbGVjdCB0YWdcbiAgICogQHJldHVybnMgeyFQcm9taXNlPCFBcnJheTwhV2ViRWxlbWVudD4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5lbGVtZW50LmZpbmRFbGVtZW50cyh7IHRhZ05hbWU6ICdvcHRpb24nIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgaWYgdGhlIHNlbGVjdCB0YWcgaXMgbXVsdGlwbGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBpc011bHRpcGxlKCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbXVsdGlwbGUnKSkgIT09IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgc2VsZWN0ZWQgb3B0aW9ucyBiZWxvbmdpbmcgdG8gdGhpcyBzZWxlY3QgdGFnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsU2VsZWN0ZWRPcHRpb25zKCkge1xuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldE9wdGlvbnMoKVxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXVxuICAgIGZvciAobGV0IG9wdGlvbnMgb2Ygb3B0cykge1xuICAgICAgaWYgKGF3YWl0IG9wdGlvbnMuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlyc3QgU2VsZWN0ZWQgT3B0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVsZW1lbnQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0Rmlyc3RTZWxlY3RlZE9wdGlvbigpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0QWxsU2VsZWN0ZWRPcHRpb25zKCkpWzBdXG4gIH1cblxuICAvKipcbiAgICogRGVzZWxlY3RzIGFsbCBzZWxlY3RlZCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgZGVzZWxlY3RBbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzTXVsdGlwbGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG9ubHkgZGVzZWxlY3QgYWxsIG9wdGlvbnMgb2YgYSBtdWx0aS1zZWxlY3QnKVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCB0aGlzLmdldE9wdGlvbnMoKVxuXG4gICAgZm9yIChsZXQgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgIGlmIChhd2FpdCBvcHRpb24uaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgIGF3YWl0IG9wdGlvbi5jbGljaygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfE51bWJlcn10ZXh0IHRleHQgb2Ygb3B0aW9uIHRvIGRlc2VsZWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgZGVzZWxlY3RCeVZpc2libGVUZXh0KHRleHQpIHtcbiAgICBpZiAoIShhd2FpdCB0aGlzLmlzTXVsdGlwbGUoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBvbmx5IGRlc2VsZWN0IG9wdGlvbnMgb2YgYSBtdWx0aS1zZWxlY3QnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgdmFsdWUgaW50byBzdHJpbmdcbiAgICAgKi9cbiAgICB0ZXh0ID0gdHlwZW9mIHRleHQgPT09ICdudW1iZXInID8gdGV4dC50b1N0cmluZygpIDogdGV4dFxuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHRleHRcbiAgICAgIC50cmltKCkgLy8gc3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGUtc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgLnJlcGxhY2UoL1xccysvLCAnICcpIC8vIHJlcGxhY2Ugc2VxdWVuY2VzIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBieSBhIHNpbmdsZSBzcGFjZVxuXG4gICAgLyoqXG4gICAgICogZmluZCBvcHRpb24gZWxlbWVudCB1c2luZyB4cGF0aFxuICAgICAqL1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IC9cIi8udGVzdChub3JtYWxpemVkKVxuICAgICAgPyAnY29uY2F0KFwiJyArIG5vcm1hbGl6ZWQuc3BsaXQoJ1wiJykuam9pbignXCIsIFxcJ1wiXFwnLCBcIicpICsgJ1wiKSdcbiAgICAgIDogYFwiJHtub3JtYWxpemVkfVwiYFxuICAgIGNvbnN0IGRvdEZvcm1hdCA9IGBbLiA9ICR7Zm9ybWF0dGVkfV1gXG4gICAgY29uc3Qgc3BhY2VGb3JtYXQgPSBgW25vcm1hbGl6ZS1zcGFjZSh0ZXh0KCkpID0gJHtmb3JtYXR0ZWR9XWBcblxuICAgIGNvbnN0IHNlbGVjdGlvbnMgPSBbXG4gICAgICBgLi9vcHRpb24ke2RvdEZvcm1hdH1gLFxuICAgICAgYC4vb3B0aW9uJHtzcGFjZUZvcm1hdH1gLFxuICAgICAgYC4vb3B0Z3JvdXAvb3B0aW9uJHtkb3RGb3JtYXR9YCxcbiAgICAgIGAuL29wdGdyb3VwL29wdGlvbiR7c3BhY2VGb3JtYXR9YCxcbiAgICBdXG5cbiAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gYXdhaXQgdGhpcy5lbGVtZW50LmZpbmRFbGVtZW50KHtcbiAgICAgIHhwYXRoOiBzZWxlY3Rpb25zLmpvaW4oJ3wnKSxcbiAgICB9KVxuICAgIGlmIChhd2FpdCBvcHRpb25FbGVtZW50LmlzU2VsZWN0ZWQoKSkge1xuICAgICAgYXdhaXQgb3B0aW9uRWxlbWVudC5jbGljaygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICAgICBpbmRleCBvZiBvcHRpb24gZWxlbWVudCB0byBkZXNlbGVjdFxuICAgKiBEZXNlbGVjdCB0aGUgb3B0aW9uIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICogVGhpcyBpcyBkb25lIGJ5IGV4YW1pbmluZyB0aGUgXCJpbmRleFwiXG4gICAqIGF0dHJpYnV0ZSBvZiBhbiBlbGVtZW50LCBhbmQgbm90IG1lcmVseSBieSBjb3VudGluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBkZXNlbGVjdEJ5SW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoIShhd2FpdCB0aGlzLmlzTXVsdGlwbGUoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBvbmx5IGRlc2VsZWN0IG9wdGlvbnMgb2YgYSBtdWx0aS1zZWxlY3QnKVxuICAgIH1cblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggbmVlZHMgdG8gYmUgMCBvciBhbnkgb3RoZXIgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBsZXQgb3B0aW9ucyA9IGF3YWl0IHRoaXMuZWxlbWVudC5maW5kRWxlbWVudHMoQnkudGFnTmFtZSgnb3B0aW9uJykpXG5cbiAgICBpZiAob3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdCBlbGVtZW50IGRvZXNuJ3QgY29udGFpbiBhbnkgb3B0aW9uIGVsZW1lbnRcIilcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sZW5ndGggLSAxIDwgaW5kZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE9wdGlvbiB3aXRoIGluZGV4IFwiJHtpbmRleH1cIiBub3QgZm91bmQuIFNlbGVjdCBlbGVtZW50IG9ubHkgY29udGFpbnMgJHtcbiAgICAgICAgICBvcHRpb25zLmxlbmd0aCAtIDFcbiAgICAgICAgfSBvcHRpb24gZWxlbWVudHNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChsZXQgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoYXdhaXQgb3B0aW9uLmdldEF0dHJpYnV0ZSgnaW5kZXgnKSkgPT09IGluZGV4LnRvU3RyaW5nKCkpIHtcbiAgICAgICAgaWYgKGF3YWl0IG9wdGlvbi5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBhd2FpdCBvcHRpb24uY2xpY2soKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB2YWx1ZSBvZiBhbiBvcHRpb24gdG8gZGVzZWxlY3RcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBkZXNlbGVjdEJ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAoIShhd2FpdCB0aGlzLmlzTXVsdGlwbGUoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBvbmx5IGRlc2VsZWN0IG9wdGlvbnMgb2YgYSBtdWx0aS1zZWxlY3QnKVxuICAgIH1cblxuICAgIGxldCBtYXRjaGVkID0gZmFsc2VcblxuICAgIGxldCBvcHRpb25zID0gYXdhaXQgdGhpcy5lbGVtZW50LmZpbmRFbGVtZW50cyh7XG4gICAgICBjc3M6ICdvcHRpb25bdmFsdWUgPScgKyBlc2NhcGVDc3ModmFsdWUpICsgJ10nLFxuICAgIH0pXG5cbiAgICBmb3IgKGxldCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgaWYgKGF3YWl0IG9wdGlvbi5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgYXdhaXQgb3B0aW9uLmNsaWNrKClcbiAgICAgIH1cbiAgICAgIG1hdGNoZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBsb2NhdGUgb3B0aW9uIHdpdGggdmFsdWU6ICR7dmFsdWV9YClcbiAgICB9XG4gIH1cblxuICBhc3luYyBzZXRTZWxlY3RlZChvcHRpb24pIHtcbiAgICBpZiAoIShhd2FpdCBvcHRpb24uaXNTZWxlY3RlZCgpKSkge1xuICAgICAgaWYgKCEoYXdhaXQgb3B0aW9uLmlzRW5hYmxlZCgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3IuVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcbiAgICAgICAgICBgWW91IG1heSBub3Qgc2VsZWN0IGEgZGlzYWJsZWQgb3B0aW9uYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBhd2FpdCBvcHRpb24uY2xpY2soKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgU2VsZWN0IH1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IENhcGFiaWxpdGllcyB9ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXRpZXMnKVxuXG4vKipcbiAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGEgc2luZ2xlIFdlYkRyaXZlciBzZXNzaW9uLlxuICovXG5jbGFzcyBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgc2Vzc2lvbiBJRC5cbiAgICogQHBhcmFtIHshLi9jYXBhYmlsaXRpZXMuQ2FwYWJpbGl0aWVzfSBjYXBhYmlsaXRpZXNcbiAgICogICAgIFRoZSBzZXNzaW9uIGNhcGFiaWxpdGllcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlkLCBjYXBhYmlsaXRpZXMpIHtcbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmlkXyA9IGlkXG5cbiAgICAvKiogQHByaXZhdGUgeyFDYXBhYmlsaXRpZXN9ICovXG4gICAgdGhpcy5jYXBzXyA9XG4gICAgICBjYXBhYmlsaXRpZXMgaW5zdGFuY2VvZiBDYXBhYmlsaXRpZXNcbiAgICAgICAgPyAvKiogQHR5cGUgeyFDYXBhYmlsaXRpZXN9ICovIChjYXBhYmlsaXRpZXMpXG4gICAgICAgIDogbmV3IENhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXMpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGlzIHNlc3Npb24ncyBJRC5cbiAgICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLmlkX1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFDYXBhYmlsaXRpZXN9IFRoaXMgc2Vzc2lvbidzIGNhcGFiaWxpdGllcy5cbiAgICovXG4gIGdldENhcGFiaWxpdGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBzX1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBjYXBhYmlsaXR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBjYXBhYmlsaXR5IHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgY2FwYWJpbGl0eSB2YWx1ZS5cbiAgICovXG4gIGdldENhcGFiaWxpdHkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2Fwc18uZ2V0KGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LCB3aGljaCBpcyBqdXN0IHRoZSBzdHJpbmdcbiAgICogc2Vzc2lvbiBJRC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFNlc3Npb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SWQoKVxuICB9XG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7IFNlc3Npb24gfVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEZWZpbmVzIHdlbGwta25vd24gc3ltYm9scyB1c2VkIHdpdGhpbiB0aGUgc2VsZW5pdW0td2ViZHJpdmVyXG4gKiBsaWJyYXJ5LlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVGhlIHNlcmlhbGl6ZSBzeW1ib2wgc3BlY2lmaWVzIGEgbWV0aG9kIHRoYXQgcmV0dXJucyBhbiBvYmplY3QncyBzZXJpYWxpemVkXG4gICAqIHJlcHJlc2VudGF0aW9uLiBJZiBhbiBvYmplY3QncyBzZXJpYWxpemVkIGZvcm0gaXMgbm90IGltbWVkaWF0ZWx5XG4gICAqIGF2YWlsYWJsZSwgdGhlIHNlcmlhbGl6ZSBtZXRob2Qgd2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiB3aXRoIHRoZSBzZXJpYWxpemVkIGZvcm0uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZGVzY3JpYmVkIG1ldGhvZCBpcyBhbmFsb2dvdXMgdG8gb2JqZWN0cyB0aGF0IGRlZmluZSBhXG4gICAqIGB0b0pTT04oKWAgbWV0aG9kLCBleGNlcHQgdGhlIHNlcmlhbGl6ZWQgcmVzdWx0IG1heSBiZSBhIHByb21pc2UsIG9yXG4gICAqIGFub3RoZXIgb2JqZWN0IHdpdGggYSBwcm9taXNlZCBwcm9wZXJ0eS5cbiAgICovXG4gIHNlcmlhbGl6ZTogU3ltYm9sKCdzZXJpYWxpemUnKSxcbn1cbiIsIi8vIExpY2Vuc2VkIHRvIHRoZSBTb2Z0d2FyZSBGcmVlZG9tIENvbnNlcnZhbmN5IChTRkMpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgU0ZDIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEZWZpbmVzIGNvbW1vbiBjb25kaXRpb25zIGZvciB1c2Ugd2l0aFxuICoge0BsaW5rIHdlYmRyaXZlci5XZWJEcml2ZXIjd2FpdCBXZWJEcml2ZXIgd2FpdH0uXG4gKlxuICogU2FtcGxlIHVzYWdlOlxuICpcbiAqICAgICBkcml2ZXIuZ2V0KCdodHRwOi8vd3d3Lmdvb2dsZS5jb20vbmNyJyk7XG4gKlxuICogICAgIHZhciBxdWVyeSA9IGRyaXZlci53YWl0KHVudGlsLmVsZW1lbnRMb2NhdGVkKEJ5Lm5hbWUoJ3EnKSkpO1xuICogICAgIHF1ZXJ5LnNlbmRLZXlzKCd3ZWJkcml2ZXJcXG4nKTtcbiAqXG4gKiAgICAgZHJpdmVyLndhaXQodW50aWwudGl0bGVJcygnd2ViZHJpdmVyIC0gR29vZ2xlIFNlYXJjaCcpKTtcbiAqXG4gKiBUbyBkZWZpbmUgYSBjdXN0b20gY29uZGl0aW9uLCBzaW1wbHkgY2FsbCBXZWJEcml2ZXIud2FpdCB3aXRoIGEgZnVuY3Rpb25cbiAqIHRoYXQgd2lsbCBldmVudHVhbGx5IHJldHVybiBhIHRydXRoeS12YWx1ZSAobmVpdGhlciBudWxsLCB1bmRlZmluZWQsIGZhbHNlLFxuICogMCwgb3IgdGhlIGVtcHR5IHN0cmluZyk6XG4gKlxuICogICAgIGRyaXZlci53YWl0KGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIGRyaXZlci5nZXRUaXRsZSgpLnRoZW4oZnVuY3Rpb24odGl0bGUpIHtcbiAqICAgICAgICAgcmV0dXJuIHRpdGxlID09PSAnd2ViZHJpdmVyIC0gR29vZ2xlIFNlYXJjaCc7XG4gKiAgICAgICB9KTtcbiAqICAgICB9LCAxMDAwKTtcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYnkgPSByZXF1aXJlKCcuL2J5JylcbmNvbnN0IGVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpXG5jb25zdCB3ZWJkcml2ZXIgPSByZXF1aXJlKCcuL3dlYmRyaXZlcicpLFxuICBDb25kaXRpb24gPSB3ZWJkcml2ZXIuQ29uZGl0aW9uLFxuICBXZWJFbGVtZW50Q29uZGl0aW9uID0gd2ViZHJpdmVyLldlYkVsZW1lbnRDb25kaXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IHVudGlsIHRoZSBpbnB1dCBkcml2ZXIgaXMgYWJsZSB0byBzd2l0Y2hcbiAqIHRvIHRoZSBkZXNpZ25hdGVkIGZyYW1lLiBUaGUgdGFyZ2V0IGZyYW1lIG1heSBiZSBzcGVjaWZpZWQgYXNcbiAqXG4gKiAxLiBhIG51bWVyaWMgaW5kZXggaW50b1xuICogICAgIFt3aW5kb3cuZnJhbWVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93LmZyYW1lcylcbiAqICAgICBmb3IgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmcmFtZS5cbiAqIDIuIGEge0BsaW5rIC4vd2ViZHJpdmVyLldlYkVsZW1lbnR9LCB3aGljaCBtdXN0IHJlZmVyZW5jZSBhIEZSQU1FIG9yIElGUkFNRVxuICogICAgIGVsZW1lbnQgb24gdGhlIGN1cnJlbnQgcGFnZS5cbiAqIDMuIGEgbG9jYXRvciB3aGljaCBtYXkgYmUgdXNlZCB0byBmaXJzdCBsb2NhdGUgYSBGUkFNRSBvciBJRlJBTUUgb24gdGhlXG4gKiAgICAgY3VycmVudCBwYWdlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHN3aXRjaCB0byBpdC5cbiAqXG4gKiBVcG9uIHN1Y2Nlc3NmdWwgcmVzb2x1dGlvbiBvZiB0aGlzIGNvbmRpdGlvbiwgdGhlIGRyaXZlciB3aWxsIGJlIGxlZnRcbiAqIGZvY3VzZWQgb24gdGhlIG5ldyBmcmFtZS5cbiAqXG4gKiBAcGFyYW0geyEobnVtYmVyfC4vd2ViZHJpdmVyLldlYkVsZW1lbnR8Qnl8XG4gKiAgICAgICAgICAgZnVuY3Rpb24oIS4vd2ViZHJpdmVyLldlYkRyaXZlcik6ICEuL3dlYmRyaXZlci5XZWJFbGVtZW50KX0gZnJhbWVcbiAqICAgICBUaGUgZnJhbWUgaWRlbnRpZmllci5cbiAqIEByZXR1cm4geyFDb25kaXRpb248Ym9vbGVhbj59IEEgbmV3IGNvbmRpdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWJsZVRvU3dpdGNoVG9GcmFtZShmcmFtZSkge1xuICBsZXQgY29uZGl0aW9uXG4gIGlmICh0eXBlb2YgZnJhbWUgPT09ICdudW1iZXInIHx8IGZyYW1lIGluc3RhbmNlb2Ygd2ViZHJpdmVyLldlYkVsZW1lbnQpIHtcbiAgICBjb25kaXRpb24gPSAoZHJpdmVyKSA9PiBhdHRlbXB0VG9Td2l0Y2hGcmFtZXMoZHJpdmVyLCBmcmFtZSlcbiAgfSBlbHNlIHtcbiAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAoZHJpdmVyKSB7XG4gICAgICBsZXQgbG9jYXRvciA9IC8qKiBAdHlwZSB7IShCeXxGdW5jdGlvbil9ICovIChmcmFtZSlcbiAgICAgIHJldHVybiBkcml2ZXIuZmluZEVsZW1lbnRzKGxvY2F0b3IpLnRoZW4oZnVuY3Rpb24gKGVscykge1xuICAgICAgICBpZiAoZWxzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBhdHRlbXB0VG9Td2l0Y2hGcmFtZXMoZHJpdmVyLCBlbHNbMF0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb25kaXRpb24oJ3RvIGJlIGFibGUgdG8gc3dpdGNoIHRvIGZyYW1lJywgY29uZGl0aW9uKVxuXG4gIGZ1bmN0aW9uIGF0dGVtcHRUb1N3aXRjaEZyYW1lcyhkcml2ZXIsIGZyYW1lKSB7XG4gICAgcmV0dXJuIGRyaXZlclxuICAgICAgLnN3aXRjaFRvKClcbiAgICAgIC5mcmFtZShmcmFtZSlcbiAgICAgIC50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgZXJyb3IuTm9TdWNoRnJhbWVFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25kaXRpb24gdGhhdCB3YWl0cyBmb3IgYW4gYWxlcnQgdG8gYmUgb3BlbmVkLiBVcG9uIHN1Y2Nlc3MsIHRoZVxuICogcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSBoYW5kbGUgZm9yIHRoZSBvcGVuZWQgYWxlcnQuXG4gKlxuICogQHJldHVybiB7IUNvbmRpdGlvbjwhLi93ZWJkcml2ZXIuQWxlcnQ+fSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWxlcnRJc1ByZXNlbnQoKSB7XG4gIHJldHVybiBuZXcgQ29uZGl0aW9uKCdmb3IgYWxlcnQgdG8gYmUgcHJlc2VudCcsIGZ1bmN0aW9uIChkcml2ZXIpIHtcbiAgICByZXR1cm4gZHJpdmVyXG4gICAgICAuc3dpdGNoVG8oKVxuICAgICAgLmFsZXJ0KClcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIShcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBlcnJvci5Ob1N1Y2hBbGVydEVycm9yIHx8XG4gICAgICAgICAgICAvLyBYWFg6IFdvcmthcm91bmQgZm9yIEdlY2tvRHJpdmVyIGVycm9yIGBUeXBlRXJyb3I6IGNhbid0IGNvbnZlcnQgbnVsbFxuICAgICAgICAgICAgLy8gdG8gb2JqZWN0YC4gRm9yIG1vcmUgZGV0YWlscywgc2VlXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vU2VsZW5pdW1IUS9zZWxlbml1bS9wdWxsLzIxMzdcbiAgICAgICAgICAgIChlIGluc3RhbmNlb2YgZXJyb3IuV2ViRHJpdmVyRXJyb3IgJiZcbiAgICAgICAgICAgICAgZS5tZXNzYWdlID09PSBgY2FuJ3QgY29udmVydCBudWxsIHRvIG9iamVjdGApXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmRpdGlvbiB0aGF0IHdpbGwgd2FpdCBmb3IgdGhlIGN1cnJlbnQgcGFnZSdzIHRpdGxlIHRvIG1hdGNoIHRoZVxuICogZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIFRoZSBleHBlY3RlZCBwYWdlIHRpdGxlLlxuICogQHJldHVybiB7IUNvbmRpdGlvbjxib29sZWFuPn0gVGhlIG5ldyBjb25kaXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRpdGxlSXModGl0bGUpIHtcbiAgcmV0dXJuIG5ldyBDb25kaXRpb24oJ2ZvciB0aXRsZSB0byBiZSAnICsgSlNPTi5zdHJpbmdpZnkodGl0bGUpLCBmdW5jdGlvbiAoXG4gICAgZHJpdmVyXG4gICkge1xuICAgIHJldHVybiBkcml2ZXIuZ2V0VGl0bGUoKS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCA9PT0gdGl0bGVcbiAgICB9KVxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25kaXRpb24gdGhhdCB3aWxsIHdhaXQgZm9yIHRoZSBjdXJyZW50IHBhZ2UncyB0aXRsZSB0byBjb250YWluXG4gKiB0aGUgZ2l2ZW4gc3Vic3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzdHIgVGhlIHN1YnN0cmluZyB0aGF0IHNob3VsZCBiZSBwcmVzZW50IGluIHRoZSBwYWdlXG4gKiAgICAgdGl0bGUuXG4gKiBAcmV0dXJuIHshQ29uZGl0aW9uPGJvb2xlYW4+fSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGl0bGVDb250YWlucyhzdWJzdHIpIHtcbiAgcmV0dXJuIG5ldyBDb25kaXRpb24oXG4gICAgJ2ZvciB0aXRsZSB0byBjb250YWluICcgKyBKU09OLnN0cmluZ2lmeShzdWJzdHIpLFxuICAgIGZ1bmN0aW9uIChkcml2ZXIpIHtcbiAgICAgIHJldHVybiBkcml2ZXIuZ2V0VGl0bGUoKS50aGVuKGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGl0bGUuaW5kZXhPZihzdWJzdHIpICE9PSAtMVxuICAgICAgfSlcbiAgICB9XG4gIClcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IGZvciB0aGUgY3VycmVudCBwYWdlJ3MgdGl0bGUgdG8gbWF0Y2ggdGhlXG4gKiBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHshUmVnRXhwfSByZWdleCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHRlc3QgYWdhaW5zdC5cbiAqIEByZXR1cm4geyFDb25kaXRpb248Ym9vbGVhbj59IFRoZSBuZXcgY29uZGl0aW9uLlxuICovXG5mdW5jdGlvbiB0aXRsZU1hdGNoZXMocmVnZXgpIHtcbiAgcmV0dXJuIG5ldyBDb25kaXRpb24oJ2ZvciB0aXRsZSB0byBtYXRjaCAnICsgcmVnZXgsIGZ1bmN0aW9uIChkcml2ZXIpIHtcbiAgICByZXR1cm4gZHJpdmVyLmdldFRpdGxlKCkudGhlbihmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgIHJldHVybiByZWdleC50ZXN0KHRpdGxlKVxuICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmRpdGlvbiB0aGF0IHdpbGwgd2FpdCBmb3IgdGhlIGN1cnJlbnQgcGFnZSdzIHVybCB0byBtYXRjaCB0aGVcbiAqIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGV4cGVjdGVkIHBhZ2UgdXJsLlxuICogQHJldHVybiB7IUNvbmRpdGlvbjxib29sZWFuPn0gVGhlIG5ldyBjb25kaXRpb24uXG4gKi9cbmZ1bmN0aW9uIHVybElzKHVybCkge1xuICByZXR1cm4gbmV3IENvbmRpdGlvbignZm9yIFVSTCB0byBiZSAnICsgSlNPTi5zdHJpbmdpZnkodXJsKSwgZnVuY3Rpb24gKFxuICAgIGRyaXZlclxuICApIHtcbiAgICByZXR1cm4gZHJpdmVyLmdldEN1cnJlbnRVcmwoKS50aGVuKGZ1bmN0aW9uICh1KSB7XG4gICAgICByZXR1cm4gdSA9PT0gdXJsXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IGZvciB0aGUgY3VycmVudCBwYWdlJ3MgdXJsIHRvIGNvbnRhaW5cbiAqIHRoZSBnaXZlbiBzdWJzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN1YnN0clVybCBUaGUgc3Vic3RyaW5nIHRoYXQgc2hvdWxkIGJlIHByZXNlbnQgaW4gdGhlIGN1cnJlbnRcbiAqICAgICBVUkwuXG4gKiBAcmV0dXJuIHshQ29uZGl0aW9uPGJvb2xlYW4+fSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqL1xuZnVuY3Rpb24gdXJsQ29udGFpbnMoc3Vic3RyVXJsKSB7XG4gIHJldHVybiBuZXcgQ29uZGl0aW9uKFxuICAgICdmb3IgVVJMIHRvIGNvbnRhaW4gJyArIEpTT04uc3RyaW5naWZ5KHN1YnN0clVybCksXG4gICAgZnVuY3Rpb24gKGRyaXZlcikge1xuICAgICAgcmV0dXJuIGRyaXZlci5nZXRDdXJyZW50VXJsKCkudGhlbihmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiB1cmwgJiYgdXJsLmluY2x1ZGVzKHN1YnN0clVybClcbiAgICAgIH0pXG4gICAgfVxuICApXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmRpdGlvbiB0aGF0IHdpbGwgd2FpdCBmb3IgdGhlIGN1cnJlbnQgcGFnZSdzIHVybCB0byBtYXRjaCB0aGVcbiAqIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0geyFSZWdFeHB9IHJlZ2V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gdGVzdCBhZ2FpbnN0LlxuICogQHJldHVybiB7IUNvbmRpdGlvbjxib29sZWFuPn0gVGhlIG5ldyBjb25kaXRpb24uXG4gKi9cbmZ1bmN0aW9uIHVybE1hdGNoZXMocmVnZXgpIHtcbiAgcmV0dXJuIG5ldyBDb25kaXRpb24oJ2ZvciBVUkwgdG8gbWF0Y2ggJyArIHJlZ2V4LCBmdW5jdGlvbiAoZHJpdmVyKSB7XG4gICAgcmV0dXJuIGRyaXZlci5nZXRDdXJyZW50VXJsKCkudGhlbihmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gcmVnZXgudGVzdCh1cmwpXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCBsb29wIHVudGlsIGFuIGVsZW1lbnQgaXNcbiAqIHtAbGluayAuL3dlYmRyaXZlci5XZWJEcml2ZXIjZmluZEVsZW1lbnQgZm91bmR9IHdpdGggdGhlIGdpdmVuIGxvY2F0b3IuXG4gKlxuICogQHBhcmFtIHshKEJ5fEZ1bmN0aW9uKX0gbG9jYXRvciBUaGUgbG9jYXRvciB0byB1c2UuXG4gKiBAcmV0dXJuIHshV2ViRWxlbWVudENvbmRpdGlvbn0gVGhlIG5ldyBjb25kaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRMb2NhdGVkKGxvY2F0b3IpIHtcbiAgbG9jYXRvciA9IGJ5LmNoZWNrZWRMb2NhdG9yKGxvY2F0b3IpXG4gIGxldCBsb2NhdG9yU3RyID1cbiAgICB0eXBlb2YgbG9jYXRvciA9PT0gJ2Z1bmN0aW9uJyA/ICdieSBmdW5jdGlvbigpJyA6IGxvY2F0b3IgKyAnJ1xuICByZXR1cm4gbmV3IFdlYkVsZW1lbnRDb25kaXRpb24oXG4gICAgJ2ZvciBlbGVtZW50IHRvIGJlIGxvY2F0ZWQgJyArIGxvY2F0b3JTdHIsXG4gICAgZnVuY3Rpb24gKGRyaXZlcikge1xuICAgICAgcmV0dXJuIGRyaXZlci5maW5kRWxlbWVudHMobG9jYXRvcikudGhlbihmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdXG4gICAgICB9KVxuICAgIH1cbiAgKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25kaXRpb24gdGhhdCB3aWxsIGxvb3AgdW50aWwgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaXNcbiAqIHtAbGluayAuL3dlYmRyaXZlci5XZWJEcml2ZXIjZmluZEVsZW1lbnQgZm91bmR9IHdpdGggdGhlIGdpdmVuIGxvY2F0b3IuXG4gKlxuICogQHBhcmFtIHshKEJ5fEZ1bmN0aW9uKX0gbG9jYXRvciBUaGUgbG9jYXRvciB0byB1c2UuXG4gKiBAcmV0dXJuIHshQ29uZGl0aW9uPCFBcnJheTwhLi93ZWJkcml2ZXIuV2ViRWxlbWVudD4+fSBUaGUgbmV3XG4gKiAgICAgY29uZGl0aW9uLlxuICovXG5mdW5jdGlvbiBlbGVtZW50c0xvY2F0ZWQobG9jYXRvcikge1xuICBsb2NhdG9yID0gYnkuY2hlY2tlZExvY2F0b3IobG9jYXRvcilcbiAgbGV0IGxvY2F0b3JTdHIgPVxuICAgIHR5cGVvZiBsb2NhdG9yID09PSAnZnVuY3Rpb24nID8gJ2J5IGZ1bmN0aW9uKCknIDogbG9jYXRvciArICcnXG4gIHJldHVybiBuZXcgQ29uZGl0aW9uKFxuICAgICdmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQgdG8gYmUgbG9jYXRlZCAnICsgbG9jYXRvclN0cixcbiAgICBmdW5jdGlvbiAoZHJpdmVyKSB7XG4gICAgICByZXR1cm4gZHJpdmVyLmZpbmRFbGVtZW50cyhsb2NhdG9yKS50aGVuKGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubGVuZ3RoID4gMCA/IGVsZW1lbnRzIDogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIClcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCB0byBiZWNvbWUgc3RhbGUuIEFuXG4gKiBlbGVtZW50IGlzIGNvbnNpZGVyZWQgc3RhbGUgb25jZSBpdCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSwgb3IgYSBuZXcgcGFnZVxuICogaGFzIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0geyEuL3dlYmRyaXZlci5XZWJFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlY29tZSBzdGFsZS5cbiAqIEByZXR1cm4geyFDb25kaXRpb248Ym9vbGVhbj59IFRoZSBuZXcgY29uZGl0aW9uLlxuICovXG5mdW5jdGlvbiBzdGFsZW5lc3NPZihlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgQ29uZGl0aW9uKCdlbGVtZW50IHRvIGJlY29tZSBzdGFsZScsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRUYWdOYW1lKCkudGhlbihcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBlcnJvci5TdGFsZUVsZW1lbnRSZWZlcmVuY2VFcnJvcikge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIClcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCB0byBiZWNvbWUgdmlzaWJsZS5cbiAqXG4gKiBAcGFyYW0geyEuL3dlYmRyaXZlci5XZWJFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHshV2ViRWxlbWVudENvbmRpdGlvbn0gVGhlIG5ldyBjb25kaXRpb24uXG4gKiBAc2VlIC4vd2ViZHJpdmVyLldlYkRyaXZlciNpc0Rpc3BsYXllZFxuICovXG5mdW5jdGlvbiBlbGVtZW50SXNWaXNpYmxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBXZWJFbGVtZW50Q29uZGl0aW9uKCd1bnRpbCBlbGVtZW50IGlzIHZpc2libGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaXNEaXNwbGF5ZWQoKS50aGVuKCh2KSA9PiAodiA/IGVsZW1lbnQgOiBudWxsKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCB0byBiZSBpbiB0aGUgRE9NLFxuICogeWV0IG5vdCB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwYXJhbSB7IS4vd2ViZHJpdmVyLldlYkVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdGVzdC5cbiAqIEByZXR1cm4geyFXZWJFbGVtZW50Q29uZGl0aW9ufSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqIEBzZWUgLi93ZWJkcml2ZXIuV2ViRHJpdmVyI2lzRGlzcGxheWVkXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRJc05vdFZpc2libGUoZWxlbWVudCkge1xuICByZXR1cm4gbmV3IFdlYkVsZW1lbnRDb25kaXRpb24oJ3VudGlsIGVsZW1lbnQgaXMgbm90IHZpc2libGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaXNEaXNwbGF5ZWQoKS50aGVuKCh2KSA9PiAodiA/IG51bGwgOiBlbGVtZW50KSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCB0byBiZSBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7IS4vd2ViZHJpdmVyLldlYkVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdGVzdC5cbiAqIEByZXR1cm4geyFXZWJFbGVtZW50Q29uZGl0aW9ufSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqIEBzZWUgd2ViZHJpdmVyLldlYkRyaXZlciNpc0VuYWJsZWRcbiAqL1xuZnVuY3Rpb24gZWxlbWVudElzRW5hYmxlZChlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgV2ViRWxlbWVudENvbmRpdGlvbigndW50aWwgZWxlbWVudCBpcyBlbmFibGVkJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbGVtZW50LmlzRW5hYmxlZCgpLnRoZW4oKHYpID0+ICh2ID8gZWxlbWVudCA6IG51bGwpKVxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25kaXRpb24gdGhhdCB3aWxsIHdhaXQgZm9yIHRoZSBnaXZlbiBlbGVtZW50IHRvIGJlIGRpc2FibGVkLlxuICpcbiAqIEBwYXJhbSB7IS4vd2ViZHJpdmVyLldlYkVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdGVzdC5cbiAqIEByZXR1cm4geyFXZWJFbGVtZW50Q29uZGl0aW9ufSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqIEBzZWUgd2ViZHJpdmVyLldlYkRyaXZlciNpc0VuYWJsZWRcbiAqL1xuZnVuY3Rpb24gZWxlbWVudElzRGlzYWJsZWQoZWxlbWVudCkge1xuICByZXR1cm4gbmV3IFdlYkVsZW1lbnRDb25kaXRpb24oJ3VudGlsIGVsZW1lbnQgaXMgZGlzYWJsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaXNFbmFibGVkKCkudGhlbigodikgPT4gKHYgPyBudWxsIDogZWxlbWVudCkpXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmRpdGlvbiB0aGF0IHdpbGwgd2FpdCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgdG8gYmUgc2VsZWN0ZWQuXG4gKiBAcGFyYW0geyEuL3dlYmRyaXZlci5XZWJFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHshV2ViRWxlbWVudENvbmRpdGlvbn0gVGhlIG5ldyBjb25kaXRpb24uXG4gKiBAc2VlIHdlYmRyaXZlci5XZWJEcml2ZXIjaXNTZWxlY3RlZFxuICovXG5mdW5jdGlvbiBlbGVtZW50SXNTZWxlY3RlZChlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgV2ViRWxlbWVudENvbmRpdGlvbigndW50aWwgZWxlbWVudCBpcyBzZWxlY3RlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5pc1NlbGVjdGVkKCkudGhlbigodikgPT4gKHYgPyBlbGVtZW50IDogbnVsbCkpXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmRpdGlvbiB0aGF0IHdpbGwgd2FpdCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgdG8gYmUgZGVzZWxlY3RlZC5cbiAqXG4gKiBAcGFyYW0geyEuL3dlYmRyaXZlci5XZWJFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHshV2ViRWxlbWVudENvbmRpdGlvbn0gVGhlIG5ldyBjb25kaXRpb24uXG4gKiBAc2VlIHdlYmRyaXZlci5XZWJEcml2ZXIjaXNTZWxlY3RlZFxuICovXG5mdW5jdGlvbiBlbGVtZW50SXNOb3RTZWxlY3RlZChlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgV2ViRWxlbWVudENvbmRpdGlvbigndW50aWwgZWxlbWVudCBpcyBub3Qgc2VsZWN0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaXNTZWxlY3RlZCgpLnRoZW4oKHYpID0+ICh2ID8gbnVsbCA6IGVsZW1lbnQpKVxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25kaXRpb24gdGhhdCB3aWxsIHdhaXQgZm9yIHRoZSBnaXZlbiBlbGVtZW50J3NcbiAqIHtAbGluayB3ZWJkcml2ZXIuV2ViRHJpdmVyI2dldFRleHQgdmlzaWJsZSB0ZXh0fSB0byBtYXRjaCB0aGUgZ2l2ZW5cbiAqIHtAY29kZSB0ZXh0fSBleGFjdGx5LlxuICpcbiAqIEBwYXJhbSB7IS4vd2ViZHJpdmVyLldlYkVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdGVzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBleHBlY3RlZCB0ZXh0LlxuICogQHJldHVybiB7IVdlYkVsZW1lbnRDb25kaXRpb259IFRoZSBuZXcgY29uZGl0aW9uLlxuICogQHNlZSB3ZWJkcml2ZXIuV2ViRHJpdmVyI2dldFRleHRcbiAqL1xuZnVuY3Rpb24gZWxlbWVudFRleHRJcyhlbGVtZW50LCB0ZXh0KSB7XG4gIHJldHVybiBuZXcgV2ViRWxlbWVudENvbmRpdGlvbigndW50aWwgZWxlbWVudCB0ZXh0IGlzJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbGVtZW50LmdldFRleHQoKS50aGVuKCh0KSA9PiAodCA9PT0gdGV4dCA/IGVsZW1lbnQgOiBudWxsKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIHRoYXQgd2lsbCB3YWl0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCdzXG4gKiB7QGxpbmsgd2ViZHJpdmVyLldlYkRyaXZlciNnZXRUZXh0IHZpc2libGUgdGV4dH0gdG8gY29udGFpbiB0aGUgZ2l2ZW5cbiAqIHN1YnN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyEuL3dlYmRyaXZlci5XZWJFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3Vic3RyIFRoZSBzdWJzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm4geyFXZWJFbGVtZW50Q29uZGl0aW9ufSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqIEBzZWUgd2ViZHJpdmVyLldlYkRyaXZlciNnZXRUZXh0XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRUZXh0Q29udGFpbnMoZWxlbWVudCwgc3Vic3RyKSB7XG4gIHJldHVybiBuZXcgV2ViRWxlbWVudENvbmRpdGlvbigndW50aWwgZWxlbWVudCB0ZXh0IGNvbnRhaW5zJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbGVtZW50XG4gICAgICAuZ2V0VGV4dCgpXG4gICAgICAudGhlbigodCkgPT4gKHQuaW5kZXhPZihzdWJzdHIpICE9IC0xID8gZWxlbWVudCA6IG51bGwpKVxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25kaXRpb24gdGhhdCB3aWxsIHdhaXQgZm9yIHRoZSBnaXZlbiBlbGVtZW50J3NcbiAqIHtAbGluayB3ZWJkcml2ZXIuV2ViRHJpdmVyI2dldFRleHQgdmlzaWJsZSB0ZXh0fSB0byBtYXRjaCBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHshLi93ZWJkcml2ZXIuV2ViRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB0ZXN0LlxuICogQHBhcmFtIHshUmVnRXhwfSByZWdleCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHRlc3QgYWdhaW5zdC5cbiAqIEByZXR1cm4geyFXZWJFbGVtZW50Q29uZGl0aW9ufSBUaGUgbmV3IGNvbmRpdGlvbi5cbiAqIEBzZWUgd2ViZHJpdmVyLldlYkRyaXZlciNnZXRUZXh0XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRUZXh0TWF0Y2hlcyhlbGVtZW50LCByZWdleCkge1xuICByZXR1cm4gbmV3IFdlYkVsZW1lbnRDb25kaXRpb24oJ3VudGlsIGVsZW1lbnQgdGV4dCBtYXRjaGVzJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbGVtZW50LmdldFRleHQoKS50aGVuKCh0KSA9PiAocmVnZXgudGVzdCh0KSA/IGVsZW1lbnQgOiBudWxsKSlcbiAgfSlcbn1cblxuLy8gUFVCTElDIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZWxlbWVudFRleHRNYXRjaGVzLFxuICBlbGVtZW50VGV4dENvbnRhaW5zLFxuICBlbGVtZW50VGV4dElzLFxuICBlbGVtZW50SXNOb3RTZWxlY3RlZCxcbiAgZWxlbWVudElzU2VsZWN0ZWQsXG4gIGVsZW1lbnRJc0Rpc2FibGVkLFxuICBhYmxlVG9Td2l0Y2hUb0ZyYW1lLFxuICBlbGVtZW50SXNFbmFibGVkLFxuICBlbGVtZW50SXNOb3RWaXNpYmxlLFxuICBlbGVtZW50SXNWaXNpYmxlLFxuICBzdGFsZW5lc3NPZixcbiAgZWxlbWVudHNMb2NhdGVkLFxuICBlbGVtZW50TG9jYXRlZCxcbiAgdXJsTWF0Y2hlcyxcbiAgdXJsQ29udGFpbnMsXG4gIHVybElzLFxuICB0aXRsZU1hdGNoZXMsXG4gIHRpdGxlQ29udGFpbnMsXG4gIGFsZXJ0SXNQcmVzZW50LFxuICB0aXRsZUlzLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEge0Bjb2RlIHZhbHVlfSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhbiBvYmplY3QuXG4gKiBAcGFyYW0gez99IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEge0Bjb2RlIHZhbHVlfSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHByb21pc2UuXG4gKiBBbnkgb2JqZWN0IHdob3NlIFwidGhlblwiIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24gd2lsbCBiZSBjb25zaWRlcmVkIGEgcHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0gez99IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdmFsdWUgaXMgYSBwcm9taXNlLlxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYXJyYXkgbm90YXRpb24gc28gdGhlIENsb3N1cmUgY29tcGlsZXIgZG9lcyBub3Qgb2JmdXNjYXRlIGF3YXkgb3VyXG4gICAgLy8gY29udHJhY3QuXG4gICAgcmV0dXJuIChcbiAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVsndGhlbiddID09PSAnZnVuY3Rpb24nXG4gICAgKVxuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09iamVjdCxcbiAgaXNQcm9taXNlLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUHJvdG9jb2wgZm9yIHZpcnR1YWwgYXV0aGVudGljYXRvcnNcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFByb3RvY29sID0ge1xuICBDVEFQMjogJ2N0YXAyJyxcbiAgVTJGOiAnY3RhcDEvdTJmJyxcbn1cblxuLyoqXG4gKiBBdXRoZW50aWNhdG9yVHJhbnNwb3J0IHZhbHVlc1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVHJhbnNwb3J0ID0ge1xuICBCTEU6ICdibGUnLFxuICBVU0I6ICd1c2InLFxuICBORkM6ICduZmMnLFxuICBJTlRFUk5BTDogJ2ludGVybmFsJyxcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgY3JlYXRpb24gb2YgdmlydHVhbCBhdXRoZW50aWNhdG9ycy5cbiAqIEBzZWUgaHR0cDovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tYXV0b21hdGlvblxuICovXG5jbGFzcyBWaXJ0dWFsQXV0aGVudGljYXRvck9wdGlvbnMge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgdG8gaW5pdGlhbGlzZSBWaXJ0dWFsQXV0aGVudGljYXRvck9wdGlvbnMgb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBQcm90b2NvbFsnQ1RBUDInXVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IFRyYW5zcG9ydFsnVVNCJ11cbiAgICB0aGlzLl9oYXNSZXNpZGVudEtleSA9IGZhbHNlXG4gICAgdGhpcy5faGFzVXNlclZlcmlmaWNhdGlvbiA9IGZhbHNlXG4gICAgdGhpcy5faXNVc2VyQ29uc2VudGluZyA9IHRydWVcbiAgICB0aGlzLl9pc1VzZXJWZXJpZmllZCA9IGZhbHNlXG4gIH1cblxuICBnZXRQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2xcbiAgfVxuXG4gIHNldFByb3RvY29sKHByb3RvY29sKSB7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBwcm90b2NvbFxuICB9XG5cbiAgZ2V0VHJhbnNwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRcbiAgfVxuXG4gIHNldFRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRcbiAgfVxuXG4gIGdldEhhc1Jlc2lkZW50S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNSZXNpZGVudEtleVxuICB9XG5cbiAgc2V0SGFzUmVzaWRlbnRLZXkodmFsdWUpIHtcbiAgICB0aGlzLl9oYXNSZXNpZGVudEtleSA9IHZhbHVlXG4gIH1cblxuICBnZXRIYXNVc2VyVmVyaWZpY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNVc2VyVmVyaWZpY2F0aW9uXG4gIH1cblxuICBzZXRIYXNVc2VyVmVyaWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5faGFzVXNlclZlcmlmaWNhdGlvbiA9IHZhbHVlXG4gIH1cblxuICBnZXRJc1VzZXJDb25zZW50aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VzZXJDb25zZW50aW5nXG4gIH1cblxuICBzZXRJc1VzZXJDb25zZW50aW5nKHZhbHVlKSB7XG4gICAgdGhpcy5faXNVc2VyQ29uc2VudGluZyA9IHZhbHVlXG4gIH1cblxuICBnZXRJc1VzZXJWZXJpZmllZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVc2VyVmVyaWZpZWRcbiAgfVxuXG4gIHNldElzVXNlclZlcmlmaWVkKHZhbHVlKSB7XG4gICAgdGhpcy5faXNVc2VyVmVyaWZpZWQgPSB2YWx1ZVxuICB9XG5cbiAgdG9EaWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm90b2NvbDogdGhpcy5nZXRQcm90b2NvbCgpLFxuICAgICAgdHJhbnNwb3J0OiB0aGlzLmdldFRyYW5zcG9ydCgpLFxuICAgICAgaGFzUmVzaWRlbnRLZXk6IHRoaXMuZ2V0SGFzUmVzaWRlbnRLZXkoKSxcbiAgICAgIGhhc1VzZXJWZXJpZmljYXRpb246IHRoaXMuZ2V0SGFzVXNlclZlcmlmaWNhdGlvbigpLFxuICAgICAgaXNVc2VyQ29uc2VudGluZzogdGhpcy5nZXRJc1VzZXJDb25zZW50aW5nKCksXG4gICAgICBpc1VzZXJWZXJpZmllZDogdGhpcy5nZXRJc1VzZXJWZXJpZmllZCgpLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgY3JlZGVudGlhbCBzdG9yZWQgaW4gYSB2aXJ0dWFsIGF1dGhlbnRpY2F0b3IuXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jY3JlZGVudGlhbC1wYXJhbWV0ZXJzXG4gKi9cbmNsYXNzIENyZWRlbnRpYWwge1xuICBjb25zdHJ1Y3RvcihcbiAgICBjcmVkZW50aWFsSWQsXG4gICAgaXNSZXNpZGVudENyZWRlbnRpYWwsXG4gICAgcnBJZCxcbiAgICB1c2VySGFuZGxlLFxuICAgIHByaXZhdGVLZXksXG4gICAgc2lnbkNvdW50XG4gICkge1xuICAgIHRoaXMuX2lkID0gY3JlZGVudGlhbElkXG4gICAgdGhpcy5faXNSZXNpZGVudENyZWRlbnRpYWwgPSBpc1Jlc2lkZW50Q3JlZGVudGlhbFxuICAgIHRoaXMuX3JwSWQgPSBycElkXG4gICAgdGhpcy5fdXNlckhhbmRsZSA9IHVzZXJIYW5kbGVcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0gcHJpdmF0ZUtleVxuICAgIHRoaXMuX3NpZ25Db3VudCA9IHNpZ25Db3VudFxuICB9XG5cbiAgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkXG4gIH1cblxuICBpc1Jlc2lkZW50Q3JlZGVudGlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSZXNpZGVudENyZWRlbnRpYWxcbiAgfVxuXG4gIHJwSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JwSWRcbiAgfVxuXG4gIHVzZXJIYW5kbGUoKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VzZXJIYW5kbGVcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVLZXlcbiAgfVxuXG4gIHNpZ25Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbkNvdW50XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlc2lkZW50IChpLmUuIHN0YXRlbGVzcykgY3JlZGVudGlhbC5cbiAgICogQHBhcmFtIGlkIFVuaXF1ZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBycElkIFJlbHlpbmcgcGFydHkgaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHVzZXJIYW5kbGUgdXNlckhhbmRsZSBhc3NvY2lhdGVkIHRvIHRoZSBjcmVkZW50aWFsLiBNdXN0IGJlIEJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHByaXZhdGVLZXkgQmFzZTY0IGVuY29kZWQgUEtDU1xuICAgKiBAcGFyYW0gc2lnbkNvdW50IGluaXRpYWwgdmFsdWUgZm9yIGEgc2lnbmF0dXJlIGNvdW50ZXIuXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGhhcyBiZWVuIG1hZGUgc3RhdGljLiBDYWxsIGl0IHdpdGggY2xhc3MgbmFtZS4gRXhhbXBsZSwgQ3JlZGVudGlhbC5jcmVhdGVSZXNpZGVudENyZWRlbnRpYWwoKVxuICAgKiBAcmV0dXJucyBBIHJlc2lkZW50IGNyZWRlbnRpYWxcbiAgICovXG4gIGNyZWF0ZVJlc2lkZW50Q3JlZGVudGlhbChpZCwgcnBJZCwgdXNlckhhbmRsZSwgcHJpdmF0ZUtleSwgc2lnbkNvdW50KSB7XG4gICAgcmV0dXJuIG5ldyBDcmVkZW50aWFsKGlkLCB0cnVlLCBycElkLCB1c2VySGFuZGxlLCBwcml2YXRlS2V5LCBzaWduQ291bnQpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlUmVzaWRlbnRDcmVkZW50aWFsKGlkLCBycElkLCB1c2VySGFuZGxlLCBwcml2YXRlS2V5LCBzaWduQ291bnQpIHtcbiAgICByZXR1cm4gbmV3IENyZWRlbnRpYWwoaWQsIHRydWUsIHJwSWQsIHVzZXJIYW5kbGUsIHByaXZhdGVLZXksIHNpZ25Db3VudClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9uLXJlc2lkZW50IChpLmUuIHN0YXRlbGVzcykgY3JlZGVudGlhbC5cbiAgICogQHBhcmFtIGlkIFVuaXF1ZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBycElkIFJlbHlpbmcgcGFydHkgaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHByaXZhdGVLZXkgQmFzZTY0IGVuY29kZWQgUEtDU1xuICAgKiBAcGFyYW0gc2lnbkNvdW50IGluaXRpYWwgdmFsdWUgZm9yIGEgc2lnbmF0dXJlIGNvdW50ZXIuXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGhhcyBiZWVuIG1hZGUgc3RhdGljLiBDYWxsIGl0IHdpdGggY2xhc3MgbmFtZS4gRXhhbXBsZSwgQ3JlZGVudGlhbC5jcmVhdGVOb25SZXNpZGVudENyZWRlbnRpYWwoKVxuICAgKiBAcmV0dXJucyBBIG5vbi1yZXNpZGVudCBjcmVkZW50aWFsXG4gICAqL1xuICBjcmVhdGVOb25SZXNpZGVudENyZWRlbnRpYWwoaWQsIHJwSWQsIHByaXZhdGVLZXksIHNpZ25Db3VudCkge1xuICAgIHJldHVybiBuZXcgQ3JlZGVudGlhbChpZCwgZmFsc2UsIHJwSWQsIG51bGwsIHByaXZhdGVLZXksIHNpZ25Db3VudClcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVOb25SZXNpZGVudENyZWRlbnRpYWwoaWQsIHJwSWQsIHByaXZhdGVLZXksIHNpZ25Db3VudCkge1xuICAgIHJldHVybiBuZXcgQ3JlZGVudGlhbChpZCwgZmFsc2UsIHJwSWQsIG51bGwsIHByaXZhdGVLZXksIHNpZ25Db3VudClcbiAgfVxuXG4gIHRvRGljdCgpIHtcbiAgICBsZXQgY3JlZGVudGlhbERhdGEgPSB7XG4gICAgICBjcmVkZW50aWFsSWQ6IEJ1ZmZlci5mcm9tKHRoaXMuX2lkKS50b1N0cmluZygnYmFzZTY0dXJsJyksXG4gICAgICBpc1Jlc2lkZW50Q3JlZGVudGlhbDogdGhpcy5faXNSZXNpZGVudENyZWRlbnRpYWwsXG4gICAgICBycElkOiB0aGlzLl9ycElkLFxuICAgICAgcHJpdmF0ZUtleTogQnVmZmVyLmZyb20odGhpcy5fcHJpdmF0ZUtleSwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjR1cmwnKSxcbiAgICAgIHNpZ25Db3VudDogdGhpcy5fc2lnbkNvdW50LFxuICAgIH1cblxuICAgIGlmICh0aGlzLnVzZXJIYW5kbGUoKSAhPSBudWxsKSB7XG4gICAgICBjcmVkZW50aWFsRGF0YVsndXNlckhhbmRsZSddID0gQnVmZmVyLmZyb20odGhpcy5fdXNlckhhbmRsZSkudG9TdHJpbmcoXG4gICAgICAgICdiYXNlNjR1cmwnXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWRlbnRpYWxEYXRhXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZnJvbSBhIG1hcC5cbiAgICovXG4gIGZyb21EaWN0KGRhdGEpIHtcbiAgICBsZXQgaWQgPSBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShkYXRhWydjcmVkZW50aWFsSWQnXSwgJ2Jhc2U2NHVybCcpKVxuICAgIGxldCBpc1Jlc2lkZW50Q3JlZGVudGlhbCA9IGRhdGFbJ2lzUmVzaWRlbnRDcmVkZW50aWFsJ11cbiAgICBsZXQgcnBJZCA9IGRhdGFbJ3JwSWQnXVxuICAgIGxldCBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20oZGF0YVsncHJpdmF0ZUtleSddLCAnYmFzZTY0dXJsJykudG9TdHJpbmcoXG4gICAgICAnYmluYXJ5J1xuICAgIClcbiAgICBsZXQgc2lnbkNvdW50ID0gZGF0YVsnc2lnbkNvdW50J11cbiAgICBsZXQgdXNlckhhbmRsZVxuXG4gICAgaWYgKCd1c2VySGFuZGxlJyBpbiBkYXRhKSB7XG4gICAgICB1c2VySGFuZGxlID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oZGF0YVsndXNlckhhbmRsZSddLCAnYmFzZTY0dXJsJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZXJIYW5kbGUgPSBudWxsXG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3JlZGVudGlhbChcbiAgICAgIGlkLFxuICAgICAgaXNSZXNpZGVudENyZWRlbnRpYWwsXG4gICAgICBycElkLFxuICAgICAgdXNlckhhbmRsZSxcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBzaWduQ291bnRcbiAgICApXG4gIH1cbn1cblxuLy8gUFVCTElDIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ3JlZGVudGlhbCxcbiAgVmlydHVhbEF1dGhlbnRpY2F0b3JPcHRpb25zLFxuICBUcmFuc3BvcnQsXG4gIFByb3RvY29sLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoZSBoZWFydCBvZiB0aGUgV2ViRHJpdmVyIEphdmFTY3JpcHQgQVBJLlxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBieSA9IHJlcXVpcmUoJy4vYnknKVxuY29uc3QgeyBSZWxhdGl2ZUJ5IH0gPSByZXF1aXJlKCcuL2J5JylcbmNvbnN0IGNvbW1hbmQgPSByZXF1aXJlKCcuL2NvbW1hbmQnKVxuY29uc3QgZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJylcbmNvbnN0IGlucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZSgnLi9sb2dnaW5nJylcbmNvbnN0IHByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKVxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCBjZHAgPSByZXF1aXJlKCcuLi9kZXZ0b29scy9DRFBDb25uZWN0aW9uJylcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJylcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCcuLi9odHRwL2luZGV4JylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgeyBDYXBhYmlsaXRpZXMgfSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0aWVzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHsgTm9TdWNoRWxlbWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9yJylcbmNvbnN0IGNkcFRhcmdldHMgPSBbJ3BhZ2UnLCAnYnJvd3NlciddXG5jb25zdCB7IENyZWRlbnRpYWwgfSA9IHJlcXVpcmUoJy4vdmlydHVhbF9hdXRoZW50aWNhdG9yJylcbmNvbnN0IHdlYkVsZW1lbnQgPSByZXF1aXJlKCcuL3dlYmVsZW1lbnQnKVxuY29uc3QgeyBpc09iamVjdCB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IEJJREkgPSByZXF1aXJlKCcuLi9iaWRpJylcbmNvbnN0IHsgUGlubmVkU2NyaXB0IH0gPSByZXF1aXJlKCcuL3Bpbm5lZFNjcmlwdCcpXG5cbi8vIENhcGFiaWxpdHkgbmFtZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgVzNDIHNwZWMuXG5jb25zdCBXM0NfQ0FQQUJJTElUWV9OQU1FUyA9IG5ldyBTZXQoW1xuICAnYWNjZXB0SW5zZWN1cmVDZXJ0cycsXG4gICdicm93c2VyTmFtZScsXG4gICdicm93c2VyVmVyc2lvbicsXG4gICdwYWdlTG9hZFN0cmF0ZWd5JyxcbiAgJ3BsYXRmb3JtTmFtZScsXG4gICdwcm94eScsXG4gICdzZXRXaW5kb3dSZWN0JyxcbiAgJ3N0cmljdEZpbGVJbnRlcmFjdGFiaWxpdHknLFxuICAndGltZW91dHMnLFxuICAndW5oYW5kbGVkUHJvbXB0QmVoYXZpb3InLFxuICAnd2ViU29ja2V0VXJsJyxcbl0pXG5cbi8qKlxuICogRGVmaW5lcyBhIGNvbmRpdGlvbiBmb3IgdXNlIHdpdGggV2ViRHJpdmVyJ3Mge0BsaW5rcGxhaW4gV2ViRHJpdmVyI3dhaXQgd2FpdFxuICogY29tbWFuZH0uXG4gKlxuICogQHRlbXBsYXRlIE9VVFxuICovXG5jbGFzcyBDb25kaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgQSBkZXNjcmlwdGl2ZSBlcnJvciBtZXNzYWdlLiBTaG91bGQgY29tcGxldGUgdGhlXG4gICAqICAgICBzZW50ZW5jZSBcIldhaXRpbmcgWy4uLl1cIlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFXZWJEcml2ZXIpOiBPVVR9IGZuIFRoZSBjb25kaXRpb24gZnVuY3Rpb24gdG9cbiAgICogICAgIGV2YWx1YXRlIG9uIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSB3YWl0IGxvb3AuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmbikge1xuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuZGVzY3JpcHRpb25fID0gJ1dhaXRpbmcgJyArIG1lc3NhZ2VcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oIVdlYkRyaXZlcik6IE9VVH0gKi9cbiAgICB0aGlzLmZuID0gZm5cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtzdHJpbmd9IEEgZGVzY3JpcHRpb24gb2YgdGhpcyBjb25kaXRpb24uICovXG4gIGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uX1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyBhIGNvbmRpdGlvbiB0aGF0IHdpbGwgcmVzdWx0IGluIGEge0BsaW5rIFdlYkVsZW1lbnR9LlxuICpcbiAqIEBleHRlbmRzIHtDb25kaXRpb248IShXZWJFbGVtZW50fElUaGVuYWJsZTwhV2ViRWxlbWVudD4pPn1cbiAqL1xuY2xhc3MgV2ViRWxlbWVudENvbmRpdGlvbiBleHRlbmRzIENvbmRpdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBBIGRlc2NyaXB0aXZlIGVycm9yIG1lc3NhZ2UuIFNob3VsZCBjb21wbGV0ZSB0aGVcbiAgICogICAgIHNlbnRlbmNlIFwiV2FpdGluZyBbLi4uXVwiXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVdlYkRyaXZlcik6ICEoV2ViRWxlbWVudHxJVGhlbmFibGU8IVdlYkVsZW1lbnQ+KX1cbiAgICogICAgIGZuIFRoZSBjb25kaXRpb24gZnVuY3Rpb24gdG8gZXZhbHVhdGUgb24gZWFjaCBpdGVyYXRpb24gb2YgdGhlIHdhaXRcbiAgICogICAgIGxvb3AuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmbikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIGZuKVxuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBXZWJEcml2ZXJcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBUcmFuc2xhdGVzIGEgY29tbWFuZCB0byBpdHMgd2lyZS1wcm90b2NvbCByZXByZXNlbnRhdGlvbiBiZWZvcmUgcGFzc2luZyBpdFxuICogdG8gdGhlIGdpdmVuIGBleGVjdXRvcmAgZm9yIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7IWNvbW1hbmQuRXhlY3V0b3J9IGV4ZWN1dG9yIFRoZSBleGVjdXRvciB0byB1c2UuXG4gKiBAcGFyYW0geyFjb21tYW5kLkNvbW1hbmR9IGNvbW1hbmQgVGhlIGNvbW1hbmQgdG8gZXhlY3V0ZS5cbiAqIEByZXR1cm4geyFQcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGUgY29tbWFuZCByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZUNvbW1hbmQoZXhlY3V0b3IsIGNvbW1hbmQpIHtcbiAgcmV0dXJuIHRvV2lyZVZhbHVlKGNvbW1hbmQuZ2V0UGFyYW1ldGVycygpKS50aGVuKGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XG4gICAgY29tbWFuZC5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpXG4gICAgcmV0dXJuIGV4ZWN1dG9yLmV4ZWN1dGUoY29tbWFuZClcbiAgfSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gdGhlIFdlYkRyaXZlciB3aXJlIHByb3RvY29sLlxuICogV2hlbiBjb252ZXJ0aW5nIHZhbHVlcyBvZiB0eXBlIG9iamVjdCwgdGhlIGZvbGxvd2luZyBzdGVwcyB3aWxsIGJlIHRha2VuOlxuICogPG9sPlxuICogPGxpPmlmIHRoZSBvYmplY3QgaXMgYSBXZWJFbGVtZW50LCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdGhlIGVsZW1lbnQnc1xuICogICAgIHNlcnZlciBJRFxuICogPGxpPmlmIHRoZSBvYmplY3QgZGVmaW5lcyBhIHtAbGluayBTeW1ib2xzLnNlcmlhbGl6ZX0gbWV0aG9kLCB0aGlzIGFsZ29yaXRobVxuICogICAgIHdpbGwgYmUgcmVjdXJzaXZlbHkgYXBwbGllZCB0byB0aGUgb2JqZWN0J3Mgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvblxuICogPGxpPmlmIHRoZSBvYmplY3QgcHJvdmlkZXMgYSBcInRvSlNPTlwiIGZ1bmN0aW9uLCB0aGlzIGFsZ29yaXRobSB3aWxsXG4gKiAgICAgcmVjdXJzaXZlbHkgYmUgYXBwbGllZCB0byB0aGUgcmVzdWx0IG9mIHRoYXQgZnVuY3Rpb25cbiAqIDxsaT5vdGhlcndpc2UsIHRoZSB2YWx1ZSBvZiBlYWNoIGtleSB3aWxsIGJlIHJlY3Vyc2l2ZWx5IGNvbnZlcnRlZCBhY2NvcmRpbmdcbiAqICAgICB0byB0aGUgcnVsZXMgYWJvdmUuXG4gKiA8L29sPlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIFRoZSBvYmplY3QgdG8gY29udmVydC5cbiAqIEByZXR1cm4geyFQcm9taXNlPD8+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIGlucHV0IHZhbHVlJ3MgSlNPTlxuICogICAgIHJlcHJlc2VudGF0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiB0b1dpcmVWYWx1ZShvYmopIHtcbiAgbGV0IHZhbHVlID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG9iailcbiAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRLZXlzKHZhbHVlKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnJyArIHZhbHVlXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlW1N5bWJvbHMuc2VyaWFsaXplXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0b1dpcmVWYWx1ZSh2YWx1ZVtTeW1ib2xzLnNlcmlhbGl6ZV0oKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRvV2lyZVZhbHVlKHZhbHVlLnRvSlNPTigpKVxuICB9XG4gIHJldHVybiBjb252ZXJ0S2V5cyh2YWx1ZSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydEtleXMob2JqKSB7XG4gIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG9iailcbiAgY29uc3QgbnVtS2V5cyA9IGlzQXJyYXkgPyBvYmoubGVuZ3RoIDogT2JqZWN0LmtleXMob2JqKS5sZW5ndGhcbiAgY29uc3QgcmV0ID0gaXNBcnJheSA/IG5ldyBBcnJheShudW1LZXlzKSA6IHt9XG4gIGlmICghbnVtS2V5cykge1xuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGZvckVhY2hLZXkob2JqLCBmbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gb2JqLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBhd2FpdCBmbihvYmpbaV0sIGkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgICAgYXdhaXQgZm4ob2JqW2tleV0sIGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhd2FpdCBmb3JFYWNoS2V5KG9iaiwgYXN5bmMgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXRba2V5XSA9IGF3YWl0IHRvV2lyZVZhbHVlKHZhbHVlKVxuICB9KVxuXG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHZhbHVlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gYWNjb3JkaW5nIHRvIHRoZSBXZWJEcml2ZXIgd2lyZVxuICogcHJvdG9jb2wuIEFueSBKU09OIG9iamVjdCB0aGF0IGRlZmluZXMgYSBXZWJFbGVtZW50IElEIHdpbGwgYmUgZGVjb2RlZCB0byBhXG4gKiB7QGxpbmsgV2ViRWxlbWVudH0gb2JqZWN0LiBBbGwgb3RoZXIgdmFsdWVzIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggYXMgaXMuXG4gKlxuICogQHBhcmFtIHshV2ViRHJpdmVyfSBkcml2ZXIgVGhlIGRyaXZlciB0byB1c2UgYXMgdGhlIHBhcmVudCBvZiBhbnkgdW53cmFwcGVkXG4gKiAgICAge0BsaW5rIFdlYkVsZW1lbnR9IHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHsqfSBUaGUgY29udmVydGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBmcm9tV2lyZVZhbHVlKGRyaXZlciwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5tYXAoKHYpID0+IGZyb21XaXJlVmFsdWUoZHJpdmVyLCB2KSlcbiAgfSBlbHNlIGlmIChXZWJFbGVtZW50LmlzSWQodmFsdWUpKSB7XG4gICAgbGV0IGlkID0gV2ViRWxlbWVudC5leHRyYWN0SWQodmFsdWUpXG4gICAgdmFsdWUgPSBuZXcgV2ViRWxlbWVudChkcml2ZXIsIGlkKVxuICB9IGVsc2UgaWYgKFNoYWRvd1Jvb3QuaXNJZCh2YWx1ZSkpIHtcbiAgICBsZXQgaWQgPSBTaGFkb3dSb290LmV4dHJhY3RJZCh2YWx1ZSlcbiAgICB2YWx1ZSA9IG5ldyBTaGFkb3dSb290KGRyaXZlciwgaWQpXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZnJvbVdpcmVWYWx1ZShkcml2ZXIsIHZhbHVlW2tleV0pXG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlID0gcmVzdWx0XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSB3YWl0IG1lc3NhZ2UgZnJvbSBlaXRoZXIgYSBmdW5jdGlvbiBvciBhIHN0cmluZy5cbiAqIEBwYXJhbSB7KHN0cmluZ3xGdW5jdGlvbik9fSBtZXNzYWdlIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gdXNlIGlmIHRoZSB3YWl0IHRpbWVzIG91dC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHJlc29sdmVkIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVdhaXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG1lc3NhZ2VcbiAgICA/IGAke3R5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nID8gbWVzc2FnZSgpIDogbWVzc2FnZX1cXG5gXG4gICAgOiAnJ1xufVxuXG4vKipcbiAqIFN0cnVjdHVyYWwgaW50ZXJmYWNlIGZvciBhIFdlYkRyaXZlciBjbGllbnQuXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBJV2ViRHJpdmVyIHtcbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCB7QGxpbmsgY29tbWFuZC5Db21tYW5kfSB1c2luZyB0aGlzIGRyaXZlcidzXG4gICAqIHtAbGluayBjb21tYW5kLkV4ZWN1dG9yfS5cbiAgICpcbiAgICogQHBhcmFtIHshY29tbWFuZC5Db21tYW5kfSBjb21tYW5kIFRoZSBjb21tYW5kIHRvIHNjaGVkdWxlLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxUPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSBjb21tYW5kXG4gICAqICAgICByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBleGVjdXRlKGNvbW1hbmQpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rcGxhaW4gaW5wdXQuRmlsZURldGVjdG9yIGZpbGUgZGV0ZWN0b3J9IHRoYXQgc2hvdWxkIGJlXG4gICAqIHVzZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge2lucHV0LkZpbGVEZXRlY3Rvcn0gZGV0ZWN0b3IgVGhlIGRldGVjdG9yIHRvIHVzZSBvciBgbnVsbGAuXG4gICAqL1xuICBzZXRGaWxlRGV0ZWN0b3IoZGV0ZWN0b3IpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQHJldHVybiB7IWNvbW1hbmQuRXhlY3V0b3J9IFRoZSBjb21tYW5kIGV4ZWN1dG9yIHVzZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICovXG4gIGdldEV4ZWN1dG9yKCkge31cblxuICAvKipcbiAgICogQHJldHVybiB7IVByb21pc2U8IVNlc3Npb24+fSBBIHByb21pc2UgZm9yIHRoaXMgY2xpZW50J3Mgc2Vzc2lvbi5cbiAgICovXG4gIGdldFNlc3Npb24oKSB7fVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTwhQ2FwYWJpbGl0aWVzPn0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdpdGhcbiAgICogICAgIHRoZSBpbnN0YW5jZSdzIGNhcGFiaWxpdGllcy5cbiAgICovXG4gIGdldENhcGFiaWxpdGllcygpIHt9XG5cbiAgLyoqXG4gICAqIFRlcm1pbmF0ZXMgdGhlIGJyb3dzZXIgc2Vzc2lvbi4gQWZ0ZXIgY2FsbGluZyBxdWl0LCB0aGlzIGluc3RhbmNlIHdpbGwgYmVcbiAgICogaW52YWxpZGF0ZWQgYW5kIG1heSBubyBsb25nZXIgYmUgdXNlZCB0byBpc3N1ZSBjb21tYW5kcyBhZ2FpbnN0IHRoZVxuICAgKiBicm93c2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZVxuICAgKiAgICAgY29tbWFuZCBoYXMgY29tcGxldGVkLlxuICAgKi9cbiAgcXVpdCgpIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYWN0aW9uIHNlcXVlbmNlIHVzaW5nIHRoaXMgZHJpdmVyLiBUaGUgc2VxdWVuY2Ugd2lsbCBub3QgYmVcbiAgICogc3VibWl0dGVkIGZvciBleGVjdXRpb24gdW50aWxcbiAgICoge0BsaW5rIC4vaW5wdXQuQWN0aW9ucyNwZXJmb3JtIEFjdGlvbnMucGVyZm9ybSgpfSBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7e2FzeW5jOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICAgKiAgICAgICAgICBicmlkZ2U6IChib29sZWFufHVuZGVmaW5lZCl9PX0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yXG4gICAqICAgICB0aGUgYWN0aW9uIHNlcXVlbmNlIChzZWUge0BsaW5rIC4vaW5wdXQuQWN0aW9ucyBBY3Rpb25zfSBkb2N1bWVudGF0aW9uXG4gICAqICAgICBmb3IgZGV0YWlscykuXG4gICAqIEByZXR1cm4geyFpbnB1dC5BY3Rpb25zfSBBIG5ldyBhY3Rpb24gc2VxdWVuY2UgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBhY3Rpb25zKG9wdGlvbnMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBzbmlwcGV0IG9mIEphdmFTY3JpcHQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKiBmcmFtZSBvciB3aW5kb3cuIFRoZSBzY3JpcHQgZnJhZ21lbnQgd2lsbCBiZSBleGVjdXRlZCBhcyB0aGUgYm9keSBvZiBhblxuICAgKiBhbm9ueW1vdXMgZnVuY3Rpb24uIElmIHRoZSBzY3JpcHQgaXMgcHJvdmlkZWQgYXMgYSBmdW5jdGlvbiBvYmplY3QsIHRoYXRcbiAgICogZnVuY3Rpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgZm9yIGluamVjdGlvbiBpbnRvIHRoZSB0YXJnZXRcbiAgICogd2luZG93LlxuICAgKlxuICAgKiBBbnkgYXJndW1lbnRzIHByb3ZpZGVkIGluIGFkZGl0aW9uIHRvIHRoZSBzY3JpcHQgd2lsbCBiZSBpbmNsdWRlZCBhcyBzY3JpcHRcbiAgICogYXJndW1lbnRzIGFuZCBtYXkgYmUgcmVmZXJlbmNlZCB1c2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBBcmd1bWVudHMgbWF5XG4gICAqIGJlIGEgYm9vbGVhbiwgbnVtYmVyLCBzdHJpbmcsIG9yIHtAbGlua3BsYWluIFdlYkVsZW1lbnR9LiBBcnJheXMgYW5kXG4gICAqIG9iamVjdHMgbWF5IGFsc28gYmUgdXNlZCBhcyBzY3JpcHQgYXJndW1lbnRzIGFzIGxvbmcgYXMgZWFjaCBpdGVtIGFkaGVyZXNcbiAgICogdG8gdGhlIHR5cGVzIHByZXZpb3VzbHkgbWVudGlvbmVkLlxuICAgKlxuICAgKiBUaGUgc2NyaXB0IG1heSByZWZlciB0byBhbnkgdmFyaWFibGVzIGFjY2Vzc2libGUgZnJvbSB0aGUgY3VycmVudCB3aW5kb3cuXG4gICAqIEZ1cnRoZXJtb3JlLCB0aGUgc2NyaXB0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgd2luZG93J3MgY29udGV4dCwgdGh1c1xuICAgKiBgZG9jdW1lbnRgIG1heSBiZSB1c2VkIHRvIHJlZmVyIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50LiBBbnkgbG9jYWxcbiAgICogdmFyaWFibGVzIHdpbGwgbm90IGJlIGF2YWlsYWJsZSBvbmNlIHRoZSBzY3JpcHQgaGFzIGZpbmlzaGVkIGV4ZWN1dGluZyxcbiAgICogdGhvdWdoIGdsb2JhbCB2YXJpYWJsZXMgd2lsbCBwZXJzaXN0LlxuICAgKlxuICAgKiBJZiB0aGUgc2NyaXB0IGhhcyBhIHJldHVybiB2YWx1ZSAoaS5lLiBpZiB0aGUgc2NyaXB0IGNvbnRhaW5zIGEgcmV0dXJuXG4gICAqIHN0YXRlbWVudCksIHRoZW4gdGhlIGZvbGxvd2luZyBzdGVwcyB3aWxsIGJlIHRha2VuIGZvciByZXNvbHZpbmcgdGhpc1xuICAgKiBmdW5jdGlvbnMgcmV0dXJuIHZhbHVlOlxuICAgKlxuICAgKiAtIEZvciBhIEhUTUwgZWxlbWVudCwgdGhlIHZhbHVlIHdpbGwgcmVzb2x2ZSB0byBhIHtAbGlua3BsYWluIFdlYkVsZW1lbnR9XG4gICAqIC0gTnVsbCBhbmQgdW5kZWZpbmVkIHJldHVybiB2YWx1ZXMgd2lsbCByZXNvbHZlIHRvIG51bGw8L2xpPlxuICAgKiAtIEJvb2xlYW5zLCBudW1iZXJzLCBhbmQgc3RyaW5ncyB3aWxsIHJlc29sdmUgYXMgaXM8L2xpPlxuICAgKiAtIEZ1bmN0aW9ucyB3aWxsIHJlc29sdmUgdG8gdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uPC9saT5cbiAgICogLSBGb3IgYXJyYXlzIGFuZCBvYmplY3RzLCBlYWNoIG1lbWJlciBpdGVtIHdpbGwgYmUgY29udmVydGVkIGFjY29yZGluZyB0b1xuICAgKiAgICAgdGhlIHJ1bGVzIGFib3ZlXG4gICAqXG4gICAqIEBwYXJhbSB7IShzdHJpbmd8RnVuY3Rpb24pfSBzY3JpcHQgVGhlIHNjcmlwdCB0byBleGVjdXRlLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBzY3JpcHQuXG4gICAqIEByZXR1cm4geyFJVGhlbmFibGU8VD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGVcbiAgICogICAgc2NyaXB0cyByZXR1cm4gdmFsdWUuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBleGVjdXRlU2NyaXB0KHNjcmlwdCwgLi4uYXJncykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHNuaXBwZXQgb2YgYXN5bmNocm9ub3VzIEphdmFTY3JpcHQgaW4gdGhlIGNvbnRleHQgb2YgdGhlXG4gICAqIGN1cnJlbnRseSBzZWxlY3RlZCBmcmFtZSBvciB3aW5kb3cuIFRoZSBzY3JpcHQgZnJhZ21lbnQgd2lsbCBiZSBleGVjdXRlZCBhc1xuICAgKiB0aGUgYm9keSBvZiBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uIElmIHRoZSBzY3JpcHQgaXMgcHJvdmlkZWQgYXMgYSBmdW5jdGlvblxuICAgKiBvYmplY3QsIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgZm9yIGluamVjdGlvbiBpbnRvIHRoZVxuICAgKiB0YXJnZXQgd2luZG93LlxuICAgKlxuICAgKiBBbnkgYXJndW1lbnRzIHByb3ZpZGVkIGluIGFkZGl0aW9uIHRvIHRoZSBzY3JpcHQgd2lsbCBiZSBpbmNsdWRlZCBhcyBzY3JpcHRcbiAgICogYXJndW1lbnRzIGFuZCBtYXkgYmUgcmVmZXJlbmNlZCB1c2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBBcmd1bWVudHMgbWF5XG4gICAqIGJlIGEgYm9vbGVhbiwgbnVtYmVyLCBzdHJpbmcsIG9yIHtAbGlua3BsYWluIFdlYkVsZW1lbnR9LiBBcnJheXMgYW5kXG4gICAqIG9iamVjdHMgbWF5IGFsc28gYmUgdXNlZCBhcyBzY3JpcHQgYXJndW1lbnRzIGFzIGxvbmcgYXMgZWFjaCBpdGVtIGFkaGVyZXNcbiAgICogdG8gdGhlIHR5cGVzIHByZXZpb3VzbHkgbWVudGlvbmVkLlxuICAgKlxuICAgKiBVbmxpa2UgZXhlY3V0aW5nIHN5bmNocm9ub3VzIEphdmFTY3JpcHQgd2l0aCB7QGxpbmsgI2V4ZWN1dGVTY3JpcHR9LFxuICAgKiBzY3JpcHRzIGV4ZWN1dGVkIHdpdGggdGhpcyBmdW5jdGlvbiBtdXN0IGV4cGxpY2l0bHkgc2lnbmFsIHRoZXkgYXJlXG4gICAqIGZpbmlzaGVkIGJ5IGludm9raW5nIHRoZSBwcm92aWRlZCBjYWxsYmFjay4gVGhpcyBjYWxsYmFjayB3aWxsIGFsd2F5cyBiZVxuICAgKiBpbmplY3RlZCBpbnRvIHRoZSBleGVjdXRlZCBmdW5jdGlvbiBhcyB0aGUgbGFzdCBhcmd1bWVudCwgYW5kIHRodXMgbWF5IGJlXG4gICAqIHJlZmVyZW5jZWQgd2l0aCAgYGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV1gLiBUaGUgZm9sbG93aW5nIHN0ZXBzXG4gICAqIHdpbGwgYmUgdGFrZW4gZm9yIHJlc29sdmluZyB0aGlzIGZ1bmN0aW9ucyByZXR1cm4gdmFsdWUgYWdhaW5zdCB0aGUgZmlyc3RcbiAgICogYXJndW1lbnQgdG8gdGhlIHNjcmlwdCdzIGNhbGxiYWNrIGZ1bmN0aW9uOlxuICAgKlxuICAgKiAtIEZvciBhIEhUTUwgZWxlbWVudCwgdGhlIHZhbHVlIHdpbGwgcmVzb2x2ZSB0byBhIHtAbGluayBXZWJFbGVtZW50fVxuICAgKiAtIE51bGwgYW5kIHVuZGVmaW5lZCByZXR1cm4gdmFsdWVzIHdpbGwgcmVzb2x2ZSB0byBudWxsXG4gICAqIC0gQm9vbGVhbnMsIG51bWJlcnMsIGFuZCBzdHJpbmdzIHdpbGwgcmVzb2x2ZSBhcyBpc1xuICAgKiAtIEZ1bmN0aW9ucyB3aWxsIHJlc29sdmUgdG8gdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIC0gRm9yIGFycmF5cyBhbmQgb2JqZWN0cywgZWFjaCBtZW1iZXIgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCBhY2NvcmRpbmcgdG9cbiAgICogICAgIHRoZSBydWxlcyBhYm92ZVxuICAgKlxuICAgKiBfX0V4YW1wbGUgIzE6X18gUGVyZm9ybWluZyBhIHNsZWVwIHRoYXQgaXMgc3luY2hyb25pemVkIHdpdGggdGhlIGN1cnJlbnRseVxuICAgKiBzZWxlY3RlZCB3aW5kb3c6XG4gICAqXG4gICAqICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICogICAgIGRyaXZlci5leGVjdXRlQXN5bmNTY3JpcHQoXG4gICAqICAgICAgICAgJ3dpbmRvdy5zZXRUaW1lb3V0KGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0sIDUwMCk7JykuXG4gICAqICAgICAgICAgdGhlbihmdW5jdGlvbigpIHtcbiAgICogICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgKiAgICAgICAgICAgICAgICdFbGFwc2VkIHRpbWU6ICcgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydCkgKyAnIG1zJyk7XG4gICAqICAgICAgICAgfSk7XG4gICAqXG4gICAqIF9fRXhhbXBsZSAjMjpfXyBTeW5jaHJvbml6aW5nIGEgdGVzdCB3aXRoIGFuIEFKQVggYXBwbGljYXRpb246XG4gICAqXG4gICAqICAgICB2YXIgYnV0dG9uID0gZHJpdmVyLmZpbmRFbGVtZW50KEJ5LmlkKCdjb21wb3NlLWJ1dHRvbicpKTtcbiAgICogICAgIGJ1dHRvbi5jbGljaygpO1xuICAgKiAgICAgZHJpdmVyLmV4ZWN1dGVBc3luY1NjcmlwdChcbiAgICogICAgICAgICAndmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTsnICtcbiAgICogICAgICAgICAnbWFpbENsaWVudC5nZXRDb21wb3NlV2luZG93V2lkZ2V0KCkub25sb2FkKGNhbGxiYWNrKTsnKTtcbiAgICogICAgIGRyaXZlci5zd2l0Y2hUbygpLmZyYW1lKCdjb21wb3NlV2lkZ2V0Jyk7XG4gICAqICAgICBkcml2ZXIuZmluZEVsZW1lbnQoQnkuaWQoJ3RvJykpLnNlbmRLZXlzKCdkb2dAZXhhbXBsZS5jb20nKTtcbiAgICpcbiAgICogX19FeGFtcGxlICMzOl9fIEluamVjdGluZyBhIFhNTEh0dHBSZXF1ZXN0IGFuZCB3YWl0aW5nIGZvciB0aGUgcmVzdWx0LiBJblxuICAgKiB0aGlzIGV4YW1wbGUsIHRoZSBpbmplY3Qgc2NyaXB0IGlzIHNwZWNpZmllZCB3aXRoIGEgZnVuY3Rpb24gbGl0ZXJhbC4gV2hlblxuICAgKiB1c2luZyB0aGlzIGZvcm1hdCwgdGhlIGZ1bmN0aW9uIGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBmb3IgaW5qZWN0aW9uLCBzb1xuICAgKiBpdCBzaG91bGQgbm90IHJlZmVyZW5jZSBhbnkgc3ltYm9scyBub3QgZGVmaW5lZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHBhZ2VcbiAgICogdW5kZXIgdGVzdC5cbiAgICpcbiAgICogICAgIGRyaXZlci5leGVjdXRlQXN5bmNTY3JpcHQoZnVuY3Rpb24oKSB7XG4gICAqICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAqICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICogICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgXCIvcmVzb3VyY2UvZGF0YS5qc29uXCIsIHRydWUpO1xuICAgKiAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcbiAgICogICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQpO1xuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfTtcbiAgICogICAgICAgeGhyLnNlbmQoJycpO1xuICAgKiAgICAgfSkudGhlbihmdW5jdGlvbihzdHIpIHtcbiAgICogICAgICAgY29uc29sZS5sb2coSlNPTi5wYXJzZShzdHIpWydmb29kJ10pO1xuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7IShzdHJpbmd8RnVuY3Rpb24pfSBzY3JpcHQgVGhlIHNjcmlwdCB0byBleGVjdXRlLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBzY3JpcHQuXG4gICAqIEByZXR1cm4geyFJVGhlbmFibGU8VD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGUgc2NyaXB0cyByZXR1cm5cbiAgICogICAgIHZhbHVlLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZXhlY3V0ZUFzeW5jU2NyaXB0KHNjcmlwdCwgLi4uYXJncykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYSBjb25kaXRpb24gdG8gZXZhbHVhdGUgdG8gYSBcInRydXRoeVwiIHZhbHVlLiBUaGUgY29uZGl0aW9uIG1heSBiZVxuICAgKiBzcGVjaWZpZWQgYnkgYSB7QGxpbmsgQ29uZGl0aW9ufSwgYXMgYSBjdXN0b20gZnVuY3Rpb24sIG9yIGFzIGFueVxuICAgKiBwcm9taXNlLWxpa2UgdGhlbmFibGUuXG4gICAqXG4gICAqIEZvciBhIHtAbGluayBDb25kaXRpb259IG9yIGZ1bmN0aW9uLCB0aGUgd2FpdCB3aWxsIHJlcGVhdGVkbHlcbiAgICogZXZhbHVhdGUgdGhlIGNvbmRpdGlvbiB1bnRpbCBpdCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLiBJZiBhbnkgZXJyb3JzIG9jY3VyXG4gICAqIHdoaWxlIGV2YWx1YXRpbmcgdGhlIGNvbmRpdGlvbiwgdGhleSB3aWxsIGJlIGFsbG93ZWQgdG8gcHJvcGFnYXRlLiBJbiB0aGVcbiAgICogZXZlbnQgYSBjb25kaXRpb24gcmV0dXJucyBhIHtAbGlua3BsYWluIFByb21pc2V9LCB0aGUgcG9sbGluZyBsb29wIHdpbGxcbiAgICogd2FpdCBmb3IgaXQgdG8gYmUgcmVzb2x2ZWQgYW5kIHVzZSB0aGUgcmVzb2x2ZWQgdmFsdWUgZm9yIHdoZXRoZXIgdGhlXG4gICAqIGNvbmRpdGlvbiBoYXMgYmVlbiBzYXRpc2ZpZWQuIFRoZSByZXNvbHV0aW9uIHRpbWUgZm9yIGEgcHJvbWlzZSBpcyBhbHdheXNcbiAgICogZmFjdG9yZWQgaW50byB3aGV0aGVyIGEgd2FpdCBoYXMgdGltZWQgb3V0LlxuICAgKlxuICAgKiBJZiB0aGUgcHJvdmlkZWQgY29uZGl0aW9uIGlzIGEge0BsaW5rIFdlYkVsZW1lbnRDb25kaXRpb259LCB0aGVuXG4gICAqIHRoZSB3YWl0IHdpbGwgcmV0dXJuIGEge0BsaW5rIFdlYkVsZW1lbnRQcm9taXNlfSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGVcbiAgICogZWxlbWVudCB0aGF0IHNhdGlzZmllZCB0aGUgY29uZGl0aW9uLlxuICAgKlxuICAgKiBfRXhhbXBsZTpfIHdhaXRpbmcgdXAgdG8gMTAgc2Vjb25kcyBmb3IgYW4gZWxlbWVudCB0byBiZSBwcmVzZW50IG9uIHRoZVxuICAgKiBwYWdlLlxuICAgKlxuICAgKiAgICAgYXN5bmMgZnVuY3Rpb24gZXhhbXBsZSgpIHtcbiAgICogICAgICAgbGV0IGJ1dHRvbiA9XG4gICAqICAgICAgICAgICBhd2FpdCBkcml2ZXIud2FpdCh1bnRpbC5lbGVtZW50TG9jYXRlZChCeS5pZCgnZm9vJykpLCAxMDAwMCk7XG4gICAqICAgICAgIGF3YWl0IGJ1dHRvbi5jbGljaygpO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0geyEoSVRoZW5hYmxlPFQ+fFxuICAgKiAgICAgICAgICAgQ29uZGl0aW9uPFQ+fFxuICAgKiAgICAgICAgICAgZnVuY3Rpb24oIVdlYkRyaXZlcik6IFQpfSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB0b1xuICAgKiAgICAgd2FpdCBvbiwgZGVmaW5lZCBhcyBhIHByb21pc2UsIGNvbmRpdGlvbiBvYmplY3QsIG9yICBhIGZ1bmN0aW9uIHRvXG4gICAqICAgICBldmFsdWF0ZSBhcyBhIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSB0aW1lb3V0IFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMsIGhvdyBsb25nIHRvIHdhaXRcbiAgICogICAgIGZvciB0aGUgY29uZGl0aW9uIHRvIGJlIHRydWUuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xGdW5jdGlvbik9fSBtZXNzYWdlIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gdXNlIGlmIHRoZSB3YWl0IHRpbWVzIG91dC5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBwb2xsVGltZW91dCBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLCBob3cgbG9uZyB0b1xuICAgKiAgICAgd2FpdCBiZXR3ZWVuIHBvbGxpbmcgdGhlIGNvbmRpdGlvbi5cbiAgICogQHJldHVybiB7IShJVGhlbmFibGU8VD58V2ViRWxlbWVudFByb21pc2UpfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlXG4gICAqICAgICByZXNvbHZlZCB3aXRoIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGNvbmRpdGlvblxuICAgKiAgICAgZnVuY3Rpb24sIG9yIHJlamVjdGVkIGlmIHRoZSBjb25kaXRpb24gdGltZXMgb3V0LiBJZiB0aGUgaW5wdXRcbiAgICogICAgIGNvbmRpdGlvbiBpcyBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBXZWJFbGVtZW50Q29uZGl0aW9ufSxcbiAgICogICAgIHRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGEge0BsaW5rIFdlYkVsZW1lbnRQcm9taXNlfS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiB0aGUgcHJvdmlkZWQgYGNvbmRpdGlvbmAgaXMgbm90IGEgdmFsaWQgdHlwZS5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIHdhaXQoXG4gICAgY29uZGl0aW9uLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdGltZW91dCA9IHVuZGVmaW5lZCwgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIG1lc3NhZ2UgPSB1bmRlZmluZWQsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBwb2xsVGltZW91dCA9IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICkge31cblxuICAvKipcbiAgICogTWFrZXMgdGhlIGRyaXZlciBzbGVlcCBmb3IgdGhlIGdpdmVuIGFtb3VudCBvZiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXMgVGhlIGFtb3VudCBvZiB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRvIHNsZWVwLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBzbGVlcCBoYXNcbiAgICogICAgIGZpbmlzaGVkLlxuICAgKi9cbiAgc2xlZXAobXMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHdpbmRvdyBoYW5kbGUuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgY3VycmVudFxuICAgKiAgICAgd2luZG93IGhhbmRsZS5cbiAgICovXG4gIGdldFdpbmRvd0hhbmRsZSgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSB3aW5kb3cgaGFuZGxlcy5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8IUFycmF5PHN0cmluZz4+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYW5cbiAgICogICAgIGFycmF5IG9mIHdpbmRvdyBoYW5kbGVzLlxuICAgKi9cbiAgZ2V0QWxsV2luZG93SGFuZGxlcygpIHt9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBwYWdlJ3Mgc291cmNlLiBUaGUgcmV0dXJuZWQgc291cmNlIGlzIGEgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIHVuZGVybHlpbmcgRE9NOiBkbyBub3QgZXhwZWN0IGl0IHRvIGJlIGZvcm1hdHRlZCBvciBlc2NhcGVkIGluIHRoZVxuICAgKiBzYW1lIHdheSBhcyB0aGUgcmF3IHJlc3BvbnNlIHNlbnQgZnJvbSB0aGUgd2ViIHNlcnZlci5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSBjdXJyZW50XG4gICAqICAgICBwYWdlIHNvdXJjZS5cbiAgICovXG4gIGdldFBhZ2VTb3VyY2UoKSB7fVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgd2luZG93LlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoaXMgY29tbWFuZFxuICAgKiAgICAgaGFzIGNvbXBsZXRlZC5cbiAgICovXG4gIGNsb3NlKCkge31cblxuICAvKipcbiAgICogTmF2aWdhdGVzIHRvIHRoZSBnaXZlbiBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgdG8gb3Blbi5cbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZG9jdW1lbnRcbiAgICogICAgIGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgKi9cbiAgZ2V0KHVybCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIFVSTCBmb3IgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZVxuICAgKiAgICAgY3VycmVudCBVUkwuXG4gICAqL1xuICBnZXRDdXJyZW50VXJsKCkge31cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHBhZ2UgdGl0bGUuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgY3VycmVudFxuICAgKiAgICAgcGFnZSdzIHRpdGxlLlxuICAgKi9cbiAgZ2V0VGl0bGUoKSB7fVxuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGFuIGVsZW1lbnQgb24gdGhlIHBhZ2UuIElmIHRoZSBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZCwgYVxuICAgKiB7QGxpbmsgZXJyb3IuTm9TdWNoRWxlbWVudEVycm9yfSB3aWxsIGJlIHJldHVybmVkIGJ5IHRoZSBkcml2ZXIuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHRlc3Qgd2hldGhlciBhbiBlbGVtZW50IGlzIHByZXNlbnQgb25cbiAgICogdGhlIHBhZ2UuIFJhdGhlciwgeW91IHNob3VsZCB1c2Uge0BsaW5rICNmaW5kRWxlbWVudHN9OlxuICAgKlxuICAgKiAgICAgZHJpdmVyLmZpbmRFbGVtZW50cyhCeS5pZCgnZm9vJykpXG4gICAqICAgICAgICAgLnRoZW4oZm91bmQgPT4gY29uc29sZS5sb2coJ0VsZW1lbnQgZm91bmQ/ICVzJywgISFmb3VuZC5sZW5ndGgpKTtcbiAgICpcbiAgICogVGhlIHNlYXJjaCBjcml0ZXJpYSBmb3IgYW4gZWxlbWVudCBtYXkgYmUgZGVmaW5lZCB1c2luZyBvbmUgb2YgdGhlXG4gICAqIGZhY3RvcmllcyBpbiB0aGUge0BsaW5rIHdlYmRyaXZlci5CeX0gbmFtZXNwYWNlLCBvciBhcyBhIHNob3J0LWhhbmRcbiAgICoge0BsaW5rIHdlYmRyaXZlci5CeS5IYXNofSBvYmplY3QuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIHR3byBzdGF0ZW1lbnRzXG4gICAqIGFyZSBlcXVpdmFsZW50OlxuICAgKlxuICAgKiAgICAgdmFyIGUxID0gZHJpdmVyLmZpbmRFbGVtZW50KEJ5LmlkKCdmb28nKSk7XG4gICAqICAgICB2YXIgZTIgPSBkcml2ZXIuZmluZEVsZW1lbnQoe2lkOidmb28nfSk7XG4gICAqXG4gICAqIFlvdSBtYXkgYWxzbyBwcm92aWRlIGEgY3VzdG9tIGxvY2F0b3IgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGFzIGlucHV0IHRoaXNcbiAgICogaW5zdGFuY2UgYW5kIHJldHVybnMgYSB7QGxpbmsgV2ViRWxlbWVudH0sIG9yIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZVxuICAgKiB0byBhIFdlYkVsZW1lbnQuIElmIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHRvIGFuIGFycmF5IG9mXG4gICAqIFdlYkVsZW1lbnRzLCBXZWJEcml2ZXIgd2lsbCB1c2UgdGhlIGZpcnN0IGVsZW1lbnQuIEZvciBleGFtcGxlLCB0byBmaW5kIHRoZVxuICAgKiBmaXJzdCB2aXNpYmxlIGxpbmsgb24gYSBwYWdlLCB5b3UgY291bGQgd3JpdGU6XG4gICAqXG4gICAqICAgICB2YXIgbGluayA9IGRyaXZlci5maW5kRWxlbWVudChmaXJzdFZpc2libGVMaW5rKTtcbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIGZpcnN0VmlzaWJsZUxpbmsoZHJpdmVyKSB7XG4gICAqICAgICAgIHZhciBsaW5rcyA9IGRyaXZlci5maW5kRWxlbWVudHMoQnkudGFnTmFtZSgnYScpKTtcbiAgICogICAgICAgcmV0dXJuIHByb21pc2UuZmlsdGVyKGxpbmtzLCBmdW5jdGlvbihsaW5rKSB7XG4gICAqICAgICAgICAgcmV0dXJuIGxpbmsuaXNEaXNwbGF5ZWQoKTtcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7IShieS5CeXxGdW5jdGlvbil9IGxvY2F0b3IgVGhlIGxvY2F0b3IgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHshV2ViRWxlbWVudFByb21pc2V9IEEgV2ViRWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlzc3VlXG4gICAqICAgICBjb21tYW5kcyBhZ2FpbnN0IHRoZSBsb2NhdGVkIGVsZW1lbnQuIElmIHRoZSBlbGVtZW50IGlzIG5vdCBmb3VuZCwgdGhlXG4gICAqICAgICBlbGVtZW50IHdpbGwgYmUgaW52YWxpZGF0ZWQgYW5kIGFsbCBzY2hlZHVsZWQgY29tbWFuZHMgYWJvcnRlZC5cbiAgICovXG4gIGZpbmRFbGVtZW50KGxvY2F0b3IpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogU2VhcmNoIGZvciBtdWx0aXBsZSBlbGVtZW50cyBvbiB0aGUgcGFnZS4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24gb25cbiAgICoge0BsaW5rICNmaW5kRWxlbWVudChieSl9IGZvciBpbmZvcm1hdGlvbiBvbiBlbGVtZW50IGxvY2F0b3Igc3RyYXRlZ2llcy5cbiAgICpcbiAgICogQHBhcmFtIHshKGJ5LkJ5fEZ1bmN0aW9uKX0gbG9jYXRvciBUaGUgbG9jYXRvciB0byB1c2UuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPCFBcnJheTwhV2ViRWxlbWVudD4+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gYW5cbiAgICogICAgIGFycmF5IG9mIFdlYkVsZW1lbnRzLlxuICAgKi9cbiAgZmluZEVsZW1lbnRzKGxvY2F0b3IpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogVGFrZXMgYSBzY3JlZW5zaG90IG9mIHRoZSBjdXJyZW50IHBhZ2UuIFRoZSBkcml2ZXIgbWFrZXMgdGhlIGJlc3QgZWZmb3J0IHRvXG4gICAqIHJldHVybiBhIHNjcmVlbnNob3Qgb2YgdGhlIGZvbGxvd2luZywgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZTpcbiAgICpcbiAgICogMS4gRW50aXJlIHBhZ2VcbiAgICogMi4gQ3VycmVudCB3aW5kb3dcbiAgICogMy4gVmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBjdXJyZW50IGZyYW1lXG4gICAqIDQuIFRoZSBlbnRpcmUgZGlzcGxheSBjb250YWluaW5nIHRoZSBicm93c2VyXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgdG8gdGhlXG4gICAqICAgICBzY3JlZW5zaG90IGFzIGEgYmFzZS02NCBlbmNvZGVkIFBORy5cbiAgICovXG4gIHRha2VTY3JlZW5zaG90KCkge31cblxuICAvKipcbiAgICogQHJldHVybiB7IU9wdGlvbnN9IFRoZSBvcHRpb25zIGludGVyZmFjZSBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICovXG4gIG1hbmFnZSgpIHt9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFOYXZpZ2F0aW9ufSBUaGUgbmF2aWdhdGlvbiBpbnRlcmZhY2UgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBuYXZpZ2F0ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFUYXJnZXRMb2NhdG9yfSBUaGUgdGFyZ2V0IGxvY2F0b3IgaW50ZXJmYWNlIGZvciB0aGlzXG4gICAqICAgICBpbnN0YW5jZS5cbiAgICovXG4gIHN3aXRjaFRvKCkge31cblxuICAvKipcbiAgICpcbiAgICogVGFrZXMgYSBQREYgb2YgdGhlIGN1cnJlbnQgcGFnZS4gVGhlIGRyaXZlciBtYWtlcyBhIGJlc3QgZWZmb3J0IHRvXG4gICAqIHJldHVybiBhIFBERiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHt7b3JpZW50YXRpb246KHN0cmluZ3x1bmRlZmluZWQpLFxuICAgKiAgICAgICAgIHNjYWxlOihudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICAgICAgICBiYWNrZ3JvdW5kOihib29sZWFufHVuZGVmaW5lZCksXG4gICAqICAgICAgICAgd2lkdGg6KG51bWJlcnx1bmRlZmluZWQpLFxuICAgKiAgICAgICAgIGhlaWdodDoobnVtYmVyfHVuZGVmaW5lZCksXG4gICAqICAgICAgICAgdG9wOihudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICAgICAgICBib3R0b206KG51bWJlcnx1bmRlZmluZWQpLFxuICAgKiAgICAgICAgIGxlZnQ6KG51bWJlcnx1bmRlZmluZWQpLFxuICAgKiAgICAgICAgIHJpZ2h0OihudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICAgICAgICBzaHJpbmtUb0ZpdDooYm9vbGVhbnx1bmRlZmluZWQpLFxuICAgKiAgICAgICAgIHBhZ2VSYW5nZXM6KEFycmF5fHVuZGVmaW5lZCl9fSBvcHRpb25zXG4gICAqL1xuICBwcmludFBhZ2Uob3B0aW9ucykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7IUNhcGFiaWxpdGllc30gY2FwYWJpbGl0aWVzIEEgY2FwYWJpbGl0aWVzIG9iamVjdC5cbiAqIEByZXR1cm4geyFDYXBhYmlsaXRpZXN9IEEgY29weSBvZiB0aGUgcGFyYW1ldGVyIGNhcGFiaWxpdGllcywgb21pdHRpbmdcbiAqICAgICBjYXBhYmlsaXR5IG5hbWVzIHRoYXQgYXJlIG5vdCB2YWxpZCBXM0MgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlck5vblczQ0NhcHMoY2FwYWJpbGl0aWVzKSB7XG4gIGxldCBuZXdDYXBzID0gbmV3IENhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXMpXG4gIGZvciAobGV0IGsgb2YgbmV3Q2Fwcy5rZXlzKCkpIHtcbiAgICAvLyBBbnkga2V5IGNvbnRhaW5pbmcgYSBjb2xvbiBpcyBhIHZlbmRvci1wcmVmaXhlZCBjYXBhYmlsaXR5LlxuICAgIGlmICghKFczQ19DQVBBQklMSVRZX05BTUVTLmhhcyhrKSB8fCBrLmluZGV4T2YoJzonKSA+PSAwKSkge1xuICAgICAgbmV3Q2Fwcy5kZWxldGUoaylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0NhcHNcbn1cblxuLyoqXG4gKiBFYWNoIFdlYkRyaXZlciBpbnN0YW5jZSBwcm92aWRlcyBhdXRvbWF0ZWQgY29udHJvbCBvdmVyIGEgYnJvd3NlciBzZXNzaW9uLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtJV2ViRHJpdmVyfVxuICovXG5jbGFzcyBXZWJEcml2ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHshKC4vc2Vzc2lvbi5TZXNzaW9ufElUaGVuYWJsZTwhLi9zZXNzaW9uLlNlc3Npb24+KX0gc2Vzc2lvbiBFaXRoZXJcbiAgICogICAgIGEga25vd24gc2Vzc2lvbiBvciBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHRvIGEgc2Vzc2lvbi5cbiAgICogQHBhcmFtIHshY29tbWFuZC5FeGVjdXRvcn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIHRvIHVzZSB3aGVuIHNlbmRpbmdcbiAgICogICAgIGNvbW1hbmRzIHRvIHRoZSBicm93c2VyLlxuICAgKiBAcGFyYW0geyhmdW5jdGlvbih0aGlzOiB2b2lkKTogPyk9fSBvblF1aXQgQSBmdW5jdGlvbiB0byBjYWxsLCBpZiBhbnksXG4gICAqICAgICB3aGVuIHRoZSBzZXNzaW9uIGlzIHRlcm1pbmF0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBleGVjdXRvciwgb25RdWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgLyoqIEBwcml2YXRlIHshUHJvbWlzZTwhU2Vzc2lvbj59ICovXG4gICAgdGhpcy5zZXNzaW9uXyA9IFByb21pc2UucmVzb2x2ZShzZXNzaW9uKVxuXG4gICAgLy8gSWYgc2Vzc2lvbiBpcyBhIHJlamVjdGVkIHByb21pc2UsIGFkZCBhIG5vLW9wIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgIC8vIFRoaXMgZWZmZWN0aXZlbHkgaGlkZXMgc2V0dXAgZXJyb3JzIHVudGlsIHVzZXJzIGF0dGVtcHQgdG8gaW50ZXJhY3RcbiAgICAvLyB3aXRoIHRoZSBzZXNzaW9uLlxuICAgIHRoaXMuc2Vzc2lvbl8uY2F0Y2goZnVuY3Rpb24gKCkge30pXG5cbiAgICAvKiogQHByaXZhdGUgeyFjb21tYW5kLkV4ZWN1dG9yfSAqL1xuICAgIHRoaXMuZXhlY3V0b3JfID0gZXhlY3V0b3JcblxuICAgIC8qKiBAcHJpdmF0ZSB7aW5wdXQuRmlsZURldGVjdG9yfSAqL1xuICAgIHRoaXMuZmlsZURldGVjdG9yXyA9IG51bGxcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyhmdW5jdGlvbih0aGlzOiB2b2lkKTogP3x1bmRlZmluZWQpfSAqL1xuICAgIHRoaXMub25RdWl0XyA9IG9uUXVpdFxuXG4gICAgLyoqIEBwcml2YXRlIHsuL3ZpcnR1YWxfYXV0aGVudGljYXRvcn0qL1xuICAgIHRoaXMuYXV0aGVudGljYXRvcklkXyA9IG51bGxcblxuICAgIHRoaXMucGlubmVkU2NyaXB0c18gPSB7fVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgV2ViRHJpdmVyIHNlc3Npb24uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHdheXMgcmV0dXJuIGEgV2ViRHJpdmVyIGluc3RhbmNlLiBJZiB0aGVyZSBpcyBhbiBlcnJvclxuICAgKiBjcmVhdGluZyB0aGUgc2Vzc2lvbiwgc3VjaCBhcyB0aGUgYWZvcmVtZW50aW9uZWQgU2Vzc2lvbk5vdENyZWF0ZWRFcnJvcixcbiAgICogdGhlIGRyaXZlciB3aWxsIGhhdmUgYSByZWplY3RlZCB7QGxpbmtwbGFpbiAjZ2V0U2Vzc2lvbiBzZXNzaW9ufSBwcm9taXNlLlxuICAgKiBUaGlzIHJlamVjdGlvbiB3aWxsIHByb3BhZ2F0ZSB0aHJvdWdoIGFueSBzdWJzZXF1ZW50IGNvbW1hbmRzIHNjaGVkdWxlZFxuICAgKiBvbiB0aGUgcmV0dXJuZWQgV2ViRHJpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiAgICAgbGV0IHJlcXVpcmVkID0gQ2FwYWJpbGl0aWVzLmZpcmVmb3goKTtcbiAgICogICAgIGxldCBkcml2ZXIgPSBXZWJEcml2ZXIuY3JlYXRlU2Vzc2lvbihleGVjdXRvciwge3JlcXVpcmVkfSk7XG4gICAqXG4gICAqICAgICAvLyBJZiB0aGUgY3JlYXRlU2Vzc2lvbiBvcGVyYXRpb24gZmFpbGVkLCB0aGVuIHRoaXMgY29tbWFuZCB3aWxsIGFsc29cbiAgICogICAgIC8vIGFsc28gZmFpbCwgcHJvcGFnYXRpbmcgdGhlIGNyZWF0aW9uIGZhaWx1cmUuXG4gICAqICAgICBkcml2ZXIuZ2V0KCdodHRwOi8vd3d3Lmdvb2dsZS5jb20nKS5jYXRjaChlID0+IGNvbnNvbGUubG9nKGUpKTtcbiAgICpcbiAgICogQHBhcmFtIHshY29tbWFuZC5FeGVjdXRvcn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIHRvIGNyZWF0ZSB0aGUgbmV3IHNlc3Npb25cbiAgICogICAgIHdpdGguXG4gICAqIEBwYXJhbSB7IUNhcGFiaWxpdGllc30gY2FwYWJpbGl0aWVzIFRoZSBkZXNpcmVkIGNhcGFiaWxpdGllcyBmb3IgdGhlIG5ld1xuICAgKiAgICAgc2Vzc2lvbi5cbiAgICogQHBhcmFtIHsoZnVuY3Rpb24odGhpczogdm9pZCk6ID8pPX0gb25RdWl0IEEgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW5cbiAgICogICAgdGhlIG5ld2x5IGNyZWF0ZWQgc2Vzc2lvbiBpcyB0ZXJtaW5hdGVkLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuXG4gICAqICAgIHVwIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJuIHshV2ViRHJpdmVyfSBUaGUgZHJpdmVyIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBzZXNzaW9uLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVNlc3Npb24oZXhlY3V0b3IsIGNhcGFiaWxpdGllcywgb25RdWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGNtZCA9IG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLk5FV19TRVNTSU9OKVxuXG4gICAgLy8gRm9yIFczQyByZW1vdGUgZW5kcy5cbiAgICBjbWQuc2V0UGFyYW1ldGVyKCdjYXBhYmlsaXRpZXMnLCB7XG4gICAgICBmaXJzdE1hdGNoOiBbe31dLFxuICAgICAgYWx3YXlzTWF0Y2g6IGZpbHRlck5vblczQ0NhcHMoY2FwYWJpbGl0aWVzKSxcbiAgICB9KVxuXG4gICAgbGV0IHNlc3Npb24gPSBleGVjdXRlQ29tbWFuZChleGVjdXRvciwgY21kKVxuICAgIGlmICh0eXBlb2Ygb25RdWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZXNzaW9uID0gc2Vzc2lvbi5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob25RdWl0LmNhbGwodm9pZCAwKSkudGhlbigoXykgPT4ge1xuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKHNlc3Npb24sIGV4ZWN1dG9yLCBvblF1aXQpXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGFzeW5jIGV4ZWN1dGUoY29tbWFuZCkge1xuICAgIGNvbW1hbmQuc2V0UGFyYW1ldGVyKCdzZXNzaW9uSWQnLCB0aGlzLnNlc3Npb25fKVxuXG4gICAgbGV0IHBhcmFtZXRlcnMgPSBhd2FpdCB0b1dpcmVWYWx1ZShjb21tYW5kLmdldFBhcmFtZXRlcnMoKSlcbiAgICBjb21tYW5kLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycylcbiAgICBsZXQgdmFsdWUgPSBhd2FpdCB0aGlzLmV4ZWN1dG9yXy5leGVjdXRlKGNvbW1hbmQpXG4gICAgcmV0dXJuIGZyb21XaXJlVmFsdWUodGhpcywgdmFsdWUpXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHNldEZpbGVEZXRlY3RvcihkZXRlY3Rvcikge1xuICAgIHRoaXMuZmlsZURldGVjdG9yXyA9IGRldGVjdG9yXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldEV4ZWN1dG9yKCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yX1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRTZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb25fXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldENhcGFiaWxpdGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uXy50aGVuKChzKSA9PiBzLmdldENhcGFiaWxpdGllcygpKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBxdWl0KCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmV4ZWN1dGUobmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuUVVJVCkpXG4gICAgLy8gRGVsZXRlIG91ciBzZXNzaW9uIElEIHdoZW4gdGhlIHF1aXQgY29tbWFuZCBmaW5pc2hlczsgdGhpcyB3aWxsIGFsbG93IHVzXG4gICAgLy8gdG8gdGhyb3cgYW4gZXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIHVzZSBhIGRyaXZlciBwb3N0LXF1aXQuXG4gICAgcmV0dXJuIHByb21pc2UuZmluYWxseShyZXN1bHQsICgpID0+IHtcbiAgICAgIHRoaXMuc2Vzc2lvbl8gPSBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IGVycm9yLk5vU3VjaFNlc3Npb25FcnJvcihcbiAgICAgICAgICAnVGhpcyBkcml2ZXIgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHNlc3Npb24gSUQgJyArXG4gICAgICAgICAgICAnKGRpZCB5b3UgY2FsbCBXZWJEcml2ZXIucXVpdCgpPykgYW5kIG1heSBubyBsb25nZXIgYmUgdXNlZC4nXG4gICAgICAgIClcbiAgICAgIClcblxuICAgICAgLy8gT25seSB3YW50IHRoZSBzZXNzaW9uIHJlamVjdGlvbiB0byBidWJibGUgaWYgYWNjZXNzZWQuXG4gICAgICB0aGlzLnNlc3Npb25fLmNhdGNoKGZ1bmN0aW9uICgpIHt9KVxuXG4gICAgICBpZiAodGhpcy5vblF1aXRfKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uUXVpdF8uY2FsbCh2b2lkIDApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgYWN0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBpbnB1dC5BY3Rpb25zKHRoaXMsIG9wdGlvbnMgfHwgdW5kZWZpbmVkKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBleGVjdXRlU2NyaXB0KHNjcmlwdCwgLi4uYXJncykge1xuICAgIGlmICh0eXBlb2Ygc2NyaXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzY3JpcHQgPSAncmV0dXJuICgnICsgc2NyaXB0ICsgJykuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsnXG4gICAgfVxuXG4gICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQgaW5zdGFuY2VvZiBQaW5uZWRTY3JpcHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoXG4gICAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkVYRUNVVEVfU0NSSVBUKVxuICAgICAgICAgIC5zZXRQYXJhbWV0ZXIoJ3NjcmlwdCcsIHNjcmlwdC5leGVjdXRpb25TY3JpcHQoKSlcbiAgICAgICAgICAuc2V0UGFyYW1ldGVyKCdhcmdzJywgYXJncylcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuRVhFQ1VURV9TQ1JJUFQpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ3NjcmlwdCcsIHNjcmlwdClcbiAgICAgICAgLnNldFBhcmFtZXRlcignYXJncycsIGFyZ3MpXG4gICAgKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBleGVjdXRlQXN5bmNTY3JpcHQoc2NyaXB0LCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzY3JpcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNjcmlwdCA9ICdyZXR1cm4gKCcgKyBzY3JpcHQgKyAnKS5hcHBseShudWxsLCBhcmd1bWVudHMpOydcbiAgICB9XG5cbiAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdCBpbnN0YW5jZW9mIFBpbm5lZFNjcmlwdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuRVhFQ1VURV9BU1lOQ19TQ1JJUFQpXG4gICAgICAgICAgLnNldFBhcmFtZXRlcignc2NyaXB0Jywgc2NyaXB0LmV4ZWN1dGlvblNjcmlwdCgpKVxuICAgICAgICAgIC5zZXRQYXJhbWV0ZXIoJ2FyZ3MnLCBhcmdzKVxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5FWEVDVVRFX0FTWU5DX1NDUklQVClcbiAgICAgICAgLnNldFBhcmFtZXRlcignc2NyaXB0Jywgc2NyaXB0KVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCdhcmdzJywgYXJncylcbiAgICApXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHdhaXQoY29uZGl0aW9uLCB0aW1lb3V0ID0gMCwgbWVzc2FnZSA9IHVuZGVmaW5lZCwgcG9sbFRpbWVvdXQgPSAyMDApIHtcbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInIHx8IHRpbWVvdXQgPCAwKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ3RpbWVvdXQgbXVzdCBiZSBhIG51bWJlciA+PSAwOiAnICsgdGltZW91dClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBvbGxUaW1lb3V0ICE9PSAnbnVtYmVyJyB8fCBwb2xsVGltZW91dCA8IDApIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcigncG9sbFRpbWVvdXQgbXVzdCBiZSBhIG51bWJlciA+PSAwOiAnICsgcG9sbFRpbWVvdXQpXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UuaXNQcm9taXNlKGNvbmRpdGlvbikpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgIHJlc29sdmUoY29uZGl0aW9uKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aW1lciA9IG51bGxcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRNZXNzYWdlID0gcmVzb2x2ZVdhaXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBlcnJvci5UaW1lb3V0RXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7dGltZW91dE1lc3NhZ2V9VGltZWQgb3V0IHdhaXRpbmcgZm9yIHByb21pc2UgdG8gcmVzb2x2ZSBhZnRlciAke1xuICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSAtIHN0YXJ0XG4gICAgICAgICAgICAgICAgfW1zYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IGVycm9yLlRpbWVvdXRFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICAgIGV4Lm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9XFxuVGltZWQgb3V0IHdhaXRpbmcgZm9yIHByb21pc2UgdG8gcmVzb2x2ZSBhZnRlciAke1xuICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSAtIHN0YXJ0XG4gICAgICAgICAgICAgICAgfW1zYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0KVxuICAgICAgICBjb25zdCBjbGVhclRpbWVyID0gKCkgPT4gdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7IUlUaGVuYWJsZX0gKi8gY29uZGl0aW9uLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVyKClcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZXIoKVxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsZXQgZm4gPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8gKGNvbmRpdGlvbilcbiAgICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgQ29uZGl0aW9uKSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBjb25kaXRpb24uZGVzY3JpcHRpb24oKVxuICAgICAgZm4gPSBjb25kaXRpb24uZm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAgICdXYWl0IGNvbmRpdGlvbiBtdXN0IGJlIGEgcHJvbWlzZS1saWtlIG9iamVjdCwgZnVuY3Rpb24sIG9yIGEgJyArXG4gICAgICAgICAgJ0NvbmRpdGlvbiBvYmplY3QnXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgZHJpdmVyID0gdGhpc1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlQ29uZGl0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNvbHZlKGZuKGRyaXZlcikpXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgICBjb25zdCBwb2xsQ29uZGl0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBldmFsdWF0ZUNvbmRpdGlvbigpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmICh0aW1lb3V0ICYmIGVsYXBzZWQgPj0gdGltZW91dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IHRpbWVvdXRNZXNzYWdlID0gcmVzb2x2ZVdhaXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgZXJyb3IuVGltZW91dEVycm9yKFxuICAgICAgICAgICAgICAgICAgYCR7dGltZW91dE1lc3NhZ2V9V2FpdCB0aW1lZCBvdXQgYWZ0ZXIgJHtlbGFwc2VkfW1zYFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBlcnJvci5UaW1lb3V0RXJyb3IoXG4gICAgICAgICAgICAgICAgICBgJHtleC5tZXNzYWdlfVxcbldhaXQgdGltZWQgb3V0IGFmdGVyICR7ZWxhcHNlZH1tc2BcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChwb2xsQ29uZGl0aW9uLCBwb2xsVGltZW91dClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHJlamVjdClcbiAgICAgIH1cbiAgICAgIHBvbGxDb25kaXRpb24oKVxuICAgIH0pXG5cbiAgICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgV2ViRWxlbWVudENvbmRpdGlvbikge1xuICAgICAgcmVzdWx0ID0gbmV3IFdlYkVsZW1lbnRQcm9taXNlKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFdlYkVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICdXZWJFbGVtZW50Q29uZGl0aW9uIGRpZCBub3QgcmVzb2x2ZSB0byBhIFdlYkVsZW1lbnQ6ICcgK1xuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgc2xlZXAobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRXaW5kb3dIYW5kbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkdFVF9DVVJSRU5UX1dJTkRPV19IQU5ETEUpXG4gICAgKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRBbGxXaW5kb3dIYW5kbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUobmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX1dJTkRPV19IQU5ETEVTKSlcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0UGFnZVNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkdFVF9QQUdFX1NPVVJDRSkpXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGNsb3NlKCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUobmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuQ0xPU0UpKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXQodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdGUoKS50byh1cmwpXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldEN1cnJlbnRVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5HRVRfQ1VSUkVOVF9VUkwpKVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkdFVF9USVRMRSkpXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGZpbmRFbGVtZW50KGxvY2F0b3IpIHtcbiAgICBsZXQgaWRcbiAgICBsZXQgY21kID0gbnVsbFxuXG4gICAgaWYgKGxvY2F0b3IgaW5zdGFuY2VvZiBSZWxhdGl2ZUJ5KSB7XG4gICAgICBjbWQgPSBuZXcgY29tbWFuZC5Db21tYW5kKFxuICAgICAgICBjb21tYW5kLk5hbWUuRklORF9FTEVNRU5UU19SRUxBVElWRVxuICAgICAgKS5zZXRQYXJhbWV0ZXIoJ2FyZ3MnLCBsb2NhdG9yLm1hcnNoYWxsKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0b3IgPSBieS5jaGVja2VkTG9jYXRvcihsb2NhdG9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbG9jYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWQgPSB0aGlzLmZpbmRFbGVtZW50SW50ZXJuYWxfKGxvY2F0b3IsIHRoaXMpXG4gICAgICByZXR1cm4gbmV3IFdlYkVsZW1lbnRQcm9taXNlKHRoaXMsIGlkKVxuICAgIH0gZWxzZSBpZiAoY21kID09PSBudWxsKSB7XG4gICAgICBjbWQgPSBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5GSU5EX0VMRU1FTlQpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ3VzaW5nJywgbG9jYXRvci51c2luZylcbiAgICAgICAgLnNldFBhcmFtZXRlcigndmFsdWUnLCBsb2NhdG9yLnZhbHVlKVxuICAgIH1cblxuICAgIGlkID0gdGhpcy5leGVjdXRlKGNtZClcbiAgICBpZiAobG9jYXRvciBpbnN0YW5jZW9mIFJlbGF0aXZlQnkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZV8oaWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgV2ViRWxlbWVudFByb21pc2UodGhpcywgaWQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSB3ZWJFbGVtZW50UHJvbWlzZSBUaGUgd2ViRWxlbWVudCBpbiB1bnJlc29sdmVkIHN0YXRlXG4gICAqIEByZXR1cm4geyFQcm9taXNlPCFXZWJFbGVtZW50Pn0gRmlyc3Qgc2luZ2xlIFdlYkVsZW1lbnQgZnJvbSBhcnJheSBvZiByZXNvbHZlZCBwcm9taXNlc1xuICAgKi9cbiAgYXN5bmMgbm9ybWFsaXplXyh3ZWJFbGVtZW50UHJvbWlzZSkge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCB3ZWJFbGVtZW50UHJvbWlzZVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoRWxlbWVudEVycm9yKFxuICAgICAgICAnQ2Fubm90IGxvY2F0ZSBhbiBlbGVtZW50IHdpdGggcHJvdmlkZWQgcGFyYW1ldGVycydcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdFswXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbG9jYXRvckZuIFRoZSBsb2NhdG9yIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHshKFdlYkRyaXZlcnxXZWJFbGVtZW50KX0gY29udGV4dCBUaGUgc2VhcmNoIGNvbnRleHQuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPCFXZWJFbGVtZW50Pn0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIGEgbGlzdCBvZlxuICAgKiAgICAgV2ViRWxlbWVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBmaW5kRWxlbWVudEludGVybmFsXyhsb2NhdG9yRm4sIGNvbnRleHQpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbG9jYXRvckZuKGNvbnRleHQpXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdXG4gICAgfVxuICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIFdlYkVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDdXN0b20gbG9jYXRvciBkaWQgbm90IHJldHVybiBhIFdlYkVsZW1lbnQnKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGFzeW5jIGZpbmRFbGVtZW50cyhsb2NhdG9yKSB7XG4gICAgbGV0IGNtZCA9IG51bGxcbiAgICBpZiAobG9jYXRvciBpbnN0YW5jZW9mIFJlbGF0aXZlQnkpIHtcbiAgICAgIGNtZCA9IG5ldyBjb21tYW5kLkNvbW1hbmQoXG4gICAgICAgIGNvbW1hbmQuTmFtZS5GSU5EX0VMRU1FTlRTX1JFTEFUSVZFXG4gICAgICApLnNldFBhcmFtZXRlcignYXJncycsIGxvY2F0b3IubWFyc2hhbGwoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRvciA9IGJ5LmNoZWNrZWRMb2NhdG9yKGxvY2F0b3IpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb2NhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kRWxlbWVudHNJbnRlcm5hbF8obG9jYXRvciwgdGhpcylcbiAgICB9IGVsc2UgaWYgKGNtZCA9PT0gbnVsbCkge1xuICAgICAgY21kID0gbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuRklORF9FTEVNRU5UUylcbiAgICAgICAgLnNldFBhcmFtZXRlcigndXNpbmcnLCBsb2NhdG9yLnVzaW5nKVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCd2YWx1ZScsIGxvY2F0b3IudmFsdWUpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzID0gYXdhaXQgdGhpcy5leGVjdXRlKGNtZClcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcykgPyByZXMgOiBbXVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBlcnJvci5Ob1N1Y2hFbGVtZW50RXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG4gICAgICB0aHJvdyBleFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbG9jYXRvckZuIFRoZSBsb2NhdG9yIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHshKFdlYkRyaXZlcnxXZWJFbGVtZW50KX0gY29udGV4dCBUaGUgc2VhcmNoIGNvbnRleHQuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPCFBcnJheTwhV2ViRWxlbWVudD4+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gYW5cbiAgICogICAgIGFycmF5IG9mIFdlYkVsZW1lbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgZmluZEVsZW1lbnRzSW50ZXJuYWxfKGxvY2F0b3JGbiwgY29udGV4dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2F0b3JGbihjb250ZXh0KVxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBXZWJFbGVtZW50KSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdF1cbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgV2ViRWxlbWVudFxuICAgIH0pXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHRha2VTY3JlZW5zaG90KCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUobmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuU0NSRUVOU0hPVCkpXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIG1hbmFnZSgpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbnModGhpcylcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgbmF2aWdhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uKHRoaXMpXG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHN3aXRjaFRvKCkge1xuICAgIHJldHVybiBuZXcgVGFyZ2V0TG9jYXRvcih0aGlzKVxuICB9XG5cbiAgdmFsaWRhdGVQcmludFBhZ2VQYXJhbXMoa2V5cywgb2JqZWN0KSB7XG4gICAgbGV0IHBhZ2UgPSB7fVxuICAgIGxldCBtYXJnaW4gPSB7fVxuICAgIGxldCBkYXRhXG4gICAgT2JqZWN0LmtleXMoa2V5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBkYXRhID0ga2V5c1trZXldXG4gICAgICBsZXQgb2JqID0ge1xuICAgICAgICBvcmllbnRhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9iamVjdC5vcmllbnRhdGlvbiA9IGRhdGFcbiAgICAgICAgfSxcblxuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9iamVjdC5zY2FsZSA9IGRhdGFcbiAgICAgICAgfSxcblxuICAgICAgICBiYWNrZ3JvdW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JqZWN0LmJhY2tncm91bmQgPSBkYXRhXG4gICAgICAgIH0sXG5cbiAgICAgICAgd2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwYWdlLndpZHRoID0gZGF0YVxuICAgICAgICAgIG9iamVjdC5wYWdlID0gcGFnZVxuICAgICAgICB9LFxuXG4gICAgICAgIGhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBhZ2UuaGVpZ2h0ID0gZGF0YVxuICAgICAgICAgIG9iamVjdC5wYWdlID0gcGFnZVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmdpbi50b3AgPSBkYXRhXG4gICAgICAgICAgb2JqZWN0Lm1hcmdpbiA9IG1hcmdpblxuICAgICAgICB9LFxuXG4gICAgICAgIGxlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXJnaW4ubGVmdCA9IGRhdGFcbiAgICAgICAgICBvYmplY3QubWFyZ2luID0gbWFyZ2luXG4gICAgICAgIH0sXG5cbiAgICAgICAgYm90dG9tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IGRhdGFcbiAgICAgICAgICBvYmplY3QubWFyZ2luID0gbWFyZ2luXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXJnaW4ucmlnaHQgPSBkYXRhXG4gICAgICAgICAgb2JqZWN0Lm1hcmdpbiA9IG1hcmdpblxuICAgICAgICB9LFxuXG4gICAgICAgIHNocmlua1RvRml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JqZWN0LnNocmlua1RvRml0ID0gZGF0YVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhZ2VSYW5nZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYmplY3QucGFnZVJhbmdlcyA9IGRhdGFcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvci5JbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCBBcmd1bWVudCAnJHtrZXl9J2ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBvYmplY3RcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgcHJpbnRQYWdlKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBrZXlzID0gb3B0aW9uc1xuICAgIGxldCBwYXJhbXMgPSB7fVxuICAgIGxldCByZXN1bHRPYmpcblxuICAgIGxldCBzZWxmID0gdGhpc1xuICAgIHJlc3VsdE9iaiA9IHNlbGYudmFsaWRhdGVQcmludFBhZ2VQYXJhbXMoa2V5cywgcGFyYW1zKVxuXG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLlBSSU5UX1BBR0UpLnNldFBhcmFtZXRlcnMocmVzdWx0T2JqKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxyZXNvbHZlZD59IEEgbmV3IENEUCBpbnN0YW5jZS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNEUENvbm5lY3Rpb24odGFyZ2V0KSB7XG4gICAgbGV0IGRlYnVnZ2VyVXJsID0gbnVsbFxuXG4gICAgY29uc3QgY2FwcyA9IGF3YWl0IHRoaXMuZ2V0Q2FwYWJpbGl0aWVzKClcblxuICAgIGlmIChwcm9jZXNzLmVudi5TRUxFTklVTV9SRU1PVEVfVVJMKSB7XG4gICAgICBjb25zdCBob3N0ID0gbmV3IFVSTChwcm9jZXNzLmVudi5TRUxFTklVTV9SRU1PVEVfVVJMKS5ob3N0XG4gICAgICBjb25zdCBzZXNzaW9uSWQgPSBhd2FpdCB0aGlzLmdldFNlc3Npb24oKS50aGVuKChzZXNzaW9uKSA9PlxuICAgICAgICBzZXNzaW9uLmdldElkKClcbiAgICAgIClcbiAgICAgIGRlYnVnZ2VyVXJsID0gYHdzOi8vJHtob3N0fS9zZXNzaW9uLyR7c2Vzc2lvbklkfS9zZS9jZHBgXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlQ2RwID0gY2Fwc1snbWFwXyddLmdldCgnc2U6Y2RwJylcbiAgICAgIGNvbnN0IHZlbmRvckluZm8gPVxuICAgICAgICBjYXBzWydtYXBfJ10uZ2V0KHRoaXMuVkVORE9SX0NPTU1BTkRfUFJFRklYICsgJzpjaHJvbWVPcHRpb25zJykgfHxcbiAgICAgICAgY2Fwc1snbWFwXyddLmdldCh0aGlzLlZFTkRPUl9DQVBBQklMSVRZX1BSRUZJWCArICc6ZWRnZU9wdGlvbnMnKSB8fFxuICAgICAgICBjYXBzWydtYXBfJ10uZ2V0KCdtb3o6ZGVidWdnZXJBZGRyZXNzJykgfHxcbiAgICAgICAgbmV3IE1hcCgpXG4gICAgICBkZWJ1Z2dlclVybCA9IHNlQ2RwIHx8IHZlbmRvckluZm9bJ2RlYnVnZ2VyQWRkcmVzcyddIHx8IHZlbmRvckluZm9cbiAgICB9XG4gICAgdGhpcy5fd3NVcmwgPSBhd2FpdCB0aGlzLmdldFdzVXJsKGRlYnVnZ2VyVXJsLCB0YXJnZXQsIGNhcHMpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3dzQ29ubmVjdGlvbiA9IG5ldyBXZWJTb2NrZXQoXG4gICAgICAgICAgdGhpcy5fd3NVcmwucmVwbGFjZSgnbG9jYWxob3N0JywgJzEyNy4wLjAuMScpXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5fY2RwQ29ubmVjdGlvbiA9IG5ldyBjZHAuQ2RwQ29ubmVjdGlvbih0aGlzLl93c0Nvbm5lY3Rpb24pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dzQ29ubmVjdGlvbi5vbignb3BlbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXRDZHBUYXJnZXRzKClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuX3dzQ29ubmVjdGlvbi5vbignbWVzc2FnZScsIGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgICAgICAgaWYgKHBhcmFtcy5yZXN1bHQpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLnJlc3VsdC50YXJnZXRJbmZvcykge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0cyA9IHBhcmFtcy5yZXN1bHQudGFyZ2V0SW5mb3NcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSB0YXJnZXRzLmZpbmQoKGluZm8pID0+IGluZm8udHlwZSA9PT0gJ3BhZ2UnKVxuICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy50YXJnZXRJRCA9IHBhZ2UudGFyZ2V0SWRcbiAgICAgICAgICAgICAgdGhpcy5fY2RwQ29ubmVjdGlvbi5leGVjdXRlKFxuICAgICAgICAgICAgICAgICdUYXJnZXQuYXR0YWNoVG9UYXJnZXQnLFxuICAgICAgICAgICAgICAgIHsgdGFyZ2V0SWQ6IHRoaXMudGFyZ2V0SUQsIGZsYXR0ZW46IHRydWUgfSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdCgnVW5hYmxlIHRvIGZpbmQgUGFnZSB0YXJnZXQuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmFtcy5yZXN1bHQuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHBhcmFtcy5yZXN1bHQuc2Vzc2lvbklkXG4gICAgICAgICAgICB0aGlzLl9jZHBDb25uZWN0aW9uLnNlc3Npb25JZCA9IHRoaXMuc2Vzc2lvbklkXG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX2NkcENvbm5lY3Rpb24pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLl93c0Nvbm5lY3Rpb24ub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGdldENkcFRhcmdldHMoKSB7XG4gICAgdGhpcy5fY2RwQ29ubmVjdGlvbi5leGVjdXRlKCdUYXJnZXQuZ2V0VGFyZ2V0cycpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGJpZGkgY29ubmVjdGlvbiB1c2luZyAnd2ViU29ja2V0VXJsJ1xuICAgKiBAcmV0dXJucyB7QklESX1cbiAgICovXG4gIGFzeW5jIGdldEJpZGkoKSB7XG4gICAgY29uc3QgY2FwcyA9IGF3YWl0IHRoaXMuZ2V0Q2FwYWJpbGl0aWVzKClcbiAgICBsZXQgV2ViU29ja2V0VXJsID0gY2Fwc1snbWFwXyddLmdldCgnd2ViU29ja2V0VXJsJylcbiAgICByZXR1cm4gbmV3IEJJREkoV2ViU29ja2V0VXJsLnJlcGxhY2UoJ2xvY2FsaG9zdCcsICcxMjcuMC4wLjEnKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgJ3dlYlNvY2tldERlYnVnZ2VyVXJsJyBieSBzZW5kaW5nIGEgaHR0cCByZXF1ZXN0IHVzaW5nIGRlYnVnZ2VyIGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRlYnVnZ2VyQWRkcmVzc1xuICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAqIEBwYXJhbSBjYXBzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyBwYXJzZWQgd2ViU29ja2V0RGVidWdnZXJVcmwgb2J0YWluZWQgZnJvbSB0aGUgaHR0cCByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBnZXRXc1VybChkZWJ1Z2dlckFkZHJlc3MsIHRhcmdldCwgY2Fwcykge1xuICAgIGlmICh0YXJnZXQgJiYgY2RwVGFyZ2V0cy5pbmRleE9mKHRhcmdldC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvci5JbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB0YXJnZXQgdmFsdWUnKVxuICAgIH1cblxuICAgIGlmIChkZWJ1Z2dlckFkZHJlc3MubWF0Y2goL1xcL3NlXFwvY2RwLykpIHtcbiAgICAgIHJldHVybiBkZWJ1Z2dlckFkZHJlc3NcbiAgICB9XG5cbiAgICBsZXQgcGF0aFxuICAgIGlmICh0YXJnZXQgPT09ICdwYWdlJyAmJiBjYXBzWydtYXBfJ10uZ2V0KCdicm93c2VyTmFtZScpICE9PSAnZmlyZWZveCcpIHtcbiAgICAgIHBhdGggPSAnL2pzb24nXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRhcmdldCA9PT0gJ3BhZ2UnICYmXG4gICAgICBjYXBzWydtYXBfJ10uZ2V0KCdicm93c2VyTmFtZScpID09PSAnZmlyZWZveCdcbiAgICApIHtcbiAgICAgIHBhdGggPSAnL2pzb24vbGlzdCdcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9ICcvanNvbi92ZXJzaW9uJ1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IGh0dHAuUmVxdWVzdCgnR0VUJywgcGF0aClcbiAgICBsZXQgY2xpZW50ID0gbmV3IGh0dHAuSHR0cENsaWVudCgnaHR0cDovLycgKyBkZWJ1Z2dlckFkZHJlc3MpXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnNlbmQocmVxdWVzdClcblxuICAgIGlmICh0YXJnZXQudG9Mb3dlckNhc2UoKSA9PT0gJ3BhZ2UnKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KVswXVsnd2ViU29ja2V0RGVidWdnZXJVcmwnXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KVsnd2ViU29ja2V0RGVidWdnZXJVcmwnXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbGlzdGVuZXIgZm9yIEZldGNoLmF1dGhSZXF1aXJlZCBldmVudCBmcm9tIENEUFxuICAgKiBJZiBldmVudCBpcyB0cmlnZ2VyZWQsIGl0IGVudGVycyB1c2VybmFtZSBhbmQgcGFzc3dvcmRcbiAgICogYW5kIGFsbG93cyB0aGUgdGVzdCB0byBtb3ZlIGZvcndhcmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBDRFAgQ29ubmVjdGlvblxuICAgKi9cbiAgYXN5bmMgcmVnaXN0ZXIodXNlcm5hbWUsIHBhc3N3b3JkLCBjb25uZWN0aW9uKSB7XG4gICAgdGhpcy5fd3NDb25uZWN0aW9uLm9uKCdtZXNzYWdlJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IEpTT04ucGFyc2UobWVzc2FnZSlcblxuICAgICAgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdGZXRjaC5hdXRoUmVxdWlyZWQnKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBwYXJhbXNbJ3BhcmFtcyddXG4gICAgICAgIGNvbm5lY3Rpb24uZXhlY3V0ZSgnRmV0Y2guY29udGludWVXaXRoQXV0aCcsIHtcbiAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RQYXJhbXNbJ3JlcXVlc3RJZCddLFxuICAgICAgICAgIGF1dGhDaGFsbGVuZ2VSZXNwb25zZToge1xuICAgICAgICAgICAgcmVzcG9uc2U6ICdQcm92aWRlQ3JlZGVudGlhbHMnLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdGZXRjaC5yZXF1ZXN0UGF1c2VkJykge1xuICAgICAgICBjb25zdCByZXF1ZXN0UGF1c2VkUGFyYW1zID0gcGFyYW1zWydwYXJhbXMnXVxuICAgICAgICBjb25uZWN0aW9uLmV4ZWN1dGUoJ0ZldGNoLmNvbnRpbnVlUmVxdWVzdCcsIHtcbiAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RQYXVzZWRQYXJhbXNbJ3JlcXVlc3RJZCddLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoXG4gICAgICAnRmV0Y2guZW5hYmxlJyxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlQXV0aFJlcXVlc3RzOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIG51bGxcbiAgICApXG4gICAgYXdhaXQgY29ubmVjdGlvbi5leGVjdXRlKFxuICAgICAgJ05ldHdvcmsuc2V0Q2FjaGVEaXNhYmxlZCcsXG4gICAgICB7XG4gICAgICAgIGNhY2hlRGlzYWJsZWQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgbnVsbFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgTmV0d29yayBpbnRlcmNlcHRpb24gcmVxdWVzdHNcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIGh0dHBSZXNwb25zZSBPYmplY3QgcmVwcmVzZW50aW5nIHdoYXQgd2UgYXJlIGludGVyY2VwdGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFzIHdlbGwgYXMgd2hhdCBzaG91bGQgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBjYWxsYmFjayBjYWxsZWQgd2hlbiB3ZSBpbnRlcmNlcHQgcmVxdWVzdHMuXG4gICAqL1xuICBhc3luYyBvbkludGVyY2VwdChjb25uZWN0aW9uLCBodHRwUmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fd3NDb25uZWN0aW9uLm9uKCdtZXNzYWdlJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgICAgIGlmIChwYXJhbXMubWV0aG9kID09PSAnRmV0Y2gucmVxdWVzdFBhdXNlZCcpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhdXNlZFBhcmFtcyA9IHBhcmFtc1sncGFyYW1zJ11cbiAgICAgICAgaWYgKHJlcXVlc3RQYXVzZWRQYXJhbXMucmVxdWVzdC51cmwgPT0gaHR0cFJlc3BvbnNlLnVybFRvSW50ZXJjZXB0KSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5leGVjdXRlKCdGZXRjaC5mdWxmaWxsUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdFBhdXNlZFBhcmFtc1sncmVxdWVzdElkJ10sXG4gICAgICAgICAgICByZXNwb25zZUNvZGU6IGh0dHBSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogaHR0cFJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5leGVjdXRlKCdGZXRjaC5jb250aW51ZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RQYXVzZWRQYXJhbXNbJ3JlcXVlc3RJZCddLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgYXdhaXQgY29ubmVjdGlvbi5leGVjdXRlKCdGZXRjaC5lbmFibGUnLCB7fSwgbnVsbClcbiAgICBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoXG4gICAgICAnTmV0d29yay5zZXRDYWNoZURpc2FibGVkJyxcbiAgICAgIHtcbiAgICAgICAgY2FjaGVEaXNhYmxlZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBudWxsXG4gICAgKVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBvbkxvZ0V2ZW50KGNvbm5lY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fd3NDb25uZWN0aW9uLm9uKCdtZXNzYWdlJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgICAgIGlmIChwYXJhbXMubWV0aG9kID09PSAnUnVudGltZS5jb25zb2xlQVBJQ2FsbGVkJykge1xuICAgICAgICBjb25zdCBjb25zb2xlRXZlbnRQYXJhbXMgPSBwYXJhbXNbJ3BhcmFtcyddXG4gICAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBjb25zb2xlRXZlbnRQYXJhbXNbJ3R5cGUnXSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKGNvbnNvbGVFdmVudFBhcmFtc1sndGltZXN0YW1wJ10pLFxuICAgICAgICAgIGFyZ3M6IGNvbnNvbGVFdmVudFBhcmFtc1snYXJncyddLFxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXZlbnQpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMubWV0aG9kID09PSAnTG9nLmVudHJ5QWRkZWQnKSB7XG4gICAgICAgIGNvbnN0IGxvZ0V2ZW50UGFyYW1zID0gcGFyYW1zWydwYXJhbXMnXVxuICAgICAgICBjb25zdCBsb2dFbnRyeSA9IGxvZ0V2ZW50UGFyYW1zWydlbnRyeSddXG4gICAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgICBsZXZlbDogbG9nRW50cnlbJ2xldmVsJ10sXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShsb2dFbnRyeVsndGltZXN0YW1wJ10pLFxuICAgICAgICAgIG1lc3NhZ2U6IGxvZ0VudHJ5Wyd0ZXh0J10sXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhldmVudClcbiAgICAgIH1cbiAgICB9KVxuICAgIGF3YWl0IGNvbm5lY3Rpb24uZXhlY3V0ZSgnUnVudGltZS5lbmFibGUnLCB7fSwgbnVsbClcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBvbkxvZ0V4Y2VwdGlvbihjb25uZWN0aW9uLCBjYWxsYmFjaykge1xuICAgIGF3YWl0IGNvbm5lY3Rpb24uZXhlY3V0ZSgnUnVudGltZS5lbmFibGUnLCB7fSwgbnVsbClcblxuICAgIHRoaXMuX3dzQ29ubmVjdGlvbi5vbignbWVzc2FnZScsIChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBKU09OLnBhcnNlKG1lc3NhZ2UpXG5cbiAgICAgIGlmIChwYXJhbXMubWV0aG9kID09PSAnUnVudGltZS5leGNlcHRpb25UaHJvd24nKSB7XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbkV2ZW50UGFyYW1zID0gcGFyYW1zWydwYXJhbXMnXVxuICAgICAgICBsZXQgZXZlbnQgPSB7XG4gICAgICAgICAgZXhjZXB0aW9uRGV0YWlsczogZXhjZXB0aW9uRXZlbnRQYXJhbXNbJ2V4Y2VwdGlvbkRldGFpbHMnXSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKGV4Y2VwdGlvbkV2ZW50UGFyYW1zWyd0aW1lc3RhbXAnXSksXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhldmVudClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGxvZ011dGF0aW9uRXZlbnRzKGNvbm5lY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgYXdhaXQgY29ubmVjdGlvbi5leGVjdXRlKCdSdW50aW1lLmVuYWJsZScsIHt9LCBudWxsKVxuICAgIGF3YWl0IGNvbm5lY3Rpb24uZXhlY3V0ZSgnUGFnZS5lbmFibGUnLCB7fSwgbnVsbClcblxuICAgIGF3YWl0IGNvbm5lY3Rpb24uZXhlY3V0ZShcbiAgICAgICdSdW50aW1lLmFkZEJpbmRpbmcnLFxuICAgICAge1xuICAgICAgICBuYW1lOiAnX193ZWJkcml2ZXJfYXR0cmlidXRlJyxcbiAgICAgIH0sXG4gICAgICBudWxsXG4gICAgKVxuXG4gICAgbGV0IG11dGF0aW9uTGlzdGVuZXIgPSAnJ1xuICAgIHRyeSB7XG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hhdCBpcyBydW5uaW5nIHRoZSBjb2RlIGl0IGNvdWxkIGFwcGVhciBpbiAyIGRpZmZlcmVudCBwbGFjZXMgd2hpY2ggaXMgd2h5IHdlIHRyeVxuICAgICAgLy8gaGVyZSBhbmQgdGhlbiB0aGUgb3RoZXIgbG9jYXRpb25cbiAgICAgIG11dGF0aW9uTGlzdGVuZXIgPSBmc1xuICAgICAgICAucmVhZEZpbGVTeW5jKFxuICAgICAgICAgICcuL2phdmFzY3JpcHQvbm9kZS9zZWxlbml1bS13ZWJkcml2ZXIvbGliL2F0b21zL211dGF0aW9uLWxpc3RlbmVyLmpzJyxcbiAgICAgICAgICAndXRmLTgnXG4gICAgICAgIClcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICB9IGNhdGNoIHtcbiAgICAgIG11dGF0aW9uTGlzdGVuZXIgPSBmc1xuICAgICAgICAucmVhZEZpbGVTeW5jKFxuICAgICAgICAgIHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuL2F0b21zL211dGF0aW9uLWxpc3RlbmVyLmpzJyksXG4gICAgICAgICAgJ3V0Zi04J1xuICAgICAgICApXG4gICAgICAgIC50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdGhpcy5leGVjdXRlU2NyaXB0KG11dGF0aW9uTGlzdGVuZXIpXG5cbiAgICBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoXG4gICAgICAnUGFnZS5hZGRTY3JpcHRUb0V2YWx1YXRlT25OZXdEb2N1bWVudCcsXG4gICAgICB7XG4gICAgICAgIHNvdXJjZTogbXV0YXRpb25MaXN0ZW5lcixcbiAgICAgIH0sXG4gICAgICBudWxsXG4gICAgKVxuXG4gICAgdGhpcy5fd3NDb25uZWN0aW9uLm9uKCdtZXNzYWdlJywgYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgICAgIGlmIChwYXJhbXMubWV0aG9kID09PSAnUnVudGltZS5iaW5kaW5nQ2FsbGVkJykge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IEpTT04ucGFyc2UocGFyYW1zWydwYXJhbXMnXVsncGF5bG9hZCddKVxuICAgICAgICBsZXQgZWxlbWVudHMgPSBhd2FpdCB0aGlzLmZpbmRFbGVtZW50cyh7XG4gICAgICAgICAgY3NzOiAnKltkYXRhLV9fd2ViZHJpdmVyX2lkPScgKyBieS5lc2NhcGVDc3MocGF5bG9hZFsndGFyZ2V0J10pICsgJ10nLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50c1swXSxcbiAgICAgICAgICBhdHRyaWJ1dGVfbmFtZTogcGF5bG9hZFsnbmFtZSddLFxuICAgICAgICAgIGN1cnJlbnRfdmFsdWU6IHBheWxvYWRbJ3ZhbHVlJ10sXG4gICAgICAgICAgb2xkX3ZhbHVlOiBwYXlsb2FkWydvbGRWYWx1ZSddLFxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBwaW5TY3JpcHQoc2NyaXB0KSB7XG4gICAgbGV0IHBpbm5lZFNjcmlwdCA9IG5ldyBQaW5uZWRTY3JpcHQoc2NyaXB0KVxuICAgIGxldCBjb25uZWN0aW9uXG4gICAgaWYgKE9iamVjdC5pcyh0aGlzLl9jZHBDb25uZWN0aW9uLCB1bmRlZmluZWQpKSB7XG4gICAgICBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5jcmVhdGVDRFBDb25uZWN0aW9uKCdwYWdlJylcbiAgICB9IGVsc2Uge1xuICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2NkcENvbm5lY3Rpb25cbiAgICB9XG5cbiAgICBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoJ1BhZ2UuZW5hYmxlJywge30sIG51bGwpXG5cbiAgICBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoXG4gICAgICAnUnVudGltZS5ldmFsdWF0ZScsXG4gICAgICB7XG4gICAgICAgIGV4cHJlc3Npb246IHBpbm5lZFNjcmlwdC5jcmVhdGlvblNjcmlwdCgpLFxuICAgICAgfSxcbiAgICAgIG51bGxcbiAgICApXG5cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kKFxuICAgICAgJ1BhZ2UuYWRkU2NyaXB0VG9FdmFsdWF0ZU9uTmV3RG9jdW1lbnQnLFxuICAgICAge1xuICAgICAgICBzb3VyY2U6IHBpbm5lZFNjcmlwdC5jcmVhdGlvblNjcmlwdCgpLFxuICAgICAgfVxuICAgIClcblxuICAgIHBpbm5lZFNjcmlwdC5zY3JpcHRJZCA9IHJlc3VsdFsncmVzdWx0J11bJ2lkZW50aWZpZXInXVxuXG4gICAgdGhpcy5waW5uZWRTY3JpcHRzX1twaW5uZWRTY3JpcHQuaGFuZGxlXSA9IHBpbm5lZFNjcmlwdFxuXG4gICAgcmV0dXJuIHBpbm5lZFNjcmlwdFxuICB9XG5cbiAgYXN5bmMgdW5waW5TY3JpcHQoc2NyaXB0KSB7XG4gICAgaWYgKHNjcmlwdCAmJiAhKHNjcmlwdCBpbnN0YW5jZW9mIFBpbm5lZFNjcmlwdCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBQYXNzIHZhbGlkIFBpbm5lZFNjcmlwdCBvYmplY3QuIFJlY2VpdmVkOiAke3NjcmlwdH1gKVxuICAgIH1cblxuICAgIGlmIChzY3JpcHQuaGFuZGxlIGluIHRoaXMucGlubmVkU2NyaXB0c18pIHtcbiAgICAgIGxldCBjb25uZWN0aW9uXG4gICAgICBpZiAoT2JqZWN0LmlzKHRoaXMuX2NkcENvbm5lY3Rpb24sIHVuZGVmaW5lZCkpIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IHRoaXMuY3JlYXRlQ0RQQ29ubmVjdGlvbigncGFnZScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY2RwQ29ubmVjdGlvblxuICAgICAgfVxuXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoJ1BhZ2UuZW5hYmxlJywge30sIG51bGwpXG5cbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uZXhlY3V0ZShcbiAgICAgICAgJ1J1bnRpbWUuZXZhbHVhdGUnLFxuICAgICAgICB7XG4gICAgICAgICAgZXhwcmVzc2lvbjogc2NyaXB0LnJlbW92YWxTY3JpcHQoKSxcbiAgICAgICAgfSxcbiAgICAgICAgbnVsbFxuICAgICAgKVxuXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoXG4gICAgICAgICdQYWdlLnJlbW92ZVNjcmlwdFRvRXZhbHVhdGVPbkxvYWQnLFxuICAgICAgICB7XG4gICAgICAgICAgaWRlbnRpZmllcjogc2NyaXB0LnNjcmlwdElkLFxuICAgICAgICB9LFxuICAgICAgICBudWxsXG4gICAgICApXG5cbiAgICAgIGRlbGV0ZSB0aGlzLnBpbm5lZFNjcmlwdHNfW3NjcmlwdC5oYW5kbGVdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiBhdXRoZW50aWNhdG9yIElEIGFkZGVkXG4gICAqL1xuICB2aXJ0dWFsQXV0aGVudGljYXRvcklkKCkge1xuICAgIHJldHVybiB0aGlzLmF1dGhlbnRpY2F0b3JJZF9cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmlydHVhbCBhdXRoZW50aWNhdG9yIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIFZpcnR1YWxBdXRoZW50aWNhdG9yT3B0aW9ucyBvYmplY3QgdG8gc2V0IGF1dGhlbnRpY2F0b3Igb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGFkZFZpcnR1YWxBdXRoZW50aWNhdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmF1dGhlbnRpY2F0b3JJZF8gPSBhd2FpdCB0aGlzLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5BRERfVklSVFVBTF9BVVRIRU5USUNBVE9SKS5zZXRQYXJhbWV0ZXJzKFxuICAgICAgICBvcHRpb25zLnRvRGljdCgpXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIHZpcnR1YWwgYXV0aGVudGljYXRvci4gVGhlIGF1dGhlbnRpY2F0b3IgaXMgbm9cbiAgICogbG9uZ2VyIHZhbGlkIGFmdGVyIHJlbW92YWwsIHNvIG5vIG1ldGhvZHMgbWF5IGJlIGNhbGxlZC5cbiAgICovXG4gIGFzeW5jIHJlbW92ZVZpcnR1YWxBdXRoZW50aWNhdG9yKCkge1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoXG4gICAgICAgIGNvbW1hbmQuTmFtZS5SRU1PVkVfVklSVFVBTF9BVVRIRU5USUNBVE9SXG4gICAgICApLnNldFBhcmFtZXRlcignYXV0aGVudGljYXRvcklkJywgdGhpcy5hdXRoZW50aWNhdG9ySWRfKVxuICAgIClcbiAgICB0aGlzLmF1dGhlbnRpY2F0b3JJZF8gPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW5qZWN0cyBhIGNyZWRlbnRpYWwgaW50byB0aGUgYXV0aGVudGljYXRvci5cbiAgICogQHBhcmFtIGNyZWRlbnRpYWwgQ3JlZGVudGlhbCB0byBiZSBhZGRlZFxuICAgKi9cbiAgYXN5bmMgYWRkQ3JlZGVudGlhbChjcmVkZW50aWFsKSB7XG4gICAgY3JlZGVudGlhbCA9IGNyZWRlbnRpYWwudG9EaWN0KClcbiAgICBjcmVkZW50aWFsWydhdXRoZW50aWNhdG9ySWQnXSA9IHRoaXMuYXV0aGVudGljYXRvcklkX1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkFERF9DUkVERU5USUFMKS5zZXRQYXJhbWV0ZXJzKGNyZWRlbnRpYWwpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGNyZWRlbnRpYWxzIG93bmVkIGJ5IHRoZSBhdXRoZW50aWNhdG9yLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q3JlZGVudGlhbHMoKSB7XG4gICAgbGV0IGNyZWRlbnRpYWxfZGF0YSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkdFVF9DUkVERU5USUFMUykuc2V0UGFyYW1ldGVyKFxuICAgICAgICAnYXV0aGVudGljYXRvcklkJyxcbiAgICAgICAgdGhpcy52aXJ0dWFsQXV0aGVudGljYXRvcklkKClcbiAgICAgIClcbiAgICApXG4gICAgdmFyIGNyZWRlbnRpYWxfbGlzdCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcmVkZW50aWFsX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNyZWRlbnRpYWxfbGlzdC5wdXNoKG5ldyBDcmVkZW50aWFsKCkuZnJvbURpY3QoY3JlZGVudGlhbF9kYXRhW2ldKSlcbiAgICB9XG4gICAgcmV0dXJuIGNyZWRlbnRpYWxfbGlzdFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjcmVkZW50aWFsIGZyb20gdGhlIGF1dGhlbnRpY2F0b3IuXG4gICAqIEBwYXJhbSBjcmVkZW50aWFsX2lkIFRoZSBJRCBvZiB0aGUgY3JlZGVudGlhbCB0byBiZSByZW1vdmVkLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ3JlZGVudGlhbChjcmVkZW50aWFsX2lkKSB7XG4gICAgLy8gSWYgY3JlZGVudGlhbF9pZCBpcyBub3QgYSBiYXNlNjR1cmwsIHRoZW4gY29udmVydCBpdCB0byBiYXNlNjR1cmwuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3JlZGVudGlhbF9pZCkpIHtcbiAgICAgIGNyZWRlbnRpYWxfaWQgPSBCdWZmZXIuZnJvbShjcmVkZW50aWFsX2lkKS50b1N0cmluZygnYmFzZTY0dXJsJylcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5SRU1PVkVfQ1JFREVOVElBTClcbiAgICAgICAgLnNldFBhcmFtZXRlcignY3JlZGVudGlhbElkJywgY3JlZGVudGlhbF9pZClcbiAgICAgICAgLnNldFBhcmFtZXRlcignYXV0aGVudGljYXRvcklkJywgdGhpcy5hdXRoZW50aWNhdG9ySWRfKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0aGUgY3JlZGVudGlhbHMgZnJvbSB0aGUgYXV0aGVudGljYXRvci5cbiAgICovXG4gIGFzeW5jIHJlbW92ZUFsbENyZWRlbnRpYWxzKCkge1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLlJFTU9WRV9BTExfQ1JFREVOVElBTFMpLnNldFBhcmFtZXRlcihcbiAgICAgICAgJ2F1dGhlbnRpY2F0b3JJZCcsXG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRvcklkX1xuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIGF1dGhlbnRpY2F0b3Igd2lsbCBzaW11bGF0ZSBzdWNjZXNzIG9yIGZhaWwgb24gdXNlciB2ZXJpZmljYXRpb24uXG4gICAqIEBwYXJhbSB2ZXJpZmllZCB0cnVlIGlmIHRoZSBhdXRoZW50aWNhdG9yIHdpbGwgcGFzcyB1c2VyIHZlcmlmaWNhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgc2V0VXNlclZlcmlmaWVkKHZlcmlmaWVkKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuU0VUX1VTRVJfVkVSSUZJRUQpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ2F1dGhlbnRpY2F0b3JJZCcsIHRoaXMuYXV0aGVudGljYXRvcklkXylcbiAgICAgICAgLnNldFBhcmFtZXRlcignaXNVc2VyVmVyaWZpZWQnLCB2ZXJpZmllZClcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIG5hdmlnYXRpbmcgYmFjayBhbmQgZm9ydGggaW4gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAqXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWQsIG9idGFpbiBhbiBpbnN0YW5jZVxuICogd2l0aFxuICpcbiAqICAgIHdlYmRyaXZlci5uYXZpZ2F0ZSgpXG4gKlxuICogQHNlZSBXZWJEcml2ZXIjbmF2aWdhdGUoKVxuICovXG5jbGFzcyBOYXZpZ2F0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IVdlYkRyaXZlcn0gZHJpdmVyIFRoZSBwYXJlbnQgZHJpdmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJpdmVyKSB7XG4gICAgLyoqIEBwcml2YXRlIHshV2ViRHJpdmVyfSAqL1xuICAgIHRoaXMuZHJpdmVyXyA9IGRyaXZlclxuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlcyB0byBhIG5ldyBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBuYXZpZ2F0ZSB0by5cbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgVVJMXG4gICAqICAgICBoYXMgYmVlbiBsb2FkZWQuXG4gICAqL1xuICB0byh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5HRVQpLnNldFBhcmFtZXRlcigndXJsJywgdXJsKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBiYWNrd2FyZHMgaW4gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGVcbiAgICogICAgIG5hdmlnYXRpb24gZXZlbnQgaGFzIGNvbXBsZXRlZC5cbiAgICovXG4gIGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkdPX0JBQ0spKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIGZvcndhcmRzIGluIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlXG4gICAqICAgICBuYXZpZ2F0aW9uIGV2ZW50IGhhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBmb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZXhlY3V0ZShuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5HT19GT1JXQVJEKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGVcbiAgICogICAgIG5hdmlnYXRpb24gZXZlbnQgaGFzIGNvbXBsZXRlZC5cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLlJFRlJFU0gpKVxuICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgbWFuYWdpbmcgYnJvd3NlciBhbmQgZHJpdmVyIHN0YXRlLlxuICpcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gSW5zdGVhZCwgb2J0YWluIGFuIGluc3RhbmNlXG4gKiB3aXRoIHtAbGlua3BsYWluIFdlYkRyaXZlciNtYW5hZ2UoKSB3ZWJkcml2ZXIubWFuYWdlKCl9LlxuICovXG5jbGFzcyBPcHRpb25zIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IVdlYkRyaXZlcn0gZHJpdmVyIFRoZSBwYXJlbnQgZHJpdmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJpdmVyKSB7XG4gICAgLyoqIEBwcml2YXRlIHshV2ViRHJpdmVyfSAqL1xuICAgIHRoaXMuZHJpdmVyXyA9IGRyaXZlclxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb29raWUuXG4gICAqXG4gICAqIF9fU2FtcGxlIFVzYWdlOl9fXG4gICAqXG4gICAqICAgICAvLyBTZXQgYSBiYXNpYyBjb29raWUuXG4gICAqICAgICBkcml2ZXIubWFuYWdlKCkuYWRkQ29va2llKHtuYW1lOiAnZm9vJywgdmFsdWU6ICdiYXInfSk7XG4gICAqXG4gICAqICAgICAvLyBTZXQgYSBjb29raWUgdGhhdCBleHBpcmVzIGluIDEwIG1pbnV0ZXMuXG4gICAqICAgICBsZXQgZXhwaXJ5ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArICgxMCAqIDYwICogMTAwMCkpO1xuICAgKiAgICAgZHJpdmVyLm1hbmFnZSgpLmFkZENvb2tpZSh7bmFtZTogJ2ZvbycsIHZhbHVlOiAnYmFyJywgZXhwaXJ5fSk7XG4gICAqXG4gICAqICAgICAvLyBUaGUgY29va2llIGV4cGlyYXRpb24gbWF5IGFsc28gYmUgc3BlY2lmaWVkIGluIHNlY29uZHMgc2luY2UgZXBvY2guXG4gICAqICAgICBkcml2ZXIubWFuYWdlKCkuYWRkQ29va2llKHtcbiAgICogICAgICAgbmFtZTogJ2ZvbycsXG4gICAqICAgICAgIHZhbHVlOiAnYmFyJyxcbiAgICogICAgICAgZXhwaXJ5OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7IU9wdGlvbnMuQ29va2llfSBzcGVjIERlZmluZXMgdGhlIGNvb2tpZSB0byBhZGQuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkXG4gICAqICAgICB3aGVuIHRoZSBjb29raWUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHBhZ2UuXG4gICAqIEB0aHJvd3Mge2Vycm9yLkludmFsaWRBcmd1bWVudEVycm9yfSBpZiBhbnkgb2YgdGhlIGNvb2tpZSBwYXJhbWV0ZXJzIGFyZVxuICAgKiAgICAgaW52YWxpZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBgc3BlY2AgaXMgbm90IGEgY29va2llIG9iamVjdC5cbiAgICovXG4gIGFkZENvb2tpZSh7IG5hbWUsIHZhbHVlLCBwYXRoLCBkb21haW4sIHNlY3VyZSwgaHR0cE9ubHksIGV4cGlyeSwgc2FtZVNpdGUgfSkge1xuICAgIC8vIFdlIGRvIG5vdCBhbGxvdyAnPScgb3IgJzsnIGluIHRoZSBuYW1lLlxuICAgIGlmICgvWzs9XS8udGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IGVycm9yLkludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIGNvb2tpZSBuYW1lIFwiJyArIG5hbWUgKyAnXCInKVxuICAgIH1cblxuICAgIC8vIFdlIGRvIG5vdCBhbGxvdyAnOycgaW4gdmFsdWUuXG4gICAgaWYgKC87Ly50ZXN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IGVycm9yLkludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICAnSW52YWxpZCBjb29raWUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBleHBpcnkgPT09ICdudW1iZXInKSB7XG4gICAgICBleHBpcnkgPSBNYXRoLmZsb29yKGV4cGlyeSlcbiAgICB9IGVsc2UgaWYgKGV4cGlyeSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGxldCBkYXRlID0gLyoqIEB0eXBlIHshRGF0ZX0gKi8gKGV4cGlyeSlcbiAgICAgIGV4cGlyeSA9IE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKVxuICAgIH1cblxuICAgIGlmIChzYW1lU2l0ZSAmJiAhWydTdHJpY3QnLCAnTGF4JywgJ05vbmUnXS5pbmNsdWRlcyhzYW1lU2l0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvci5JbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYEludmFsaWQgc2FtZVNpdGUgY29va2llIHZhbHVlICcke3NhbWVTaXRlfScuIEl0IHNob3VsZCBiZSBvbmUgb2YgXCJMYXhcIiwgXCJTdHJpY3RcIiBvciBcIk5vbmVcImBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoc2FtZVNpdGUgPT09ICdOb25lJyAmJiAhc2VjdXJlKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3IuSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgICdJbnZhbGlkIGNvb2tpZSBjb25maWd1cmF0aW9uOiBTYW1lU2l0ZT1Ob25lIG11c3QgYmUgU2VjdXJlJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkFERF9DT09LSUUpLnNldFBhcmFtZXRlcignY29va2llJywge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICBzZWN1cmU6ICEhc2VjdXJlLFxuICAgICAgICBodHRwT25seTogISFodHRwT25seSxcbiAgICAgICAgZXhwaXJ5OiBleHBpcnksXG4gICAgICAgIHNhbWVTaXRlOiBzYW1lU2l0ZSxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGNvb2tpZXMgdmlzaWJsZSB0byB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiAgICAgd2hlbiBhbGwgY29va2llcyBoYXZlIGJlZW4gZGVsZXRlZC5cbiAgICovXG4gIGRlbGV0ZUFsbENvb2tpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuREVMRVRFX0FMTF9DT09LSUVTKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBjb29raWUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gVGhpcyBjb21tYW5kIGlzIGEgbm8tb3AgaWYgdGhlcmUgaXNcbiAgICogbm8gY29va2llIHdpdGggdGhlIGdpdmVuIG5hbWUgdmlzaWJsZSB0byB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29va2llIHRvIGRlbGV0ZS5cbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcbiAgICogICAgIHdoZW4gdGhlIGNvb2tpZSBoYXMgYmVlbiBkZWxldGVkLlxuICAgKi9cbiAgZGVsZXRlQ29va2llKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5ERUxFVEVfQ09PS0lFKS5zZXRQYXJhbWV0ZXIoJ25hbWUnLCBuYW1lKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIGNvb2tpZXMgdmlzaWJsZSB0byB0aGUgY3VycmVudCBwYWdlLiBFYWNoIGNvb2tpZSB3aWxsIGJlXG4gICAqIHJldHVybmVkIGFzIGEgSlNPTiBvYmplY3QgYXMgZGVzY3JpYmVkIGJ5IHRoZSBXZWJEcml2ZXIgd2lyZSBwcm90b2NvbC5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8IUFycmF5PCFPcHRpb25zLkNvb2tpZT4+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlXG4gICAqICAgICByZXNvbHZlZCB3aXRoIHRoZSBjb29raWVzIHZpc2libGUgdG8gdGhlIGN1cnJlbnQgYnJvd3NpbmcgY29udGV4dC5cbiAgICovXG4gIGdldENvb2tpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0FMTF9DT09LSUVTKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvb2tpZSB3aXRoIHRoZSBnaXZlbiBuYW1lLiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaFxuICAgKiBjb29raWUuIFRoZSBjb29raWUgd2lsbCBiZSByZXR1cm5lZCBhcyBhIEpTT04gb2JqZWN0IGFzIGRlc2NyaWJlZCBieSB0aGVcbiAgICogV2ViRHJpdmVyIHdpcmUgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb29raWUgdG8gcmV0cmlldmUuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPD9PcHRpb25zLkNvb2tpZT59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcbiAgICogICAgIHdpdGggdGhlIG5hbWVkIGNvb2tpZVxuICAgKiBAdGhyb3dzIHtlcnJvci5Ob1N1Y2hDb29raWVFcnJvcn0gaWYgdGhlcmUgaXMgbm8gc3VjaCBjb29raWUuXG4gICAqL1xuICBhc3luYyBnZXRDb29raWUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb29raWUgPSBhd2FpdCB0aGlzLmRyaXZlcl8uZXhlY3V0ZShcbiAgICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0NPT0tJRSkuc2V0UGFyYW1ldGVyKCduYW1lJywgbmFtZSlcbiAgICAgIClcbiAgICAgIHJldHVybiBjb29raWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShlcnIgaW5zdGFuY2VvZiBlcnJvci5Vbmtub3duQ29tbWFuZEVycm9yKSAmJlxuICAgICAgICAhKGVyciBpbnN0YW5jZW9mIGVycm9yLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvb2tpZXMgPSBhd2FpdCB0aGlzLmdldENvb2tpZXMoKVxuICAgICAgZm9yIChsZXQgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgaWYgKGNvb2tpZSAmJiBjb29raWVbJ25hbWUnXSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiBjb29raWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgdGltZW91dHMgY3VycmVudGx5IGNvbmZpZ3VyZWQgZm9yIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHtzY3JpcHQ6IG51bWJlcixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VMb2FkOiBudW1iZXIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBsaWNpdDogbnVtYmVyfT59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmVcbiAgICogICAgIHJlc29sdmVkIHdpdGggdGhlIHRpbWVvdXRzIGN1cnJlbnRseSBjb25maWd1cmVkIGZvciB0aGUgY3VycmVudFxuICAgKiAgICAgc2Vzc2lvbi5cbiAgICogQHNlZSAjc2V0VGltZW91dHMoKVxuICAgKi9cbiAgZ2V0VGltZW91dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkdFVF9USU1FT1VUKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aW1lb3V0IGR1cmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyB0aW1lb3V0cyBhcmUgc3VwcG9ydGVkIChhbGwgdGltZW91dHMgYXJlIHNwZWNpZmllZCBpblxuICAgKiBtaWxsaXNlY29uZHMpOlxuICAgKlxuICAgKiAtICBgaW1wbGljaXRgIHNwZWNpZmllcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciBhbiBlbGVtZW50XG4gICAqICAgIGxvY2F0b3IgdG8gc3VjY2VlZCB3aGVuIHtAbGlua3BsYWluIFdlYkRyaXZlciNmaW5kRWxlbWVudCBsb2NhdGluZ31cbiAgICogICAge0BsaW5rcGxhaW4gV2ViRHJpdmVyI2ZpbmRFbGVtZW50cyBlbGVtZW50c30gb24gdGhlIHBhZ2UuXG4gICAqICAgIERlZmF1bHRzIHRvIDAgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiAtICBgcGFnZUxvYWRgIHNwZWNpZmllcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciBhIHBhZ2UgdG9cbiAgICogICAgZmluaXNoaW5nIGxvYWRpbmcuIERlZmF1bHRzIHRvIDMwMDAwMCBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIC0gIGBzY3JpcHRgIHNwZWNpZmllcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciBhblxuICAgKiAgICB7QGxpbmtwbGFpbiBXZWJEcml2ZXIjZXhlY3V0ZVNjcmlwdCBldmFsdWF0ZWQgc2NyaXB0fSB0byBydW4uIElmIHNldCB0b1xuICAgKiAgICBgbnVsbGAsIHRoZSBzY3JpcHQgdGltZW91dCB3aWxsIGJlIGluZGVmaW5pdGUuXG4gICAqICAgIERlZmF1bHRzIHRvIDMwMDAwIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHBhcmFtIHt7c2NyaXB0OiAobnVtYmVyfG51bGx8dW5kZWZpbmVkKSxcbiAgICogICAgICAgICAgcGFnZUxvYWQ6IChudW1iZXJ8bnVsbHx1bmRlZmluZWQpLFxuICAgKiAgICAgICAgICBpbXBsaWNpdDogKG51bWJlcnxudWxsfHVuZGVmaW5lZCl9fSBjb25mXG4gICAqICAgICBUaGUgZGVzaXJlZCB0aW1lb3V0IGNvbmZpZ3VyYXRpb24uXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHRpbWVvdXRzXG4gICAqICAgICBoYXZlIGJlZW4gc2V0LlxuICAgKiBAdGhyb3dzIHshVHlwZUVycm9yfSBpZiBhbiBpbnZhbGlkIG9wdGlvbnMgb2JqZWN0IGlzIHByb3ZpZGVkLlxuICAgKiBAc2VlICNnZXRUaW1lb3V0cygpXG4gICAqIEBzZWUgPGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvd2ViZHJpdmVyLXNwZWMuaHRtbCNkZm4tc2V0LXRpbWVvdXRzPlxuICAgKi9cbiAgc2V0VGltZW91dHMoeyBzY3JpcHQsIHBhZ2VMb2FkLCBpbXBsaWNpdCB9ID0ge30pIHtcbiAgICBsZXQgY21kID0gbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuU0VUX1RJTUVPVVQpXG5cbiAgICBsZXQgdmFsaWQgPSBmYWxzZVxuICAgIGZ1bmN0aW9uIHNldFBhcmFtKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbGlkID0gdHJ1ZVxuICAgICAgICBjbWQuc2V0UGFyYW1ldGVyKGtleSwgdmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIHRpbWVvdXRzIGNvbmZpZ3VyYXRpb246JyArXG4gICAgICAgICAgICBgIGV4cGVjdGVkIFwiJHtrZXl9XCIgdG8gYmUgYSBudW1iZXIsIGdvdCAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0UGFyYW0oJ2ltcGxpY2l0JywgaW1wbGljaXQpXG4gICAgc2V0UGFyYW0oJ3BhZ2VMb2FkJywgcGFnZUxvYWQpXG4gICAgc2V0UGFyYW0oJ3NjcmlwdCcsIHNjcmlwdClcblxuICAgIGlmICh2YWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKGNtZCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBGYWxsYmFjayB0byB0aGUgbGVnYWN5IG1ldGhvZC5cbiAgICAgICAgbGV0IGNtZHMgPSBbXVxuICAgICAgICBpZiAodHlwZW9mIHNjcmlwdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjbWRzLnB1c2gobGVnYWN5VGltZW91dCh0aGlzLmRyaXZlcl8sICdzY3JpcHQnLCBzY3JpcHQpKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW1wbGljaXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY21kcy5wdXNoKGxlZ2FjeVRpbWVvdXQodGhpcy5kcml2ZXJfLCAnaW1wbGljaXQnLCBpbXBsaWNpdCkpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYWdlTG9hZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjbWRzLnB1c2gobGVnYWN5VGltZW91dCh0aGlzLmRyaXZlcl8sICdwYWdlIGxvYWQnLCBwYWdlTG9hZCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNtZHMpXG4gICAgICB9KVxuICAgIH1cbiAgICB0aHJvdyBUeXBlRXJyb3IoJ25vIHRpbWVvdXRzIHNwZWNpZmllZCcpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUxvZ3N9IFRoZSBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nIGRyaXZlciBsb2dzLlxuICAgKi9cbiAgbG9ncygpIHtcbiAgICByZXR1cm4gbmV3IExvZ3ModGhpcy5kcml2ZXJfKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFXaW5kb3d9IFRoZSBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nIHRoZSBjdXJyZW50IHdpbmRvdy5cbiAgICovXG4gIHdpbmRvdygpIHtcbiAgICByZXR1cm4gbmV3IFdpbmRvdyh0aGlzLmRyaXZlcl8pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXZWJEcml2ZXJ9IGRyaXZlclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xuICogQHJldHVybiB7IVByb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIGxlZ2FjeVRpbWVvdXQoZHJpdmVyLCB0eXBlLCBtcykge1xuICByZXR1cm4gZHJpdmVyLmV4ZWN1dGUoXG4gICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuU0VUX1RJTUVPVVQpXG4gICAgICAuc2V0UGFyYW1ldGVyKCd0eXBlJywgdHlwZSlcbiAgICAgIC5zZXRQYXJhbWV0ZXIoJ21zJywgbXMpXG4gIClcbn1cblxuLyoqXG4gKiBBIHJlY29yZCBvYmplY3QgZGVzY3JpYmluZyBhIGJyb3dzZXIgY29va2llLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuT3B0aW9ucy5Db29raWUgPSBmdW5jdGlvbiAoKSB7fVxuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBjb29raWUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuT3B0aW9ucy5Db29raWUucHJvdG90eXBlLm5hbWVcblxuLyoqXG4gKiBUaGUgY29va2llIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbk9wdGlvbnMuQ29va2llLnByb3RvdHlwZS52YWx1ZVxuXG4vKipcbiAqIFRoZSBjb29raWUgcGF0aC4gRGVmYXVsdHMgdG8gXCIvXCIgd2hlbiBhZGRpbmcgYSBjb29raWUuXG4gKlxuICogQHR5cGUgeyhzdHJpbmd8dW5kZWZpbmVkKX1cbiAqL1xuT3B0aW9ucy5Db29raWUucHJvdG90eXBlLnBhdGhcblxuLyoqXG4gKiBUaGUgZG9tYWluIHRoZSBjb29raWUgaXMgdmlzaWJsZSB0by4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgYnJvd3NpbmdcbiAqIGNvbnRleHQncyBkb2N1bWVudCdzIFVSTCB3aGVuIGFkZGluZyBhIGNvb2tpZS5cbiAqXG4gKiBAdHlwZSB7KHN0cmluZ3x1bmRlZmluZWQpfVxuICovXG5PcHRpb25zLkNvb2tpZS5wcm90b3R5cGUuZG9tYWluXG5cbi8qKlxuICogV2hldGhlciB0aGUgY29va2llIGlzIGEgc2VjdXJlIGNvb2tpZS4gRGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBhZGRpbmcgYSBuZXdcbiAqIGNvb2tpZS5cbiAqXG4gKiBAdHlwZSB7KGJvb2xlYW58dW5kZWZpbmVkKX1cbiAqL1xuT3B0aW9ucy5Db29raWUucHJvdG90eXBlLnNlY3VyZVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGNvb2tpZSBpcyBhbiBIVFRQIG9ubHkgY29va2llLiBEZWZhdWx0cyB0byBmYWxzZSB3aGVuIGFkZGluZyBhXG4gKiBuZXcgY29va2llLlxuICpcbiAqIEB0eXBlIHsoYm9vbGVhbnx1bmRlZmluZWQpfVxuICovXG5PcHRpb25zLkNvb2tpZS5wcm90b3R5cGUuaHR0cE9ubHlcblxuLyoqXG4gKiBXaGVuIHRoZSBjb29raWUgZXhwaXJlcy5cbiAqXG4gKiBXaGVuIHtAbGlua3BsYWluIE9wdGlvbnMjYWRkQ29va2llKCkgYWRkaW5nIGEgY29va2llfSwgdGhpcyBtYXkgYmUgc3BlY2lmaWVkXG4gKiBhcyBhIHtAbGluayBEYXRlfSBvYmplY3QsIG9yIGluIF9zZWNvbmRzXyBzaW5jZSBVbml4IGVwb2NoIChKYW51YXJ5IDEsIDE5NzApLlxuICpcbiAqIFRoZSBleHBpcnkgaXMgYWx3YXlzIHJldHVybmVkIGluIHNlY29uZHMgc2luY2UgZXBvY2ggd2hlblxuICoge0BsaW5rcGxhaW4gT3B0aW9ucyNnZXRDb29raWVzKCkgcmV0cmlldmluZyBjb29raWVzfSBmcm9tIHRoZSBicm93c2VyLlxuICpcbiAqIEB0eXBlIHsoIURhdGV8bnVtYmVyfHVuZGVmaW5lZCl9XG4gKi9cbk9wdGlvbnMuQ29va2llLnByb3RvdHlwZS5leHBpcnlcblxuLyoqXG4gKiBXaGVuIHRoZSBjb29raWUgYXBwbGllcyB0byBhIFNhbWVTaXRlIHBvbGljeS5cbiAqXG4gKiBXaGVuIHtAbGlua3BsYWluIE9wdGlvbnMjYWRkQ29va2llKCkgYWRkaW5nIGEgY29va2llfSwgdGhpcyBtYXkgYmUgc3BlY2lmaWVkXG4gKiBhcyBhIHtAbGluayBzdHJpbmd9IG9iamVjdCB3aGljaCBpcyBvbmUgb2YgJ0xheCcsICdTdHJpY3QnIG9yICdOb25lJy5cbiAqXG4gKlxuICogQHR5cGUgeyhzdHJpbmd8dW5kZWZpbmVkKX1cbiAqL1xuT3B0aW9ucy5Db29raWUucHJvdG90eXBlLnNhbWVTaXRlXG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZyB0aGUgY3VycmVudCB3aW5kb3cuXG4gKlxuICogVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkLCBvYnRhaW4gYW4gaW5zdGFuY2VcbiAqIHdpdGhcbiAqXG4gKiAgICB3ZWJkcml2ZXIubWFuYWdlKCkud2luZG93KClcbiAqXG4gKiBAc2VlIFdlYkRyaXZlciNtYW5hZ2UoKVxuICogQHNlZSBPcHRpb25zI3dpbmRvdygpXG4gKi9cbmNsYXNzIFdpbmRvdyB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFXZWJEcml2ZXJ9IGRyaXZlciBUaGUgcGFyZW50IGRyaXZlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRyaXZlcikge1xuICAgIC8qKiBAcHJpdmF0ZSB7IVdlYkRyaXZlcn0gKi9cbiAgICB0aGlzLmRyaXZlcl8gPSBkcml2ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSByZWN0IGRlc2NyaWJpbmcgdGhlIGN1cnJlbnQgdG9wLWxldmVsIHdpbmRvdydzIHNpemUgYW5kXG4gICAqIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT59XG4gICAqICAgICBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIHdpbmRvdyByZWN0IG9mIHRoZSBjdXJyZW50IHdpbmRvdy5cbiAgICovXG4gIGdldFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX1dJTkRPV19SRUNUKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHRvcC1sZXZlbCB3aW5kb3cncyBzaXplIGFuZCBwb3NpdGlvbi4gWW91IG1heSB1cGRhdGUganVzdFxuICAgKiB0aGUgc2l6ZSBieSBvbWl0dGluZyBgeGAgJiBgeWAsIG9yIGp1c3QgdGhlIHBvc2l0aW9uIGJ5IG9taXR0aW5nXG4gICAqIGB3aWR0aGAgJiBgaGVpZ2h0YCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3t4OiAobnVtYmVyfHVuZGVmaW5lZCksXG4gICAqICAgICAgICAgIHk6IChudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICAgICAgICAgd2lkdGg6IChudW1iZXJ8dW5kZWZpbmVkKSxcbiAgICogICAgICAgICAgaGVpZ2h0OiAobnVtYmVyfHVuZGVmaW5lZCl9fSBvcHRpb25zXG4gICAqICAgICBUaGUgZGVzaXJlZCB3aW5kb3cgc2l6ZSBhbmQgcG9zaXRpb24uXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHt4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9Pn1cbiAgICogICAgIEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGUgY3VycmVudCB3aW5kb3cncyB1cGRhdGVkIHdpbmRvd1xuICAgKiAgICAgcmVjdC5cbiAgICovXG4gIHNldFJlY3QoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5TRVRfV0lORE9XX1JFQ1QpLnNldFBhcmFtZXRlcnMoe1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogTWF4aW1pemVzIHRoZSBjdXJyZW50IHdpbmRvdy4gVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgY29tbWFuZCBpc1xuICAgKiBzcGVjaWZpYyB0byBpbmRpdmlkdWFsIHdpbmRvdyBtYW5hZ2VycywgYnV0IHR5cGljYWxseSBpbnZvbHZlcyBpbmNyZWFzaW5nXG4gICAqIHRoZSB3aW5kb3cgdG8gdGhlIG1heGltdW0gYXZhaWxhYmxlIHNpemUgd2l0aG91dCBnb2luZyBmdWxsLXNjcmVlbi5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgY29tbWFuZFxuICAgKiAgICAgaGFzIGNvbXBsZXRlZC5cbiAgICovXG4gIG1heGltaXplKCkge1xuICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLk1BWElNSVpFX1dJTkRPVykuc2V0UGFyYW1ldGVyKFxuICAgICAgICAnd2luZG93SGFuZGxlJyxcbiAgICAgICAgJ2N1cnJlbnQnXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIE1pbmltaXplcyB0aGUgY3VycmVudCB3aW5kb3cuIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIGNvbW1hbmQgaXNcbiAgICogc3BlY2lmaWMgdG8gaW5kaXZpZHVhbCB3aW5kb3cgbWFuYWdlcnMsIGJ1dCB0eXBpY2FsbHkgaW52b2x2ZXMgaGlkaW5nXG4gICAqIHRoZSB3aW5kb3cgaW4gdGhlIHN5c3RlbSB0cmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBjb21tYW5kXG4gICAqICAgICBoYXMgY29tcGxldGVkLlxuICAgKi9cbiAgbWluaW1pemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuTUlOSU1JWkVfV0lORE9XKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIHRoZSBcImZ1bGwgc2NyZWVuXCIgb3BlcmF0aW9uIG9uIHRoZSBjdXJyZW50IHdpbmRvdy4gVGhlIGV4YWN0XG4gICAqIGJlaGF2aW9yIG9mIHRoaXMgY29tbWFuZCBpcyBzcGVjaWZpYyB0byBpbmRpdmlkdWFsIHdpbmRvdyBtYW5hZ2VycywgYnV0XG4gICAqIHRoaXMgd2lsbCB0eXBpY2FsbHkgaW5jcmVhc2UgdGhlIHdpbmRvdyBzaXplIHRvIHRoZSBzaXplIG9mIHRoZSBwaHlzaWNhbFxuICAgKiBkaXNwbGF5IGFuZCBoaWRlIHRoZSBicm93c2VyIGNocm9tZS5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgY29tbWFuZFxuICAgKiAgICAgaGFzIGNvbXBsZXRlZC5cbiAgICogQHNlZSA8aHR0cHM6Ly9mdWxsc2NyZWVuLnNwZWMud2hhdHdnLm9yZy8jZnVsbHNjcmVlbi1hbi1lbGVtZW50PlxuICAgKi9cbiAgZnVsbHNjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5GVUxMU0NSRUVOX1dJTkRPVylcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY3VycmVudCB3aW5kb3dcbiAgICogQHBhcmFtIHdpbmRvd0hhbmRsZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7d2lkdGg6ICosIGhlaWdodDogKn0+fVxuICAgKi9cbiAgYXN5bmMgZ2V0U2l6ZSh3aW5kb3dIYW5kbGUgPSAnY3VycmVudCcpIHtcbiAgICBpZiAod2luZG93SGFuZGxlICE9PSAnY3VycmVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYE9ubHkgJ2N1cnJlbnQnIHdpbmRvdyBpcyBzdXBwb3J0ZWQgZm9yIFczQyBjb21wYXRpYmxlIGJyb3dzZXJzLmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCByZWN0ID0gYXdhaXQgdGhpcy5nZXRSZWN0KClcbiAgICByZXR1cm4geyBoZWlnaHQ6IHJlY3QuaGVpZ2h0LCB3aWR0aDogcmVjdC53aWR0aCB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY3VycmVudCB3aW5kb3cuICh3aW5kb3cucmVzaXplVG8pXG4gICAqIEBwYXJhbSB4XG4gICAqIEBwYXJhbSB5XG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqIEBwYXJhbSB3aW5kb3dIYW5kbGVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzZXRTaXplKFxuICAgIHsgeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDAgfSxcbiAgICB3aW5kb3dIYW5kbGUgPSAnY3VycmVudCdcbiAgKSB7XG4gICAgaWYgKHdpbmRvd0hhbmRsZSAhPT0gJ2N1cnJlbnQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBPbmx5ICdjdXJyZW50JyB3aW5kb3cgaXMgc3VwcG9ydGVkIGZvciBXM0MgY29tcGF0aWJsZSBicm93c2Vycy5gXG4gICAgICApXG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5zZXRSZWN0KHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KVxuICB9XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBtYW5hZ2luZyBXZWJEcml2ZXIgbG9nIHJlY29yZHMuXG4gKlxuICogVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkLCBvYnRhaW4gYW5cbiAqIGluc3RhbmNlIHdpdGhcbiAqXG4gKiAgICAgd2ViZHJpdmVyLm1hbmFnZSgpLmxvZ3MoKVxuICpcbiAqIEBzZWUgV2ViRHJpdmVyI21hbmFnZSgpXG4gKiBAc2VlIE9wdGlvbnMjbG9ncygpXG4gKi9cbmNsYXNzIExvZ3Mge1xuICAvKipcbiAgICogQHBhcmFtIHshV2ViRHJpdmVyfSBkcml2ZXIgVGhlIHBhcmVudCBkcml2ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkcml2ZXIpIHtcbiAgICAvKiogQHByaXZhdGUgeyFXZWJEcml2ZXJ9ICovXG4gICAgdGhpcy5kcml2ZXJfID0gZHJpdmVyXG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhdmFpbGFibGUgbG9nIGVudHJpZXMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgbG9nIGJ1ZmZlcnMgYXJlIHJlc2V0IGFmdGVyIGVhY2ggY2FsbCwgbWVhbmluZyB0aGF0IGF2YWlsYWJsZVxuICAgKiBsb2cgZW50cmllcyBjb3JyZXNwb25kIHRvIHRob3NlIGVudHJpZXMgbm90IHlldCByZXR1cm5lZCBmb3IgYSBnaXZlbiBsb2dcbiAgICogdHlwZS4gSW4gcHJhY3RpY2UsIHRoaXMgbWVhbnMgdGhhdCB0aGlzIGNhbGwgd2lsbCByZXR1cm4gdGhlIGF2YWlsYWJsZSBsb2dcbiAgICogZW50cmllcyBzaW5jZSB0aGUgbGFzdCBjYWxsLCBvciBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc2Vzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHshbG9nZ2luZy5UeXBlfSB0eXBlIFRoZSBkZXNpcmVkIGxvZyB0eXBlLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTwhQXJyYXkuPCFsb2dnaW5nLkVudHJ5Pj59IEFcbiAgICogICBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIGEgbGlzdCBvZiBsb2cgZW50cmllcyBmb3IgdGhlIHNwZWNpZmllZFxuICAgKiAgIHR5cGUuXG4gICAqL1xuICBnZXQodHlwZSkge1xuICAgIGxldCBjbWQgPSBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5HRVRfTE9HKS5zZXRQYXJhbWV0ZXIoXG4gICAgICAndHlwZScsXG4gICAgICB0eXBlXG4gICAgKVxuICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZXhlY3V0ZShjbWQpLnRoZW4oZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBsb2dnaW5nLkVudHJ5KSkge1xuICAgICAgICAgIHJldHVybiBuZXcgbG9nZ2luZy5FbnRyeShcbiAgICAgICAgICAgIGVudHJ5WydsZXZlbCddLFxuICAgICAgICAgICAgZW50cnlbJ21lc3NhZ2UnXSxcbiAgICAgICAgICAgIGVudHJ5Wyd0aW1lc3RhbXAnXSxcbiAgICAgICAgICAgIGVudHJ5Wyd0eXBlJ11cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsb2cgdHlwZXMgYXZhaWxhYmxlIHRvIHRoaXMgZHJpdmVyLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTwhQXJyYXk8IWxvZ2dpbmcuVHlwZT4+fSBBXG4gICAqICAgICBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIGEgbGlzdCBvZiBhdmFpbGFibGUgbG9nIHR5cGVzLlxuICAgKi9cbiAgZ2V0QXZhaWxhYmxlTG9nVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0FWQUlMQUJMRV9MT0dfVFlQRVMpXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciBjaGFuZ2luZyB0aGUgZm9jdXMgb2YgdGhlIGRyaXZlciB0byBhbm90aGVyIGZyYW1lIG9yIHdpbmRvdy5cbiAqXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWQsIG9idGFpbiBhblxuICogaW5zdGFuY2Ugd2l0aFxuICpcbiAqICAgICB3ZWJkcml2ZXIuc3dpdGNoVG8oKVxuICpcbiAqIEBzZWUgV2ViRHJpdmVyI3N3aXRjaFRvKClcbiAqL1xuY2xhc3MgVGFyZ2V0TG9jYXRvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFXZWJEcml2ZXJ9IGRyaXZlciBUaGUgcGFyZW50IGRyaXZlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRyaXZlcikge1xuICAgIC8qKiBAcHJpdmF0ZSB7IVdlYkRyaXZlcn0gKi9cbiAgICB0aGlzLmRyaXZlcl8gPSBkcml2ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NhdGVzIHRoZSBET00gZWxlbWVudCBvbiB0aGUgY3VycmVudCBwYWdlIHRoYXQgY29ycmVzcG9uZHMgdG9cbiAgICogYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIG9yIGBkb2N1bWVudC5ib2R5YCBpZiB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgbm90XG4gICAqIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybiB7IVdlYkVsZW1lbnRQcm9taXNlfSBUaGUgYWN0aXZlIGVsZW1lbnQuXG4gICAqL1xuICBhY3RpdmVFbGVtZW50KCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5kcml2ZXJfLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5HRVRfQUNUSVZFX0VMRU1FTlQpXG4gICAgKVxuICAgIHJldHVybiBuZXcgV2ViRWxlbWVudFByb21pc2UodGhpcy5kcml2ZXJfLCBpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBmb2N1cyBvZiBhbGwgZnV0dXJlIGNvbW1hbmRzIHRvIHRoZSB0b3Btb3N0IGZyYW1lIGluIHRoZSBjdXJyZW50XG4gICAqIHdpbmRvdy5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcbiAgICogICAgIHdoZW4gdGhlIGRyaXZlciBoYXMgY2hhbmdlZCBmb2N1cyB0byB0aGUgZGVmYXVsdCBjb250ZW50LlxuICAgKi9cbiAgZGVmYXVsdENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuU1dJVENIX1RPX0ZSQU1FKS5zZXRQYXJhbWV0ZXIoJ2lkJywgbnVsbClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgZm9jdXMgb2YgYWxsIGZ1dHVyZSBjb21tYW5kcyB0byBhbm90aGVyIGZyYW1lIG9uIHRoZSBwYWdlLiBUaGVcbiAgICogdGFyZ2V0IGZyYW1lIG1heSBiZSBzcGVjaWZpZWQgYXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIC0gQSBudW1iZXIgdGhhdCBzcGVjaWZpZXMgYSAoemVyby1iYXNlZCkgaW5kZXggaW50byBbd2luZG93LmZyYW1lc10oXG4gICAqICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5mcmFtZXMpLlxuICAgKiAtIEEge0BsaW5rIFdlYkVsZW1lbnR9IHJlZmVyZW5jZSwgd2hpY2ggY29ycmVzcG9uZCB0byBhIGBmcmFtZWAgb3IgYGlmcmFtZWBcbiAgICogICBET00gZWxlbWVudC5cbiAgICogLSBUaGUgYG51bGxgIHZhbHVlLCB0byBzZWxlY3QgdGhlIHRvcG1vc3QgZnJhbWUgb24gdGhlIHBhZ2UuIFBhc3NpbmcgYG51bGxgXG4gICAqICAgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyB7QGxpbmsgI2RlZmF1bHRDb250ZW50IGRlZmF1bHRDb250ZW50KCl9LlxuICAgKlxuICAgKiBJZiB0aGUgc3BlY2lmaWVkIGZyYW1lIGNhbiBub3QgYmUgZm91bmQsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmVcbiAgICogcmVqZWN0ZWQgd2l0aCBhIHtAbGlua3BsYWluIGVycm9yLk5vU3VjaEZyYW1lRXJyb3J9LlxuICAgKlxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nfFdlYkVsZW1lbnR8bnVsbCl9IGlkIFRoZSBmcmFtZSBsb2NhdG9yLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiAgICAgd2hlbiB0aGUgZHJpdmVyIGhhcyBjaGFuZ2VkIGZvY3VzIHRvIHRoZSBzcGVjaWZpZWQgZnJhbWUuXG4gICAqL1xuICBmcmFtZShpZCkge1xuICAgIGxldCBmcmFtZVJlZmVyZW5jZSA9IGlkXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZyYW1lUmVmZXJlbmNlID0gdGhpcy5kcml2ZXJfXG4gICAgICAgIC5maW5kRWxlbWVudCh7IGlkIH0pXG4gICAgICAgIC5jYXRjaCgoXykgPT4gdGhpcy5kcml2ZXJfLmZpbmRFbGVtZW50KHsgbmFtZTogaWQgfSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuU1dJVENIX1RPX0ZSQU1FKS5zZXRQYXJhbWV0ZXIoXG4gICAgICAgICdpZCcsXG4gICAgICAgIGZyYW1lUmVmZXJlbmNlXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGZvY3VzIG9mIGFsbCBmdXR1cmUgY29tbWFuZHMgdG8gdGhlIHBhcmVudCBmcmFtZSBvZiB0aGVcbiAgICogY3VycmVudGx5IHNlbGVjdGVkIGZyYW1lLiBUaGlzIGNvbW1hbmQgaGFzIG5vIGVmZmVjdCBpZiB0aGUgZHJpdmVyIGlzXG4gICAqIGFscmVhZHkgZm9jdXNlZCBvbiB0aGUgdG9wLWxldmVsIGJyb3dzaW5nIGNvbnRleHQuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvbW1hbmRcbiAgICogICAgIGhhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBwYXJlbnRGcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfLmV4ZWN1dGUoXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5TV0lUQ0hfVE9fRlJBTUVfUEFSRU5UKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBmb2N1cyBvZiBhbGwgZnV0dXJlIGNvbW1hbmRzIHRvIGFub3RoZXIgd2luZG93LiBXaW5kb3dzIG1heSBiZVxuICAgKiBzcGVjaWZpZWQgYnkgdGhlaXIge0Bjb2RlIHdpbmRvdy5uYW1lfSBhdHRyaWJ1dGUgb3IgYnkgaXRzIGhhbmRsZVxuICAgKiAoYXMgcmV0dXJuZWQgYnkge0BsaW5rIFdlYkRyaXZlciNnZXRXaW5kb3dIYW5kbGVzfSkuXG4gICAqXG4gICAqIElmIHRoZSBzcGVjaWZpZWQgd2luZG93IGNhbm5vdCBiZSBmb3VuZCwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZVxuICAgKiByZWplY3RlZCB3aXRoIGEge0BsaW5rcGxhaW4gZXJyb3IuTm9TdWNoV2luZG93RXJyb3J9LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZU9ySGFuZGxlIFRoZSBuYW1lIG9yIHdpbmRvdyBoYW5kbGUgb2YgdGhlIHdpbmRvdyB0b1xuICAgKiAgICAgc3dpdGNoIGZvY3VzIHRvLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiAgICAgd2hlbiB0aGUgZHJpdmVyIGhhcyBjaGFuZ2VkIGZvY3VzIHRvIHRoZSBzcGVjaWZpZWQgd2luZG93LlxuICAgKi9cbiAgd2luZG93KG5hbWVPckhhbmRsZSkge1xuICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLlNXSVRDSF9UT19XSU5ET1cpXG4gICAgICAgIC8vIFwibmFtZVwiIHN1cHBvcnRzIHRoZSBsZWdhY3kgZHJpdmVycy4gXCJoYW5kbGVcIiBpcyB0aGUgVzNDXG4gICAgICAgIC8vIGNvbXBsaWFudCBwYXJhbWV0ZXIuXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ25hbWUnLCBuYW1lT3JIYW5kbGUpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ2hhbmRsZScsIG5hbWVPckhhbmRsZSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBicm93c2VyIHdpbmRvdyBhbmQgc3dpdGNoZXMgdGhlIGZvY3VzIGZvciBmdXR1cmVcbiAgICogY29tbWFuZHMgb2YgdGhpcyBkcml2ZXIgdG8gdGhlIG5ldyB3aW5kb3cuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlSGludCAnd2luZG93JyBvciAndGFiJy4gVGhlIGNyZWF0ZWQgd2luZG93IGlzIG5vdFxuICAgKiAgICAgZ3VhcmFudGVlZCB0byBiZSBvZiB0aGUgcmVxdWVzdGVkIHR5cGU7IGlmIHRoZSBkcml2ZXIgZG9lcyBub3Qgc3VwcG9ydFxuICAgKiAgICAgdGhlIHJlcXVlc3RlZCB0eXBlLCBhIG5ldyBicm93c2VyIHdpbmRvdyB3aWxsIGJlIGNyZWF0ZWQgb2Ygd2hhdGV2ZXIgdHlwZVxuICAgKiAgICAgdGhlIGRyaXZlciBkb2VzIHN1cHBvcnQuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkXG4gICAqICAgICB3aGVuIHRoZSBkcml2ZXIgaGFzIGNoYW5nZWQgZm9jdXMgdG8gdGhlIG5ldyB3aW5kb3cuXG4gICAqL1xuICBuZXdXaW5kb3codHlwZUhpbnQpIHtcbiAgICBjb25zdCBkcml2ZXIgPSB0aGlzLmRyaXZlcl9cbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfXG4gICAgICAuZXhlY3V0ZShcbiAgICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuU1dJVENIX1RPX05FV19XSU5ET1cpLnNldFBhcmFtZXRlcihcbiAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgdHlwZUhpbnRcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBkcml2ZXIuc3dpdGNoVG8oKS53aW5kb3cocmVzcG9uc2UuaGFuZGxlKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIGZvY3VzIHRvIHRoZSBhY3RpdmUgbW9kYWwgZGlhbG9nLCBzdWNoIGFzIHRob3NlIG9wZW5lZCBieVxuICAgKiBgd2luZG93LmFsZXJ0KClgLCBgd2luZG93LmNvbmZpcm0oKWAsIGFuZCBgd2luZG93LnByb21wdCgpYC4gVGhlIHJldHVybmVkXG4gICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIGFcbiAgICoge0BsaW5rcGxhaW4gZXJyb3IuTm9TdWNoQWxlcnRFcnJvcn0gaWYgdGhlcmUgYXJlIG5vIG9wZW4gYWxlcnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHshQWxlcnRQcm9taXNlfSBUaGUgb3BlbiBhbGVydC5cbiAgICovXG4gIGFsZXJ0KCkge1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLmRyaXZlcl8uZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkdFVF9BTEVSVF9URVhUKVxuICAgIClcbiAgICBjb25zdCBkcml2ZXIgPSB0aGlzLmRyaXZlcl9cbiAgICByZXR1cm4gbmV3IEFsZXJ0UHJvbWlzZShcbiAgICAgIGRyaXZlcixcbiAgICAgIHRleHQudGhlbihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEFsZXJ0KGRyaXZlciwgdGV4dClcbiAgICAgIH0pXG4gICAgKVxuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBXZWJFbGVtZW50XG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmNvbnN0IExFR0FDWV9FTEVNRU5UX0lEX0tFWSA9ICdFTEVNRU5UJ1xuY29uc3QgRUxFTUVOVF9JRF9LRVkgPSAnZWxlbWVudC02MDY2LTExZTQtYTUyZS00ZjczNTQ2NmNlY2YnXG5jb25zdCBTSEFET1dfUk9PVF9JRF9LRVkgPSAnc2hhZG93LTYwNjYtMTFlNC1hNTJlLTRmNzM1NDY2Y2VjZidcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgRE9NIGVsZW1lbnQuIFdlYkVsZW1lbnRzIGNhbiBiZSBmb3VuZCBieSBzZWFyY2hpbmcgZnJvbSB0aGVcbiAqIGRvY3VtZW50IHJvb3QgdXNpbmcgYSB7QGxpbmsgV2ViRHJpdmVyfSBpbnN0YW5jZSwgb3IgYnkgc2VhcmNoaW5nXG4gKiB1bmRlciBhbm90aGVyIFdlYkVsZW1lbnQ6XG4gKlxuICogICAgIGRyaXZlci5nZXQoJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvbScpO1xuICogICAgIHZhciBzZWFyY2hGb3JtID0gZHJpdmVyLmZpbmRFbGVtZW50KEJ5LnRhZ05hbWUoJ2Zvcm0nKSk7XG4gKiAgICAgdmFyIHNlYXJjaEJveCA9IHNlYXJjaEZvcm0uZmluZEVsZW1lbnQoQnkubmFtZSgncScpKTtcbiAqICAgICBzZWFyY2hCb3guc2VuZEtleXMoJ3dlYmRyaXZlcicpO1xuICovXG5jbGFzcyBXZWJFbGVtZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IVdlYkRyaXZlcn0gZHJpdmVyIHRoZSBwYXJlbnQgV2ViRHJpdmVyIGluc3RhbmNlIGZvciB0aGlzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7KCFJVGhlbmFibGU8c3RyaW5nPnxzdHJpbmcpfSBpZCBUaGUgc2VydmVyLWFzc2lnbmVkIG9wYXF1ZSBJRCBmb3JcbiAgICogICAgIHRoZSB1bmRlcmx5aW5nIERPTSBlbGVtZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJpdmVyLCBpZCkge1xuICAgIC8qKiBAcHJpdmF0ZSB7IVdlYkRyaXZlcn0gKi9cbiAgICB0aGlzLmRyaXZlcl8gPSBkcml2ZXJcblxuICAgIC8qKiBAcHJpdmF0ZSB7IVByb21pc2U8c3RyaW5nPn0gKi9cbiAgICB0aGlzLmlkXyA9IFByb21pc2UucmVzb2x2ZShpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHJhdyBJRC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gbm9MZWdhY3kgV2hldGhlciB0byBleGNsdWRlIHRoZSBsZWdhY3kgZWxlbWVudCBrZXkuXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBlbGVtZW50IElEIGZvciB1c2Ugd2l0aCBXZWJEcml2ZXIncyB3aXJlIHByb3RvY29sLlxuICAgKi9cbiAgc3RhdGljIGJ1aWxkSWQoaWQsIG5vTGVnYWN5ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbm9MZWdhY3lcbiAgICAgID8geyBbRUxFTUVOVF9JRF9LRVldOiBpZCB9XG4gICAgICA6IHsgW0VMRU1FTlRfSURfS0VZXTogaWQsIFtMRUdBQ1lfRUxFTUVOVF9JRF9LRVldOiBpZCB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGVuY29kZWQgV2ViRWxlbWVudCBJRCBmcm9tIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7P30gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgSUQgZnJvbS5cbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXh0cmFjdGVkIElELlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHRoZSBvYmplY3QgaXMgbm90IGEgdmFsaWQgZW5jb2RlZCBJRC5cbiAgICovXG4gIHN0YXRpYyBleHRyYWN0SWQob2JqKSB7XG4gICAgcmV0dXJuIHdlYkVsZW1lbnQuZXh0cmFjdElkKG9iailcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez99IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIHZhbGlkIGVuY29kZWQgV2ViRWxlbWVudCBJRC5cbiAgICovXG4gIHN0YXRpYyBpc0lkKG9iaikge1xuICAgIHJldHVybiB3ZWJFbGVtZW50LmlzSWQob2JqKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHR3byBXZWJFbGVtZW50cyBmb3IgZXF1YWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVdlYkVsZW1lbnR9IGEgQSBXZWJFbGVtZW50LlxuICAgKiBAcGFyYW0geyFXZWJFbGVtZW50fSBiIEEgV2ViRWxlbWVudC5cbiAgICogQHJldHVybiB7IVByb21pc2U8Ym9vbGVhbj59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmVcbiAgICogICAgIHJlc29sdmVkIHRvIHdoZXRoZXIgdGhlIHR3byBXZWJFbGVtZW50cyBhcmUgZXF1YWwuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGEuZHJpdmVyXy5leGVjdXRlU2NyaXB0KCdyZXR1cm4gYXJndW1lbnRzWzBdID09PSBhcmd1bWVudHNbMV0nLCBhLCBiKVxuICB9XG5cbiAgLyoqIEByZXR1cm4geyFXZWJEcml2ZXJ9IFRoZSBwYXJlbnQgZHJpdmVyIGZvciB0aGlzIGluc3RhbmNlLiAqL1xuICBnZXREcml2ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyX1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvXG4gICAqICAgICB0aGUgc2VydmVyLWFzc2lnbmVkIG9wYXF1ZSBJRCBhc3NpZ25lZCB0byB0aGlzIGVsZW1lbnQuXG4gICAqL1xuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZF9cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIHRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgV2ViRWxlbWVudC5cbiAgICovXG4gIFtTeW1ib2xzLnNlcmlhbGl6ZV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SWQoKS50aGVuKFdlYkVsZW1lbnQuYnVpbGRJZClcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBjb21tYW5kIHRoYXQgdGFyZ2V0cyB0aGlzIGVsZW1lbnQgd2l0aCB0aGUgcGFyZW50IFdlYkRyaXZlclxuICAgKiBpbnN0YW5jZS4gV2lsbCBlbnN1cmUgdGhpcyBlbGVtZW50J3MgSUQgaXMgaW5jbHVkZWQgaW4gdGhlIGNvbW1hbmRcbiAgICogcGFyYW1ldGVycyB1bmRlciB0aGUgXCJpZFwiIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHshY29tbWFuZC5Db21tYW5kfSBjb21tYW5kIFRoZSBjb21tYW5kIHRvIHNjaGVkdWxlLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxUPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBzZWUgV2ViRHJpdmVyI3NjaGVkdWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleGVjdXRlXyhjb21tYW5kKSB7XG4gICAgY29tbWFuZC5zZXRQYXJhbWV0ZXIoJ2lkJywgdGhpcylcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfLmV4ZWN1dGUoY29tbWFuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZSBhIGNvbW1hbmQgdG8gZmluZCBhIGRlc2NlbmRhbnQgb2YgdGhpcyBlbGVtZW50LiBJZiB0aGUgZWxlbWVudFxuICAgKiBjYW5ub3QgYmUgZm91bmQsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhXG4gICAqIHtAbGlua3BsYWluIGVycm9yLk5vU3VjaEVsZW1lbnRFcnJvciBOb1N1Y2hFbGVtZW50RXJyb3J9LlxuICAgKlxuICAgKiBUaGUgc2VhcmNoIGNyaXRlcmlhIGZvciBhbiBlbGVtZW50IG1heSBiZSBkZWZpbmVkIHVzaW5nIG9uZSBvZiB0aGUgc3RhdGljXG4gICAqIGZhY3RvcmllcyBvbiB0aGUge0BsaW5rIGJ5LkJ5fSBjbGFzcywgb3IgYXMgYSBzaG9ydC1oYW5kXG4gICAqIHtAbGluayAuL2J5LkJ5SGFzaH0gb2JqZWN0LiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB0d28gc3RhdGVtZW50c1xuICAgKiBhcmUgZXF1aXZhbGVudDpcbiAgICpcbiAgICogICAgIHZhciBlMSA9IGVsZW1lbnQuZmluZEVsZW1lbnQoQnkuaWQoJ2ZvbycpKTtcbiAgICogICAgIHZhciBlMiA9IGVsZW1lbnQuZmluZEVsZW1lbnQoe2lkOidmb28nfSk7XG4gICAqXG4gICAqIFlvdSBtYXkgYWxzbyBwcm92aWRlIGEgY3VzdG9tIGxvY2F0b3IgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGFzIGlucHV0IHRoaXNcbiAgICogaW5zdGFuY2UgYW5kIHJldHVybnMgYSB7QGxpbmsgV2ViRWxlbWVudH0sIG9yIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZVxuICAgKiB0byBhIFdlYkVsZW1lbnQuIElmIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHRvIGFuIGFycmF5IG9mXG4gICAqIFdlYkVsZW1lbnRzLCBXZWJEcml2ZXIgd2lsbCB1c2UgdGhlIGZpcnN0IGVsZW1lbnQuIEZvciBleGFtcGxlLCB0byBmaW5kIHRoZVxuICAgKiBmaXJzdCB2aXNpYmxlIGxpbmsgb24gYSBwYWdlLCB5b3UgY291bGQgd3JpdGU6XG4gICAqXG4gICAqICAgICB2YXIgbGluayA9IGVsZW1lbnQuZmluZEVsZW1lbnQoZmlyc3RWaXNpYmxlTGluayk7XG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBmaXJzdFZpc2libGVMaW5rKGVsZW1lbnQpIHtcbiAgICogICAgICAgdmFyIGxpbmtzID0gZWxlbWVudC5maW5kRWxlbWVudHMoQnkudGFnTmFtZSgnYScpKTtcbiAgICogICAgICAgcmV0dXJuIHByb21pc2UuZmlsdGVyKGxpbmtzLCBmdW5jdGlvbihsaW5rKSB7XG4gICAqICAgICAgICAgcmV0dXJuIGxpbmsuaXNEaXNwbGF5ZWQoKTtcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7IShieS5CeXxGdW5jdGlvbil9IGxvY2F0b3IgVGhlIGxvY2F0b3Igc3RyYXRlZ3kgdG8gdXNlIHdoZW5cbiAgICogICAgIHNlYXJjaGluZyBmb3IgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFXZWJFbGVtZW50UHJvbWlzZX0gQSBXZWJFbGVtZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaXNzdWVcbiAgICogICAgIGNvbW1hbmRzIGFnYWluc3QgdGhlIGxvY2F0ZWQgZWxlbWVudC4gSWYgdGhlIGVsZW1lbnQgaXMgbm90IGZvdW5kLCB0aGVcbiAgICogICAgIGVsZW1lbnQgd2lsbCBiZSBpbnZhbGlkYXRlZCBhbmQgYWxsIHNjaGVkdWxlZCBjb21tYW5kcyBhYm9ydGVkLlxuICAgKi9cbiAgZmluZEVsZW1lbnQobG9jYXRvcikge1xuICAgIGxvY2F0b3IgPSBieS5jaGVja2VkTG9jYXRvcihsb2NhdG9yKVxuICAgIGxldCBpZFxuICAgIGlmICh0eXBlb2YgbG9jYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWQgPSB0aGlzLmRyaXZlcl8uZmluZEVsZW1lbnRJbnRlcm5hbF8obG9jYXRvciwgdGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNtZCA9IG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkZJTkRfQ0hJTERfRUxFTUVOVClcbiAgICAgICAgLnNldFBhcmFtZXRlcigndXNpbmcnLCBsb2NhdG9yLnVzaW5nKVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCd2YWx1ZScsIGxvY2F0b3IudmFsdWUpXG4gICAgICBpZCA9IHRoaXMuZXhlY3V0ZV8oY21kKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFdlYkVsZW1lbnRQcm9taXNlKHRoaXMuZHJpdmVyXywgaWQpXG4gIH1cblxuICAvKipcbiAgICogTG9jYXRlcyBhbGwgdGhlIGRlc2NlbmRhbnRzIG9mIHRoaXMgZWxlbWVudCB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzZWFyY2hcbiAgICogY3JpdGVyaWEuXG4gICAqXG4gICAqIEBwYXJhbSB7IShieS5CeXxGdW5jdGlvbil9IGxvY2F0b3IgVGhlIGxvY2F0b3Igc3RyYXRlZ3kgdG8gdXNlIHdoZW5cbiAgICogICAgIHNlYXJjaGluZyBmb3IgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPCFBcnJheTwhV2ViRWxlbWVudD4+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gYW5cbiAgICogICAgIGFycmF5IG9mIFdlYkVsZW1lbnRzLlxuICAgKi9cbiAgYXN5bmMgZmluZEVsZW1lbnRzKGxvY2F0b3IpIHtcbiAgICBsb2NhdG9yID0gYnkuY2hlY2tlZExvY2F0b3IobG9jYXRvcilcbiAgICBpZiAodHlwZW9mIGxvY2F0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZmluZEVsZW1lbnRzSW50ZXJuYWxfKGxvY2F0b3IsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbWQgPSBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5GSU5EX0NISUxEX0VMRU1FTlRTKVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCd1c2luZycsIGxvY2F0b3IudXNpbmcpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ3ZhbHVlJywgbG9jYXRvci52YWx1ZSlcbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVfKGNtZClcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGlja3Mgb24gdGhpcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBjbGlja1xuICAgKiAgICAgY29tbWFuZCBoYXMgY29tcGxldGVkLlxuICAgKi9cbiAgY2xpY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuQ0xJQ0tfRUxFTUVOVCkpXG4gIH1cblxuICAvKipcbiAgICogVHlwZXMgYSBrZXkgc2VxdWVuY2Ugb24gdGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAqXG4gICAqIE1vZGlmaWVyIGtleXMgKFNISUZULCBDT05UUk9MLCBBTFQsIE1FVEEpIGFyZSBzdGF0ZWZ1bDsgb25jZSBhIG1vZGlmaWVyIGlzXG4gICAqIHByb2Nlc3NlZCBpbiB0aGUga2V5IHNlcXVlbmNlLCB0aGF0IGtleSBzdGF0ZSBpcyB0b2dnbGVkIHVudGlsIG9uZSBvZiB0aGVcbiAgICogZm9sbG93aW5nIG9jY3VyczpcbiAgICpcbiAgICogLSBUaGUgbW9kaWZpZXIga2V5IGlzIGVuY291bnRlcmVkIGFnYWluIGluIHRoZSBzZXF1ZW5jZS4gQXQgdGhpcyBwb2ludCB0aGVcbiAgICogICBzdGF0ZSBvZiB0aGUga2V5IGlzIHRvZ2dsZWQgKGFsb25nIHdpdGggdGhlIGFwcHJvcHJpYXRlIGtleXVwL2Rvd25cbiAgICogICBldmVudHMpLlxuICAgKiAtIFRoZSB7QGxpbmsgaW5wdXQuS2V5Lk5VTEx9IGtleSBpcyBlbmNvdW50ZXJlZCBpbiB0aGUgc2VxdWVuY2UuIFdoZW5cbiAgICogICB0aGlzIGtleSBpcyBlbmNvdW50ZXJlZCwgYWxsIG1vZGlmaWVyIGtleXMgY3VycmVudCBpbiB0aGUgZG93biBzdGF0ZSBhcmVcbiAgICogICByZWxlYXNlZCAod2l0aCBhY2NvbXBhbnlpbmcga2V5dXAgZXZlbnRzKS4gVGhlIE5VTEwga2V5IGNhbiBiZSB1c2VkIHRvXG4gICAqICAgc2ltdWxhdGUgY29tbW9uIGtleWJvYXJkIHNob3J0Y3V0czpcbiAgICpcbiAgICogICAgICAgICBlbGVtZW50LnNlbmRLZXlzKFwidGV4dCB3YXNcIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEtleS5DT05UUk9MLCBcImFcIiwgS2V5Lk5VTEwsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vdyB0ZXh0IGlzXCIpO1xuICAgKiAgICAgICAgIC8vIEFsdGVybmF0aXZlbHk6XG4gICAqICAgICAgICAgZWxlbWVudC5zZW5kS2V5cyhcInRleHQgd2FzXCIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBLZXkuY2hvcmQoS2V5LkNPTlRST0wsIFwiYVwiKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFwibm93IHRleHQgaXNcIik7XG4gICAqXG4gICAqIC0gVGhlIGVuZCBvZiB0aGUga2V5IHNlcXVlbmNlIGlzIGVuY291bnRlcmVkLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGtleXNcbiAgICogICB0byB0eXBlLCBhbGwgZGVwcmVzc2VkIG1vZGlmaWVyIGtleXMgYXJlIHJlbGVhc2VkICh3aXRoIGFjY29tcGFueWluZ1xuICAgKiAgIGtleXVwIGV2ZW50cykuXG4gICAqXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBhIGZpbGUgaW5wdXQgKHtAY29kZSA8aW5wdXQgdHlwZT1cImZpbGVcIj59KSwgdGhlXG4gICAqIHNwZWNpZmllZCBrZXkgc2VxdWVuY2Ugc2hvdWxkIHNwZWNpZnkgdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gYXR0YWNoIHRvXG4gICAqIHRoZSBlbGVtZW50LiBUaGlzIGlzIGFuYWxvZ291cyB0byB0aGUgdXNlciBjbGlja2luZyBcIkJyb3dzZS4uLlwiIGFuZCBlbnRlcmluZ1xuICAgKiB0aGUgcGF0aCBpbnRvIHRoZSBmaWxlIHNlbGVjdCBkaWFsb2cuXG4gICAqXG4gICAqICAgICB2YXIgZm9ybSA9IGRyaXZlci5maW5kRWxlbWVudChCeS5jc3MoJ2Zvcm0nKSk7XG4gICAqICAgICB2YXIgZWxlbWVudCA9IGZvcm0uZmluZEVsZW1lbnQoQnkuY3NzKCdpbnB1dFt0eXBlPWZpbGVdJykpO1xuICAgKiAgICAgZWxlbWVudC5zZW5kS2V5cygnL3BhdGgvdG8vZmlsZS50eHQnKTtcbiAgICogICAgIGZvcm0uc3VibWl0KCk7XG4gICAqXG4gICAqIEZvciB1cGxvYWRzIHRvIGZ1bmN0aW9uIGNvcnJlY3RseSwgdGhlIGVudGVyZWQgcGF0aCBtdXN0IHJlZmVyZW5jZSBhIGZpbGVcbiAgICogb24gdGhlIF9icm93c2VyJ3NfIG1hY2hpbmUsIG5vdCB0aGUgbG9jYWwgbWFjaGluZSBydW5uaW5nIHRoaXMgc2NyaXB0LiBXaGVuXG4gICAqIHJ1bm5pbmcgYWdhaW5zdCBhIHJlbW90ZSBTZWxlbml1bSBzZXJ2ZXIsIGEge0BsaW5rIGlucHV0LkZpbGVEZXRlY3Rvcn1cbiAgICogbWF5IGJlIHVzZWQgdG8gdHJhbnNwYXJlbnRseSBjb3B5IGZpbGVzIHRvIHRoZSByZW1vdGUgbWFjaGluZSBiZWZvcmVcbiAgICogYXR0ZW1wdGluZyB0byB1cGxvYWQgdGhlbSBpbiB0aGUgYnJvd3Nlci5cbiAgICpcbiAgICogX19Ob3RlOl9fIE9uIGJyb3dzZXJzIHdoZXJlIG5hdGl2ZSBrZXlib2FyZCBldmVudHMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICogKGUuZy4gRmlyZWZveCBvbiBPUyBYKSwga2V5IGV2ZW50cyB3aWxsIGJlIHN5bnRoZXNpemVkLiBTcGVjaWFsXG4gICAqIHB1bmN0dWF0aW9uIGtleXMgd2lsbCBiZSBzeW50aGVzaXplZCBhY2NvcmRpbmcgdG8gYSBzdGFuZGFyZCBRV0VSVFkgZW4tdXNcbiAgICoga2V5Ym9hcmQgbGF5b3V0LlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihudW1iZXJ8c3RyaW5nfCFJVGhlbmFibGU8KG51bWJlcnxzdHJpbmcpPil9IGFyZ3MgVGhlXG4gICAqICAgICBzZXF1ZW5jZSBvZiBrZXlzIHRvIHR5cGUuIE51bWJlciBrZXlzIG1heSBiZSByZWZlcmVuY2VkIG51bWVyaWNhbGx5IG9yXG4gICAqICAgICBieSBzdHJpbmcgKDEgb3IgJzEnKS4gQWxsIGFyZ3VtZW50cyB3aWxsIGJlIGpvaW5lZCBpbnRvIGEgc2luZ2xlXG4gICAqICAgICBzZXF1ZW5jZS5cbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiBhbGwga2V5c1xuICAgKiAgICAgaGF2ZSBiZWVuIHR5cGVkLlxuICAgKi9cbiAgYXN5bmMgc2VuZEtleXMoLi4uYXJncykge1xuICAgIGxldCBrZXlzID0gW11cbiAgICA7KGF3YWl0IFByb21pc2UuYWxsKGFyZ3MpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCB0eXBlID0gdHlwZW9mIGtleVxuICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGtleSA9IFN0cmluZyhrZXkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZWFjaCBrZXkgbXVzdCBiZSBhIG51bWJlciBvciBzdHJpbmc7IGdvdCAnICsgdHlwZSlcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIFczQyBwcm90b2NvbCByZXF1aXJlcyBrZXlzIHRvIGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheSB3aGVyZVxuICAgICAgLy8gZWFjaCBlbGVtZW50IGlzIGEgc2luZ2xlIGtleS5cbiAgICAgIGtleXMucHVzaCguLi5rZXkpXG4gICAgfSlcblxuICAgIGlmICghdGhpcy5kcml2ZXJfLmZpbGVEZXRlY3Rvcl8pIHtcbiAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVfKFxuICAgICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5TRU5EX0tFWVNfVE9fRUxFTUVOVClcbiAgICAgICAgICAuc2V0UGFyYW1ldGVyKCd0ZXh0Jywga2V5cy5qb2luKCcnKSlcbiAgICAgICAgICAuc2V0UGFyYW1ldGVyKCd2YWx1ZScsIGtleXMpXG4gICAgICApXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGtleXMgPSBhd2FpdCB0aGlzLmRyaXZlcl8uZmlsZURldGVjdG9yXy5oYW5kbGVGaWxlKFxuICAgICAgICB0aGlzLmRyaXZlcl8sXG4gICAgICAgIGtleXMuam9pbignJylcbiAgICAgIClcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICdFcnJvciB0cnlpbmcgcGFyc2Ugc3RyaW5nIGFzIGEgZmlsZSB3aXRoIGZpbGUgZGV0ZWN0b3I7IHNlbmRpbmcga2V5cyBpbnN0ZWFkJyArXG4gICAgICAgICAgZXhcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5leGVjdXRlXyhcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLlNFTkRfS0VZU19UT19FTEVNRU5UKVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCd0ZXh0Jywga2V5cylcbiAgICAgICAgLnNldFBhcmFtZXRlcigndmFsdWUnLCBrZXlzLnNwbGl0KCcnKSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50J3MgdGFnIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgICogICAgIGVsZW1lbnQncyB0YWcgbmFtZS5cbiAgICovXG4gIGdldFRhZ05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0VMRU1FTlRfVEFHX05BTUUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBjb21wdXRlZCBzdHlsZSBwcm9wZXJ0eSBmb3IgdGhpcyBpbnN0YW5jZS4gSWZcbiAgICogdGhlIGVsZW1lbnQgaW5oZXJpdHMgdGhlIG5hbWVkIHN0eWxlIGZyb20gaXRzIHBhcmVudCwgdGhlIHBhcmVudCB3aWxsIGJlXG4gICAqIHF1ZXJpZWQgZm9yIGl0cyB2YWx1ZS4gIFdoZXJlIHBvc3NpYmxlLCBjb2xvciB2YWx1ZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG9cbiAgICogdGhlaXIgaGV4IHJlcHJlc2VudGF0aW9uIChlLmcuICMwMGZmMDAgaW5zdGVhZCBvZiByZ2IoMCwgMjU1LCAwKSkuXG4gICAqXG4gICAqIF9XYXJuaW5nOl8gdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgYmUgYXMgdGhlIGJyb3dzZXIgaW50ZXJwcmV0cyBpdCwgc29cbiAgICogaXQgbWF5IGJlIHRyaWNreSB0byBmb3JtIGEgcHJvcGVyIGFzc2VydGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1N0eWxlUHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIENTUyBzdHlsZSBwcm9wZXJ0eSB0byBsb29rXG4gICAqICAgICB1cC5cbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZVxuICAgKiAgICAgcmVxdWVzdGVkIENTUyB2YWx1ZS5cbiAgICovXG4gIGdldENzc1ZhbHVlKGNzc1N0eWxlUHJvcGVydHkpIHtcbiAgICBjb25zdCBuYW1lID0gY29tbWFuZC5OYW1lLkdFVF9FTEVNRU5UX1ZBTFVFX09GX0NTU19QUk9QRVJUWVxuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVfKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChuYW1lKS5zZXRQYXJhbWV0ZXIoJ3Byb3BlcnR5TmFtZScsIGNzc1N0eWxlUHJvcGVydHkpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoaXMgZWxlbWVudC5cbiAgICogV2lsbCByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUsIGV2ZW4gaWYgaXQgaGFzIGJlZW4gbW9kaWZpZWQgYWZ0ZXIgdGhlIHBhZ2VcbiAgICogaGFzIGJlZW4gbG9hZGVkLiBNb3JlIGV4YWN0bHksIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZVxuICAgKiBvZiB0aGUgZ2l2ZW4gYXR0cmlidXRlLCB1bmxlc3MgdGhhdCBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQsIGluIHdoaWNoIGNhc2VcbiAgICogdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWUgaXMgcmV0dXJuZWQuIElmIG5laXRoZXIgdmFsdWVcbiAgICogaXMgc2V0LCBudWxsIGlzIHJldHVybmVkIChmb3IgZXhhbXBsZSwgdGhlIFwidmFsdWVcIiBwcm9wZXJ0eSBvZiBhIHRleHRhcmVhXG4gICAqIGVsZW1lbnQpLiBUaGUgXCJzdHlsZVwiIGF0dHJpYnV0ZSBpcyBjb252ZXJ0ZWQgYXMgYmVzdCBjYW4gYmUgdG8gYVxuICAgKiB0ZXh0IHJlcHJlc2VudGF0aW9uIHdpdGggYSB0cmFpbGluZyBzZW1pY29sb24uIFRoZSBmb2xsb3dpbmcgYXJlIGRlZW1lZCB0b1xuICAgKiBiZSBcImJvb2xlYW5cIiBhdHRyaWJ1dGVzIGFuZCB3aWxsIHJldHVybiBlaXRoZXIgXCJ0cnVlXCIgb3IgbnVsbDpcbiAgICpcbiAgICogYXN5bmMsIGF1dG9mb2N1cywgYXV0b3BsYXksIGNoZWNrZWQsIGNvbXBhY3QsIGNvbXBsZXRlLCBjb250cm9scywgZGVjbGFyZSxcbiAgICogZGVmYXVsdGNoZWNrZWQsIGRlZmF1bHRzZWxlY3RlZCwgZGVmZXIsIGRpc2FibGVkLCBkcmFnZ2FibGUsIGVuZGVkLFxuICAgKiBmb3Jtbm92YWxpZGF0ZSwgaGlkZGVuLCBpbmRldGVybWluYXRlLCBpc2NvbnRlbnRlZGl0YWJsZSwgaXNtYXAsIGl0ZW1zY29wZSxcbiAgICogbG9vcCwgbXVsdGlwbGUsIG11dGVkLCBub2hyZWYsIG5vcmVzaXplLCBub3NoYWRlLCBub3ZhbGlkYXRlLCBub3dyYXAsIG9wZW4sXG4gICAqIHBhdXNlZCwgcHViZGF0ZSwgcmVhZG9ubHksIHJlcXVpcmVkLCByZXZlcnNlZCwgc2NvcGVkLCBzZWFtbGVzcywgc2Vla2luZyxcbiAgICogc2VsZWN0ZWQsIHNwZWxsY2hlY2ssIHRydWVzcGVlZCwgd2lsbHZhbGlkYXRlXG4gICAqXG4gICAqIEZpbmFsbHksIHRoZSBmb2xsb3dpbmcgY29tbW9ubHkgbWlzLWNhcGl0YWxpemVkIGF0dHJpYnV0ZS9wcm9wZXJ0eSBuYW1lc1xuICAgKiBhcmUgZXZhbHVhdGVkIGFzIGV4cGVjdGVkOlxuICAgKlxuICAgKiAtIFwiY2xhc3NcIlxuICAgKiAtIFwicmVhZG9ubHlcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTw/c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgcmVzb2x2ZWQgd2l0aCB0aGUgYXR0cmlidXRlJ3MgdmFsdWUuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGFsd2F5cyBiZVxuICAgKiAgICAgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGwuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVfKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0VMRU1FTlRfQVRUUklCVVRFKS5zZXRQYXJhbWV0ZXIoXG4gICAgICAgICduYW1lJyxcbiAgICAgICAgYXR0cmlidXRlTmFtZVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGVsZW1lbnQuXG4gICAqIDxwPlxuICAgKiBUaGlzIG1ldGhvZCwgdW5saWtlIHtAbGluayAjZ2V0QXR0cmlidXRlKFN0cmluZyl9LCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHdpdGggdGhlXG4gICAqIGdpdmVuIG5hbWUgYnV0IG5vdCB0aGUgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICAgKiA8cD5cbiAgICogVGhlIGZvbGxvd2luZyBhcmUgZGVlbWVkIHRvIGJlIFwiYm9vbGVhblwiIGF0dHJpYnV0ZXMsIGFuZCB3aWxsIHJldHVybiBlaXRoZXIgXCJ0cnVlXCIgb3IgbnVsbDpcbiAgICogPHA+XG4gICAqIGFzeW5jLCBhdXRvZm9jdXMsIGF1dG9wbGF5LCBjaGVja2VkLCBjb21wYWN0LCBjb21wbGV0ZSwgY29udHJvbHMsIGRlY2xhcmUsIGRlZmF1bHRjaGVja2VkLFxuICAgKiBkZWZhdWx0c2VsZWN0ZWQsIGRlZmVyLCBkaXNhYmxlZCwgZHJhZ2dhYmxlLCBlbmRlZCwgZm9ybW5vdmFsaWRhdGUsIGhpZGRlbiwgaW5kZXRlcm1pbmF0ZSxcbiAgICogaXNjb250ZW50ZWRpdGFibGUsIGlzbWFwLCBpdGVtc2NvcGUsIGxvb3AsIG11bHRpcGxlLCBtdXRlZCwgbm9ocmVmLCBub3Jlc2l6ZSwgbm9zaGFkZSxcbiAgICogbm92YWxpZGF0ZSwgbm93cmFwLCBvcGVuLCBwYXVzZWQsIHB1YmRhdGUsIHJlYWRvbmx5LCByZXF1aXJlZCwgcmV2ZXJzZWQsIHNjb3BlZCwgc2VhbWxlc3MsXG4gICAqIHNlZWtpbmcsIHNlbGVjdGVkLCB0cnVlc3BlZWQsIHdpbGx2YWxpZGF0ZVxuICAgKiA8cD5cbiAgICogU2VlIDxhIGhyZWY9XCJodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLyNnZXQtZWxlbWVudC1hdHRyaWJ1dGVcIj5XM0MgV2ViRHJpdmVyIHNwZWNpZmljYXRpb248L2E+XG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4gVGhlIGF0dHJpYnV0ZSdzIHZhbHVlIG9yIG51bGwgaWYgdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gICAqL1xuXG4gIGdldERvbUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8oXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5HRVRfRE9NX0FUVFJJQlVURSkuc2V0UGFyYW1ldGVyKFxuICAgICAgICAnbmFtZScsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVcbiAgICAgIClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBnaXZlbiBwcm9wZXJ0eSBvZiB0aGUgcmVmZXJlbmNlZCB3ZWIgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmVcbiAgICogICAgIHJlc29sdmVkIHdpdGggdGhlIGVsZW1lbnQncyBwcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgZ2V0UHJvcGVydHkocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8oXG4gICAgICBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5HRVRfRUxFTUVOVF9QUk9QRVJUWSkuc2V0UGFyYW1ldGVyKFxuICAgICAgICAnbmFtZScsXG4gICAgICAgIHByb3BlcnR5TmFtZVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNoYWRvdyByb290IG9mIHRoZSBjdXJyZW50IHdlYiBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7IVByb21pc2U8U2hhZG93Um9vdD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmVcbiAgICogICAgICByZXNvbHZlZCB3aXRoIHRoZSBlbGVtZW50cyBzaGFkb3cgcm9vdCBvciByZWplY3RlZFxuICAgKiAgICAgIHdpdGgge0BsaW5rIE5vU3VjaFNoYWRvd1Jvb3RFcnJvcn1cbiAgICovXG4gIGdldFNoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX1NIQURPV19ST09UKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpc2libGUgKGkuZS4gbm90IGhpZGRlbiBieSBDU1MpIGlubmVyVGV4dCBvZiB0aGlzIGVsZW1lbnQsXG4gICAqIGluY2x1ZGluZyBzdWItZWxlbWVudHMsIHdpdGhvdXQgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgcmVzb2x2ZWQgd2l0aCB0aGUgZWxlbWVudCdzIHZpc2libGUgdGV4dC5cbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0VMRU1FTlRfVEVYVCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wdXRlZCBXQUktQVJJQSByb2xlIG9mIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmVcbiAgICogICAgIHJlc29sdmVkIHdpdGggdGhlIGVsZW1lbnQncyBjb21wdXRlZCByb2xlLlxuICAgKi9cbiAgZ2V0QXJpYVJvbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0NPTVBVVEVEX1JPTEUpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcHV0ZWQgV0FJLUFSSUEgbGFiZWwgb2YgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgcmVzb2x2ZWQgd2l0aCB0aGUgZWxlbWVudCdzIGNvbXB1dGVkIGxhYmVsLlxuICAgKi9cbiAgZ2V0QWNjZXNzaWJsZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0NPTVBVVEVEX0xBQkVMKSlcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgZGVzY3JpYmluZyBhbiBlbGVtZW50J3MgbG9jYXRpb24sIGluIHBpeGVscyByZWxhdGl2ZSB0b1xuICAgKiB0aGUgZG9jdW1lbnQgZWxlbWVudCwgYW5kIHRoZSBlbGVtZW50J3Mgc2l6ZSBpbiBwaXhlbHMuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXJ9Pn1cbiAgICogICAgIEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBlbGVtZW50J3MgcmVjdC5cbiAgICovXG4gIGdldFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuR0VUX0VMRU1FTlRfUkVDVCkpXG4gIH1cblxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciB0aGlzIGVsZW1lbnQgaXMgZW5hYmxlZCwgYXMgZGljdGF0ZWQgYnkgdGhlIGBkaXNhYmxlZGBcbiAgICogYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxib29sZWFuPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgcmVzb2x2ZWQgd2l0aCB3aGV0aGVyIHRoaXMgZWxlbWVudCBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlXyhuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5JU19FTEVNRU5UX0VOQUJMRUQpKVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgdGhpcyBlbGVtZW50IGlzIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxib29sZWFuPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgcmVzb2x2ZWQgd2l0aCB3aGV0aGVyIHRoaXMgZWxlbWVudCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAqL1xuICBpc1NlbGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVfKG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLklTX0VMRU1FTlRfU0VMRUNURUQpKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgdGhlIGZvcm0gY29udGFpbmluZyB0aGlzIGVsZW1lbnQgKG9yIHRoaXMgZWxlbWVudCBpZiBpdCBpcyBpdHNlbGZcbiAgICogYSBGT1JNIGVsZW1lbnQpLiBoaXMgY29tbWFuZCBpcyBhIG5vLW9wIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBjb250YWluZWQgaW5cbiAgICogYSBmb3JtLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICAgKiAgICAgd2hlbiB0aGUgZm9ybSBoYXMgYmVlbiBzdWJtaXR0ZWQuXG4gICAqL1xuICBzdWJtaXQoKSB7XG4gICAgY29uc3Qgc2NyaXB0ID1cbiAgICAgICcvKiBzdWJtaXRGb3JtICovdmFyIGZvcm0gPSBhcmd1bWVudHNbMF07XFxuJyArXG4gICAgICAnd2hpbGUgKGZvcm0ubm9kZU5hbWUgIT0gXCJGT1JNXCIgJiYgZm9ybS5wYXJlbnROb2RlKSB7XFxuJyArXG4gICAgICAnICBmb3JtID0gZm9ybS5wYXJlbnROb2RlO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgIFwiaWYgKCFmb3JtKSB7IHRocm93IEVycm9yKCdVbmFibGUgdG8gZmluZCBjb250YWluaW5nIGZvcm0gZWxlbWVudCcpOyB9XFxuXCIgK1xuICAgICAgXCJpZiAoIWZvcm0ub3duZXJEb2N1bWVudCkgeyB0aHJvdyBFcnJvcignVW5hYmxlIHRvIGZpbmQgb3duaW5nIGRvY3VtZW50Jyk7IH1cXG5cIiArXG4gICAgICBcInZhciBlID0gZm9ybS5vd25lckRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xcblwiICtcbiAgICAgIFwiZS5pbml0RXZlbnQoJ3N1Ym1pdCcsIHRydWUsIHRydWUpO1xcblwiICtcbiAgICAgICdpZiAoZm9ybS5kaXNwYXRjaEV2ZW50KGUpKSB7IEhUTUxGb3JtRWxlbWVudC5wcm90b3R5cGUuc3VibWl0LmNhbGwoZm9ybSkgfVxcbidcblxuICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZXhlY3V0ZVNjcmlwdChzY3JpcHQsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGB2YWx1ZWAgb2YgdGhpcyBlbGVtZW50LiBUaGlzIGNvbW1hbmQgaGFzIG5vIGVmZmVjdCBpZiB0aGVcbiAgICogdW5kZXJseWluZyBET00gZWxlbWVudCBpcyBuZWl0aGVyIGEgdGV4dCBJTlBVVCBlbGVtZW50IG5vciBhIFRFWFRBUkVBXG4gICAqIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkXG4gICAqICAgICB3aGVuIHRoZSBlbGVtZW50IGhhcyBiZWVuIGNsZWFyZWQuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlXyhuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5DTEVBUl9FTEVNRU5UKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhpcyBlbGVtZW50IGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlXG4gICAqICAgICByZXNvbHZlZCB3aXRoIHdoZXRoZXIgdGhpcyBlbGVtZW50IGlzIGN1cnJlbnRseSB2aXNpYmxlIG9uIHRoZSBwYWdlLlxuICAgKi9cbiAgaXNEaXNwbGF5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8obmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuSVNfRUxFTUVOVF9ESVNQTEFZRUQpKVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgYSBzY3JlZW5zaG90IG9mIHRoZSB2aXNpYmxlIHJlZ2lvbiBlbmNvbXBhc3NlZCBieSB0aGlzIGVsZW1lbnQnc1xuICAgKiBib3VuZGluZyByZWN0YW5nbGUuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmVcbiAgICogICAgIHJlc29sdmVkIHRvIHRoZSBzY3JlZW5zaG90IGFzIGEgYmFzZS02NCBlbmNvZGVkIFBORy5cbiAgICovXG4gIHRha2VTY3JlZW5zaG90KCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVfKFxuICAgICAgbmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuVEFLRV9FTEVNRU5UX1NDUkVFTlNIT1QpXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogV2ViRWxlbWVudFByb21pc2UgaXMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCBhIFdlYkVsZW1lbnQuXG4gKiBUaGlzIHNlcnZlcyBhcyBhIGZvcndhcmQgcHJveHkgb24gV2ViRWxlbWVudCwgYWxsb3dpbmcgY2FsbHMgdG8gYmVcbiAqIHNjaGVkdWxlZCB3aXRob3V0IGRpcmVjdGx5IG9uIHRoaXMgaW5zdGFuY2UgYmVmb3JlIHRoZSB1bmRlcmx5aW5nXG4gKiBXZWJFbGVtZW50IGhhcyBiZWVuIGZ1bGZpbGxlZC4gSW4gb3RoZXIgd29yZHMsIHRoZSBmb2xsb3dpbmcgdHdvIHN0YXRlbWVudHNcbiAqIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgICBkcml2ZXIuZmluZEVsZW1lbnQoe2lkOiAnbXktYnV0dG9uJ30pLmNsaWNrKCk7XG4gKiAgICAgZHJpdmVyLmZpbmRFbGVtZW50KHtpZDogJ215LWJ1dHRvbid9KS50aGVuKGZ1bmN0aW9uKGVsKSB7XG4gKiAgICAgICByZXR1cm4gZWwuY2xpY2soKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAaW1wbGVtZW50cyB7SVRoZW5hYmxlPCFXZWJFbGVtZW50Pn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBXZWJFbGVtZW50UHJvbWlzZSBleHRlbmRzIFdlYkVsZW1lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshV2ViRHJpdmVyfSBkcml2ZXIgVGhlIHBhcmVudCBXZWJEcml2ZXIgaW5zdGFuY2UgZm9yIHRoaXNcbiAgICogICAgIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IVByb21pc2U8IVdlYkVsZW1lbnQ+fSBlbCBBIHByb21pc2VcbiAgICogICAgIHRoYXQgd2lsbCByZXNvbHZlIHRvIHRoZSBwcm9taXNlZCBlbGVtZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJpdmVyLCBlbCkge1xuICAgIHN1cGVyKGRyaXZlciwgJ3VudXNlZCcpXG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgdGhpcy50aGVuID0gZWwudGhlbi5iaW5kKGVsKVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIHRoaXMuY2F0Y2ggPSBlbC5jYXRjaC5iaW5kKGVsKVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIHJldHVybmluZyB0aGUgZWxlbWVudCBJRCB1bnRpbCB0aGUgd3JhcHBlZCBXZWJFbGVtZW50IGhhcyBiZWVuXG4gICAgICogcmVzb2x2ZWQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdGhpcy5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlbC50aGVuKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwuZ2V0SWQoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gIFNoYWRvd1Jvb3Rcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgU2hhZG93Um9vdCBvZiBhIHtAbGluayBXZWJFbGVtZW50fS4gUHJvdmlkZXMgZnVuY3Rpb25zIHRvXG4gKiByZXRyaWV2ZSBlbGVtZW50cyB0aGF0IGxpdmUgaW4gdGhlIERPTSBiZWxvdyB0aGUgU2hhZG93Um9vdC5cbiAqL1xuY2xhc3MgU2hhZG93Um9vdCB7XG4gIGNvbnN0cnVjdG9yKGRyaXZlciwgaWQpIHtcbiAgICB0aGlzLmRyaXZlcl8gPSBkcml2ZXJcbiAgICB0aGlzLmlkXyA9IGlkXG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGVuY29kZWQgU2hhZG93Um9vdCBJRCBmcm9tIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7P30gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgSUQgZnJvbS5cbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXh0cmFjdGVkIElELlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHRoZSBvYmplY3QgaXMgbm90IGEgdmFsaWQgZW5jb2RlZCBJRC5cbiAgICovXG4gIHN0YXRpYyBleHRyYWN0SWQob2JqKSB7XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHR5cGVvZiBvYmpbU0hBRE9XX1JPT1RfSURfS0VZXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9ialtTSEFET1dfUk9PVF9JRF9LRVldXG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBpcyBub3QgYSBTaGFkb3dSb290IElEJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez99IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIHZhbGlkIGVuY29kZWQgV2ViRWxlbWVudCBJRC5cbiAgICovXG4gIHN0YXRpYyBpc0lkKG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICBvYmogJiZcbiAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygb2JqW1NIQURPV19ST09UX0lEX0tFWV0gPT09ICdzdHJpbmcnXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgdGhlIHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBTaGFkb3dSb290LlxuICAgKi9cbiAgW1N5bWJvbHMuc2VyaWFsaXplXSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJZCgpXG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgY29tbWFuZCB0aGF0IHRhcmdldHMgdGhpcyBlbGVtZW50IHdpdGggdGhlIHBhcmVudCBXZWJEcml2ZXJcbiAgICogaW5zdGFuY2UuIFdpbGwgZW5zdXJlIHRoaXMgZWxlbWVudCdzIElEIGlzIGluY2x1ZGVkIGluIHRoZSBjb21tYW5kXG4gICAqIHBhcmFtZXRlcnMgdW5kZXIgdGhlIFwiaWRcIiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7IWNvbW1hbmQuQ29tbWFuZH0gY29tbWFuZCBUaGUgY29tbWFuZCB0byBzY2hlZHVsZS5cbiAgICogQHJldHVybiB7IVByb21pc2U8VD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAc2VlIFdlYkRyaXZlciNzY2hlZHVsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhlY3V0ZV8oY29tbWFuZCkge1xuICAgIGNvbW1hbmQuc2V0UGFyYW1ldGVyKCdpZCcsIHRoaXMpXG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKGNvbW1hbmQpXG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGUgYSBjb21tYW5kIHRvIGZpbmQgYSBkZXNjZW5kYW50IG9mIHRoaXMgU2hhZG93Uk9vdC4gSWYgdGhlIGVsZW1lbnRcbiAgICogY2Fubm90IGJlIGZvdW5kLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYVxuICAgKiB7QGxpbmtwbGFpbiBlcnJvci5Ob1N1Y2hFbGVtZW50RXJyb3IgTm9TdWNoRWxlbWVudEVycm9yfS5cbiAgICpcbiAgICogVGhlIHNlYXJjaCBjcml0ZXJpYSBmb3IgYW4gZWxlbWVudCBtYXkgYmUgZGVmaW5lZCB1c2luZyBvbmUgb2YgdGhlIHN0YXRpY1xuICAgKiBmYWN0b3JpZXMgb24gdGhlIHtAbGluayBieS5CeX0gY2xhc3MsIG9yIGFzIGEgc2hvcnQtaGFuZFxuICAgKiB7QGxpbmsgLi9ieS5CeUhhc2h9IG9iamVjdC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgdHdvIHN0YXRlbWVudHNcbiAgICogYXJlIGVxdWl2YWxlbnQ6XG4gICAqXG4gICAqICAgICB2YXIgZTEgPSBzaGFkb3dyb290LmZpbmRFbGVtZW50KEJ5LmlkKCdmb28nKSk7XG4gICAqICAgICB2YXIgZTIgPSBzaGFkb3dyb290LmZpbmRFbGVtZW50KHtpZDonZm9vJ30pO1xuICAgKlxuICAgKiBZb3UgbWF5IGFsc28gcHJvdmlkZSBhIGN1c3RvbSBsb2NhdG9yIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhcyBpbnB1dCB0aGlzXG4gICAqIGluc3RhbmNlIGFuZCByZXR1cm5zIGEge0BsaW5rIFdlYkVsZW1lbnR9LCBvciBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmVcbiAgICogdG8gYSBXZWJFbGVtZW50LiBJZiB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB0byBhbiBhcnJheSBvZlxuICAgKiBXZWJFbGVtZW50cywgV2ViRHJpdmVyIHdpbGwgdXNlIHRoZSBmaXJzdCBlbGVtZW50LiBGb3IgZXhhbXBsZSwgdG8gZmluZCB0aGVcbiAgICogZmlyc3QgdmlzaWJsZSBsaW5rIG9uIGEgcGFnZSwgeW91IGNvdWxkIHdyaXRlOlxuICAgKlxuICAgKiAgICAgdmFyIGxpbmsgPSBlbGVtZW50LmZpbmRFbGVtZW50KGZpcnN0VmlzaWJsZUxpbmspO1xuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gZmlyc3RWaXNpYmxlTGluayhzaGFkb3dSb290KSB7XG4gICAqICAgICAgIHZhciBsaW5rcyA9IHNoYWRvd1Jvb3QuZmluZEVsZW1lbnRzKEJ5LnRhZ05hbWUoJ2EnKSk7XG4gICAqICAgICAgIHJldHVybiBwcm9taXNlLmZpbHRlcihsaW5rcywgZnVuY3Rpb24obGluaykge1xuICAgKiAgICAgICAgIHJldHVybiBsaW5rLmlzRGlzcGxheWVkKCk7XG4gICAqICAgICAgIH0pO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0geyEoYnkuQnl8RnVuY3Rpb24pfSBsb2NhdG9yIFRoZSBsb2NhdG9yIHN0cmF0ZWd5IHRvIHVzZSB3aGVuXG4gICAqICAgICBzZWFyY2hpbmcgZm9yIHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshV2ViRWxlbWVudFByb21pc2V9IEEgV2ViRWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlzc3VlXG4gICAqICAgICBjb21tYW5kcyBhZ2FpbnN0IHRoZSBsb2NhdGVkIGVsZW1lbnQuIElmIHRoZSBlbGVtZW50IGlzIG5vdCBmb3VuZCwgdGhlXG4gICAqICAgICBlbGVtZW50IHdpbGwgYmUgaW52YWxpZGF0ZWQgYW5kIGFsbCBzY2hlZHVsZWQgY29tbWFuZHMgYWJvcnRlZC5cbiAgICovXG4gIGZpbmRFbGVtZW50KGxvY2F0b3IpIHtcbiAgICBsb2NhdG9yID0gYnkuY2hlY2tlZExvY2F0b3IobG9jYXRvcilcbiAgICBsZXQgaWRcbiAgICBpZiAodHlwZW9mIGxvY2F0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlkID0gdGhpcy5kcml2ZXJfLmZpbmRFbGVtZW50SW50ZXJuYWxfKGxvY2F0b3IsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbWQgPSBuZXcgY29tbWFuZC5Db21tYW5kKGNvbW1hbmQuTmFtZS5GSU5EX0VMRU1FTlRfRlJPTV9TSEFET1dST09UKVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCd1c2luZycsIGxvY2F0b3IudXNpbmcpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ3ZhbHVlJywgbG9jYXRvci52YWx1ZSlcbiAgICAgIGlkID0gdGhpcy5leGVjdXRlXyhjbWQpXG4gICAgfVxuICAgIHJldHVybiBuZXcgU2hhZG93Um9vdFByb21pc2UodGhpcy5kcml2ZXJfLCBpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGFsbCB0aGUgZGVzY2VuZGFudHMgb2YgdGhpcyBlbGVtZW50IHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHNlYXJjaFxuICAgKiBjcml0ZXJpYS5cbiAgICpcbiAgICogQHBhcmFtIHshKGJ5LkJ5fEZ1bmN0aW9uKX0gbG9jYXRvciBUaGUgbG9jYXRvciBzdHJhdGVneSB0byB1c2Ugd2hlblxuICAgKiAgICAgc2VhcmNoaW5nIGZvciB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7IVByb21pc2U8IUFycmF5PCFXZWJFbGVtZW50Pj59IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byBhblxuICAgKiAgICAgYXJyYXkgb2YgV2ViRWxlbWVudHMuXG4gICAqL1xuICBhc3luYyBmaW5kRWxlbWVudHMobG9jYXRvcikge1xuICAgIGxvY2F0b3IgPSBieS5jaGVja2VkTG9jYXRvcihsb2NhdG9yKVxuICAgIGlmICh0eXBlb2YgbG9jYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5maW5kRWxlbWVudHNJbnRlcm5hbF8obG9jYXRvciwgdGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNtZCA9IG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkZJTkRfRUxFTUVOVFNfRlJPTV9TSEFET1dST09UKVxuICAgICAgICAuc2V0UGFyYW1ldGVyKCd1c2luZycsIGxvY2F0b3IudXNpbmcpXG4gICAgICAgIC5zZXRQYXJhbWV0ZXIoJ3ZhbHVlJywgbG9jYXRvci52YWx1ZSlcbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVfKGNtZClcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiBbXVxuICAgIH1cbiAgfVxuXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLmlkX1xuICB9XG59XG5cbi8qKlxuICogU2hhZG93Um9vdFByb21pc2UgaXMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCBhIFdlYkVsZW1lbnQuXG4gKiBUaGlzIHNlcnZlcyBhcyBhIGZvcndhcmQgcHJveHkgb24gU2hhZG93Um9vdCwgYWxsb3dpbmcgY2FsbHMgdG8gYmVcbiAqIHNjaGVkdWxlZCB3aXRob3V0IGRpcmVjdGx5IG9uIHRoaXMgaW5zdGFuY2UgYmVmb3JlIHRoZSB1bmRlcmx5aW5nXG4gKiBTaGFkb3dSb290IGhhcyBiZWVuIGZ1bGZpbGxlZC5cbiAqXG4gKiBAaW1wbGVtZW50cyB7IElUaGVuYWJsZTwhU2hhZG93Um9vdD59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgU2hhZG93Um9vdFByb21pc2UgZXh0ZW5kcyBTaGFkb3dSb290IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IVdlYkRyaXZlcn0gZHJpdmVyIFRoZSBwYXJlbnQgV2ViRHJpdmVyIGluc3RhbmNlIGZvciB0aGlzXG4gICAqICAgICBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFQcm9taXNlPCFTaGFkb3dSb290Pn0gc2hhZG93IEEgcHJvbWlzZVxuICAgKiAgICAgdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIHByb21pc2VkIGVsZW1lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkcml2ZXIsIHNoYWRvdykge1xuICAgIHN1cGVyKGRyaXZlciwgJ3VudXNlZCcpXG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgdGhpcy50aGVuID0gc2hhZG93LnRoZW4uYmluZChzaGFkb3cpXG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgdGhpcy5jYXRjaCA9IHNoYWRvdy5jYXRjaC5iaW5kKHNoYWRvdylcblxuICAgIC8qKlxuICAgICAqIERlZmVycyByZXR1cm5pbmcgdGhlIFNoYWRvd1Jvb3QgSUQgdW50aWwgdGhlIHdyYXBwZWQgV2ViRWxlbWVudCBoYXMgYmVlblxuICAgICAqIHJlc29sdmVkLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2hhZG93LnRoZW4oZnVuY3Rpb24gKHNoYWRvdykge1xuICAgICAgICByZXR1cm4gc2hhZG93LmdldElkKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBBbGVydFxuLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtb2RhbCBkaWFsb2cgc3VjaCBhcyB7QGNvZGUgYWxlcnR9LCB7QGNvZGUgY29uZmlybX0sIG9yXG4gKiB7QGNvZGUgcHJvbXB0fS4gUHJvdmlkZXMgZnVuY3Rpb25zIHRvIHJldHJpZXZlIHRoZSBtZXNzYWdlIGRpc3BsYXllZCB3aXRoXG4gKiB0aGUgYWxlcnQsIGFjY2VwdCBvciBkaXNtaXNzIHRoZSBhbGVydCwgYW5kIHNldCB0aGUgcmVzcG9uc2UgdGV4dCAoaW4gdGhlXG4gKiBjYXNlIG9mIHtAY29kZSBwcm9tcHR9KS5cbiAqL1xuY2xhc3MgQWxlcnQge1xuICAvKipcbiAgICogQHBhcmFtIHshV2ViRHJpdmVyfSBkcml2ZXIgVGhlIGRyaXZlciBjb250cm9sbGluZyB0aGUgYnJvd3NlciB0aGlzIGFsZXJ0XG4gICAqICAgICBpcyBhdHRhY2hlZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIG1lc3NhZ2UgdGV4dCBkaXNwbGF5ZWQgd2l0aCB0aGlzIGFsZXJ0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJpdmVyLCB0ZXh0KSB7XG4gICAgLyoqIEBwcml2YXRlIHshV2ViRHJpdmVyfSAqL1xuICAgIHRoaXMuZHJpdmVyXyA9IGRyaXZlclxuXG4gICAgLyoqIEBwcml2YXRlIHshUHJvbWlzZTxzdHJpbmc+fSAqL1xuICAgIHRoaXMudGV4dF8gPSBQcm9taXNlLnJlc29sdmUodGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG1lc3NhZ2UgdGV4dCBkaXNwbGF5ZWQgd2l0aCB0aGlzIGFsZXJ0LiBGb3IgaW5zdGFuY2UsIGlmIHRoZVxuICAgKiBhbGVydCB3ZXJlIG9wZW5lZCB3aXRoIGFsZXJ0KFwiaGVsbG9cIiksIHRoZW4gdGhpcyB3b3VsZCByZXR1cm4gXCJoZWxsb1wiLlxuICAgKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlXG4gICAqICAgICByZXNvbHZlZCB0byB0aGUgdGV4dCBkaXNwbGF5ZWQgd2l0aCB0aGlzIGFsZXJ0LlxuICAgKi9cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0X1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgdGhpcyBhbGVydC5cbiAgICpcbiAgICogQHJldHVybiB7IVByb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcbiAgICogICAgIHdoZW4gdGhpcyBjb21tYW5kIGhhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBhY2NlcHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyXy5leGVjdXRlKG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLkFDQ0VQVF9BTEVSVCkpXG4gIH1cblxuICAvKipcbiAgICogRGlzbWlzc2VzIHRoaXMgYWxlcnQuXG4gICAqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkXG4gICAqICAgICB3aGVuIHRoaXMgY29tbWFuZCBoYXMgY29tcGxldGVkLlxuICAgKi9cbiAgZGlzbWlzcygpIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJfLmV4ZWN1dGUobmV3IGNvbW1hbmQuQ29tbWFuZChjb21tYW5kLk5hbWUuRElTTUlTU19BTEVSVCkpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzcG9uc2UgdGV4dCBvbiB0aGlzIGFsZXJ0LiBUaGlzIGNvbW1hbmQgd2lsbCByZXR1cm4gYW4gZXJyb3IgaWZcbiAgICogdGhlIHVuZGVybHlpbmcgYWxlcnQgZG9lcyBub3Qgc3VwcG9ydCByZXNwb25zZSB0ZXh0IChlLmcuIHdpbmRvdy5hbGVydCBhbmRcbiAgICogd2luZG93LmNvbmZpcm0pLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZXQuXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkXG4gICAqICAgICB3aGVuIHRoaXMgY29tbWFuZCBoYXMgY29tcGxldGVkLlxuICAgKi9cbiAgc2VuZEtleXModGV4dCkge1xuICAgIHJldHVybiB0aGlzLmRyaXZlcl8uZXhlY3V0ZShcbiAgICAgIG5ldyBjb21tYW5kLkNvbW1hbmQoY29tbWFuZC5OYW1lLlNFVF9BTEVSVF9URVhUKS5zZXRQYXJhbWV0ZXIoXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgdGV4dFxuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEFsZXJ0UHJvbWlzZSBpcyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIGFuIEFsZXJ0LiBUaGlzIHByb21pc2VcbiAqIHNlcnZlcyBhcyBhIGZvcndhcmQgcHJveHkgb24gYW4gQWxlcnQsIGFsbG93aW5nIGNhbGxzIHRvIGJlIHNjaGVkdWxlZFxuICogZGlyZWN0bHkgb24gdGhpcyBpbnN0YW5jZSBiZWZvcmUgdGhlIHVuZGVybHlpbmcgQWxlcnQgaGFzIGJlZW4gZnVsZmlsbGVkLiBJblxuICogb3RoZXIgd29yZHMsIHRoZSBmb2xsb3dpbmcgdHdvIHN0YXRlbWVudHMgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAgIGRyaXZlci5zd2l0Y2hUbygpLmFsZXJ0KCkuZGlzbWlzcygpO1xuICogICAgIGRyaXZlci5zd2l0Y2hUbygpLmFsZXJ0KCkudGhlbihmdW5jdGlvbihhbGVydCkge1xuICogICAgICAgcmV0dXJuIGFsZXJ0LmRpc21pc3MoKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAaW1wbGVtZW50cyB7SVRoZW5hYmxlPCFBbGVydD59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgQWxlcnRQcm9taXNlIGV4dGVuZHMgQWxlcnQge1xuICAvKipcbiAgICogQHBhcmFtIHshV2ViRHJpdmVyfSBkcml2ZXIgVGhlIGRyaXZlciBjb250cm9sbGluZyB0aGUgYnJvd3NlciB0aGlzXG4gICAqICAgICBhbGVydCBpcyBhdHRhY2hlZCB0by5cbiAgICogQHBhcmFtIHshUHJvbWlzZTwhQWxlcnQ+fSBhbGVydCBBIHRoZW5hYmxlXG4gICAqICAgICB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdpdGggdGhlIHByb21pc2VkIGFsZXJ0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJpdmVyLCBhbGVydCkge1xuICAgIHN1cGVyKGRyaXZlciwgJ3VudXNlZCcpXG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgdGhpcy50aGVuID0gYWxlcnQudGhlbi5iaW5kKGFsZXJ0KVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIHRoaXMuY2F0Y2ggPSBhbGVydC5jYXRjaC5iaW5kKGFsZXJ0KVxuXG4gICAgLyoqXG4gICAgICogRGVmZXIgcmV0dXJuaW5nIHRleHQgdW50aWwgdGhlIHByb21pc2VkIGFsZXJ0IGhhcyBiZWVuIHJlc29sdmVkLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhbGVydC50aGVuKGZ1bmN0aW9uIChhbGVydCkge1xuICAgICAgICByZXR1cm4gYWxlcnQuZ2V0VGV4dCgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBhY3Rpb24gdW50aWwgdGhlIGFsZXJ0IGhhcyBiZWVuIGxvY2F0ZWQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdGhpcy5hY2NlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYWxlcnQudGhlbihmdW5jdGlvbiAoYWxlcnQpIHtcbiAgICAgICAgcmV0dXJuIGFsZXJ0LmFjY2VwdCgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBhY3Rpb24gdW50aWwgdGhlIGFsZXJ0IGhhcyBiZWVuIGxvY2F0ZWQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdGhpcy5kaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFsZXJ0LnRoZW4oZnVuY3Rpb24gKGFsZXJ0KSB7XG4gICAgICAgIHJldHVybiBhbGVydC5kaXNtaXNzKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGFjdGlvbiB1bnRpbCB0aGUgYWxlcnQgaGFzIGJlZW4gbG9jYXRlZC5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICB0aGlzLnNlbmRLZXlzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHJldHVybiBhbGVydC50aGVuKGZ1bmN0aW9uIChhbGVydCkge1xuICAgICAgICByZXR1cm4gYWxlcnQuc2VuZEtleXModGV4dClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbi8vIFBVQkxJQyBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFsZXJ0LFxuICBBbGVydFByb21pc2UsXG4gIENvbmRpdGlvbixcbiAgTG9ncyxcbiAgTmF2aWdhdGlvbixcbiAgT3B0aW9ucyxcbiAgU2hhZG93Um9vdCxcbiAgVGFyZ2V0TG9jYXRvcixcbiAgSVdlYkRyaXZlcixcbiAgV2ViRHJpdmVyLFxuICBXZWJFbGVtZW50LFxuICBXZWJFbGVtZW50Q29uZGl0aW9uLFxuICBXZWJFbGVtZW50UHJvbWlzZSxcbiAgV2luZG93LFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5jb25zdCB7IGlzT2JqZWN0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBzb21lIGNvbW1vbiBtZXRob2RzIHVzZWQgZm9yIFdlYkVsZW1lbnRzLlxuICovXG5cbmNvbnN0IExFR0FDWV9FTEVNRU5UX0lEX0tFWSA9ICdFTEVNRU5UJ1xuY29uc3QgRUxFTUVOVF9JRF9LRVkgPSAnZWxlbWVudC02MDY2LTExZTQtYTUyZS00ZjczNTQ2NmNlY2YnXG5cbi8qKlxuICogQ29udGFpbnMgbG9naWMgYWJvdXQgV2ViRWxlbWVudHMuXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgb2JqZWN0IGlzIGEgdmFsaWQgZW5jb2RlZCBXZWJFbGVtZW50IElELlxuICovXG5mdW5jdGlvbiBpc0lkKG9iaikge1xuICByZXR1cm4gKFxuICAgIGlzT2JqZWN0KG9iaikgJiZcbiAgICAodHlwZW9mIG9ialtFTEVNRU5UX0lEX0tFWV0gPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2Ygb2JqW0xFR0FDWV9FTEVNRU5UX0lEX0tFWV0gPT09ICdzdHJpbmcnKVxuICApXG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGVuY29kZWQgV2ViRWxlbWVudCBJRCBmcm9tIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHs/fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHRoZSBJRCBmcm9tLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXh0cmFjdGVkIElELlxuICogQHRocm93cyB7VHlwZUVycm9yfSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBhIHZhbGlkIGVuY29kZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RJZChvYmopIHtcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICBpZiAodHlwZW9mIG9ialtFTEVNRU5UX0lEX0tFWV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2JqW0VMRU1FTlRfSURfS0VZXVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtMRUdBQ1lfRUxFTUVOVF9JRF9LRVldID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG9ialtMRUdBQ1lfRUxFTUVOVF9JRF9LRVldXG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBpcyBub3QgYSBXZWJFbGVtZW50IElEJylcbn1cblxuLy8gUFVCTElDIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNJZCxcbiAgZXh0cmFjdElkLFxufVxuIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSAoKSA9PiAoW10pO1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL3NlbGVuaXVtLXdlYmRyaXZlci9saWIgc3luYyByZWN1cnNpdmVcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDsiLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpXG5cbmZ1bmN0aW9uIGdldExvSW50ZXJmYWNlKCkge1xuICBsZXQgbmFtZVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICBuYW1lID0gJ2xvMCdcbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgbmFtZSA9ICdsbydcbiAgfVxuICByZXR1cm4gbmFtZSA/IG9zLm5ldHdvcmtJbnRlcmZhY2VzKClbbmFtZV0gOiBudWxsXG59XG5cbi8qKlxuICogUXVlcmllcyB0aGUgc3lzdGVtIG5ldHdvcmsgaW50ZXJmYWNlcyBmb3IgYW4gSVAgYWRkcmVzcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcGJhY2sgV2hldGhlciB0byBmaW5kIGEgbG9vcGJhY2sgYWRkcmVzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHkgVGhlIElQIGZhbWlseSAoSVB2NCBvciBJUHY2KS4gRGVmYXVsdHMgdG8gSVB2NC5cbiAqIEByZXR1cm4geyhzdHJpbmd8dW5kZWZpbmVkKX0gVGhlIGxvY2F0ZWQgSVAgYWRkcmVzcyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGdldElQQWRkcmVzcyhsb29wYmFjaywgZmFtaWx5KSB7XG4gIGxldCBpbnRlcmZhY2VzXG4gIGlmIChsb29wYmFjaykge1xuICAgIGNvbnN0IGxvID0gZ2V0TG9JbnRlcmZhY2UoKVxuICAgIGludGVyZmFjZXMgPSBsbyA/IFtsb10gOiBudWxsXG4gIH1cbiAgaW50ZXJmYWNlcyA9IGludGVyZmFjZXMgfHwgb3MubmV0d29ya0ludGVyZmFjZXMoKVxuICBmb3IgKGxldCBrZXkgaW4gaW50ZXJmYWNlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGludGVyZmFjZXMsIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaXBBZGRyZXNzIG9mIGludGVyZmFjZXNba2V5XSkge1xuICAgICAgaWYgKFxuICAgICAgICAoaXBBZGRyZXNzLmZhbWlseSA9PT0gZmFtaWx5IHx8IGBJUHYke2lwQWRkcmVzcy5mYW1pbHl9YCA9PT0gZmFtaWx5KSAmJlxuICAgICAgICBpcEFkZHJlc3MuaW50ZXJuYWwgPT09IGxvb3BiYWNrXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGlwQWRkcmVzcy5hZGRyZXNzXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLy8gUFVCTElDIEFQSVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgZXh0ZXJuYWwgSVAgYWRkcmVzcyBmb3IgdGhpcyBob3N0LlxuICogQHBhcmFtIHtzdHJpbmc9fSBmYW1pbHkgVGhlIElQIGZhbWlseSB0byByZXRyaWV2ZS4gRGVmYXVsdHMgdG8gXCJJUHY0XCIuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfHVuZGVmaW5lZCl9IFRoZSBJUCBhZGRyZXNzIG9yIHVuZGVmaW5lZCBpZiBub3QgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRBZGRyZXNzKGZhbWlseSA9ICdJUHY0Jykge1xuICByZXR1cm4gZ2V0SVBBZGRyZXNzKGZhbHNlLCBmYW1pbHkpXG59XG5cbi8qKlxuICogUmV0cmlldmVzIGEgbG9vcGJhY2sgYWRkcmVzcyBmb3IgdGhpcyBtYWNoaW5lLlxuICogQHBhcmFtIHtzdHJpbmc9fSBmYW1pbHkgVGhlIElQIGZhbWlseSB0byByZXRyaWV2ZS4gRGVmYXVsdHMgdG8gXCJJUHY0XCIuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfHVuZGVmaW5lZCl9IFRoZSBJUCBhZGRyZXNzIG9yIHVuZGVmaW5lZCBpZiBub3QgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRMb29wYmFja0FkZHJlc3MoZmFtaWx5ID0gJ0lQdjQnKSB7XG4gIHJldHVybiBnZXRJUEFkZHJlc3ModHJ1ZSwgZmFtaWx5KVxufVxuXG4vKipcbiAqIFNwbGl0cyBhIGhvc3Rwb3J0IHN0cmluZywgZS5nLiBcInd3dy5leGFtcGxlLmNvbTo4MFwiLCBpbnRvIGl0cyBjb21wb25lbnRcbiAqIHBhcnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0cG9ydCBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICogQHJldHVybiB7e2hvc3Q6IHN0cmluZywgcG9ydDogP251bWJlcn19IEEgaG9zdCBhbmQgcG9ydC4gSWYgbm8gcG9ydCBpc1xuICogICAgIHByZXNlbnQgaW4gdGhlIGFyZ3VtZW50IGBob3N0cG9ydGAsIHBvcnQgaXMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gc3BsaXRIb3N0QW5kUG9ydChob3N0cG9ydCkge1xuICBsZXQgbGFzdEluZGV4ID0gaG9zdHBvcnQubGFzdEluZGV4T2YoJzonKVxuICBpZiAobGFzdEluZGV4IDwgMCkge1xuICAgIHJldHVybiB7IGhvc3Q6IGhvc3Rwb3J0LCBwb3J0OiBudWxsIH1cbiAgfVxuXG4gIGxldCBmaXJzdEluZGV4ID0gaG9zdHBvcnQuaW5kZXhPZignOicpXG4gIGlmIChmaXJzdEluZGV4ICE9IGxhc3RJbmRleCAmJiAhaG9zdHBvcnQuaW5jbHVkZXMoJ1snKSkge1xuICAgIC8vIE11bHRpcGxlIGNvbG9ucyBidXQgbm8gYnJhY2tldHMsIHNvIGFzc3VtZSB0aGUgc3RyaW5nIGlzIGFuIElQdjYgYWRkcmVzc1xuICAgIC8vIHdpdGggbm8gcG9ydCAoZS5nLiBcIjEyMzQ6NTY3ODo5OjA6MTIzNDo1Njc4Ojk6MFwiKS5cbiAgICByZXR1cm4geyBob3N0OiBob3N0cG9ydCwgcG9ydDogbnVsbCB9XG4gIH1cblxuICBsZXQgaG9zdCA9IGhvc3Rwb3J0LnNsaWNlKDAsIGxhc3RJbmRleClcbiAgaWYgKGhvc3Quc3RhcnRzV2l0aCgnWycpICYmIGhvc3QuZW5kc1dpdGgoJ10nKSkge1xuICAgIGhvc3QgPSBob3N0LnNsaWNlKDEsIC0xKVxuICB9XG5cbiAgbGV0IHBvcnQgPSBwYXJzZUludChob3N0cG9ydC5zbGljZShsYXN0SW5kZXggKyAxKSwgMTApXG4gIHJldHVybiB7IGhvc3QsIHBvcnQgfVxufVxuXG4vLyBQVUJMSUMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3BsaXRIb3N0QW5kUG9ydCxcbiAgZ2V0TG9vcGJhY2tBZGRyZXNzLFxuICBnZXRBZGRyZXNzLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5cbi8qKlxuICogVGVzdHMgaWYgYSBwb3J0IGlzIGZyZWUuXG4gKiBAcGFyYW0ge251bWJlcn0gcG9ydCBUaGUgcG9ydCB0byB0ZXN0LlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfaG9zdCBUaGUgYm91bmQgaG9zdCB0byB0ZXN0IHRoZSB7QGNvZGUgcG9ydH0gYWdhaW5zdC5cbiAqICAgICBEZWZhdWx0cyB0byB7QGNvZGUgSU5BRERSX0FOWX0uXG4gKiBAcmV0dXJuIHshUHJvbWlzZTxib29sZWFuPn0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdpdGggd2hldGhlciB0aGUgcG9ydFxuICogICAgIGlzIGZyZWUuXG4gKi9cbmZ1bmN0aW9uIGlzRnJlZShwb3J0LCBvcHRfaG9zdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNlcnZlciA9IG5ldC5jcmVhdGVTZXJ2ZXIoKS5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ0VBRERSSU5VU0UnIHx8IGUuY29kZSA9PT0gJ0VBQ0NFUycpIHtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBzZXJ2ZXIubGlzdGVuKHBvcnQsIG9wdF9ob3N0LCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIuY2xvc2UoKCkgPT4gcmVzb2x2ZSh0cnVlKSlcbiAgICB9KVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2hvc3QgVGhlIGJvdW5kIGhvc3QgdG8gdGVzdCB0aGUge0Bjb2RlIHBvcnR9IGFnYWluc3QuXG4gKiAgICAgRGVmYXVsdHMgdG8ge0Bjb2RlIElOQUREUl9BTll9LlxuICogQHJldHVybiB7IVByb21pc2U8bnVtYmVyPn0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIGEgZnJlZSBwb3J0LiBJZiBhXG4gKiAgICAgcG9ydCBjYW5ub3QgYmUgZm91bmQsIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKi9cblxuZnVuY3Rpb24gZmluZEZyZWVQb3J0KG9wdF9ob3N0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2VydmVyID0gbmV0LmNyZWF0ZVNlcnZlcigpXG4gICAgc2VydmVyLm9uKCdsaXN0ZW5pbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKHNlcnZlci5hZGRyZXNzKCkucG9ydClcbiAgICAgIHNlcnZlci5jbG9zZSgpXG4gICAgfSlcbiAgICBzZXJ2ZXIub24oJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdFQUREUklOVVNFJyB8fCBlLmNvZGUgPT09ICdFQUNDRVMnKSB7XG4gICAgICAgIHJlc29sdmUoJ1VuYWJsZSB0byBmaW5kIGEgZnJlZSBwb3J0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlKVxuICAgICAgfVxuICAgIH0pXG4gICAgLy8gQnkgcHJvdmlkaW5nIDAgd2UgbGV0IHRoZSBvcGVyYXRpdmUgc3lzdGVtIGZpbmQgYW4gYXJiaXRyYXJ5IHBvcnRcbiAgICBzZXJ2ZXIubGlzdGVuKDAsIG9wdF9ob3N0KVxuICB9KVxufVxuXG4vLyBQVUJMSUMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmluZEZyZWVQb3J0LFxuICBpc0ZyZWUsXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5jb25zdCBodHRwVXRpbCA9IHJlcXVpcmUoJy4uL2h0dHAvdXRpbCcpXG5jb25zdCBpbyA9IHJlcXVpcmUoJy4uL2lvJylcbmNvbnN0IHsgZXhlYyB9ID0gcmVxdWlyZSgnLi4vaW8vZXhlYycpXG5jb25zdCB7IFppcCB9ID0gcmVxdWlyZSgnLi4vaW8vemlwJylcbmNvbnN0IGNtZCA9IHJlcXVpcmUoJy4uL2xpYi9jb21tYW5kJylcbmNvbnN0IGlucHV0ID0gcmVxdWlyZSgnLi4vbGliL2lucHV0JylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJy4uL25ldCcpXG5jb25zdCBwb3J0cHJvYmVyID0gcmVxdWlyZSgnLi4vbmV0L3BvcnRwcm9iZXInKVxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoJy4uL2xpYi9sb2dnaW5nJylcblxuY29uc3QgeyBnZXRKYXZhUGF0aCwgZm9ybWF0U3Bhd25BcmdzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHsoc3RyaW5nfCFBcnJheTxzdHJpbmd8bnVtYmVyfCFzdHJlYW0uU3RyZWFtfG51bGx8dW5kZWZpbmVkPil9XG4gKi9cbmxldCBTdGRJb09wdGlvbnMgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEB0eXBlZGVmIHsoc3RyaW5nfCFJVGhlbmFibGU8c3RyaW5nPil9XG4gKi9cbmxldCBDb21tYW5kTGluZUZsYWcgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEEgcmVjb3JkIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYSBEcml2ZXJTZXJ2aWNlXG4gKiBpbnN0YW5jZS5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2VPcHRpb25zKCkge31cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBzZXJ2aWNlIHNob3VsZCBvbmx5IGJlIGFjY2Vzc2VkIG9uIHRoaXMgaG9zdCdzIGxvb3BiYWNrIGFkZHJlc3MuXG4gKlxuICogQHR5cGUgeyhib29sZWFufHVuZGVmaW5lZCl9XG4gKi9cblNlcnZpY2VPcHRpb25zLnByb3RvdHlwZS5sb29wYmFja1xuXG4vKipcbiAqIFRoZSBob3N0IG5hbWUgdG8gYWNjZXNzIHRoZSBzZXJ2ZXIgb24uIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlXG4gKiB7QGxpbmsgI2xvb3BiYWNrfSBvcHRpb24gd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEB0eXBlIHsoc3RyaW5nfHVuZGVmaW5lZCl9XG4gKi9cblNlcnZpY2VPcHRpb25zLnByb3RvdHlwZS5ob3N0bmFtZVxuXG4vKipcbiAqIFRoZSBwb3J0IHRvIHN0YXJ0IHRoZSBzZXJ2ZXIgb24gKG11c3QgYmUgPiAwKS4gSWYgdGhlIHBvcnQgaXMgcHJvdmlkZWQgYXMgYVxuICogcHJvbWlzZSwgdGhlIHNlcnZpY2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBzdGFydGluZy5cbiAqXG4gKiBAdHlwZSB7KG51bWJlcnwhSVRoZW5hYmxlPG51bWJlcj4pfVxuICovXG5TZXJ2aWNlT3B0aW9ucy5wcm90b3R5cGUucG9ydFxuXG4vKipcbiAqIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgc2VydmljZS4gSWYgYSBwcm9taXNlIGlzIHByb3ZpZGVkLCB0aGUgc2VydmljZVxuICogd2lsbCB3YWl0IGZvciBpdCB0byByZXNvbHZlIGJlZm9yZSBzdGFydGluZy5cbiAqXG4gKiBAdHlwZSB7IShBcnJheTxDb21tYW5kTGluZUZsYWc+fElUaGVuYWJsZTwhQXJyYXk8Q29tbWFuZExpbmVGbGFnPj4pfVxuICovXG5TZXJ2aWNlT3B0aW9ucy5wcm90b3R5cGUuYXJnc1xuXG4vKipcbiAqIFRoZSBiYXNlIHBhdGggb24gdGhlIHNlcnZlciBmb3IgdGhlIFdlYkRyaXZlciB3aXJlIHByb3RvY29sIChlLmcuICcvd2QvaHViJykuXG4gKiBEZWZhdWx0cyB0byAnLycuXG4gKlxuICogQHR5cGUgeyhzdHJpbmd8dW5kZWZpbmVkfG51bGwpfVxuICovXG5TZXJ2aWNlT3B0aW9ucy5wcm90b3R5cGUucGF0aFxuXG4vKipcbiAqIFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBzaG91bGQgYmUgdmlzaWJsZSB0byB0aGUgc2VydmVyIHByb2Nlc3MuXG4gKiBEZWZhdWx0cyB0byBpbmhlcml0aW5nIHRoZSBjdXJyZW50IHByb2Nlc3MncyBlbnZpcm9ubWVudC5cbiAqXG4gKiBAdHlwZSB7KE9iamVjdDxzdHJpbmcsIHN0cmluZz58dW5kZWZpbmVkKX1cbiAqL1xuU2VydmljZU9wdGlvbnMucHJvdG90eXBlLmVudlxuXG4vKipcbiAqIElPIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzcGF3bmVkIHNlcnZlciBwcm9jZXNzLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXJcbiAqIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBjaGlsZF9wcm9jZXNzLnNwYXduYC5cbiAqXG4gKiBAdHlwZSB7KFN0ZElvT3B0aW9uc3x1bmRlZmluZWQpfVxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjQueC9kb2NzL2FwaS9jaGlsZF9wcm9jZXNzLmh0bWwjY2hpbGRfcHJvY2Vzc19vcHRpb25zX3N0ZGlvXG4gKi9cblNlcnZpY2VPcHRpb25zLnByb3RvdHlwZS5zdGRpb1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGxpZmUgYW5kIGRlYXRoIG9mIGEgbmF0aXZlIGV4ZWN1dGFibGUgV2ViRHJpdmVyIHNlcnZlci5cbiAqXG4gKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoZSBkcml2ZXIgc2VydmVyIGltcGxlbWVudHMgdGhlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU2VsZW5pdW1IUS9zZWxlbml1bS93aWtpL0pzb25XaXJlUHJvdG9jb2wuXG4gKiBGdXJ0aGVybW9yZSwgdGhlIG1hbmFnZWQgc2VydmVyIHNob3VsZCBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgc2Vzc2lvbnMsXG4gKiBzbyB0aGF0IHRoaXMgY2xhc3MgbWF5IGJlIHJldXNlZCBmb3IgbXVsdGlwbGUgY2xpZW50cy5cbiAqL1xuY2xhc3MgRHJpdmVyU2VydmljZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhlY3V0YWJsZSBQYXRoIHRvIHRoZSBleGVjdXRhYmxlIHRvIHJ1bi5cbiAgICogQHBhcmFtIHshU2VydmljZU9wdGlvbnN9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc2VydmljZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4ZWN1dGFibGUsIG9wdGlvbnMpIHtcbiAgICAvKiogQHByaXZhdGUgQGNvbnN0ICovXG4gICAgdGhpcy5sb2dfID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3dlYmRyaXZlci5Ecml2ZXJTZXJ2aWNlJylcbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmV4ZWN1dGFibGVfID0gZXhlY3V0YWJsZVxuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMubG9vcGJhY2tPbmx5XyA9ICEhb3B0aW9ucy5sb29wYmFja1xuXG4gICAgLyoqIEBwcml2YXRlIHsoc3RyaW5nfHVuZGVmaW5lZCl9ICovXG4gICAgdGhpcy5ob3N0bmFtZV8gPSBvcHRpb25zLmhvc3RuYW1lXG5cbiAgICAvKiogQHByaXZhdGUgeyhudW1iZXJ8IUlUaGVuYWJsZTxudW1iZXI+KX0gKi9cbiAgICB0aGlzLnBvcnRfID0gb3B0aW9ucy5wb3J0XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSB7IShBcnJheTxDb21tYW5kTGluZUZsYWc+fFxuICAgICAqICAgICAgICAgICAgIElUaGVuYWJsZTwhQXJyYXk8Q29tbWFuZExpbmVGbGFnPj4pfVxuICAgICAqL1xuICAgIHRoaXMuYXJnc18gPSBvcHRpb25zLmFyZ3NcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMucGF0aF8gPSBvcHRpb25zLnBhdGggfHwgJy8nXG5cbiAgICAvKiogQHByaXZhdGUgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIHRoaXMuZW52XyA9IG9wdGlvbnMuZW52IHx8IHByb2Nlc3MuZW52XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSB7KHN0cmluZ3whQXJyYXk8c3RyaW5nfG51bWJlcnwhc3RyZWFtLlN0cmVhbXxudWxsfHVuZGVmaW5lZD4pfVxuICAgICAqL1xuICAgIHRoaXMuc3RkaW9fID0gb3B0aW9ucy5zdGRpbyB8fCAnaWdub3JlJ1xuXG4gICAgLyoqXG4gICAgICogQSBwcm9taXNlIGZvciB0aGUgbWFuYWdlZCBzdWJwcm9jZXNzLCBvciBudWxsIGlmIHRoZSBzZXJ2ZXIgaGFzIG5vdCBiZWVuXG4gICAgICogc3RhcnRlZCB5ZXQuIFRoaXMgcHJvbWlzZSB3aWxsIG5ldmVyIGJlIHJlamVjdGVkLlxuICAgICAqIEBwcml2YXRlIHtQcm9taXNlPCFleGVjLkNvbW1hbmQ+fVxuICAgICAqL1xuICAgIHRoaXMuY29tbWFuZF8gPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNlcnZlcidzIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgc2VydmVyIGhhc1xuICAgICAqIG5vdCBiZWVuIHN0YXJ0ZWQuIFRoaXMgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIGlmIHRoZSBzZXJ2ZXIgdGVybWluYXRlc1xuICAgICAqIGJlZm9yZSBpdCBzdGFydHMgYWNjZXB0aW5nIFdlYkRyaXZlciByZXF1ZXN0cy5cbiAgICAgKiBAcHJpdmF0ZSB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuYWRkcmVzc18gPSBudWxsXG4gIH1cblxuICBnZXRFeGVjdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGFibGVfXG4gIH1cblxuICBzZXRFeGVjdXRhYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5leGVjdXRhYmxlXyA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IVByb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNlcnZlcidzIGFkZHJlc3MuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2VydmVyIGhhcyBub3QgYmVlbiBzdGFydGVkLlxuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5hZGRyZXNzXykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzc19cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ1NlcnZlciBoYXMgbm90IGJlZW4gc3RhcnRlZC4nKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgdW5kZXJseWluZyBwcm9jZXNzIGlzIHN0aWxsIHJ1bm5pbmcuIFRoaXMgZG9lcyBub3QgdGFrZVxuICAgKiBpbnRvIGFjY291bnQgd2hldGhlciB0aGUgcHJvY2VzcyBpcyBpbiB0aGUgcHJvY2VzcyBvZiBzaHV0dGluZyBkb3duLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1bmRlcmx5aW5nIHNlcnZpY2UgcHJvY2VzcyBpcyBydW5uaW5nLlxuICAgKi9cbiAgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMuYWRkcmVzc19cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHNlcnZlciBpZiBpdCBpcyBub3QgYWxyZWFkeSBydW5uaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF90aW1lb3V0TXMgSG93IGxvbmcgdG8gd2FpdCwgaW4gbWlsbGlzZWNvbmRzLCBmb3IgdGhlXG4gICAqICAgICBzZXJ2ZXIgdG8gc3RhcnQgYWNjZXB0aW5nIHJlcXVlc3RzLiBEZWZhdWx0cyB0byAzMCBzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIHNlcnZlcidzIGJhc2VcbiAgICogICAgIFVSTCB3aGVuIGl0IGhhcyBzdGFydGVkIGFjY2VwdGluZyByZXF1ZXN0cy4gSWYgdGhlIHRpbWVvdXQgZXhwaXJlc1xuICAgKiAgICAgYmVmb3JlIHRoZSBzZXJ2ZXIgaGFzIHN0YXJ0ZWQsIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAqL1xuICBzdGFydChvcHRfdGltZW91dE1zKSB7XG4gICAgaWYgKHRoaXMuYWRkcmVzc18pIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZHJlc3NfXG4gICAgfVxuXG4gICAgY29uc3QgdGltZW91dCA9IG9wdF90aW1lb3V0TXMgfHwgRHJpdmVyU2VydmljZS5ERUZBVUxUX1NUQVJUX1RJTUVPVVRfTVNcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuXG4gICAgbGV0IHJlc29sdmVDb21tYW5kXG4gICAgdGhpcy5jb21tYW5kXyA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAocmVzb2x2ZUNvbW1hbmQgPSByZXNvbHZlKSlcblxuICAgIHRoaXMuYWRkcmVzc18gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZUFkZHJlc3MsIHJlamVjdEFkZHJlc3MpID0+IHtcbiAgICAgIHJlc29sdmVBZGRyZXNzKFxuICAgICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5wb3J0XykudGhlbigocG9ydCkgPT4ge1xuICAgICAgICAgIGlmIChwb3J0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdQb3J0IG11c3QgYmUgPiAwOiAnICsgcG9ydClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbW1hbmRMaW5lRmxhZ3ModGhpcy5hcmdzXykudGhlbigoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IGV4ZWMoc2VsZi5leGVjdXRhYmxlXywge1xuICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICBlbnY6IHNlbGYuZW52XyxcbiAgICAgICAgICAgICAgc3RkaW86IHNlbGYuc3RkaW9fLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmVzb2x2ZUNvbW1hbmQoY29tbWFuZClcblxuICAgICAgICAgICAgY29uc3QgZWFybHlUZXJtaW5hdGlvbiA9IGNvbW1hbmQucmVzdWx0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yID1cbiAgICAgICAgICAgICAgICByZXN1bHQuY29kZSA9PSBudWxsXG4gICAgICAgICAgICAgICAgICA/IEVycm9yKCdTZXJ2ZXIgd2FzIGtpbGxlZCB3aXRoICcgKyByZXN1bHQuc2lnbmFsKVxuICAgICAgICAgICAgICAgICAgOiBFcnJvcignU2VydmVyIHRlcm1pbmF0ZWQgZWFybHkgd2l0aCBzdGF0dXMgJyArIHJlc3VsdC5jb2RlKVxuICAgICAgICAgICAgICByZWplY3RBZGRyZXNzKGVycm9yKVxuICAgICAgICAgICAgICBzZWxmLmFkZHJlc3NfID0gbnVsbFxuICAgICAgICAgICAgICBzZWxmLmNvbW1hbmRfID0gbnVsbFxuICAgICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgbGV0IGhvc3RuYW1lID0gc2VsZi5ob3N0bmFtZV9cbiAgICAgICAgICAgIGlmICghaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgaG9zdG5hbWUgPVxuICAgICAgICAgICAgICAgICghc2VsZi5sb29wYmFja09ubHlfICYmIG5ldC5nZXRBZGRyZXNzKCkpIHx8XG4gICAgICAgICAgICAgICAgbmV0LmdldExvb3BiYWNrQWRkcmVzcygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclVybCA9IHVybC5mb3JtYXQoe1xuICAgICAgICAgICAgICBwcm90b2NvbDogJ2h0dHAnLFxuICAgICAgICAgICAgICBob3N0bmFtZTogaG9zdG5hbWUsXG4gICAgICAgICAgICAgIHBvcnQ6IHBvcnQgKyAnJyxcbiAgICAgICAgICAgICAgcGF0aG5hbWU6IHNlbGYucGF0aF8sXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgY2FuY2VsVG9rZW4gPSBlYXJseVRlcm1pbmF0aW9uLmNhdGNoKChlKSA9PlxuICAgICAgICAgICAgICAgIHJlamVjdChFcnJvcihlLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgaHR0cFV0aWwud2FpdEZvclNlcnZlcihzZXJ2ZXJVcmwsIHRpbWVvdXQsIGNhbmNlbFRva2VuKS50aGVuKFxuICAgICAgICAgICAgICAgIChfKSA9PiBmdWxmaWxsKHNlcnZlclVybCksXG4gICAgICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGh0dHBVdGlsLkNhbmNlbGxhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VydmVyVXJsKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc19cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgc2VydmljZSBpZiBpdCBpcyBub3QgY3VycmVudGx5IHJ1bm5pbmcuIFRoaXMgZnVuY3Rpb24gd2lsbCBraWxsXG4gICAqIHRoZSBzZXJ2ZXIgaW1tZWRpYXRlbHkuIFRvIHN5bmNocm9uaXplIHdpdGggdGhlIGFjdGl2ZSBjb250cm9sIGZsb3csIHVzZVxuICAgKiB7QGxpbmsgI3N0b3AoKX0uXG4gICAqIEByZXR1cm4geyFQcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNlcnZlciBoYXMgYmVlblxuICAgKiAgICAgc3RvcHBlZC5cbiAgICovXG4gIGtpbGwoKSB7XG4gICAgaWYgKCF0aGlzLmFkZHJlc3NfIHx8ICF0aGlzLmNvbW1hbmRfKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkgLy8gTm90IGN1cnJlbnRseSBydW5uaW5nLlxuICAgIH1cbiAgICBsZXQgY21kID0gdGhpcy5jb21tYW5kX1xuICAgIHRoaXMuYWRkcmVzc18gPSBudWxsXG4gICAgdGhpcy5jb21tYW5kXyA9IG51bGxcbiAgICByZXR1cm4gY21kLnRoZW4oKGMpID0+IGMua2lsbCgnU0lHVEVSTScpKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHshKEFycmF5PENvbW1hbmRMaW5lRmxhZz58SVRoZW5hYmxlPCFBcnJheTxDb21tYW5kTGluZUZsYWc+Pil9IGFyZ3NcbiAqIEByZXR1cm4geyFQcm9taXNlPCFBcnJheTxzdHJpbmc+Pn1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbW1hbmRMaW5lRmxhZ3MoYXJncykge1xuICAvLyBSZXNvbHZlIHRoZSBvdXRlciBhcnJheSwgdGhlbiB0aGUgaW5kaXZpZHVhbCBmbGFncy5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhcmdzKS50aGVuKFxuICAgIC8qKiAhQXJyYXk8Q29tbWFuZExpbmVGbGFnPiAqLyAoYXJncykgPT4gUHJvbWlzZS5hbGwoYXJncylcbiAgKVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFtb3VudCBvZiB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRvIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG9cbiAqIHN0YXJ0LlxuICogQGNvbnN0IHtudW1iZXJ9XG4gKi9cbkRyaXZlclNlcnZpY2UuREVGQVVMVF9TVEFSVF9USU1FT1VUX01TID0gMzAgKiAxMDAwXG5cbi8qKlxuICogQ3JlYXRlcyB7QGxpbmsgRHJpdmVyU2VydmljZX0gb2JqZWN0cyB0aGF0IG1hbmFnZSBhIFdlYkRyaXZlciBzZXJ2ZXIgaW4gYVxuICogY2hpbGQgcHJvY2Vzcy5cbiAqL1xuRHJpdmVyU2VydmljZS5CdWlsZGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4ZSBQYXRoIHRvIHRoZSBleGVjdXRhYmxlIHRvIHVzZS4gVGhpcyBleGVjdXRhYmxlIG11c3RcbiAgICogICAgIGFjY2VwdCB0aGUgYC0tcG9ydGAgZmxhZyBmb3IgZGVmaW5pbmcgdGhlIHBvcnQgdG8gc3RhcnQgdGhlIHNlcnZlciBvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcm92aWRlZCBleGVjdXRhYmxlIHBhdGggZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleGUpIHtcbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHtzdHJpbmd9ICovXG4gICAgdGhpcy5leGVfID0gZXhlXG5cbiAgICAvKiogQHByaXZhdGUgeyFTZXJ2aWNlT3B0aW9uc30gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0ge1xuICAgICAgYXJnczogW10sXG4gICAgICBwb3J0OiAwLFxuICAgICAgZW52OiBudWxsLFxuICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYWRkaXRpb25hbCBjb21tYW5kIGxpbmUgYXJndW1lbnRzIHRvIHVzZSB3aGVuIHN0YXJ0aW5nIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uQ29tbWFuZExpbmVGbGFnfSB2YXJfYXJncyBUaGUgYXJndW1lbnRzIHRvIGluY2x1ZGUuXG4gICAqIEByZXR1cm4geyFUSElTfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKiBAdGhpcyB7VEhJU31cbiAgICogQHRlbXBsYXRlIFRISVNcbiAgICovXG4gIGFkZEFyZ3VtZW50cyguLi5hcmd1bWVudHNfKSB7XG4gICAgdGhpcy5vcHRpb25zXy5hcmdzID0gdGhpcy5vcHRpb25zXy5hcmdzLmNvbmNhdChhcmd1bWVudHNfKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaG9zdCBuYW1lIHRvIGFjY2VzcyB0aGUgc2VydmVyIG9uLiBJZiBzcGVjaWZpZWQsIHRoZVxuICAgKiB7QGxpbmtwbGFpbiAjc2V0TG9vcGJhY2soKSBsb29wYmFja30gc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZVxuICAgKiBAcmV0dXJuIHshRHJpdmVyU2VydmljZS5CdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0SG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgICB0aGlzLm9wdGlvbnNfLmhvc3RuYW1lID0gaG9zdG5hbWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgc2VydmljZSBzaG91bGQgYmUgYWNjZXNzZWQgYXQgdGhpcyBob3N0J3MgbG9vcGJhY2tcbiAgICogYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBsb29wYmFja1xuICAgKiBAcmV0dXJuIHshRHJpdmVyU2VydmljZS5CdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0TG9vcGJhY2sobG9vcGJhY2spIHtcbiAgICB0aGlzLm9wdGlvbnNfLmxvb3BiYWNrID0gbG9vcGJhY2tcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhc2UgcGF0aCBmb3IgV2ViRHJpdmVyIFJFU1QgY29tbWFuZHMgKGUuZy4gXCIvd2QvaHViXCIpLlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgZHJpdmVyIHdpbGwgYWNjZXB0IGNvbW1hbmRzIHJlbGF0aXZlIHRvIFwiL1wiLlxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGJhc2VQYXRoIFRoZSBiYXNlIHBhdGggdG8gdXNlLCBvciBgbnVsbGAgdG8gdXNlIHRoZVxuICAgKiAgICAgZGVmYXVsdC5cbiAgICogQHJldHVybiB7IURyaXZlclNlcnZpY2UuQnVpbGRlcn0gQSBzZWxmIHJlZmVyZW5jZS5cbiAgICovXG4gIHNldFBhdGgoYmFzZVBhdGgpIHtcbiAgICB0aGlzLm9wdGlvbnNfLnBhdGggPSBiYXNlUGF0aFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9ydCB0byBzdGFydCB0aGUgc2VydmVyIG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydCBUaGUgcG9ydCB0byB1c2UsIG9yIDAgZm9yIGFueSBmcmVlIHBvcnQuXG4gICAqIEByZXR1cm4geyFEcml2ZXJTZXJ2aWNlLkJ1aWxkZXJ9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiBpbnZhbGlkIHBvcnQgaXMgc3BlY2lmaWVkLlxuICAgKi9cbiAgc2V0UG9ydChwb3J0KSB7XG4gICAgaWYgKHBvcnQgPCAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihgcG9ydCBtdXN0IGJlID49IDA6ICR7cG9ydH1gKVxuICAgIH1cbiAgICB0aGlzLm9wdGlvbnNfLnBvcnQgPSBwb3J0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBlbnZpcm9ubWVudCB0byBzdGFydCB0aGUgc2VydmVyIHVuZGVyLiBUaGlzIHNldHRpbmcgd2lsbCBiZVxuICAgKiBpbmhlcml0ZWQgYnkgZXZlcnkgYnJvd3NlciBzZXNzaW9uIHN0YXJ0ZWQgYnkgdGhlIHNlcnZlci4gQnkgZGVmYXVsdCwgdGhlXG4gICAqIHNlcnZlciB3aWxsIGluaGVyaXQgdGhlIGVudmlyb21lbnQgb2YgdGhlIGN1cnJlbnQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHsoTWFwPHN0cmluZywgc3RyaW5nPnxPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fG51bGwpfSBlbnYgVGhlIGRlc2lyZWRcbiAgICogICAgIGVudmlyb25tZW50IHRvIHVzZSwgb3IgYG51bGxgIGlmIHRoZSBzZXJ2ZXIgc2hvdWxkIGluaGVyaXQgdGhlXG4gICAqICAgICBjdXJyZW50IGVudmlyb25tZW50LlxuICAgKiBAcmV0dXJuIHshRHJpdmVyU2VydmljZS5CdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2V0RW52aXJvbm1lbnQoZW52KSB7XG4gICAgaWYgKGVudiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgbGV0IHRtcCA9IHt9XG4gICAgICBlbnYuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gKHRtcFtrZXldID0gdmFsdWUpKVxuICAgICAgZW52ID0gdG1wXG4gICAgfVxuICAgIHRoaXMub3B0aW9uc18uZW52ID0gZW52XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJTyBjb25maWd1cmF0aW9uIGZvciB0aGUgc3Bhd25lZCBzZXJ2ZXIgcHJvY2Vzcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sXG4gICAqIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBjaGlsZF9wcm9jZXNzLnNwYXduYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdGRJb09wdGlvbnN9IGNvbmZpZyBUaGUgZGVzaXJlZCBJTyBjb25maWd1cmF0aW9uLlxuICAgKiBAcmV0dXJuIHshRHJpdmVyU2VydmljZS5CdWlsZGVyfSBBIHNlbGYgcmVmZXJlbmNlLlxuICAgKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12NC54L2RvY3MvYXBpL2NoaWxkX3Byb2Nlc3MuaHRtbCNjaGlsZF9wcm9jZXNzX29wdGlvbnNfc3RkaW9cbiAgICovXG4gIHNldFN0ZGlvKGNvbmZpZykge1xuICAgIHRoaXMub3B0aW9uc18uc3RkaW8gPSBjb25maWdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRHJpdmVyU2VydmljZSB1c2luZyB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHshRHJpdmVyU2VydmljZX0gQSBuZXcgZHJpdmVyIHNlcnZpY2UuXG4gICAqL1xuICBidWlsZCgpIHtcbiAgICBsZXQgcG9ydCA9IHRoaXMub3B0aW9uc18ucG9ydCB8fCBwb3J0cHJvYmVyLmZpbmRGcmVlUG9ydCgpXG4gICAgbGV0IGFyZ3MgPSBQcm9taXNlLnJlc29sdmUocG9ydCkudGhlbigocG9ydCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc18uYXJncy5jb25jYXQoJy0tcG9ydD0nICsgcG9ydClcbiAgICB9KVxuXG4gICAgbGV0IG9wdGlvbnMgPVxuICAgICAgLyoqIEB0eXBlIHshU2VydmljZU9wdGlvbnN9ICovXG4gICAgICAoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zXywgeyBhcmdzLCBwb3J0IH0pKVxuICAgIHJldHVybiBuZXcgRHJpdmVyU2VydmljZSh0aGlzLmV4ZV8sIG9wdGlvbnMpXG4gIH1cbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBsaWZlIGFuZCBkZWF0aCBvZiB0aGVcbiAqIDxhIGhyZWY9XCJodHRwczovL3d3dy5zZWxlbml1bS5kZXYvZG93bmxvYWRzL1wiPlxuICogc3RhbmRhbG9uZSBTZWxlbml1bSBzZXJ2ZXI8L2E+LlxuICovXG5jbGFzcyBTZWxlbml1bVNlcnZlciBleHRlbmRzIERyaXZlclNlcnZpY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGphciBQYXRoIHRvIHRoZSBTZWxlbml1bSBzZXJ2ZXIgamFyLlxuICAgKiBAcGFyYW0ge1NlbGVuaXVtU2VydmVyLk9wdGlvbnM9fSBvcHRfb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZVxuICAgKiAgICAgc2VydmVyLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBhdGggdG8gdGhlIFNlbGVuaXVtIGphciBpcyBub3Qgc3BlY2lmaWVkIG9yIGlmIGFuXG4gICAqICAgICBpbnZhbGlkIHBvcnQgaXMgc3BlY2lmaWVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoamFyLCBvcHRfb3B0aW9ucykge1xuICAgIGlmICghamFyKSB7XG4gICAgICB0aHJvdyBFcnJvcignUGF0aCB0byB0aGUgU2VsZW5pdW0gamFyIG5vdCBzcGVjaWZpZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fVxuXG4gICAgaWYgKG9wdGlvbnMucG9ydCA8IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdQb3J0IG11c3QgYmUgPj0gMDogJyArIG9wdGlvbnMucG9ydClcbiAgICB9XG5cbiAgICBsZXQgcG9ydCA9IG9wdGlvbnMucG9ydCB8fCBwb3J0cHJvYmVyLmZpbmRGcmVlUG9ydCgpXG4gICAgbGV0IGFyZ3MgPSBQcm9taXNlLmFsbChbXG4gICAgICBwb3J0LFxuICAgICAgb3B0aW9ucy5qdm1BcmdzIHx8IFtdLFxuICAgICAgb3B0aW9ucy5hcmdzIHx8IFtdLFxuICAgIF0pLnRoZW4oKHJlc29sdmVkKSA9PiB7XG4gICAgICBsZXQgcG9ydCA9IHJlc29sdmVkWzBdXG4gICAgICBsZXQganZtQXJncyA9IHJlc29sdmVkWzFdXG4gICAgICBsZXQgYXJncyA9IHJlc29sdmVkWzJdXG5cbiAgICAgIGNvbnN0IGZ1bGxBcmdzTGlzdCA9IGp2bUFyZ3NcbiAgICAgICAgLmNvbmNhdCgnLWphcicsIGphciwgJy1wb3J0JywgcG9ydClcbiAgICAgICAgLmNvbmNhdChhcmdzKVxuXG4gICAgICByZXR1cm4gZm9ybWF0U3Bhd25BcmdzKGphciwgZnVsbEFyZ3NMaXN0KVxuICAgIH0pXG5cbiAgICBjb25zdCBqYXZhID0gZ2V0SmF2YVBhdGgoKVxuXG4gICAgc3VwZXIoamF2YSwge1xuICAgICAgbG9vcGJhY2s6IG9wdGlvbnMubG9vcGJhY2ssXG4gICAgICBwb3J0OiBwb3J0LFxuICAgICAgYXJnczogYXJncyxcbiAgICAgIHBhdGg6ICcvd2QvaHViJyxcbiAgICAgIGVudjogb3B0aW9ucy5lbnYsXG4gICAgICBzdGRpbzogb3B0aW9ucy5zdGRpbyxcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQSByZWNvcmQgb2JqZWN0IGRlc2NyaWJpbmcgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhIHtAbGluayBTZWxlbml1bVNlcnZlcn1cbiAqIGluc3RhbmNlLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuU2VsZW5pdW1TZXJ2ZXIuT3B0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc2VydmVyIHNob3VsZCBvbmx5IGJlIGFjY2Vzc2libGUgb24gdGhpcyBob3N0J3MgbG9vcGJhY2tcbiAgICAgKiBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHR5cGUgeyhib29sZWFufHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgdGhpcy5sb29wYmFja1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvcnQgdG8gc3RhcnQgdGhlIHNlcnZlciBvbiAobXVzdCBiZSA+IDApLiBJZiB0aGUgcG9ydCBpcyBwcm92aWRlZCBhc1xuICAgICAqIGEgcHJvbWlzZSwgdGhlIHNlcnZpY2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZVxuICAgICAqIHN0YXJ0aW5nLlxuICAgICAqXG4gICAgICogQHR5cGUgeyhudW1iZXJ8IUlUaGVuYWJsZTxudW1iZXI+KX1cbiAgICAgKi9cbiAgICB0aGlzLnBvcnRcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgc2VydmljZS4gSWYgYSBwcm9taXNlIGlzIHByb3ZpZGVkLFxuICAgICAqIHRoZSBzZXJ2aWNlIHdpbGwgd2FpdCBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgc3RhcnRpbmcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7IShBcnJheTxzdHJpbmc+fElUaGVuYWJsZTwhQXJyYXk8c3RyaW5nPj4pfVxuICAgICAqL1xuICAgIHRoaXMuYXJnc1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBKVk0uIElmIGEgcHJvbWlzZSBpcyBwcm92aWRlZCxcbiAgICAgKiB0aGUgc2VydmljZSB3aWxsIHdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlIHN0YXJ0aW5nLlxuICAgICAqXG4gICAgICogQHR5cGUgeyghQXJyYXk8c3RyaW5nPnwhSVRoZW5hYmxlPCFBcnJheTxzdHJpbmc+Pnx1bmRlZmluZWQpfVxuICAgICAqL1xuICAgIHRoaXMuanZtQXJnc1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IHNob3VsZCBiZSB2aXNpYmxlIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBwcm9jZXNzLiBEZWZhdWx0cyB0byBpbmhlcml0aW5nIHRoZSBjdXJyZW50IHByb2Nlc3MncyBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHsoIU9iamVjdDxzdHJpbmcsIHN0cmluZz58dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICB0aGlzLmVudlxuXG4gICAgLyoqXG4gICAgICogSU8gY29uZmlndXJhdGlvbiBmb3IgdGhlIHNwYXduZWQgc2VydmVyIHByb2Nlc3MuIElmIHVuc3BlY2lmaWVkLCBJTyB3aWxsXG4gICAgICogYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHsoc3RyaW5nfCFBcnJheTxzdHJpbmd8bnVtYmVyfCFzdHJlYW0uU3RyZWFtfG51bGx8dW5kZWZpbmVkPnxcbiAgICAgKiAgICAgICAgIHVuZGVmaW5lZCl9XG4gICAgICogQHNlZSA8aHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXY4LngvZG9jcy9hcGkvY2hpbGRfcHJvY2Vzcy5odG1sI2NoaWxkX3Byb2Nlc3Nfb3B0aW9uc19zdGRpbz5cbiAgICAgKi9cbiAgICB0aGlzLnN0ZGlvXG4gIH1cbn1cblxuLyoqXG4gKiBBIHtAbGluayB3ZWJkcml2ZXIuRmlsZURldGVjdG9yfSB0aGF0IG1heSBiZSB1c2VkIHdoZW4gcnVubmluZ1xuICogYWdhaW5zdCBhIHJlbW90ZVxuICogW1NlbGVuaXVtIHNlcnZlcl0oaHR0cHM6Ly93d3cuc2VsZW5pdW0uZGV2L2Rvd25sb2Fkcy8pLlxuICpcbiAqIFdoZW4gYSBmaWxlIHBhdGggb24gdGhlIGxvY2FsIG1hY2hpbmUgcnVubmluZyB0aGlzIHNjcmlwdCBpcyBlbnRlcmVkIHdpdGhcbiAqIHtAbGluayB3ZWJkcml2ZXIuV2ViRWxlbWVudCNzZW5kS2V5cyBXZWJFbGVtZW50I3NlbmRLZXlzfSwgdGhpcyBmaWxlIGRldGVjdG9yXG4gKiB3aWxsIHRyYW5zZmVyIHRoZSBzcGVjaWZpZWQgZmlsZSB0byB0aGUgU2VsZW5pdW0gc2VydmVyJ3MgaG9zdDsgdGhlIHNlbmRLZXlzXG4gKiBjb21tYW5kIHdpbGwgYmUgdXBkYXRlZCB0byB1c2UgdGhlIHRyYW5zZmVycmVkIGZpbGUncyBwYXRoLlxuICpcbiAqIF9fTm90ZTpfXyBUaGlzIGNsYXNzIGRlcGVuZHMgb24gYSBub24tc3RhbmRhcmQgY29tbWFuZCBzdXBwb3J0ZWQgb24gdGhlXG4gKiBKYXZhIFNlbGVuaXVtIHNlcnZlci4gVGhlIGZpbGUgZGV0ZWN0b3Igd2lsbCBmYWlsIGlmIHVzZWQgd2l0aCBhIHNlcnZlciB0aGF0XG4gKiBvbmx5IHN1cHBvcnRzIHN0YW5kYXJkIFdlYkRyaXZlciBjb21tYW5kcyAoc3VjaCBhcyB0aGUgQ2hyb21lRHJpdmVyKS5cbiAqXG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgRmlsZURldGVjdG9yIGV4dGVuZHMgaW5wdXQuRmlsZURldGVjdG9yIHtcbiAgLyoqXG4gICAqIFByZXBhcmVzIGEgYGZpbGVgIGZvciB1c2Ugd2l0aCB0aGUgcmVtb3RlIGJyb3dzZXIuIElmIHRoZSBwcm92aWRlZCBwYXRoXG4gICAqIGRvZXMgbm90IHJlZmVyZW5jZSBhIG5vcm1hbCBmaWxlIChpLmUuIGl0IGRvZXMgbm90IGV4aXN0IG9yIGlzIGFcbiAgICogZGlyZWN0b3J5KSwgdGhlbiB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgICogdGhlIG9yaWdpbmFsIGZpbGUgcGF0aC4gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCB3aWxsIHVwbG9hZCB0aGUgZmlsZSB0byB0aGVcbiAgICogcmVtb3RlIHNlcnZlciwgd2hpY2ggd2lsbCByZXR1cm4gdGhlIGZpbGUncyBwYXRoIG9uIHRoZSByZW1vdGUgc3lzdGVtIHNvXG4gICAqIGl0IG1heSBiZSByZWZlcmVuY2VkIGluIHN1YnNlcXVlbnQgY29tbWFuZHMuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRmlsZShkcml2ZXIsIGZpbGUpIHtcbiAgICByZXR1cm4gaW8uc3RhdChmaWxlKS50aGVuKFxuICAgICAgZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGUgLy8gTm90IGEgdmFsaWQgZmlsZSwgcmV0dXJuIG9yaWdpbmFsIGlucHV0LlxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHppcCA9IG5ldyBaaXAoKVxuICAgICAgICByZXR1cm4gemlwXG4gICAgICAgICAgLmFkZEZpbGUoZmlsZSlcbiAgICAgICAgICAudGhlbigoKSA9PiB6aXAudG9CdWZmZXIoKSlcbiAgICAgICAgICAudGhlbigoYnVmKSA9PiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpKVxuICAgICAgICAgIC50aGVuKChlbmNvZGVkWmlwKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29tbWFuZCA9IG5ldyBjbWQuQ29tbWFuZChjbWQuTmFtZS5VUExPQURfRklMRSkuc2V0UGFyYW1ldGVyKFxuICAgICAgICAgICAgICAnZmlsZScsXG4gICAgICAgICAgICAgIGVuY29kZWRaaXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBkcml2ZXIuZXhlY3V0ZShjb21tYW5kKVxuICAgICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGUgLy8gTm90IGEgZmlsZTsgcmV0dXJuIG9yaWdpbmFsIGlucHV0LlxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIClcbiAgfVxufVxuXG4vLyBQVUJMSUMgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBEcml2ZXJTZXJ2aWNlLFxuICBGaWxlRGV0ZWN0b3IsXG4gIFNlbGVuaXVtU2VydmVyLFxuICAvLyBFeHBvcnRlZCBmb3IgQVBJIGRvY3MuXG4gIFNlcnZpY2VPcHRpb25zLFxufVxuIiwiLy8gTGljZW5zZWQgdG8gdGhlIFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3kgKFNGQykgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBTRkMgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNwID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG5cbi8qKlxuICogcmV0dXJucyBwYXRoIHRvIGphdmEgb3IgJ2phdmEnIHN0cmluZyBpZiBKQVZBX0hPTUUgZG9lcyBub3QgZXhpc3QgaW4gZW52IG9ialxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SmF2YVBhdGgoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudlsnSkFWQV9IT01FJ11cbiAgICA/IHBhdGguam9pbihwcm9jZXNzLmVudlsnSkFWQV9IT01FJ10sICdiaW4vamF2YScpXG4gICAgOiAnamF2YSdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZW5pdW1TdGFuZGFsb25lUGF0aCBwYXRoIHRvIHN0YW5kYWxvbmUgc2VydmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTZWxlbml1bTN4KHNlbGVuaXVtU3RhbmRhbG9uZVBhdGgpIHtcbiAgY29uc3QgamF2YVBhdGggPSBnZXRKYXZhUGF0aCgpXG5cbiAgY29uc3QgZXhlY1JlcyA9IGNwLmV4ZWNTeW5jKFxuICAgIGAke2phdmFQYXRofSAtamFyICR7c2VsZW5pdW1TdGFuZGFsb25lUGF0aH0gLS12ZXJzaW9uYFxuICApXG5cbiAgcmV0dXJuIGV4ZWNSZXMudG9TdHJpbmcoKS50cmltKCkuc3RhcnRzV2l0aCgnU2VsZW5pdW0gc2VydmVyIHZlcnNpb246IDMnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlbml1bVN0YW5kYWxvbmVQYXRoIHBhdGggdG8gc3RhbmRhbG9uZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGFyZ3Mgc3Bhd24gYXJndW1lbnRzIGFycmF5XG4gKiByZXR1cm5zIGZvcm1hdHRlZCBhcmdzIGJhc2VkIG9uIHNlbGVuaXVtIHN0YW5kYWxvbmUgc2VydmVyIHZlcnNpb25cbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0U3Bhd25BcmdzKHNlbGVuaXVtU3RhbmRhbG9uZVBhdGgsIGFyZ3MpIHtcbiAgaWYgKGlzU2VsZW5pdW0zeChzZWxlbml1bVN0YW5kYWxvbmVQYXRoKSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdEZXByZWNhdGlvbjogU3VwcG9ydCBmb3IgU3RhbmRhbG9uZSBTZXJ2ZXIgMy54IHdpbGwgYmUgcmVtb3ZlZCBzb29uLiBQbGVhc2UgdXBkYXRlIHRvIHZlcnNpb24gNC54J1xuICAgIClcbiAgICByZXR1cm4gYXJnc1xuICB9XG5cbiAgY29uc3Qgc3RhbmRhbG9uZUFyZyA9ICdzdGFuZGFsb25lJ1xuICBjb25zdCBwb3J0M3hBcmdGb3JtYXQgPSAnLXBvcnQnXG4gIGNvbnN0IHBvcnQ0eEFyZ0Zvcm1hdCA9ICctLXBvcnQnXG5cbiAgbGV0IGZvcm1hdHRlZEFyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpXG5cbiAgY29uc3Qgc3RhbmRhbG9uZUFyZ0luZGV4ID0gZm9ybWF0dGVkQXJncy5maW5kSW5kZXgoXG4gICAgKGFyZykgPT4gYXJnID09PSBzZWxlbml1bVN0YW5kYWxvbmVQYXRoXG4gIClcbiAgY29uc3QgdjNwb3J0QXJnRm9ybWF0ID0gZm9ybWF0dGVkQXJncy5maW5kSW5kZXgoXG4gICAgKGFyZykgPT4gYXJnID09PSBwb3J0M3hBcmdGb3JtYXRcbiAgKVxuXG4gIC8vIG9sZCB2M3ggcG9ydCBhcmcgZm9ybWF0IHdhcyAtcG9ydCwgbmV3IHY0eCBwb3J0IGFyZyBmb3JtYXQgaXMgLS1wb3J0XG4gIGlmICh2M3BvcnRBcmdGb3JtYXQgIT09IC0xKSB7XG4gICAgZm9ybWF0dGVkQXJnc1t2M3BvcnRBcmdGb3JtYXRdID0gcG9ydDR4QXJnRm9ybWF0XG4gIH1cblxuICAvLyAnc3RhbmRhbG9uZScgYXJnIHNob3VsZCBiZSByaWdodCBhZnRlciBqYXIgZmlsZSBwYXRoXG4gIC8vIGluIGNhc2UgaWYgaXQgaXMgYWxyZWFkeSBpbiBwbGFjZSAtIHJldHVybnMgYXJnc1xuICBpZiAoZm9ybWF0dGVkQXJnc1tzdGFuZGFsb25lQXJnSW5kZXggKyAxXSA9PT0gc3RhbmRhbG9uZUFyZylcbiAgICByZXR1cm4gZm9ybWF0dGVkQXJnc1xuXG4gIC8vIGluc2VydCAnc3RhbmRhbG9uZScgcmlnaHQgYWZ0ZXIgamFyIGZpbGUgcGF0aFxuICBmb3JtYXR0ZWRBcmdzLnNwbGljZShzdGFuZGFsb25lQXJnSW5kZXggKyAxLCAwLCBzdGFuZGFsb25lQXJnKVxuXG4gIHJldHVybiBmb3JtYXR0ZWRBcmdzXG59XG5cbi8vIFBVQkxJQyBBUElcbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRKYXZhUGF0aCxcbiAgaXNTZWxlbml1bTN4LFxuICBmb3JtYXRTcGF3bkFyZ3MsXG59XG4iLCIvLyBMaWNlbnNlZCB0byB0aGUgU29mdHdhcmUgRnJlZWRvbSBDb25zZXJ2YW5jeSAoU0ZDKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIFNGQyBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBhIFdlYkRyaXZlciBjbGllbnQgZm9yIFNhZmFyaS5cbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJy4vaHR0cCcpXG5jb25zdCBpbyA9IHJlcXVpcmUoJy4vaW8nKVxuY29uc3QgcmVtb3RlID0gcmVxdWlyZSgnLi9yZW1vdGUnKVxuY29uc3Qgd2ViZHJpdmVyID0gcmVxdWlyZSgnLi9saWIvd2ViZHJpdmVyJylcbmNvbnN0IHsgQnJvd3NlciwgQ2FwYWJpbGl0aWVzIH0gPSByZXF1aXJlKCcuL2xpYi9jYXBhYmlsaXRpZXMnKVxuXG4vKipcbiAqIF9TeW5jaHJvbm91c2x5XyBhdHRlbXB0cyB0byBsb2NhdGUgdGhlIElFIGRyaXZlciBleGVjdXRhYmxlIG9uIHRoZSBjdXJyZW50XG4gKiBzeXN0ZW0uXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gdGhlIGxvY2F0ZWQgZXhlY3V0YWJsZSwgb3IgYG51bGxgLlxuICovXG5mdW5jdGlvbiBsb2NhdGVTeW5jaHJvbm91c2x5KCkge1xuICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbidcbiAgICA/IGlvLmZpbmRJblBhdGgoJ3NhZmFyaWRyaXZlcicsIHRydWUpXG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSAuXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gZmluZFNhZmFyaURyaXZlcigpIHtcbiAgbGV0IGV4ZSA9IGxvY2F0ZVN5bmNocm9ub3VzbHkoKVxuICBpZiAoIWV4ZSkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYFRoZSBzYWZhcmlkcml2ZXIgZXhlY3V0YWJsZSBjb3VsZCBub3QgYmUgZm91bmQgb24gdGhlIGN1cnJlbnQgUEFUSC5cbiAgICAgIFBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyBTYWZhcmkgMTAuMCBvciBhYm92ZS5gXG4gICAgKVxuICB9XG4gIHJldHVybiBleGVcbn1cblxuLyoqXG4gKiBDcmVhdGVzIHtAbGluayBzZWxlbml1bS13ZWJkcml2ZXIvcmVtb3RlLkRyaXZlclNlcnZpY2V9IGluc3RhbmNlcyB0aGF0IG1hbmFnZVxuICogYSBbc2FmYXJpZHJpdmVyXSBzZXJ2ZXIgaW4gYSBjaGlsZCBwcm9jZXNzLlxuICpcbiAqIFtzYWZhcmlkcml2ZXJdOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9wcmVyZWxlYXNlL2NvbnRlbnQvcmVsZWFzZW5vdGVzL0dlbmVyYWwvV2hhdHNOZXdJblNhZmFyaS9BcnRpY2xlcy9TYWZhcmlfMTBfMC5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAxNDMwNS1DSDExLURvbnRMaW5rRWxlbWVudElEXzI4XG4gKi9cbmNsYXNzIFNlcnZpY2VCdWlsZGVyIGV4dGVuZHMgcmVtb3RlLkRyaXZlclNlcnZpY2UuQnVpbGRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9leGUgUGF0aCB0byB0aGUgc2VydmVyIGV4ZWN1dGFibGUgdG8gdXNlLiBJZiBvbWl0dGVkLFxuICAgKiAgICAgdGhlIGJ1aWxkZXIgd2lsbCBhdHRlbXB0IHRvIGxvY2F0ZSB0aGUgc2FmYXJpZHJpdmVyIG9uIHRoZSBzeXN0ZW0gUEFUSC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9leGUpIHtcbiAgICBzdXBlcihvcHRfZXhlIHx8IGZpbmRTYWZhcmlEcml2ZXIoKSlcbiAgICB0aGlzLnNldExvb3BiYWNrKHRydWUpIC8vIFJlcXVpcmVkLlxuICB9XG59XG5cbmNvbnN0IE9QVElPTlNfQ0FQQUJJTElUWV9LRVkgPSAnc2FmYXJpLm9wdGlvbnMnXG5jb25zdCBURUNITk9MT0dZX1BSRVZJRVdfT1BUSU9OU19LRVkgPSAndGVjaG5vbG9neVByZXZpZXcnXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIHNwZWNpZmljIHRvIHRoZSB7QGxpbmsgRHJpdmVyIFNhZmFyaURyaXZlcn0uXG4gKi9cbmNsYXNzIE9wdGlvbnMgZXh0ZW5kcyBDYXBhYmlsaXRpZXMge1xuICAvKipcbiAgICogQHBhcmFtIHsoQ2FwYWJpbGl0aWVzfE1hcDxzdHJpbmcsID8+fE9iamVjdCk9fSBvdGhlciBBbm90aGVyIHNldCBvZlxuICAgKiAgICAgY2FwYWJpbGl0aWVzIHRvIGluaXRpYWxpemUgdGhpcyBpbnN0YW5jZSBmcm9tLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3RoZXIgPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihvdGhlcilcblxuICAgIC8qKiBAcHJpdmF0ZSB7IU9iamVjdH0gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0gdGhpcy5nZXQoT1BUSU9OU19DQVBBQklMSVRZX0tFWSkgfHwge31cblxuICAgIHRoaXMuc2V0KE9QVElPTlNfQ0FQQUJJTElUWV9LRVksIHRoaXMub3B0aW9uc18pXG4gICAgdGhpcy5zZXRCcm93c2VyTmFtZShCcm93c2VyLlNBRkFSSSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0cnVjdCB0aGUgU2FmYXJpRHJpdmVyIHRvIHVzZSB0aGUgU2FmYXJpIFRlY2hub2xvZ3kgUHJldmlldyBpZiB0cnVlLlxuICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgcmVsZWFzZSB2ZXJzaW9uIG9mIFNhZmFyaS4gRGVmYXVsdHMgdG8gdXNpbmcgdGhlIHJlbGVhc2UgdmVyc2lvbiBvZiBTYWZhcmkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlVGVjaG5vbG9neVByZXZpZXdcbiAgICogQHJldHVybiB7IU9wdGlvbnN9IEEgc2VsZiByZWZlcmVuY2UuXG4gICAqL1xuICBzZXRUZWNobm9sb2d5UHJldmlldyh1c2VUZWNobm9sb2d5UHJldmlldykge1xuICAgIHRoaXMub3B0aW9uc19bVEVDSE5PTE9HWV9QUkVWSUVXX09QVElPTlNfS0VZXSA9ICEhdXNlVGVjaG5vbG9neVByZXZpZXdcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7KENhcGFiaWxpdGllc3xPYmplY3Q8c3RyaW5nLCAqPik9fSBvIFRoZSBvcHRpb25zIG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdXNlVGVjaG5vbG9neVByZXZpZXcobykge1xuICBpZiAobyBpbnN0YW5jZW9mIENhcGFiaWxpdGllcykge1xuICAgIGxldCBvcHRpb25zID0gby5nZXQoT1BUSU9OU19DQVBBQklMSVRZX0tFWSlcbiAgICByZXR1cm4gISEob3B0aW9ucyAmJiBvcHRpb25zW1RFQ0hOT0xPR1lfUFJFVklFV19PUFRJT05TX0tFWV0pXG4gIH1cblxuICBpZiAobyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gISFvW1RFQ0hOT0xPR1lfUFJFVklFV19PUFRJT05TX0tFWV1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBTQUZBUklEUklWRVJfVEVDSE5PTE9HWV9QUkVWSUVXX0VYRSA9XG4gICcvQXBwbGljYXRpb25zL1NhZmFyaSBUZWNobm9sb2d5IFByZXZpZXcuYXBwL0NvbnRlbnRzL01hY09TL3NhZmFyaWRyaXZlcidcblxuLyoqXG4gKiBBIFdlYkRyaXZlciBjbGllbnQgZm9yIFNhZmFyaS4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFudGlhdGVkXG4gKiBkaXJlY3RseTsgaW5zdGVhZCwgdXNlIHRoZSB7QGxpbmtwbGFpbiAuL2J1aWxkZXIuQnVpbGRlciBCdWlsZGVyfTpcbiAqXG4gKiAgICAgdmFyIGRyaXZlciA9IG5ldyBCdWlsZGVyKClcbiAqICAgICAgICAgLmZvckJyb3dzZXIoJ3NhZmFyaScpXG4gKiAgICAgICAgIC5idWlsZCgpO1xuICpcbiAqL1xuY2xhc3MgRHJpdmVyIGV4dGVuZHMgd2ViZHJpdmVyLldlYkRyaXZlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNhZmFyaSBzZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyhPcHRpb25zfENhcGFiaWxpdGllcyk9fSBvcHRpb25zIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqIEByZXR1cm4geyFEcml2ZXJ9IEEgbmV3IGRyaXZlciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVTZXNzaW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgY2FwcyA9IG9wdGlvbnMgfHwgbmV3IE9wdGlvbnMoKVxuXG4gICAgbGV0IGV4ZVxuICAgIGlmICh1c2VUZWNobm9sb2d5UHJldmlldyhjYXBzLmdldChPUFRJT05TX0NBUEFCSUxJVFlfS0VZKSkpIHtcbiAgICAgIGV4ZSA9IFNBRkFSSURSSVZFUl9URUNITk9MT0dZX1BSRVZJRVdfRVhFXG4gICAgfVxuXG4gICAgbGV0IHNlcnZpY2UgPSBuZXcgU2VydmljZUJ1aWxkZXIoZXhlKS5idWlsZCgpXG4gICAgbGV0IGV4ZWN1dG9yID0gbmV3IGh0dHAuRXhlY3V0b3IoXG4gICAgICBzZXJ2aWNlLnN0YXJ0KCkudGhlbigodXJsKSA9PiBuZXcgaHR0cC5IdHRwQ2xpZW50KHVybCkpXG4gICAgKVxuXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IURyaXZlcn0gKi8gKFxuICAgICAgc3VwZXIuY3JlYXRlU2Vzc2lvbihleGVjdXRvciwgY2FwcywgKCkgPT4gc2VydmljZS5raWxsKCkpXG4gICAgKVxuICB9XG59XG5cbi8vIFB1YmxpYyBBUElcblxuZXhwb3J0cy5Ecml2ZXIgPSBEcml2ZXJcbmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnNcbmV4cG9ydHMuU2VydmljZUJ1aWxkZXIgPSBTZXJ2aWNlQnVpbGRlclxuZXhwb3J0cy5sb2NhdGVTeW5jaHJvbm91c2x5ID0gbG9jYXRlU3luY2hyb25vdXNseVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiLyohXG4gKiBUbXBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNyBLQVJBU1pJIElzdHZhbiA8Z2l0aHViQHNwYW0ucmFzemkuaHU+XG4gKlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLypcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IF9jID0geyBmczogZnMuY29uc3RhbnRzLCBvczogb3MuY29uc3RhbnRzIH07XG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCdyaW1yYWYnKTtcblxuLypcbiAqIFRoZSB3b3JraW5nIGlubmVyIHZhcmlhYmxlcy5cbiAqL1xuY29uc3RcbiAgLy8gdGhlIHJhbmRvbSBjaGFyYWN0ZXJzIHRvIGNob29zZSBmcm9tXG4gIFJBTkRPTV9DSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG5cbiAgVEVNUExBVEVfUEFUVEVSTiA9IC9YWFhYWFgvLFxuXG4gIERFRkFVTFRfVFJJRVMgPSAzLFxuXG4gIENSRUFURV9GTEFHUyA9IChfYy5PX0NSRUFUIHx8IF9jLmZzLk9fQ1JFQVQpIHwgKF9jLk9fRVhDTCB8fCBfYy5mcy5PX0VYQ0wpIHwgKF9jLk9fUkRXUiB8fCBfYy5mcy5PX1JEV1IpLFxuXG4gIC8vIGNvbnN0YW50cyBhcmUgb2ZmIG9uIHRoZSB3aW5kb3dzIHBsYXRmb3JtIGFuZCB3aWxsIG5vdCBtYXRjaCB0aGUgYWN0dWFsIGVycm5vIGNvZGVzXG4gIElTX1dJTjMyID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyxcbiAgRUJBREYgPSBfYy5FQkFERiB8fCBfYy5vcy5lcnJuby5FQkFERixcbiAgRU5PRU5UID0gX2MuRU5PRU5UIHx8IF9jLm9zLmVycm5vLkVOT0VOVCxcblxuICBESVJfTU9ERSA9IDBvNzAwIC8qIDQ0OCAqLyxcbiAgRklMRV9NT0RFID0gMG82MDAgLyogMzg0ICovLFxuXG4gIEVYSVQgPSAnZXhpdCcsXG5cbiAgLy8gdGhpcyB3aWxsIGhvbGQgdGhlIG9iamVjdHMgbmVlZCB0byBiZSByZW1vdmVkIG9uIGV4aXRcbiAgX3JlbW92ZU9iamVjdHMgPSBbXSxcblxuICAvLyBBUEkgY2hhbmdlIGluIGZzLnJtZGlyU3luYyBsZWFkcyB0byBlcnJvciB3aGVuIHBhc3NpbmcgaW4gYSBzZWNvbmQgcGFyYW1ldGVyLCBlLmcuIHRoZSBjYWxsYmFja1xuICBGTl9STURJUl9TWU5DID0gZnMucm1kaXJTeW5jLmJpbmQoZnMpLFxuICBGTl9SSU1SQUZfU1lOQyA9IHJpbXJhZi5zeW5jO1xuXG5sZXRcbiAgX2dyYWNlZnVsQ2xlYW51cCA9IGZhbHNlO1xuXG4vKipcbiAqIEdldHMgYSB0ZW1wb3JhcnkgZmlsZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8dG1wTmFtZUNhbGxiYWNrKX0gb3B0aW9ucyBvcHRpb25zIG9yIGNhbGxiYWNrXG4gKiBAcGFyYW0gez90bXBOYW1lQ2FsbGJhY2t9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB0bXBOYW1lKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIHRyeSB7XG4gICAgX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cblxuICBsZXQgdHJpZXMgPSBvcHRzLnRyaWVzO1xuICAoZnVuY3Rpb24gX2dldFVuaXF1ZU5hbWUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBwYXRoIGV4aXN0cyB0aGVuIHJldHJ5IGlmIG5lZWRlZFxuICAgICAgZnMuc3RhdChuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAodHJpZXMtLSA+IDApIHJldHVybiBfZ2V0VW5pcXVlTmFtZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkICcgKyBuYW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYihudWxsLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0oKSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiB0bXBOYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBuYW1lXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQgb3IgY291bGQgbm90IGdlbmVyYXRlIGEgZmlsZW5hbWVcbiAqL1xuZnVuY3Rpb24gdG1wTmFtZVN5bmMob3B0aW9ucykge1xuICBjb25zdFxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucyksXG4gICAgb3B0cyA9IGFyZ3NbMF07XG5cbiAgX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRzKTtcblxuICBsZXQgdHJpZXMgPSBvcHRzLnRyaWVzO1xuICBkbyB7XG4gICAgY29uc3QgbmFtZSA9IF9nZW5lcmF0ZVRtcE5hbWUob3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnN0YXRTeW5jKG5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfSB3aGlsZSAodHJpZXMtLSA+IDApO1xuXG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgb3BlbnMgYSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfG51bGx8dW5kZWZpbmVkfGZpbGVDYWxsYmFjayl9IG9wdGlvbnMgdGhlIGNvbmZpZyBvcHRpb25zIG9yIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvciBudWxsIG9yIHVuZGVmaW5lZFxuICogQHBhcmFtIHs/ZmlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmaWxlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIC8vIGdldHMgYSB0ZW1wb3JhcnkgZmlsZW5hbWVcbiAgdG1wTmFtZShvcHRzLCBmdW5jdGlvbiBfdG1wTmFtZUNyZWF0ZWQoZXJyLCBuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGNyZWF0ZSBhbmQgb3BlbiB0aGUgZmlsZVxuICAgIGZzLm9wZW4obmFtZSwgQ1JFQVRFX0ZMQUdTLCBvcHRzLm1vZGUgfHwgRklMRV9NT0RFLCBmdW5jdGlvbiBfZmlsZUNyZWF0ZWQoZXJyLCBmZCkge1xuICAgICAgLyogaXN0YW5idSBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChvcHRzLmRpc2NhcmREZXNjcmlwdG9yKSB7XG4gICAgICAgIHJldHVybiBmcy5jbG9zZShmZCwgZnVuY3Rpb24gX2Rpc2NhcmRDYWxsYmFjayhwb3NzaWJsZUVycikge1xuICAgICAgICAgIC8vIHRoZSBjaGFuY2Ugb2YgZ2V0dGluZyBhbiBlcnJvciBvbiBjbG9zZSBoZXJlIGlzIHJhdGhlciBsb3cgYW5kIG1pZ2h0IG9jY3VyIGluIHRoZSBtb3N0IGVkZ2llc3QgY2FzZXMgb25seVxuICAgICAgICAgIHJldHVybiBjYihwb3NzaWJsZUVyciwgbmFtZSwgdW5kZWZpbmVkLCBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCAtMSwgb3B0cywgZmFsc2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZXRhY2hEZXNjcmlwdG9yIHBhc3NlcyB0aGUgZGVzY3JpcHRvciB3aGVyZWFzIGRpc2NhcmREZXNjcmlwdG9yIGNsb3NlcyBpdCwgZWl0aGVyIHdheSwgd2Ugbm8gbG9uZ2VyIGNhcmVcbiAgICAgICAgLy8gYWJvdXQgdGhlIGRlc2NyaXB0b3JcbiAgICAgICAgY29uc3QgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA9IG9wdHMuZGlzY2FyZERlc2NyaXB0b3IgfHwgb3B0cy5kZXRhY2hEZXNjcmlwdG9yO1xuICAgICAgICBjYihudWxsLCBuYW1lLCBmZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA/IC0xIDogZmQsIG9wdHMsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtGaWxlU3luY09iamVjdH0gb2JqZWN0IGNvbnNpc3RzIG9mIG5hbWUsIGZkIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGNhbm5vdCBjcmVhdGUgYSBmaWxlXG4gKi9cbmZ1bmN0aW9uIGZpbGVTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3RcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPSBvcHRzLmRpc2NhcmREZXNjcmlwdG9yIHx8IG9wdHMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgY29uc3QgbmFtZSA9IHRtcE5hbWVTeW5jKG9wdHMpO1xuICB2YXIgZmQgPSBmcy5vcGVuU3luYyhuYW1lLCBDUkVBVEVfRkxBR1MsIG9wdHMubW9kZSB8fCBGSUxFX01PREUpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAob3B0cy5kaXNjYXJkRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgZmQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZmQ6IGZkLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID8gLTEgOiBmZCwgb3B0cywgdHJ1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfGRpckNhbGxiYWNrKX0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P2RpckNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBkaXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3RcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgLy8gZ2V0cyBhIHRlbXBvcmFyeSBmaWxlbmFtZVxuICB0bXBOYW1lKG9wdHMsIGZ1bmN0aW9uIF90bXBOYW1lQ3JlYXRlZChlcnIsIG5hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkaXJlY3RvcnlcbiAgICBmcy5ta2RpcihuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUsIGZ1bmN0aW9uIF9kaXJDcmVhdGVkKGVycikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBjYihudWxsLCBuYW1lLCBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMsIGZhbHNlKSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZGlyLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0RpclN5bmNPYmplY3R9IG9iamVjdCBjb25zaXN0cyBvZiBuYW1lIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGNhbm5vdCBjcmVhdGUgYSBkaXJlY3RvcnlcbiAqL1xuZnVuY3Rpb24gZGlyU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXTtcblxuICBjb25zdCBuYW1lID0gdG1wTmFtZVN5bmMob3B0cyk7XG4gIGZzLm1rZGlyU3luYyhuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUpO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByZW1vdmVDYWxsYmFjazogX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCB0cnVlKVxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgYXN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZkUGF0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUZpbGVBc3luYyhmZFBhdGgsIG5leHQpIHtcbiAgY29uc3QgX2hhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiAhX2lzRU5PRU5UKGVycikpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgfVxuICAgIG5leHQoKTtcbiAgfTtcblxuICBpZiAoMCA8PSBmZFBhdGhbMF0pXG4gICAgZnMuY2xvc2UoZmRQYXRoWzBdLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmcy51bmxpbmsoZmRQYXRoWzFdLCBfaGFuZGxlcik7XG4gICAgfSk7XG4gIGVsc2UgZnMudW5saW5rKGZkUGF0aFsxXSwgX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmRQYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRmlsZVN5bmMoZmRQYXRoKSB7XG4gIGxldCByZXRocm93bkV4Y2VwdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKDAgPD0gZmRQYXRoWzBdKSBmcy5jbG9zZVN5bmMoZmRQYXRoWzBdKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICBpZiAoIV9pc0VCQURGKGUpICYmICFfaXNFTk9FTlQoZSkpIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnVubGlua1N5bmMoZmRQYXRoWzFdKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIGlmICghX2lzRU5PRU5UKGUpKSByZXRocm93bkV4Y2VwdGlvbiA9IGU7XG4gICAgfVxuICB9XG4gIGlmIChyZXRocm93bkV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgIHRocm93IHJldGhyb3duRXhjZXB0aW9uO1xuICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogZmlsZVN5bmMgb3IgZmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwYXRoIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7ZmlsZUNhbGxiYWNrIHwgZmlsZUNhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIGZkLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrU3luYyA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2soX3JlbW92ZUZpbGVTeW5jLCBbZmQsIG5hbWVdLCBzeW5jKTtcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKF9yZW1vdmVGaWxlQXN5bmMsIFtmZCwgbmFtZV0sIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgaWYgKCFvcHRzLmtlZXApIF9yZW1vdmVPYmplY3RzLnVuc2hpZnQocmVtb3ZlQ2FsbGJhY2tTeW5jKTtcblxuICByZXR1cm4gc3luYyA/IHJlbW92ZUNhbGxiYWNrU3luYyA6IHJlbW92ZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBjYWxsYmFjayBmb3IgcmVtb3ZhbCBvZiB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogdG1wRmlsZVN5bmMgb3IgdG1wRmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uID0gb3B0cy51bnNhZmVDbGVhbnVwID8gcmltcmFmIDogZnMucm1kaXIuYmluZChmcyk7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uU3luYyA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IEZOX1JJTVJBRl9TWU5DIDogRk5fUk1ESVJfU1lOQztcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2tTeW5jID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvblN5bmMsIG5hbWUsIHN5bmMpO1xuICBjb25zdCByZW1vdmVDYWxsYmFjayA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIG5hbWUsIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG4gIGlmICghb3B0cy5rZWVwKSBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgcmV0dXJuIHN5bmMgPyByZW1vdmVDYWxsYmFja1N5bmMgOiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ3VhcmRlZCBmdW5jdGlvbiB3cmFwcGluZyB0aGUgcmVtb3ZlRnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBUaGUgY2xlYW51cCBjYWxsYmFjayBpcyBzYXZlIHRvIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIFN1YnNlcXVlbnQgaW52b2NhdGlvbnMgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbW92ZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU9yRGlyTmFtZVxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmM/fSBjbGVhbnVwQ2FsbGJhY2tTeW5jXG4gKiBAcmV0dXJucyB7Y2xlYW51cENhbGxiYWNrIHwgY2xlYW51cENhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIGZpbGVPckRpck5hbWUsIHN5bmMsIGNsZWFudXBDYWxsYmFja1N5bmMpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGlmIHN5bmMgaXMgdHJ1ZSwgdGhlIG5leHQgcGFyYW1ldGVyIHdpbGwgYmUgaWdub3JlZFxuICByZXR1cm4gZnVuY3Rpb24gX2NsZWFudXBDYWxsYmFjayhuZXh0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAvLyByZW1vdmUgY2xlYW51cENhbGxiYWNrIGZyb20gY2FjaGVcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gY2xlYW51cENhbGxiYWNrU3luYyB8fCBfY2xlYW51cENhbGxiYWNrO1xuICAgICAgY29uc3QgaW5kZXggPSBfcmVtb3ZlT2JqZWN0cy5pbmRleE9mKHRvUmVtb3ZlKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoaW5kZXggPj0gMCkgX3JlbW92ZU9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzeW5jIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9STURJUl9TWU5DIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9SSU1SQUZfU1lOQykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSwgbmV4dCB8fCBmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nYXJiYWdlQ29sbGVjdG9yKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9ncmFjZWZ1bENsZWFudXApIHJldHVybjtcblxuICAvLyB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIHJlbW92ZXMgaXRzZWxmIGZyb20gX3JlbW92ZU9iamVjdHMsXG4gIC8vIGxvb3AgdW50aWwgX3JlbW92ZU9iamVjdHMgaXMgZW1wdHlcbiAgd2hpbGUgKF9yZW1vdmVPYmplY3RzLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBfcmVtb3ZlT2JqZWN0c1swXSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVtb3ZlZD9cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSYW5kb20gbmFtZSBnZW5lcmF0b3IgYmFzZWQgb24gY3J5cHRvLlxuICogQWRhcHRlZCBmcm9tIGh0dHA6Ly9ibG9nLnRvbXBhd2xhay5vcmcvaG93LXRvLWdlbmVyYXRlLXJhbmRvbS12YWx1ZXMtbm9kZWpzLWphdmFzY3JpcHRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaG93TWFueVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JhbmRvbUNoYXJzKGhvd01hbnkpIHtcbiAgbGV0XG4gICAgdmFsdWUgPSBbXSxcbiAgICBybmQgPSBudWxsO1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGRvIG5vdCBmYWlsIGJlY2F1c2Ugd2UgcmFuIG91dCBvZiBlbnRyb3B5XG4gIHRyeSB7XG4gICAgcm5kID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcm5kID0gY3J5cHRvLnBzZXVkb1JhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHtcbiAgICB2YWx1ZS5wdXNoKFJBTkRPTV9DSEFSU1tybmRbaV0gJSBSQU5ET01fQ0hBUlMubGVuZ3RoXSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUuam9pbignJyk7XG59XG5cbi8qKlxuICogSGVscGVyIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBzIGlzIGJsYW5rLCB0aGF0IGlzIHVuZGVmaW5lZCwgb3IgZW1wdHkgb3IgbnVsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIHdoZXRoZXIgdGhlIHN0cmluZyBzIGlzIGJsYW5rLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gX2lzQmxhbmsocykge1xuICByZXR1cm4gcyA9PT0gbnVsbCB8fCBfaXNVbmRlZmluZWQocykgfHwgIXMudHJpbSgpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBgb2JqYCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyB1bmRlZmluZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZnVuY3Rpb24gYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGVscHMgdG8gaGF2ZSBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xudWxsfHVuZGVmaW5lZHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fSBwYXJzZWQgYXJndW1lbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFt7fSwgb3B0aW9uc107XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX2lzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFt7fSwgY2FsbGJhY2tdO1xuICB9XG5cbiAgLy8gY29weSBvcHRpb25zIHNvIHdlIGRvIG5vdCBsZWFrIHRoZSBjaGFuZ2VzIHdlIG1ha2UgaW50ZXJuYWxseVxuICBjb25zdCBhY3R1YWxPcHRpb25zID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMpKSB7XG4gICAgYWN0dWFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIFthY3R1YWxPcHRpb25zLCBjYWxsYmFja107XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IHRlbXBvcmFyeSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbmV3IHJhbmRvbSBuYW1lIGFjY29yZGluZyB0byBvcHRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpIHtcblxuICBjb25zdCB0bXBEaXIgPSBvcHRzLnRtcGRpcjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLm5hbWUpKVxuICAgIHJldHVybiBwYXRoLmpvaW4odG1wRGlyLCBvcHRzLmRpciwgb3B0cy5uYW1lKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLnRlbXBsYXRlKSlcbiAgICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgb3B0cy5kaXIsIG9wdHMudGVtcGxhdGUpLnJlcGxhY2UoVEVNUExBVEVfUEFUVEVSTiwgX3JhbmRvbUNoYXJzKDYpKTtcblxuICAvLyBwcmVmaXggYW5kIHBvc3RmaXhcbiAgY29uc3QgbmFtZSA9IFtcbiAgICBvcHRzLnByZWZpeCA/IG9wdHMucHJlZml4IDogJ3RtcCcsXG4gICAgJy0nLFxuICAgIHByb2Nlc3MucGlkLFxuICAgICctJyxcbiAgICBfcmFuZG9tQ2hhcnMoMTIpLFxuICAgIG9wdHMucG9zdGZpeCA/ICctJyArIG9wdHMucG9zdGZpeCA6ICcnXG4gIF0uam9pbignJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbih0bXBEaXIsIG9wdHMuZGlyLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBvcHRpb25zIGFyZSB2YWxpZCwgYWxzbyBzYW5pdGl6ZXMgb3B0aW9ucyBhbmQgcHJvdmlkZXMgc2FuZSBkZWZhdWx0cyBmb3IgbWlzc2luZ1xuICogb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMob3B0aW9ucykge1xuXG4gIG9wdGlvbnMudG1wZGlyID0gX2dldFRtcERpcihvcHRpb25zKTtcblxuICBjb25zdCB0bXBEaXIgPSBvcHRpb25zLnRtcGRpcjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpKVxuICAgIF9hc3NlcnRJc1JlbGF0aXZlKG9wdGlvbnMubmFtZSwgJ25hbWUnLCB0bXBEaXIpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLmRpcikpXG4gICAgX2Fzc2VydElzUmVsYXRpdmUob3B0aW9ucy5kaXIsICdkaXInLCB0bXBEaXIpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRlbXBsYXRlKSkge1xuICAgIF9hc3NlcnRJc1JlbGF0aXZlKG9wdGlvbnMudGVtcGxhdGUsICd0ZW1wbGF0ZScsIHRtcERpcik7XG4gICAgaWYgKCFvcHRpb25zLnRlbXBsYXRlLm1hdGNoKFRFTVBMQVRFX1BBVFRFUk4pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlLCBmb3VuZCBcIiR7b3B0aW9ucy50ZW1wbGF0ZX1cIi5gKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRyaWVzKSAmJiBpc05hTihvcHRpb25zLnRyaWVzKSB8fCBvcHRpb25zLnRyaWVzIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJpZXMsIGZvdW5kIFwiJHtvcHRpb25zLnRyaWVzfVwiLmApO1xuXG4gIC8vIGlmIGEgbmFtZSB3YXMgc3BlY2lmaWVkIHdlIHdpbGwgdHJ5IG9uY2VcbiAgb3B0aW9ucy50cmllcyA9IF9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gb3B0aW9ucy50cmllcyB8fCBERUZBVUxUX1RSSUVTIDogMTtcbiAgb3B0aW9ucy5rZWVwID0gISFvcHRpb25zLmtlZXA7XG4gIG9wdGlvbnMuZGV0YWNoRGVzY3JpcHRvciA9ICEhb3B0aW9ucy5kZXRhY2hEZXNjcmlwdG9yO1xuICBvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yID0gISFvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yO1xuICBvcHRpb25zLnVuc2FmZUNsZWFudXAgPSAhIW9wdGlvbnMudW5zYWZlQ2xlYW51cDtcblxuICAvLyBzYW5pdGl6ZSBkaXIsIGFsc28ga2VlcCAobXVsdGlwbGUpIGJsYW5rcyBpZiB0aGUgdXNlciwgcHVycG9ydGVkbHkgc2FuZSwgcmVxdWVzdHMgdXMgdG9cbiAgb3B0aW9ucy5kaXIgPSBfaXNVbmRlZmluZWQob3B0aW9ucy5kaXIpID8gJycgOiBwYXRoLnJlbGF0aXZlKHRtcERpciwgX3Jlc29sdmVQYXRoKG9wdGlvbnMuZGlyLCB0bXBEaXIpKTtcbiAgb3B0aW9ucy50ZW1wbGF0ZSA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnRlbXBsYXRlKSA/IHVuZGVmaW5lZCA6IHBhdGgucmVsYXRpdmUodG1wRGlyLCBfcmVzb2x2ZVBhdGgob3B0aW9ucy50ZW1wbGF0ZSwgdG1wRGlyKSk7XG4gIC8vIHNhbml0aXplIGZ1cnRoZXIgaWYgdGVtcGxhdGUgaXMgcmVsYXRpdmUgdG8gb3B0aW9ucy5kaXJcbiAgb3B0aW9ucy50ZW1wbGF0ZSA9IF9pc0JsYW5rKG9wdGlvbnMudGVtcGxhdGUpID8gdW5kZWZpbmVkIDogcGF0aC5yZWxhdGl2ZShvcHRpb25zLmRpciwgb3B0aW9ucy50ZW1wbGF0ZSk7XG5cbiAgLy8gZm9yIGNvbXBsZXRlbmVzcycgc2FrZSBvbmx5LCBhbHNvIGtlZXAgKG11bHRpcGxlKSBibGFua3MgaWYgdGhlIHVzZXIsIHB1cnBvcnRlZGx5IHNhbmUsIHJlcXVlc3RzIHVzIHRvXG4gIG9wdGlvbnMubmFtZSA9IF9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gdW5kZWZpbmVkIDogX3Nhbml0aXplTmFtZShvcHRpb25zLm5hbWUpO1xuICBvcHRpb25zLnByZWZpeCA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnByZWZpeCkgPyAnJyA6IG9wdGlvbnMucHJlZml4O1xuICBvcHRpb25zLnBvc3RmaXggPSBfaXNVbmRlZmluZWQob3B0aW9ucy5wb3N0Zml4KSA/ICcnIDogb3B0aW9ucy5wb3N0Zml4O1xufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHNwZWNpZmllZCBwYXRoIG5hbWUgaW4gcmVzcGVjdCB0byB0bXBEaXIuXG4gKlxuICogVGhlIHNwZWNpZmllZCBuYW1lIG1pZ2h0IGluY2x1ZGUgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzLCBlLmcuIC4uL1xuICogc28gd2UgbmVlZCB0byByZXNvbHZlIGluIG9yZGVyIHRvIGJlIHN1cmUgdGhhdCBpcyBpcyBsb2NhdGVkIGluc2lkZSB0bXBEaXJcbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHBhcmFtIHRtcERpclxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlUGF0aChuYW1lLCB0bXBEaXIpIHtcbiAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IF9zYW5pdGl6ZU5hbWUobmFtZSk7XG4gIGlmIChzYW5pdGl6ZWROYW1lLnN0YXJ0c1dpdGgodG1wRGlyKSkge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUoc2FuaXRpemVkTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShwYXRoLmpvaW4odG1wRGlyLCBzYW5pdGl6ZWROYW1lKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgc3BlY2lmaWVkIHBhdGggbmFtZSBieSByZW1vdmluZyBhbGwgcXVvdGUgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9zYW5pdGl6ZU5hbWUobmFtZSkge1xuICBpZiAoX2lzQmxhbmsobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bXCInXS9nLCAnJyk7XG59XG5cbi8qKlxuICogQXNzZXJ0cyB3aGV0aGVyIHNwZWNpZmllZCBuYW1lIGlzIHJlbGF0aXZlIHRvIHRoZSBzcGVjaWZpZWQgdG1wRGlyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdG1wRGlyXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRJc1JlbGF0aXZlKG5hbWUsIG9wdGlvbiwgdG1wRGlyKSB7XG4gIGlmIChvcHRpb24gPT09ICduYW1lJykge1xuICAgIC8vIGFzc2VydCB0aGF0IG5hbWUgaXMgbm90IGFic29sdXRlIGFuZCBkb2VzIG5vdCBjb250YWluIGEgcGF0aFxuICAgIGlmIChwYXRoLmlzQWJzb2x1dGUobmFtZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ufSBvcHRpb24gbXVzdCBub3QgY29udGFpbiBhbiBhYnNvbHV0ZSBwYXRoLCBmb3VuZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAvLyBtdXN0IG5vdCBmYWlsIG9uIHZhbGlkIC48bmFtZT4gb3IgLi48bmFtZT4gb3Igc2ltaWxhciBzdWNoIGNvbnN0cnVjdHNcbiAgICBsZXQgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG5hbWUpO1xuICAgIGlmIChiYXNlbmFtZSA9PT0gJy4uJyB8fCBiYXNlbmFtZSA9PT0gJy4nIHx8IGJhc2VuYW1lICE9PSBuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3Qgbm90IGNvbnRhaW4gYSBwYXRoLCBmb3VuZCBcIiR7bmFtZX1cIi5gKTtcbiAgfVxuICBlbHNlIHsgLy8gaWYgKG9wdGlvbiA9PT0gJ2RpcicgfHwgb3B0aW9uID09PSAndGVtcGxhdGUnKSB7XG4gICAgLy8gYXNzZXJ0IHRoYXQgZGlyIG9yIHRlbXBsYXRlIGFyZSByZWxhdGl2ZSB0byB0bXBEaXJcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKG5hbWUpICYmICFuYW1lLnN0YXJ0c1dpdGgodG1wRGlyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3QgYmUgcmVsYXRpdmUgdG8gXCIke3RtcERpcn1cIiwgZm91bmQgXCIke25hbWV9XCIuYCk7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZFBhdGggPSBfcmVzb2x2ZVBhdGgobmFtZSwgdG1wRGlyKTtcbiAgICBpZiAoIXJlc29sdmVkUGF0aC5zdGFydHNXaXRoKHRtcERpcikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ufSBvcHRpb24gbXVzdCBiZSByZWxhdGl2ZSB0byBcIiR7dG1wRGlyfVwiLCBmb3VuZCBcIiR7cmVzb2x2ZWRQYXRofVwiLmApO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZvciB0ZXN0aW5nIGFnYWluc3QgRUJBREYgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNFQkFERihlcnJvcikge1xuICByZXR1cm4gX2lzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVCQURGLCAnRUJBREYnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRlc3RpbmcgYWdhaW5zdCBFTk9FTlQgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNFTk9FTlQoZXJyb3IpIHtcbiAgcmV0dXJuIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIC1FTk9FTlQsICdFTk9FTlQnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGV4cGVjdGVkIGVycm9yIGNvZGUgbWF0Y2hlcyB0aGUgYWN0dWFsIGNvZGUgYW5kIGVycm5vLFxuICogd2hpY2ggd2lsbCBkaWZmZXIgYmV0d2VlbiB0aGUgc3VwcG9ydGVkIG5vZGUgdmVyc2lvbnMuXG4gKlxuICogLSBOb2RlID49IDcuMDpcbiAqICAgZXJyb3IuY29kZSB7c3RyaW5nfVxuICogICBlcnJvci5lcnJubyB7bnVtYmVyfSBhbnkgbnVtZXJpY2FsIHZhbHVlIHdpbGwgYmUgbmVnYXRlZFxuICpcbiAqIENBVkVBVFxuICpcbiAqIE9uIHdpbmRvd3MsIHRoZSBlcnJubyBmb3IgRUJBREYgaXMgLTQwODMgYnV0IG9zLmNvbnN0YW50cy5lcnJuby5FQkFERiBpcyBkaWZmZXJlbnQgYW5kIHdlIG11c3QgYXNzdW1lIHRoYXQgRU5PRU5UXG4gKiBpcyBubyBkaWZmZXJlbnQgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge1N5c3RlbUVycm9yfSBlcnJvclxuICogQHBhcmFtIHtudW1iZXJ9IGVycm5vXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRXhwZWN0ZWRFcnJvcihlcnJvciwgZXJybm8sIGNvZGUpIHtcbiAgcmV0dXJuIElTX1dJTjMyID8gZXJyb3IuY29kZSA9PT0gY29kZSA6IGVycm9yLmNvZGUgPT09IGNvZGUgJiYgZXJyb3IuZXJybm8gPT09IGVycm5vO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGdyYWNlZnVsIGNsZWFudXAuXG4gKlxuICogSWYgZ3JhY2VmdWwgY2xlYW51cCBpcyBzZXQsIHRtcCB3aWxsIHJlbW92ZSBhbGwgY29udHJvbGxlZCB0ZW1wb3Jhcnkgb2JqZWN0cyBvbiBwcm9jZXNzIGV4aXQsIG90aGVyd2lzZSB0aGVcbiAqIHRlbXBvcmFyeSBvYmplY3RzIHdpbGwgcmVtYWluIGluIHBsYWNlLCB3YWl0aW5nIHRvIGJlIGNsZWFuZWQgdXAgb24gc3lzdGVtIHJlc3RhcnQgb3Igb3RoZXJ3aXNlIHNjaGVkdWxlZCB0ZW1wb3JhcnlcbiAqIG9iamVjdCByZW1vdmFscy5cbiAqL1xuZnVuY3Rpb24gc2V0R3JhY2VmdWxDbGVhbnVwKCkge1xuICBfZ3JhY2VmdWxDbGVhbnVwID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCB0bXAgZGlyIGZyb20gb3MudG1wZGlyKCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7P09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCB0bXAgZGlyXG4gKi9cbmZ1bmN0aW9uIF9nZXRUbXBEaXIob3B0aW9ucykge1xuICByZXR1cm4gcGF0aC5yZXNvbHZlKF9zYW5pdGl6ZU5hbWUob3B0aW9ucyAmJiBvcHRpb25zLnRtcGRpciB8fCBvcy50bXBkaXIoKSkpO1xufVxuXG4vLyBJbnN0YWxsIHByb2Nlc3MgZXhpdCBsaXN0ZW5lclxucHJvY2Vzcy5hZGRMaXN0ZW5lcihFWElULCBfZ2FyYmFnZUNvbGxlY3Rvcik7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGtlZXAgdGhlIHRlbXBvcmFyeSBvYmplY3QgKGZpbGUgb3IgZGlyKSB3aWxsIG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSB0cmllcyB0aGUgbnVtYmVyIG9mIHRyaWVzIGJlZm9yZSBnaXZlIHVwIHRoZSBuYW1lIGdlbmVyYXRpb25cbiAqIEBwcm9wZXJ0eSAoP2ludCkgbW9kZSB0aGUgYWNjZXNzIG1vZGUsIGRlZmF1bHRzIGFyZSAwbzcwMCBmb3IgZGlyZWN0b3JpZXMgYW5kIDBvNjAwIGZvciBmaWxlc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSB0ZW1wbGF0ZSB0aGUgXCJta3N0ZW1wXCIgbGlrZSBmaWxlbmFtZSB0ZW1wbGF0ZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBuYW1lIGZpeGVkIG5hbWUgcmVsYXRpdmUgdG8gdG1wZGlyIG9yIHRoZSBzcGVjaWZpZWQgZGlyIG9wdGlvblxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBkaXIgdG1wIGRpcmVjdG9yeSByZWxhdGl2ZSB0byB0aGUgcm9vdCB0bXAgZGlyZWN0b3J5IGluIHVzZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwcmVmaXggcHJlZml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcG9zdGZpeCBwb3N0Zml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdG1wZGlyIHRoZSByb290IHRtcCBkaXJlY3Rvcnkgd2hpY2ggb3ZlcnJpZGVzIHRoZSBvcyB0bXBkaXJcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHVuc2FmZUNsZWFudXAgcmVjdXJzaXZlbHkgcmVtb3ZlcyB0aGUgY3JlYXRlZCB0ZW1wb3JhcnkgZGlyZWN0b3J5LCBldmVuIHdoZW4gaXQncyBub3QgZW1wdHlcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRldGFjaERlc2NyaXB0b3IgZGV0YWNoZXMgdGhlIGZpbGUgZGVzY3JpcHRvciwgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBjbG9zaW5nIHRoZSBmaWxlLCB0bXAgd2lsbCBubyBsb25nZXIgdHJ5IGNsb3NpbmcgdGhlIGZpbGUgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvblxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZGlzY2FyZERlc2NyaXB0b3IgZGlzY2FyZHMgdGhlIGZpbGUgZGVzY3JpcHRvciAoY2xvc2VzIGZpbGUsIGZkIGlzIC0xKSwgdG1wIHdpbGwgbm8gbG9uZ2VyIHRyeSBjbG9zaW5nIHRoZSBmaWxlIGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGVTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3IgLTEgaWYgdGhlIGZkIGhhcyBiZWVuIGRpc2NhcmRlZFxuICogQHByb3BlcnR5IHtmaWxlQ2FsbGJhY2t9IHJlbW92ZUNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZW1vdmUgdGhlIGZpbGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERpclN5bmNPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnlcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBkaXJlY3RvcnlcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayB0bXBOYW1lQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbGVDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgdGhlIGZpbGUgZGVzY3JpcHRvciBvciAtMSBpZiB0aGUgZmQgaGFkIGJlZW4gZGlzY2FyZGVkXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tTeW5jXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yIG9yIC0xIGlmIHRoZSBmZCBoYWQgYmVlbiBkaXNjYXJkZWRcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrU3luY30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBkaXJDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBkaXJDYWxsYmFja1N5bmNcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2tTeW5jfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1xuICogQHBhcmFtIHtzaW1wbGVDYWxsYmFja30gW25leHRdIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbmV2ZXIgdGhlIHRtcCBvYmplY3QgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1N5bmNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBjb21wb3NpdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9yYXN6aS9ub2RlLXRtcC9pc3N1ZXMvNTd8cmFzemkvbm9kZS10bXAjNTd9XG4gKlxuICogQGNhbGxiYWNrIHNpbXBsZUNhbGxiYWNrXG4gKi9cblxuLy8gZXhwb3J0aW5nIGFsbCB0aGUgbmVlZGVkIG1ldGhvZHNcblxuLy8gZXZhbHVhdGUgX2dldFRtcERpcigpIGxhemlseSwgbWFpbmx5IGZvciBzaW1wbGlmeWluZyB0ZXN0aW5nIGJ1dCBpdCBhbHNvIHdpbGxcbi8vIGFsbG93IHVzZXJzIHRvIHJlY29uZmlndXJlIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICd0bXBkaXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0VG1wRGlyKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5kaXIgPSBkaXI7XG5tb2R1bGUuZXhwb3J0cy5kaXJTeW5jID0gZGlyU3luYztcblxubW9kdWxlLmV4cG9ydHMuZmlsZSA9IGZpbGU7XG5tb2R1bGUuZXhwb3J0cy5maWxlU3luYyA9IGZpbGVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lID0gdG1wTmFtZTtcbm1vZHVsZS5leHBvcnRzLnRtcE5hbWVTeW5jID0gdG1wTmFtZVN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLnNldEdyYWNlZnVsQ2xlYW51cCA9IHNldEdyYWNlZnVsQ2xlYW51cDtcbiIsIlxuLyoqXG4gKiBGb3IgTm9kZS5qcywgc2ltcGx5IHJlLWV4cG9ydCB0aGUgY29yZSBgdXRpbC5kZXByZWNhdGVgIGZ1bmN0aW9uLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgndXRpbCcpLmRlcHJlY2F0ZTtcbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFzc2VydFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJidWZmZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlY3Ryb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6ZXZlbnRzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm9zXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IGNvbnRleHRCcmlkZ2UsIGlwY1JlbmRlcmVyLCBJcGNSZW5kZXJlckV2ZW50IH0gZnJvbSAnZWxlY3Ryb24nO1xyXG5pbXBvcnQgeyBCcm93c2VyLCBCdWlsZGVyLCBCeSwgdW50aWwsIEtleSB9IGZyb20gJ3NlbGVuaXVtLXdlYmRyaXZlcic7XHJcbmltcG9ydCBmcyBmcm9tICdmcydcclxuXHJcbmV4cG9ydCB0eXBlIENoYW5uZWxzID0gJ2lwYy1leGFtcGxlJztcclxuXHJcbmludGVyZmFjZSBDb250YWN0IHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgcGhvbmU6IHN0cmluZztcclxuICB2YXIxOiBzdHJpbmc7XHJcbiAgdmFyMjogc3RyaW5nO1xyXG4gIHZhcjM6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIFRpbWVyQ29uZmlndXJhdGlvbiB7XHJcbiAgc3RhcnQ6IG51bWJlcixcclxuICBpbml0aWF0ZV9zZW5kOiBudW1iZXIsXHJcbiAgY2hlY2tfZXJyb3I6IG51bWJlcixcclxuICBzZW5kX21lc3NhZ2U6IG51bWJlcixcclxuICBzZW5kX2F0dGFjaG1lbnQ6IG51bWJlcixcclxuICBmaW5hbGl6ZV9zZW5kOiBudW1iZXIsXHJcbiAgbmV3X3doYXRzYXBwX3NlbmRfYnV0dG9uOiBib29sZWFuLFxyXG59XHJcblxyXG5pbnRlcmZhY2UgRXh0cmFjdGlvbk9iamVjdCB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgcGhvbmU6IHN0cmluZztcclxufVxyXG5cclxuY29uc3QgbG9nID0gKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgaXBjUmVuZGVyZXIuc2VuZCgnaXBjLWV4YW1wbGUnLCBbbWVzc2FnZV0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlbGF5KHRpbWU6IG51bWJlcikge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKTtcclxuICB9KTtcclxufVxyXG5cclxubGV0IEdsb2JhbERyaXZlcjogYW55O1xyXG5cclxuY29udGV4dEJyaWRnZS5leHBvc2VJbk1haW5Xb3JsZCgnZWxlY3Ryb24nLCB7XHJcbiAgY2hlY2tGaWxlUGF0aDogKHBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgcmV0dXJuIGZzLmV4aXN0c1N5bmMocGF0aClcclxuICB9LFxyXG4gIGV4dHJhY3RDb250YWN0czogYXN5bmMgKGdyb3VwX25hbWU6IHN0cmluZywgY29uZmlnOiBUaW1lckNvbmZpZ3VyYXRpb24pID0+IHtcclxuICAgIGxldCBjb250YWN0c19leHRyYWN0ZWQ6IEV4dHJhY3Rpb25PYmplY3RbXSA9IFtdXHJcblxyXG4gICAgbG9nKFwiSW5pY2lhbmRvIGluc3RhbmNpYSBkbyBuYXZlZ2Fkb3JcIilcclxuICAgIGNvbnN0IGluaXRpYXRlZF9hdCA9IERhdGUubm93KClcclxuICAgIGxldCBkcml2ZXIgPSBhd2FpdCBuZXcgQnVpbGRlcigpLmZvckJyb3dzZXIoQnJvd3Nlci5DSFJPTUUpLmJ1aWxkKCk7XHJcblxyXG4gICAgbG9nKFwiQWJyaW5kbyBMb2dpbiBXaGF0c2FwcFwiKVxyXG4gICAgYXdhaXQgZHJpdmVyLmdldChgaHR0cHM6Ly93ZWIud2hhdHNhcHAuY29tL2ApXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgbG9nKFwiQWd1YXJkYW5kbyBWYWxpZGFyIGEgcMOhZ2luYSBkZSBpbmljaW9cIilcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKFwiaDFbZGF0YS10ZXN0aWQ9J2ludHJvLXRpdGxlJ11cIikpKTtcclxuXHJcbiAgICAgIGxvZyhcIkF1dGVudGljYWRvXCIpXHJcbiAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5zdGFydCk7XHJcblxyXG4gICAgICBsb2coXCJQcm9jdXJhbmRvIGdydXBvXCIpXHJcbiAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgZHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKGBzcGFuW3RpdGxlPScke2dyb3VwX25hbWV9J11gKSkpO1xyXG5cclxuICAgICAgbG9nKFwiQWJyaW5kbyBvIGdydXBvXCIpXHJcbiAgICAgIGdyb3VwLmNsaWNrKClcclxuXHJcbiAgICAgIGxvZyhcIkNsaWNhbmRvIGVtIGluZm9ybWHDp8O1ZXNcIilcclxuICAgICAgY29uc3QgZ3JvdXBJbmZvVGl0bGUgPSBhd2FpdCBkcml2ZXIud2FpdCh1bnRpbC5lbGVtZW50TG9jYXRlZChCeS5jc3MoXCJzcGFuW2RhdGEtdGVzdGlkPSdjb252ZXJzYXRpb24taW5mby1oZWFkZXItY2hhdC10aXRsZSddXCIpKSk7XHJcbiAgICAgIGdyb3VwSW5mb1RpdGxlLmNsaWNrKCk7XHJcblxyXG5cclxuICAgICAgbG9nKFwiT2J0ZW5kbyB0b3RhbCBkZSBwYXJ0aWNpcGFudGVzXCIpXHJcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IGF3YWl0IGRyaXZlci53YWl0KHVudGlsLmVsZW1lbnRMb2NhdGVkKEJ5LmNzcyhcImRpdltkYXRhLXRlc3RpZD0nc2VjdGlvbi1wYXJ0aWNpcGFudHMnXSBzcGFuW2NsYXNzPSd4MmRzRCBfMWxGN3QgYnplMzB5NjUgYTR5d2FrZm8nXVwiKSkpO1xyXG4gICAgICBjb25zdCBwcSA9IGF3YWl0IHBhcnRpY2lwYW50cy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxyXG4gICAgICBjb25zb2xlLmxvZyhcInBhcnRpY2lwYW50c1wiLCBwYXJ0aWNpcGFudHMpXHJcbiAgICAgIGxvZyhgQXF1aSBlc3TDoSBvIHRvdGFsIGRlIHBhcnRpY2lwYW50ZXMgJHtwcX1gKVxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgcmV0dXJuIGNvbnRhY3RzX2V4dHJhY3RlZFxyXG4gIH0sXHJcbiAgY3JlYXRlR2xvYmFsSW5zdGFuY2VPZkRyaXZlcjogYXN5bmMgKCkgPT4ge1xyXG4gICAgR2xvYmFsRHJpdmVyID0gbmV3IEJ1aWxkZXIoKS5mb3JCcm93c2VyKEJyb3dzZXIuQ0hST01FKS5idWlsZCgpO1xyXG4gIH0sXHJcbiAgbG9naW5XaGF0c2FwcDogYXN5bmMgKGNvbmZpZzogVGltZXJDb25maWd1cmF0aW9uKSA9PiB7XHJcbiAgICBsb2coXCJBYnJpbmRvIExvZ2luIFdoYXRzYXBwXCIpXHJcbiAgICBhd2FpdCBHbG9iYWxEcml2ZXIuZ2V0KGBodHRwczovL3dlYi53aGF0c2FwcC5jb20vYClcclxuXHJcbiAgICBsb2coXCJBZ3VhcmRhbmRvIFZhbGlkYXIgYSBww6FnaW5hIGRlIGluaWNpb1wiKVxyXG4gICAgYXdhaXQgR2xvYmFsRHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKFwiaDFbZGF0YS10ZXN0aWQ9J2ludHJvLXRpdGxlJ11cIikpKTtcclxuICAgIGxvZyhcIkF1dGVudGljYWRvXCIpXHJcbiAgICBhd2FpdCBkZWxheShjb25maWcuc3RhcnQpO1xyXG4gIH0sXHJcbiAgY2xvc2VHbG9iYWxJbnN0YW5jZU9mRHJpdmVyOiBhc3luYyAoKSA9PiB7XHJcbiAgICBhd2FpdCBHbG9iYWxEcml2ZXIucXVpdCgpO1xyXG4gIH0sXHJcbiAgc2VuZE1lc3NhZ2U6IGFzeW5jIChjb250YWN0OiBDb250YWN0LCBtZXNzYWdlOiBzdHJpbmcsIGF0dGFjaG1lbnRzOiBhbnlbXSwgY29uZmlnOiBUaW1lckNvbmZpZ3VyYXRpb24pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCBmaW5hbE1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2VBbGwoXCJ7cHJpbWVpcm9Ob21lfVwiLCBjb250YWN0Lm5hbWUuc3BsaXQoXCIgXCIpWzBdKVxyXG4gICAgICAgIC5yZXBsYWNlQWxsKFwie25vbWVDb21wbGV0b31cIiwgY29udGFjdC5uYW1lKVxyXG4gICAgICAgIC5yZXBsYWNlQWxsKFwie3RlbGVmb25lfVwiLCBjb250YWN0LnBob25lKVxyXG4gICAgICAgIC5yZXBsYWNlQWxsKFwie3ZhcjF9XCIsIGNvbnRhY3QudmFyMSlcclxuICAgICAgICAucmVwbGFjZUFsbChcInt2YXIyfVwiLCBjb250YWN0LnZhcjIpXHJcbiAgICAgICAgLnJlcGxhY2VBbGwoXCJ7dmFyM31cIiwgY29udGFjdC52YXIzKVxyXG5cclxuICAgICAgYXdhaXQgR2xvYmFsRHJpdmVyLmdldChgaHR0cHM6Ly93ZWIud2hhdHNhcHAuY29tL3NlbmQvP3Bob25lPSUyQjU1JHtjb250YWN0LnBob25lLnJlcGxhY2UoL1xcRC9nLCBcIlwiKX0mdGV4dD0ke2VuY29kZVVSSShmaW5hbE1lc3NhZ2UpLnJlcGxhY2UoLyYvZywgXCIlMjZcIikucmVwbGFjZSgvXFwrL2csIFwiJTJCXCIpfSZhbXA7dGV4dCZhbXA7dHlwZT1waG9uZV9udW1iZXImYW1wO2FwcF9hYnNlbnQ9MGApXHJcblxyXG4gICAgICBhd2FpdCBkZWxheShjb25maWcuaW5pdGlhdGVfc2VuZCk7XHJcbiAgICAgIGxvZyhcIlZlcmlmaWNhbmRvIHNlIHRlbSBtZW5zYWdlbSBkZSBlcnJvXCIpXHJcbiAgICAgIGF3YWl0IEdsb2JhbERyaXZlci53YWl0KHVudGlsLmVsZW1lbnRMb2NhdGVkKEJ5LmNzcyhcImRpdltkYXRhLXRlc3RpZD0nY29uZmlybS1wb3B1cCddXCIpKSwgMTAwMDApO1xyXG4gICAgICBhd2FpdCBkZWxheShjb25maWcuY2hlY2tfZXJyb3IpO1xyXG5cclxuICAgICAgY29uc3QgZWxlbWVudCA9IGF3YWl0IEdsb2JhbERyaXZlci5maW5kRWxlbWVudChCeS5jc3MoJ2RpdltkYXRhLXRlc3RpZD1cInBvcHVwLWNvbnRlbnRzXCJdJykpXHJcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBlbGVtZW50LmdldFRleHQoKVxyXG5cclxuICAgICAgbG9nKFwiSG91dmUgbWVuc2FnZW0gZGUgZXJyb1wiKVxyXG4gICAgICBsb2codGV4dClcclxuXHJcbiAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5maW5hbGl6ZV9zZW5kKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogdGV4dCxcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuXHJcbiAgICAgIGxvZyhcIlByb2N1cmFuZG8gYm90w6NvIHBhcmEgZW52aWFyIG1lbnNhZ2VtXCIpXHJcbiAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5zZW5kX21lc3NhZ2UpO1xyXG4gICAgICBjb25zdCBzZW5kQnV0dG9uID0gYXdhaXQgR2xvYmFsRHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKFwiYnV0dG9uW2RhdGEtdGVzdGlkPSdjb21wb3NlLWJ0bi1zZW5kJ11cIikpKTtcclxuICAgICAgYXdhaXQgZGVsYXkoY29uZmlnLnNlbmRfbWVzc2FnZSk7XHJcbiAgICAgIHNlbmRCdXR0b24uY2xpY2soKTtcclxuXHJcbiAgICAgIGlmIChhdHRhY2htZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbG9nKFwiRW52aWFuZG8gYXJxdWl2b3NcIikgICAgICAgXHJcbiAgXHJcbiAgICAgICAgY29uc3QgdGlwb3NJbWFnZW1TdXBvcnRhZG9zID0gWydqcGVnJywgJ2pwZycsICdwbmcnLCAnZ2lmJywgJ2JtcCcsICd0aWZmJywgJ3dlYnAnXTtcclxuICAgICAgICBjb25zdCB0aXBvc1ZpZGVvU3Vwb3J0YWRvcyA9IFsnbXA0JywgJ21vdicsICdhdmknLCAnM2dwJywgJ3dtdicsICdta3YnXTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICBpZihjb25maWcubmV3X3doYXRzYXBwX3NlbmRfYnV0dG9uKXtcclxuICAgICAgICAgICAgbG9nKFwiUHJvY3VyYW5kbyBub3ZvIGJvdMOjbyBkcm9wIHVwXCIpXHJcbiAgICAgICAgICAgIGNvbnN0IGF0dGFjaE1lbnVQbHVzID0gYXdhaXQgR2xvYmFsRHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKFwic3BhbltkYXRhLXRlc3RpZD0nYXR0YWNoLW1lbnUtcGx1cyddXCIpKSk7XHJcbiAgICAgICAgICAgIGF0dGFjaE1lbnVQbHVzLmNsaWNrKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBkZWxheShjb25maWcuc2VuZF9tZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW1hZ2VPclZpZGVvID0gdGlwb3NJbWFnZW1TdXBvcnRhZG9zLmluY2x1ZGVzKGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkpIHx8IHRpcG9zVmlkZW9TdXBvcnRhZG9zLmluY2x1ZGVzKGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkpXHJcblxyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RCdXR0b25CeVR5cGVzID0gaXNJbWFnZU9yVmlkZW8gPyBcImxpW2RhdGEtdGVzdGlkPSdtaS1hdHRhY2gtbWVkaWEnXVwiIDogXCJsaVtkYXRhLXRlc3RpZD0nbWktYXR0YWNoLWRvY3VtZW50J11cIlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbG9nKGBCT1TDg08gU0VMRUNJT05BRE86ICR7c2VsZWN0QnV0dG9uQnlUeXBlc30sIMOpIGltYWdlbSBvdSB2aWRlbz8gJHtmaWxlLmlzSW1hZ2VPclZpZGVvfWApXHJcbiAgICAgICAgICAgIGxvZyhcIlByb2N1cmFuZG8gYm90w6NvIGRlIGFuZXhhciBvIHRpcG9cIilcclxuICAgICAgICAgICAgY29uc3QgYXR0YWNoQnV0dG9uID0gYXdhaXQgR2xvYmFsRHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKHNlbGVjdEJ1dHRvbkJ5VHlwZXMpKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsb2coXCJJbnNlcmluZG8gYW5leG9cIilcclxuICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtZW50ID0gYXdhaXQgYXR0YWNoQnV0dG9uLmZpbmRFbGVtZW50KEJ5LmNzcyhgaW5wdXRgKSlcclxuICAgICAgICAgICAgaW5wdXRFbGVtZW50LnNlbmRLZXlzKGZpbGUucGF0aCkgXHJcbiAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgbG9nKFwiUHJvY3VyYW5kbyBib3TDo28gY2xpcFwiKVxyXG4gICAgICAgICAgICBjb25zdCBjbGlwQnV0dG9uID0gYXdhaXQgR2xvYmFsRHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKFwiZGl2W2RhdGEtdGVzdGlkPSdjb252ZXJzYXRpb24tY2xpcCddXCIpKSk7XHJcbiAgICAgICAgICAgIGNsaXBCdXR0b24uY2xpY2soKTtcclxuICBcclxuICAgICAgICAgICAgYXdhaXQgZGVsYXkoY29uZmlnLnNlbmRfbWVzc2FnZSk7XHJcbiAgXHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW1hZ2VPclZpZGVvID0gdGlwb3NJbWFnZW1TdXBvcnRhZG9zLmluY2x1ZGVzKGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkpIHx8IHRpcG9zVmlkZW9TdXBvcnRhZG9zLmluY2x1ZGVzKGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE8gQVFVSVwiLCBpc0ltYWdlT3JWaWRlbywgZmlsZSlcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0QnV0dG9uQnlUeXBlcyA9IGlzSW1hZ2VPclZpZGVvID8gXCJidXR0b25bYXJpYS1sYWJlbD0nRm90b3MgZSB2w61kZW9zJ11cIiA6IFwiYnV0dG9uW2FyaWEtbGFiZWw9J0RvY3VtZW50byddXCJcclxuICBcclxuICAgICAgICAgICAgbG9nKGBCT1TDg08gU0VMRUNJT05BRE86ICR7c2VsZWN0QnV0dG9uQnlUeXBlc30sIMOpIGltYWdlbSBvdSB2aWRlbz8gJHtmaWxlLmlzSW1hZ2VPclZpZGVvfWApXHJcbiAgICAgICAgICAgIGxvZyhcIlByb2N1cmFuZG8gYm90w6NvIGRlIGFuZXhhciBvIHRpcG9cIilcclxuICAgICAgICAgICAgY29uc3QgYXR0YWNoQnV0dG9uID0gYXdhaXQgR2xvYmFsRHJpdmVyLndhaXQodW50aWwuZWxlbWVudExvY2F0ZWQoQnkuY3NzKHNlbGVjdEJ1dHRvbkJ5VHlwZXMpKSk7XHJcbiAgICAgICAgICAgIGxvZyhcIkluc2VyaW5kbyBhbmV4b1wiKVxyXG4gICAgICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBhd2FpdCBhdHRhY2hCdXR0b24uZmluZEVsZW1lbnQoQnkuY3NzKGBpbnB1dGApKVxyXG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuc2VuZEtleXMoZmlsZS5wYXRoKSAgICAgICAgICAgIFxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5zZW5kX21lc3NhZ2UpO1xyXG5cclxuICAgICAgICAgIGxvZyhcIlByb2N1cmFuZG8gYm90w6NvIHBhcmEgZW52aWFyIGFuZXhvXCIpXHJcbiAgICAgICAgICBjb25zdCBzZW5kSW1hZ2VCdXR0b24gPSBhd2FpdCBHbG9iYWxEcml2ZXIud2FpdCh1bnRpbC5lbGVtZW50TG9jYXRlZChCeS5jc3MoXCJzcGFuW2RhdGEtdGVzdGlkPSdzZW5kJ11cIikpKTtcclxuICAgICAgICAgIHNlbmRJbWFnZUJ1dHRvbi5jbGljaygpO1xyXG4gICAgICAgICAgYXdhaXQgZGVsYXkoY29uZmlnLnNlbmRfYXR0YWNobWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGxvZyhcIkZpbmFsaXplaSBvIGVudmlvXCIpXHJcbiAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5zZW5kX21lc3NhZ2UpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXR1czogdHJ1ZSxcclxuICAgICAgICBlcnJvcjogJ2ZhbHNlJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBpbml0aWF0ZVNlbmRQcm9jZXNzOiBhc3luYyAocm93czogYW55W10sIG1lc3NhZ2U6IHN0cmluZywgaW1hZ2VzOiBhbnlbXSwgaXNOZXdMaW5lUmV0dXJuQ2hhcmFjdGVyOiBib29sZWFuLCBjb25maWc6IFRpbWVyQ29uZmlndXJhdGlvbikgPT4ge1xyXG4gICAgbG9nKFwiSW5pY2lhbmRvIGluc3RhbmNpYSBkbyBuYXZlZ2Fkb3JcIilcclxuICAgIGNvbnN0IGluaXRpYXRlZF9hdCA9IERhdGUubm93KClcclxuXHJcbiAgICBsZXQgZHJpdmVyID0gYXdhaXQgbmV3IEJ1aWxkZXIoKS5mb3JCcm93c2VyKEJyb3dzZXIuQ0hST01FKS5idWlsZCgpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGxvZyhcIkFicmluZG8gTG9naW4gV2hhdHNhcHBcIilcclxuICAgICAgYXdhaXQgZHJpdmVyLmdldChgaHR0cHM6Ly93ZWIud2hhdHNhcHAuY29tL2ApXHJcblxyXG4gICAgICBsb2coXCJBZ3VhcmRhbmRvIFZhbGlkYXIgYSBww6FnaW5hIGRlIGluaWNpb1wiKVxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkcml2ZXIud2FpdCh1bnRpbC5lbGVtZW50TG9jYXRlZChCeS5jc3MoXCJoMVtkYXRhLXRlc3RpZD0naW50cm8tdGl0bGUnXVwiKSkpO1xyXG4gICAgICBsb2coXCJBdXRlbnRpY2Fkb1wiKVxyXG4gICAgICBhd2FpdCBkZWxheShjb25maWcuc3RhcnQpO1xyXG5cclxuICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgIGxldCBuZXdSb3dzID0gW11cclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2Ygcm93cykge1xyXG4gICAgICAgICAgbG9nKFwiQWJyaW5kbyBjb250YXRvXCIpXHJcbiAgICAgICAgICBpZiAoIWlzTmV3TGluZVJldHVybkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBsZXQgZmluYWxNZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlQWxsKFwie3ByaW1laXJvTm9tZX1cIiwgY29udGFjdC5uYW1lLnNwbGl0KFwiIFwiKVswXSlcclxuICAgICAgICAgICAgICAucmVwbGFjZUFsbChcIntub21lQ29tcGxldG99XCIsIGNvbnRhY3QubmFtZSlcclxuICAgICAgICAgICAgICAucmVwbGFjZUFsbChcInt0ZWxlZm9uZX1cIiwgY29udGFjdC5waG9uZSlcclxuICAgICAgICAgICAgICAucmVwbGFjZUFsbChcInt2YXIxfVwiLCBjb250YWN0LnZhcjEpXHJcbiAgICAgICAgICAgICAgLnJlcGxhY2VBbGwoXCJ7dmFyMn1cIiwgY29udGFjdC52YXIyKVxyXG4gICAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwie3ZhcjN9XCIsIGNvbnRhY3QudmFyMylcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGRyaXZlci5nZXQoYGh0dHBzOi8vd2ViLndoYXRzYXBwLmNvbS9zZW5kLz9waG9uZT0lMkI1NSR7Y29udGFjdC5waG9uZS5yZXBsYWNlKC9cXEQvZywgXCJcIil9JnRleHQ9JHtlbmNvZGVVUkkoZmluYWxNZXNzYWdlKX0mYW1wO3RleHQmYW1wO3R5cGU9cGhvbmVfbnVtYmVyJmFtcDthcHBfYWJzZW50PTBgKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgZHJpdmVyLmdldChgaHR0cHM6Ly93ZWIud2hhdHNhcHAuY29tL3NlbmQvP3Bob25lPSUyQjU1JHtjb250YWN0LnBob25lLnJlcGxhY2UoL1xcRC9nLCBcIlwiKX0mYW1wO3RleHQmYW1wO3R5cGU9cGhvbmVfbnVtYmVyJmFtcDthcHBfYWJzZW50PTBgKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXdhaXQgZGVsYXkoY29uZmlnLmluaXRpYXRlX3NlbmQpO1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxvZyhcIlZlcmlmaWNhbmRvIHNlIHRlbSBtZW5zYWdlbSBkZSBlcnJvXCIpXHJcbiAgICAgICAgICAgIGF3YWl0IGRyaXZlci53YWl0KHVudGlsLmVsZW1lbnRMb2NhdGVkKEJ5LmNzcyhcImRpdltkYXRhLXRlc3RpZD0nY29uZmlybS1wb3B1cCddXCIpKSwgMTAwMDApO1xyXG4gICAgICAgICAgICBhd2FpdCBkZWxheShjb25maWcuY2hlY2tfZXJyb3IpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGF3YWl0IGRyaXZlci5maW5kRWxlbWVudChCeS5jc3MoJ2RpdltkYXRhLXRlc3RpZD1cInBvcHVwLWNvbnRlbnRzXCJdJykpXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBlbGVtZW50LmdldFRleHQoKVxyXG5cclxuICAgICAgICAgICAgbG9nKFwiSG91dmUgbWVuc2FnZW0gZGUgZXJyb1wiKVxyXG4gICAgICAgICAgICBsb2codGV4dClcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5maW5hbGl6ZV9zZW5kKTtcclxuXHJcbiAgICAgICAgICAgIG5ld1Jvd3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgLi4uY29udGFjdCxcclxuICAgICAgICAgICAgICBzdGF0dXNJbmZvOiB0ZXh0XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc05ld0xpbmVSZXR1cm5DaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICBsb2coXCJQcm9jdXJhbmRvIGJvdMOjbyBwYXJhIGVudmlhciBtZW5zYWdlbVwiKVxyXG4gICAgICAgICAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5zZW5kX21lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHNlbmRCdXR0b24gPSBhd2FpdCBkcml2ZXIud2FpdCh1bnRpbC5lbGVtZW50TG9jYXRlZChCeS5jc3MoXCJidXR0b25bZGF0YS10ZXN0aWQ9J2NvbXBvc2UtYnRuLXNlbmQnXVwiKSkpO1xyXG4gICAgICAgICAgICAgIHNlbmRCdXR0b24uY2xpY2soKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBsb2coXCJQcm9jdXJhbmRvIGlucHV0XCIpXHJcbiAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBhd2FpdCBkcml2ZXIud2FpdCh1bnRpbC5lbGVtZW50TG9jYXRlZChCeS5jc3MoXCJwLnNlbGVjdGFibGUtdGV4dC5jb3B5YWJsZS10ZXh0XCIpKSk7XHJcblxyXG4gICAgICAgICAgICAgIGxvZyhcIkluc2VyaW5kbyB0ZXh0b1wiKVxyXG4gICAgICAgICAgICAgIGxldCBmaW5hbE1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2VBbGwoXCJ7cHJpbWVpcm9Ob21lfVwiLCBjb250YWN0Lm5hbWUuc3BsaXQoXCIgXCIpWzBdKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2VBbGwoXCJ7bm9tZUNvbXBsZXRvfVwiLCBjb250YWN0Lm5hbWUpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZUFsbChcInt0ZWxlZm9uZX1cIiwgY29udGFjdC5waG9uZSlcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwie3ZhcjF9XCIsIGNvbnRhY3QudmFyMSlcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwie3ZhcjJ9XCIsIGNvbnRhY3QudmFyMilcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwie3ZhcjN9XCIsIGNvbnRhY3QudmFyMylcclxuXHJcbiAgICAgICAgICAgICAgaW5wdXQuY2xpY2soKVxyXG5cclxuICAgICAgICAgICAgICBjb25zdCBmaW5hbE1lc3NhZ2VBcnJheSA9IGZpbmFsTWVzc2FnZS5zcGxpdChcIlxcblwiKVxyXG5cclxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgZmluYWxNZXNzYWdlQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0LnNlbmRLZXlzKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoY29uZmlnLnNlbmRfbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5zZW5kS2V5cyhpc05ld0xpbmVSZXR1cm5DaGFyYWN0ZXIgPyBLZXkuRU5URVIgOiBLZXkuY2hvcmQoS2V5LlNISUZULCBLZXkuRU5URVIpKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5zZW5kX21lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGltYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgbG9nKFwiRW52aWFuZG8gaW1hZ2VucyBhbmV4YWRhc1wiKVxyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBsb2coXCJQcm9jdXJhbmRvIGJvdMOjbyBjbGlwZVwiKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpcEJ1dHRvbiA9IGF3YWl0IGRyaXZlci53YWl0KHVudGlsLmVsZW1lbnRMb2NhdGVkKEJ5LmNzcyhcImRpdltkYXRhLXRlc3RpZD0nY29udmVyc2F0aW9uLWNsaXAnXVwiKSkpO1xyXG4gICAgICAgICAgICAgICAgY2xpcEJ1dHRvbi5jbGljaygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KGNvbmZpZy5zZW5kX21lc3NhZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxvZyhcIlByb2N1cmFuZG8gYm90w6NvIGFuZXhhciBpbWFnZW5zXCIpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2hCdXR0b24gPSBhd2FpdCBkcml2ZXIud2FpdCh1bnRpbC5lbGVtZW50TG9jYXRlZChCeS5jc3MoXCJidXR0b25bYXJpYS1sYWJlbD0nRm90b3MgZSB2w61kZW9zJ11cIikpKTtcclxuICAgICAgICAgICAgICAgIGxvZyhcIkluc2VyaW5kbyBpbWFnZW1cIilcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IGF3YWl0IGF0dGFjaEJ1dHRvbi5maW5kRWxlbWVudChCeS5jc3MoYGlucHV0YCkpXHJcbiAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuc2VuZEtleXMoaW1hZ2UucGF0aClcclxuXHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShjb25maWcuc2VuZF9tZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2coXCJQcm9jdXJhbmRvIGJvdMOjbyBwYXJhIGVudmlhciBpbWFnZW1cIilcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRJbWFnZUJ1dHRvbiA9IGF3YWl0IGRyaXZlci53YWl0KHVudGlsLmVsZW1lbnRMb2NhdGVkKEJ5LmNzcyhcInNwYW5bZGF0YS10ZXN0aWQ9J3NlbmQnXVwiKSkpO1xyXG4gICAgICAgICAgICAgICAgc2VuZEltYWdlQnV0dG9uLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShjb25maWcuc2VuZF9tZXNzYWdlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5ld1Jvd3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgLi4uY29udGFjdCxcclxuICAgICAgICAgICAgICBzdGF0dXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgc3RhdHVzSW5mbzogXCJNZW5zYWdlbSBlbnZpYWRhIVwiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCBkZWxheShjb25maWcuZmluYWxpemVfc2VuZCk7XHJcblxyXG4gICAgICAgIGF3YWl0IGRyaXZlci5xdWl0KCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHJvd3M6IG5ld1Jvd3MsXHJcbiAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgc3RhdHVzOiB0cnVlLFxyXG4gICAgICAgICAgaW5pdGlhdGVkX2F0LFxyXG4gICAgICAgICAgZmluYWxpemVkX2F0OiBEYXRlLm5vdygpXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCBkcml2ZXIucXVpdCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByb3dzOiByb3dzLFxyXG4gICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgIGVycm9yOiBcIk7Do28gZm9pIHBvc3NpdmVsIGF1dGVudGljYXJcIixcclxuICAgICAgICAgIHN0YXR1czogZmFsc2UsXHJcbiAgICAgICAgICBpbml0aWF0ZWRfYXQsXHJcbiAgICAgICAgICBmaW5hbGl6ZWRfYXQ6IERhdGUubm93KClcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVzdG91IGFxdWlcIiwgZXJyb3IpXHJcbiAgICAgIGxvZyhcIkhvdXZlIHVtIGVycm8gZSBmZWNoYW1vcyBvIG5hdmVnYWRvclwiKVxyXG5cclxuICAgICAgYXdhaXQgZHJpdmVyLnF1aXQoKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcm93cyxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgIHN0YXR1czogZmFsc2UsXHJcbiAgICAgICAgaW5pdGlhdGVkX2F0LFxyXG4gICAgICAgIGZpbmFsaXplZF9hdDogRGF0ZS5ub3coKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBpcGNSZW5kZXJlcjoge1xyXG4gICAgc2VuZE1lc3NhZ2UoY2hhbm5lbDogQ2hhbm5lbHMsIGFyZ3M6IHVua25vd25bXSkge1xyXG4gICAgICBpcGNSZW5kZXJlci5zZW5kKGNoYW5uZWwsIGFyZ3MpO1xyXG4gICAgfSxcclxuICAgIG9uKGNoYW5uZWw6IENoYW5uZWxzLCBmdW5jOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkKSB7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IChfZXZlbnQ6IElwY1JlbmRlcmVyRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT5cclxuICAgICAgICBmdW5jKC4uLmFyZ3MpO1xyXG4gICAgICBpcGNSZW5kZXJlci5vbihjaGFubmVsLCBzdWJzY3JpcHRpb24pO1xyXG5cclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBpcGNSZW5kZXJlci5yZW1vdmVMaXN0ZW5lcihjaGFubmVsLCBzdWJzY3JpcHRpb24pO1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIG9uY2UoY2hhbm5lbDogQ2hhbm5lbHMsIGZ1bmM6ICguLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWQpIHtcclxuICAgICAgaXBjUmVuZGVyZXIub25jZShjaGFubmVsLCAoX2V2ZW50LCAuLi5hcmdzKSA9PiBmdW5jKC4uLmFyZ3MpKTtcclxuICAgIH0sXHJcbiAgfSxcclxufSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
